<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-16T05:25:30.929Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 202周赛</title>
    <link href="http://yoursite.com/2020/08/16/191/"/>
    <id>http://yoursite.com/2020/08/16/191/</id>
    <published>2020-08-16T05:25:21.003Z</published>
    <updated>2020-08-16T05:25:30.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202场周赛"><a href="#202场周赛" class="headerlink" title="202场周赛"></a>202场周赛</h1><p>本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。</p><h2 id="5185-存在连续三个奇数的数组"><a href="#5185-存在连续三个奇数的数组" class="headerlink" title="5185. 存在连续三个奇数的数组"></a>5185. 存在连续三个奇数的数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/three-consecutive-odds" target="_blank" rel="noopener">https://leetcode-cn.com/problems/three-consecutive-odds</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-2</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i<span class="number">-1</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5488-使数组中所有元素相等的最小操作数"><a href="#5488-使数组中所有元素相等的最小操作数" class="headerlink" title="5488. 使数组中所有元素相等的最小操作数"></a>5488. 使数组中所有元素相等的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>存在一个长度为 <code>n</code>的数组 <code>arr</code>，其中 <code>arr[i] = (2 * i) + 1 （ 0 &lt;= i &lt; n ）</code>。</p><p>一次操作中，你可以选出两个下标，记作 <code>x</code>和 <code>y （ 0 &lt;= x, y &lt; n ）</code>并使 <code>arr[x]</code> 减去 1 、<code>arr[y]</code>加上 1 （即 <code>arr[x] -=1</code>且 <code>arr[y] += 1</code>）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p><p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 最小操作数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">第一次操作选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，使数组变为 [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">第二次操作继续选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，数组将会变成 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本质就是个数学问题，弄清楚等差数列的元素和长度，即可很快的求出来。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (n*n)/<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>)*(n+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5489-两球之间的磁力"><a href="#5489-两球之间的磁力" class="headerlink" title="5489. 两球之间的磁力"></a>5489. 两球之间的磁力</h2><p>在代号为 <code>C-137</code>的地球上，<code>Rick</code> 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。<code>Rick</code> 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> ，<code>Morty</code>想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于<code>x</code>和<code>y</code>，那么它们之间的磁力为<code>|x - y|</code>。</p><p>给你一个整数数组 <code>position</code>和一个整数<code>m</code>，请你返回最大化的最小磁力。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], m = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将 <span class="number">3</span> 个球分别放入位于 <span class="number">1</span>，<span class="number">4</span> 和 <span class="number">7</span> 的三个篮子，两球间的磁力分别为 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]。最小磁力为 <span class="number">3</span> 。我们没办法让最小磁力大于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1000000000</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">999999999</span></span><br><span class="line">解释：我们使用位于 <span class="number">1</span> 和 <span class="number">1000000000</span> 的篮子时最小磁力最大。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == position.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= position[i] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ 所有` position `中的整数 互不相同 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= m &lt;= position.length`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/magnetic-force-between-two-balls</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  二分查找</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的二分查找解法。与之前的类似的题目切巧克力基本上一样的题目，一看基本就直到解法。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> check(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m,<span class="built_in">int</span> distance)&#123;</span><br><span class="line">        m--;</span><br><span class="line">        <span class="built_in">int</span> curr = position[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; position.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position[i] - curr &gt;= distance)&#123;</span><br><span class="line">                curr = position[i];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDistance(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = position.size();</span><br><span class="line">        long long l = <span class="number">1</span>;</span><br><span class="line">        long long r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        sort(position.begin(),position.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(position,m,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5490-吃掉-N-个橘子的最少天数"><a href="#5490-吃掉-N-个橘子的最少天数" class="headerlink" title="5490. 吃掉 N 个橘子的最少天数"></a>5490. 吃掉 N 个橘子的最少天数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><p>吃掉一个橘子。<br>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 n/2 个橘子。<br>如果剩余橘子数 <code>n</code>能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。<br>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code>个橘子的最少天数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你总共有 <span class="number">10</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span>。</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">6</span> 个橘子，剩余橘子数 <span class="number">9</span> - <span class="number">2</span>*(<span class="number">9</span>/<span class="number">3</span>) = <span class="number">9</span> - <span class="number">6</span> = <span class="number">3</span>。（<span class="number">9</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。</span><br><span class="line">第 <span class="number">4</span> 天：吃掉最后 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你需要至少 <span class="number">4</span> 天吃掉 <span class="number">10</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你总共有 <span class="number">6</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">3</span> 个橘子，剩余橘子数 <span class="number">6</span> - <span class="number">6</span>/<span class="number">2</span> = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>。（<span class="number">6</span> 可以被 <span class="number">2</span> 整除）</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。（<span class="number">3</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃掉剩余 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你至少需要 <span class="number">3</span> 天吃掉 <span class="number">6</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">56</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs + 记忆式搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本质是典型的记忆式搜素，题目非常简单。</li><li>或者简单的BFS快速搜素即可，也没什么好讨论的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(n)) <span class="keyword">return</span> cnt[n];</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">2</span>) + n%<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">3</span>) + n%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        cnt[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = que.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> q = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">3</span>);</span><br><span class="line">                    s.insert(q / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">2</span>);</span><br><span class="line">                    s.insert(q / <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.count(q - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q - <span class="number">1</span>);</span><br><span class="line">                    s.insert(q - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;202场周赛&quot;&gt;&lt;a href=&quot;#202场周赛&quot; class=&quot;headerlink&quot; title=&quot;202场周赛&quot;&gt;&lt;/a&gt;202场周赛&lt;/h1&gt;&lt;p&gt;本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。&lt;/p&gt;&lt;h2 id=&quot;5185-存在连续三个奇数的数组&quot;&gt;&lt;a href=&quot;#5185-存在连续三个奇数的数组&quot; class=&quot;headerlink&quot; title=&quot;5185. 存在连续三个奇数的数组&quot;&gt;&lt;/a&gt;5185. 存在连续三个奇数的数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：不存在连续三个元素都是奇数的情况。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：存在连续三个元素都是奇数的情况，即 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 201周周赛</title>
    <link href="http://yoursite.com/2020/08/09/190/"/>
    <id>http://yoursite.com/2020/08/09/190/</id>
    <published>2020-08-09T08:21:04.153Z</published>
    <updated>2020-08-09T09:26:54.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="201周周赛"><a href="#201周周赛" class="headerlink" title="201周周赛"></a>201周周赛</h1><p>本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png" alt="1"><br>不过整体来说，感觉题目质量非常高，leetcode出题还是用心。</p><h2 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code>和 <code>s[i + 1]</code>不会同时满足下述条件：</p><a id="more"></a><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</li></ul><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leEeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：无论你第一次选的是 <span class="selector-tag">i</span> = <span class="number">1</span> 还是 <span class="selector-tag">i</span> = <span class="number">2</span>，都会使 <span class="string">"leEeetcode"</span> 缩减为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abBAcC"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"aAcC"</span> --&gt; <span class="string">"cC"</span> --&gt; <span class="string">""</span></span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"abBA"</span> --&gt; <span class="string">"aA"</span> --&gt; <span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"s"</span></span><br><span class="line">输出：<span class="string">"s"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-string-great" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-string-great</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  堆栈</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题感觉比较坑，简单的题目估计卡住不少人，感觉可以到达mid难度。</li><li>模拟堆栈即可，遍历字符串，如果当前字符串中的元素与栈顶的元素的绝对值之差为<code>32</code>，则出栈即可。最后返回栈中剩余的元素即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res.push_back(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res.back()-s[i]) == <span class="number">32</span>)&#123;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code><br>其中 + 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转<code>x</code>中的每一位（<code>0</code>变为 <code>1</code>，而 <code>1</code> 变为 <code>0</code>）</li></ul><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code><br>请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：S3 为 <span class="string">"0111001"</span>，其第 <span class="number">1</span> 位为 <span class="string">"0"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br><span class="line">解释：S4 为 <span class="string">"011100110110001"</span>，其第 <span class="number">11</span> 位为 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 找规律</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>先找到规律，刚拿到题目感觉没法下手，直接去求解的话，感觉很难。</li><li>仔细发现一下找到规律即可，实际我们直到$S_{n}$与$S_{n+1}$之间的递推关系，实际我们就可以用递归求解即可。我们可以讲字符串滑下来。</li><li>我们可以举例<code>S4</code>：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809165248.png" alt="1">。<br>首先我们可以直到$S_{n}$的长度$len(S_{n}) = 2^{n}-1$.假如<code>k</code>刚好在当前字符串中间的话，则直接返回<code>1</code>,因为我们直到除<code>S1</code>以外的字符串，最中间的字符都为<code>1</code>,最中间的位置刚好为：$2^{n-1}$<br>所以我们分为三种情况来讨论：</li></ol><ul><li>当$K &lt; 2^{n-1}$时：则此时$S_{n}[k] = S_{n-1}[k]$</li><li>当$K = 2^{n-1}$时：则此时$S_{n}[K] = 1$</li><li>当$K &gt; 2^{n-1}$时：则此时稍微麻烦点，由于后半部分是$reverse(invert(S_{n-1}))$,则$S_{n}[K] = inverse(S_{n-1}[2^{n}-k])$.</li><li>当$n = 0$时，则返回<code>0</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,<span class="built_in">pow</span>(<span class="number">2</span>,n)-k) == <span class="string">'0'</span>?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5471-和为目标值的最大数目不重叠非空子数组数目"><a href="#5471-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="5471. 和为目标值的最大数目不重叠非空子数组数目"></a>5471. 和为目标值的最大数目不重叠非空子数组数目</h2><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个不重叠子数组（加粗数字表示） [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] ，它们的和为目标值 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个子数组和为 <span class="number">6</span> 。</span><br><span class="line">([<span class="number">5</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>]) 但只有前 <span class="number">2</span> 个是不重叠的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目有点意思，我们设<code>dp[i]</code>代表前<code>i</code>个元素中含有最多的非连续符合条件且不重合的子数组的数目。</li><li>我们每次从在索引<code>i</code>初找到由元素<code>a[i]</code>作为符合条件的子数组的最后一个元素。我们利用前缀和，每次找到<code>prefixsum[i]-tagret</code>的索引<code>j</code>处。则可以得到以下递推公式.<script type="math/tex; mode=display">ans = max(ans,dp[j] + 1)</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            curr += nums[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[curr-target];</span><br><span class="line">                dp[i] = max(dp[i],dp[x] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,dp[i]);</span><br><span class="line">            cnt[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5486-切棍子的最小成本"><a href="#5486-切棍子的最小成本" class="headerlink" title="5486. 切棍子的最小成本"></a>5486. 切棍子的最小成本</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一根长度为<code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <code>6</code> 的棍子可以标记如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171755.png" alt="1"><br>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。<br>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 最小总成本 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, cuts = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：按 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] 的顺序切割的情况如下所示：</span><br><span class="line"></span><br><span class="line">第一次切割长度为 <span class="number">7</span> 的棍子，成本为 <span class="number">7</span> 。第二次切割长度为 <span class="number">6</span> 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 <span class="number">4</span> 的棍子，最后切割长度为 <span class="number">3</span> 的棍子。总成本为 <span class="number">7</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> = <span class="number">20</span> 。</span><br><span class="line">而将切割顺序重新排列为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>] 后，总成本 = <span class="number">16</span>（如示例图中 <span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">16</span>）。</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171815.png" alt="2"><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, cuts = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 <span class="number">25</span> 。总成本 &lt;= <span class="number">25</span> 的切割顺序很多，例如，[<span class="number">4</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">2</span>，<span class="number">1</span>] 的总成本 = <span class="number">22</span>，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，这种类型的题目已经见了很多了。</li><li>为了方便计算，我们首先讲头和尾加入<code>cuts</code>.我们用<code>dp[i][j]</code>代表<code>cuts[i]</code>到<code>cuts[j]</code>之间的切割最小成本。我们可以直到<code>dp[i][i] = 0</code>和 <code>dp[i][i+1]</code>，因为不需要切割。</li><li>我们很容易得出递推公式：<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j] + cuts[j] - cuts[i]) \qquad ( i \le k \le j</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;        </span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="keyword">int</span> m = cuts.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        </span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[m<span class="number">-1</span>][m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j+i; ++k)&#123;</span><br><span class="line">                    dp[j][j+i] = min(dp[j][j+i],dp[j][k] + dp[k][j+i] + cuts[j+i] - cuts[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;201周周赛&quot;&gt;&lt;a href=&quot;#201周周赛&quot; class=&quot;headerlink&quot; title=&quot;201周周赛&quot;&gt;&lt;/a&gt;201周周赛&lt;/h1&gt;&lt;p&gt;本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;不过整体来说，感觉题目质量非常高，leetcode出题还是用心。&lt;/p&gt;&lt;h2 id=&quot;5483-整理字符串&quot;&gt;&lt;a href=&quot;#5483-整理字符串&quot; class=&quot;headerlink&quot; title=&quot;5483. 整理字符串&quot;&gt;&lt;/a&gt;5483. 整理字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由大小写英文字母组成的字符串 &lt;code&gt;s&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一个整理好的字符串中，两个相邻字符 &lt;code&gt;s[i]&lt;/code&gt;和 &lt;code&gt;s[i + 1]&lt;/code&gt;不会同时满足下述条件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 32周双周赛</title>
    <link href="http://yoursite.com/2020/08/09/189/"/>
    <id>http://yoursite.com/2020/08/09/189/</id>
    <published>2020-08-09T02:13:37.052Z</published>
    <updated>2020-08-09T14:45:51.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32周双周赛"><a href="#32周双周赛" class="headerlink" title="32周双周赛"></a>32周双周赛</h1><p>本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。</p><h2 id="5468-第-k-个缺失的正整数"><a href="#5468-第-k-个缺失的正整数" class="headerlink" title="5468. 第 k 个缺失的正整数"></a>5468. 第 k 个缺失的正整数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格升序排列 的正整数数组<code>arr</code>和一个整数 <code>k</code>。</p><p>请你找到这个数组里第 <code>k</code> 个缺失的正整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,...] 。第 <span class="number">5</span> 个缺失的正整数为 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,...] 。第 <span class="number">2</span> 个缺失的正整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li>对于所有 <code>1 &lt;= i &lt; j &lt;= arr.length</code>的 <code>i</code>和 <code>j</code>满足 <code>arr[i] &lt; arr[j]</code>.</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-missing-positive-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-missing-positive-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力计数即可，如果发现当前的计数出现在数组中，则k不变，否则k进行减一操作。</li><li>当<code>k</code>为0时返回当前计数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; arr.size() &amp;&amp; curr == arr[idx])&#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5469-K-次操作转变字符串"><a href="#5469-K-次操作转变字符串" class="headerlink" title="5469. K 次操作转变字符串"></a>5469. K 次操作转变字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，你的目标是在<code>k</code>次操作以内把字符串 <code>s</code> 转变成 <code>t</code>。</p><p>在第 <code>i</code>次操作时<code>（1 &lt;= i &lt;= k）</code>，你可以选择进行如下操作：</p><p>选择字符串 <code>s</code> 中满足 <code>1 &lt;= j &lt;= s.length</code> 且之前未被选过的任意下标 <code>j</code>（下标从<code>1</code>开始），并将此位置的字符切换 <code>i</code>次。<br>不进行任何操作。<br>切换 <code>1</code> 次字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 ‘z’ 切换后会变成 ‘a’）。</p><p>请记住任意一个下标<code>j</code> 最多只能被操作 <code>1</code> 次。</p><p>如果在不超过 <code>k</code> 次操作内可以把字符串 <code>s</code>转变成<code>t</code> ，那么请你返回 <code>true</code> ，否则请你返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"input"</span>, t = <span class="string">"ouput"</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">6</span> 次操作时，我们将 <span class="string">'i'</span> 切换 <span class="number">6</span> 次得到 <span class="string">'o'</span> 。第 <span class="number">7</span> 次操作时，我们将 <span class="string">'n'</span> 切换 <span class="number">7</span> 次得到 <span class="string">'u'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, t = <span class="string">"bcd"</span>, k = <span class="number">10</span></span><br><span class="line">输出：false</span><br><span class="line">解释：我们需要将每个字符切换 <span class="number">1</span> 次才能得到 t 。我们可以在第 <span class="number">1</span> 次操作时将 'a' 切换成 'b' ，但另外 <span class="number">2</span> 个字母在剩余操作中无法再转变为 t 中对应字母。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aab"</span>, t = <span class="string">"bbb"</span>, k = <span class="number">27</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">1</span> 次操作时，我们将第一个 <span class="string">'a'</span> 切换 <span class="number">1</span> 次得到 <span class="string">'b'</span> 。在第 <span class="number">27</span> 次操作时，我们将第二个字母 <span class="string">'a'</span> 切换 <span class="number">27</span> 次得到 <span class="string">'b'</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>1 &lt;= s.length, t.length &lt;= 10^5<br>0 &lt;= k &lt;= 10^9<br>s 和 t 只包含小写英文字母。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-convert-string-in-k-moves</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5470-平衡括号字符串的最少插入次数"><a href="#5470-平衡括号字符串的最少插入次数" class="headerlink" title="5470. 平衡括号字符串的最少插入次数"></a>5470. 平衡括号字符串的最少插入次数</h2><p>给你一个括号字符串 <code>s</code> ，它只包含字符 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。一个括号字符串被称为平衡的当它满足：</p><ul><li>任何左括号 ‘(‘ 必须对应两个连续的右括号 ‘))’ 。</li><li>左括号 ‘(‘ 必须在对应的连续两个右括号 ‘))’ 之前。<br>比方说 “())”， “())(())))” 和 “(())())))” 都是平衡的， “)()”， “()))” 和 “(()))” 都是不平衡的。</li></ul><p>你可以在任意位置插入字符 ‘(‘ 和 ‘)’ 使字符串平衡。</p><p>请你返回让 s 平衡的最少插入次数。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()))"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 <span class="string">"(())))"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"())"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经平衡了。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"))())("</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(((((("</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：添加 <span class="number">12</span> 个 ')' 得到平衡字符串。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")))))))"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在字符串开头添加 <span class="number">4</span> 个 '(' 并在结尾添加 <span class="number">1</span> 个 ')' ，字符串变成平衡字符串 <span class="string">"(((())))))))"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目真心是好题，看似简单，实则需要思考的深度很多，不容易作对，并且做到最简单的方法夜不容易。</li><li>第一种思路，首先补齐右括号<code>)</code>，我们将所有的连续的右括号全部填充成偶数个，然后再将两个右括号<code>))</code>换成单个右括号<code>)</code>,然后再进行匹配，找出最少需要多少个右括号和左括号才能能完成匹配即可。这样做的是思路非常简单容易理解，不容易出错。</li><li>第二种思路，遇到左括号则我们进行计数加<code>1</code>,如果遇到连续的两个右括号，我们将指针指针移动两位，如果遇到<code>1</code>个右括号，我们则将其补齐，这时再看是否有左括号是否能够匹配，如果有左括号可以匹配，我们将左括号计数减一，否则我们补齐一个左括号，最后将剩余的计数的左括号全部补齐匹配即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                curr.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.size() &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!curr.empty())&#123;</span><br><span class="line">                    curr.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans + curr.size()*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5485-找出最长的超赞子字符串"><a href="#5485-找出最长的超赞子字符串" class="headerlink" title="5485. 找出最长的超赞子字符串"></a>5485. 找出最长的超赞子字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>。请返回<code>s</code> 中最长的 超赞子字符串 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><p>该字符串是 <code>s</code> 的一个非空子字符串<br>进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3242415"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：<span class="string">"24241"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"24142"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"12345678"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"213123"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">"213123"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"231132"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-longest-awesome-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-longest-awesome-substring</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目跟之前的<code>1317</code>题目很像，不过这个题目是求得连续子数组为回文串得最长长度。</li><li>题目还是非常有技巧的，首先我们要分析以下，什么样的字串可以通过无数次变化后变为回文字符串：</li></ol><ul><li>2.1字符串中所有字符的统计个数都为偶数。</li><li>2.2字符串中所有字符的统计个数只有一个字符的统计个数为奇数，其余的都为偶数。</li></ul><ol><li>看到上述描述后，由于题目中的字符串只有好友<code>0-9</code>的数字，因此最多只有10种字符，因此我们最多用10位即可表示10种字符的奇偶状态。比如：</li></ol><ul><li><code>0000000000</code>:代表字符<code>0~9</code>的统计个数都为偶数。</li><li><code>1000000000</code>:代表字符<code>1~9</code>的统计个数都为偶数，字符<code>0</code>的统计个数为奇数。</li><li><code>0110000000</code>:代表字符<code>0,3,4,5,6,7,8,9</code>的统计个数都为偶数,字符<code>1,2</code>的统计个数为奇数。</li></ul><ol><li>所以总共有<code>1024</code>种状态，我们获取当前字符索引<code>i</code>的奇偶状态<code>state[i]</code>，同时获取与<code>state[i]</code>相同的最小前缀<code>j</code>，可以得到以当前字符结束的且符合<code>2.1</code>条件的最长字串;当同时依次反转某个字符的奇偶状态得到<code>inverse_state[i]</code>，同时获取与<code>inverse_state[i]</code>相同的最小前缀<code>j</code>,可以得到以当前字符结束的且符合<code>2.2</code>条件的最长字串长度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(<span class="number">1</span>&lt;&lt;<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line">        prev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[i<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            mask ^= (<span class="number">1</span>&lt;&lt;ch);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = mask^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">if</span>(prev[next] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,i-prev[next]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(prev[mask] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                ans = max(ans,i-prev[mask]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev[mask] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;32周双周赛&quot;&gt;&lt;a href=&quot;#32周双周赛&quot; class=&quot;headerlink&quot; title=&quot;32周双周赛&quot;&gt;&lt;/a&gt;32周双周赛&lt;/h1&gt;&lt;p&gt;本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。&lt;/p&gt;&lt;h2 id=&quot;5468-第-k-个缺失的正整数&quot;&gt;&lt;a href=&quot;#5468-第-k-个缺失的正整数&quot; class=&quot;headerlink&quot; title=&quot;5468. 第 k 个缺失的正整数&quot;&gt;&lt;/a&gt;5468. 第 k 个缺失的正整数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 严格升序排列 的正整数数组&lt;code&gt;arr&lt;/code&gt;和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;请你找到这个数组里第 &lt;code&gt;k&lt;/code&gt; 个缺失的正整数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Programming Languages</title>
    <link href="http://yoursite.com/2020/08/05/188/"/>
    <id>http://yoursite.com/2020/08/05/188/</id>
    <published>2020-08-05T04:11:55.607Z</published>
    <updated>2020-08-05T04:12:00.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Programming-languages"><a href="#Programming-languages" class="headerlink" title="Programming languages"></a>Programming languages</h1><p>一直听说<code>coursera</code>上<code>UW</code>的<code>Programming languages</code>的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了<code>part A</code>和<code>part B</code>部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的<code>皮毛</code>,对所谓的<code>lambda</code>表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看<code>python</code>的好多特性都可以在这几门课中找到，特别是<code>yeild,lambda,@,stream</code>等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用<code>rackets</code>编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。<code>PL</code>领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。</p><a id="more"></a><ul><li><code>dynamic type</code>： 最大的好处写起来很爽，非常容易扩展和迁移，但是如果用这种动态语言来做大型工程项目来说，我感觉就是噩梦，因为没有强制的类型和规则，意味着处处都有可能产生<code>bug</code>，因为参数和返回值的类型由运行时决定，意外的产生<code>bug</code>会非常难以调试.并且动态类型语言的效率还是个非常大的问题，因为从语言的实现角度来看，如果真要实现动态类型，实际是需要加许多<code>tag</code>的附加信息来标记类型。</li><li><code>static type</code>:最大的好处是有强制的类型和规则校验，编译器会自动做类型检查，帮程序员发现不必要的类型匹配错误，并静态类型语言很容易编译成机器码，效率会很高，占用的内存会较小。非常适合于大型的工程项目。<br>所以的<code>homework project source code</code>都放在<code>github</code>上。实际还是非常花功夫来完成这些<code>project</code>，又熬了好多次夜才完成这些<code>homework</code>,作为二胎的父亲刷网课不易。</li></ul><p><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages" target="_blank" rel="noopener">programming languages</a></p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111309.png" alt="1"><br><code>part A</code>部分主要讲述了<code>ML</code>语言，其实是一门学术上研究的语言，实际上很少人会用<code>ML</code>语言来开发项目，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。<br>partA 主要学习了不少概念性的东西：</p><ul><li>hw1:主要学习了递归，<code>list</code>和函数的基本概念，以及类型的基本概念，还是颠覆了原来的认知，函数式编程最大的特点就是各种递归操作。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week1" target="_blank" rel="noopener">hw1</a></li><li>hw2:主要学习了<code>pair,tuple</code>以及<code>option</code>,<code>datatype</code>的各种基本概念。非常绕口的概念，跟过程式编程的体会完全不一样。过程式编程主要考虑程序的顺序执行，函数式编程考虑的怎样函数套函数。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week2" target="_blank" rel="noopener">hw2</a></li><li>hw3:学习了基本的<code>curry</code>的概念，感觉印象深刻，其实本质概念，一个函数接受了一个函数作为参数，返回了另一个函数，相当于可以根据参数类型，动态生成一个函数。学到了更高级的<code>map</code>和<code>filter</code>的函数的写法，感觉10行的代码实现了<code>c</code>语言几百行的工作量，非常的优雅，写起来很爽。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week3" target="_blank" rel="noopener">hw3</a></li><li>hw4: 学习了<code>ml</code>基本的模块的概念，如何编写模块和访问控制权限，类似<code>C++</code>中类的基本概念。</li></ul><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111406.png" alt="2"><br><code>part B</code>部分主要讲述了<code>racket</code>语言，其实是一门学术上研究的语言，是由<code>lisp</code>语言发展来的分支，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。</p><ul><li>hw5:学习了<code>racket</code>语言的基本语法和概念，学习了<code>stream</code>和<code>marco</code>的基本使用，毫无疑问的来说<code>stream</code>是个强大的工具，相当于函数本身返回一个函数，然后可以再反复调用这个函数。内部的实现原理其实很简单。<code>racket</code>据说有非常强的<code>marco</code>,不过在这一章里面只写了一个非常简单的皮毛而已。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week5" target="_blank" rel="noopener">hw5</a></li><li>hw6:这章里面主要的就是如何写一个简单的脚本解释器，利用<code>struct</code>创造类型出来，然后各种非常骚的操作写脚本解释器，还有一个很重要的<code>clouser</code>的概念。这章的<code>homework</code>还是比较有意思。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week6" target="_blank" rel="noopener">hw6</a><br>虽然每次的<code>homework</code>代码量不大，但是需要思考的很多，很多其实非常有意思，如果把这么课理解透了，对于理解函数的<code>闭包</code>这种概念就会非常的深刻。</li></ul><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Programming-languages&quot;&gt;&lt;a href=&quot;#Programming-languages&quot; class=&quot;headerlink&quot; title=&quot;Programming languages&quot;&gt;&lt;/a&gt;Programming languages&lt;/h1&gt;&lt;p&gt;一直听说&lt;code&gt;coursera&lt;/code&gt;上&lt;code&gt;UW&lt;/code&gt;的&lt;code&gt;Programming languages&lt;/code&gt;的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了&lt;code&gt;part A&lt;/code&gt;和&lt;code&gt;part B&lt;/code&gt;部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的&lt;code&gt;皮毛&lt;/code&gt;,对所谓的&lt;code&gt;lambda&lt;/code&gt;表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看&lt;code&gt;python&lt;/code&gt;的好多特性都可以在这几门课中找到，特别是&lt;code&gt;yeild,lambda,@,stream&lt;/code&gt;等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用&lt;code&gt;rackets&lt;/code&gt;编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。&lt;code&gt;PL&lt;/code&gt;领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PL" scheme="http://yoursite.com/categories/PL/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 Brainfuck编译器</title>
    <link href="http://yoursite.com/2020/08/04/187/"/>
    <id>http://yoursite.com/2020/08/04/187/</id>
    <published>2020-08-04T02:34:26.152Z</published>
    <updated>2020-08-04T02:34:32.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Brain-fuck语言"><a href="#Brain-fuck语言" class="headerlink" title="Brain fuck语言"></a>Brain fuck语言</h1><p>第一次听到<code>brain fuck</code>语言是在提交<code>spoj</code>第二道题目时，竟然用<code>brain fuck</code>语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。</p><ul><li>背景：<code>Brainfuck</code>是一种极小化的计算机语言，它是由<code>Urban Müller</code>在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段<code>brain fuck</code>代码：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/111.png" alt="1"><br>这段奇怪的符号实际为<code>100</code>行的<code>Brainfuck</code>虚拟机，实际代码非常晦涩难懂。</li><li>现状：实际上<code>brain fuck</code>只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。</li></ul><a id="more"></a><h2 id="语言规则"><a href="#语言规则" class="headerlink" title="语言规则"></a>语言规则</h2><p>实际上<code>brain fuck</code>只规定了8种基本的机器操作，分别为：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。每个操作用一个符号来替代。下表为实际的操作说明。</p><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th><th>C语言实现</th></tr></thead><tbody><tr><td>&gt;</td><td>当前的地址加1</td><td>ptr++</td></tr><tr><td>&lt;</td><td>当前的地址加1</td><td>ptr—</td></tr><tr><td>+</td><td>指针指向的字节的值加一</td><td>++*ptr;</td></tr><tr><td>-</td><td>指针指向的字节的值减一</td><td>—*ptr;</td></tr><tr><td>.</td><td>输出指针指向的单元内容（ASCII码）</td><td>putchar(*ptr);</td></tr><tr><td>,</td><td>输入内容到指针指向的单元（ASCII码）</td><td>*ptr =getchar();</td></tr><tr><td>[</td><td>如果当前指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</td><td>while (*ptr){</td></tr><tr><td>]</td><td>如果当前指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</td><td>}</td></tr></tbody></table></div><p>实际用<code>brain fuck</code>语言来写程序的话，非常锻炼你的机器思维。</p><ul><li><p>在屏幕上打印<code>hello word!</code>:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&lt;&lt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure></li><li><p>目前位置归零,我们可以看到当执行到<code>[</code>时，如果当前指针值不等于<code>0</code>则顺序执行<code>-</code>,否则跳到下一个<code>]</code>的后一条指令，当执行到<code>]</code>时，如果当前指针值不等于<code>0</code>则跳转到<code>-</code>，一直循环直到当前指针的位置为<code>0</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name"><span class="builtin-name">-</span></span>]</span><br></pre></td></tr></table></figure></li><li><p>字符I/O,从键盘中读取一个字符，然后打印出来。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,.</span><br></pre></td></tr></table></figure></li><li><p>简单的循环读取键盘字符,直到输入字符<code>\0</code>结束。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="string">[.,]</span></span><br></pre></td></tr></table></figure></li><li><p>将所有的输入的字符全部保存到内存中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;,<span class="string">[.&gt;,]</span></span><br></pre></td></tr></table></figure></li><li><p>加法,这个比较有趣，每次将当前的位置元素减<code>1</code>,同时将下一个指针的元素的元素加<code>1</code>,直到当前元素的元素为<code>0</code>.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;+&lt;]</span><br></pre></td></tr></table></figure></li><li><p>条件指令.这个程序会把从键盘读来的小写字符转换成大写。按回车键退出程序,每次读取大写字符<code>x</code>,然后将其减去<code>34</code>即可，如果读到回车键，则它的<code>ascii</code>码为<code>10</code>,刚好<code>10</code>的时候，程序会退出。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure></li><li><p>加法器 <code>add(summand, addend, *sum)</code></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&lt;&lt;&lt; // clear cell <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">[-&gt;&gt;+&gt;+&lt;&lt;&lt;] // transfer cell <span class="string">#0</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#0</span></span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // transfer cell <span class="string">#1</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#1</span></span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure><p>该代码以 cell #3 作为临时变量，将保存在 cell #0 和 cell #1 中的两个整数相加，<br>结果保存在 cell #2；同时维持原来的两个存储单元数值不变，方便以后使用。<br>代码运行前，设定指针指向 cell #0，<br>第一步，先将 cell #2 和 cell #3 清空，确保不会有脏数据影响运算结果；<br>第二步，将 cell #0 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #0 的值；<br>第三步，将 cell #1 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #1 的值；<br>最后，指针归位（回到初始位置，即指向 cell #0），方便后续运算。</p></li><li><p>乘法器 <code>multiply(multiplicand, multiplier, *product)</code></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&gt;[-]&lt;&lt;&lt;&lt; // clear cell <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span> <span class="keyword">and</span> <span class="symbol">#4</span></span><br><span class="line">[-&gt;</span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // <span class="keyword">add</span> cell <span class="symbol">#1</span> <span class="keyword">to</span> <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">[-&lt;&lt;+&gt;&gt;] // move cell <span class="symbol">#3</span> back <span class="keyword">to</span> <span class="symbol">#1</span></span><br><span class="line">&gt;+&lt; // copy cell <span class="symbol">#0</span> <span class="keyword">to</span> <span class="symbol">#4</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">&lt;]</span><br><span class="line">&gt;&gt;&gt;&gt;[-&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt; // move cell <span class="symbol">#4</span> back <span class="keyword">to</span> <span class="symbol">#0</span></span><br></pre></td></tr></table></figure><p>跟上面的“加法器”类似，这个“乘法器”将保存在 cell #0 和 cell #1 的两个整数相乘，结果保存在 cell</p><h1 id="2；同时维持原来的两个存储单元数值不变，方便以后使用。"><a href="#2；同时维持原来的两个存储单元数值不变，方便以后使用。" class="headerlink" title="2；同时维持原来的两个存储单元数值不变，方便以后使用。"></a>2；同时维持原来的两个存储单元数值不变，方便以后使用。</h1></li></ul><p>从以上几个例子，我们可以看出实际上<code>brain fuck</code>实际还是非常有意思的，非常锻炼逻辑思维能力，但是实际工业界和学术界肯定不会用这么低效的语言来开发实际程序。</p><h2 id="brainfuck-解释器"><a href="#brainfuck-解释器" class="headerlink" title="brainfuck 解释器"></a>brainfuck 解释器</h2><p>由于<code>brain fuck</code>语言的功能很简单，只有8个指令，实际上我们可以C语言大概<code>100</code>行左右就可以实现该语言的解释器。</p><ul><li>直接翻译为C语言：这个就比较简单,我们直接翻译即可，转换为C语言。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"brainfuck_out.c"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    out&lt;&lt;<span class="string">"#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"int main()&#123;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char arr[1000000];\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char *ptr = arr;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  memset(arr,0,sizeof(arr));\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: out&lt;&lt;<span class="string">"    ++ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: out&lt;&lt;<span class="string">"    --ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: out&lt;&lt;<span class="string">"    ++*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: out&lt;&lt;<span class="string">"    --*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: out&lt;&lt;<span class="string">"    putchar(*ptr);\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: out&lt;&lt;<span class="string">"    *ptr =getchar();\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: out&lt;&lt;<span class="string">"    while (*ptr) &#123;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: out&lt;&lt;<span class="string">"    &#125;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;<span class="string">"&#125;\n"</span>;</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>直接源程序文件，进行解析。稍微复杂点的是需要找到左括号<code>[</code>最近的右括号，同时需要找到右括号<code>]</code>最近的左括号，我们用<code>skip_table</code>存放跳转指令即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="built_in">string</span> code;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">       code.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* check '[]'*/</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; skip_table;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; code.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(code[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">            assert(!st.empty());</span><br><span class="line">            skip_table[i] = st.top();</span><br><span class="line">            <span class="keyword">if</span>(!skip_table.count(st.top()))&#123;</span><br><span class="line">                skip_table[st.top()] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = arr;</span><br><span class="line">    <span class="keyword">while</span>(ip &lt; code.size())&#123;</span><br><span class="line">        c = code[ip];</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;assert(ptr &lt; (arr+MAX_SIZE<span class="number">-1</span>)); ptr++;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;assert(ptr &gt; arr); ptr--;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: &#123;++*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: &#123;--*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: &#123;<span class="built_in">putchar</span>(*ptr);&#125;  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: &#123;*ptr = getchar();&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: <span class="keyword">if</span>(*ptr == <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(*ptr != <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ip++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h2><ul><li>将当前字节减去<code>100</code>，当然我们可以书写成连续<code>100</code>个<code>-</code>,但是这明显太长了。我们可以用<code>10</code>个循环减去<code>10</code>来完成。</li></ul><ol><li>首先将下一个字节作为计数器，首先对下一个字节清零，然后直接加上10;</li><li>我们对上一个字节减去<code>10</code>，然后对下一个字节减去<code>1</code>;</li><li>直到下一个字节为<code>0</code>即可。<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">[-]</span>++++++++++<span class="string">[&lt;----------&gt;-]</span>&lt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><code>Brainfuck</code>总的来说还是非常烧脑的程序，用来写非常普通的计算程序会非常麻烦，但是我们需要这样的练习。对于负数或者浮点数感觉非常的复杂，应为<code>ieee754</code>浮点数的标准解析浮点数是非常蛋疼的一件事。目前只看到部分非常蛋疼的<code>OJ</code>上有要求用<code>brainfuck</code>代码来解题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Brain-fuck语言&quot;&gt;&lt;a href=&quot;#Brain-fuck语言&quot; class=&quot;headerlink&quot; title=&quot;Brain fuck语言&quot;&gt;&lt;/a&gt;Brain fuck语言&lt;/h1&gt;&lt;p&gt;第一次听到&lt;code&gt;brain fuck&lt;/code&gt;语言是在提交&lt;code&gt;spoj&lt;/code&gt;第二道题目时，竟然用&lt;code&gt;brain fuck&lt;/code&gt;语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;背景：&lt;code&gt;Brainfuck&lt;/code&gt;是一种极小化的计算机语言，它是由&lt;code&gt;Urban Müller&lt;/code&gt;在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段&lt;code&gt;brain fuck&lt;/code&gt;代码：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/111.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;这段奇怪的符号实际为&lt;code&gt;100&lt;/code&gt;行的&lt;code&gt;Brainfuck&lt;/code&gt;虚拟机，实际代码非常晦涩难懂。&lt;/li&gt;
&lt;li&gt;现状：实际上&lt;code&gt;brain fuck&lt;/code&gt;只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 200周赛</title>
    <link href="http://yoursite.com/2020/08/02/186/"/>
    <id>http://yoursite.com/2020/08/02/186/</id>
    <published>2020-08-02T07:53:24.458Z</published>
    <updated>2020-08-02T07:53:57.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="200场周赛"><a href="#200场周赛" class="headerlink" title="200场周赛"></a>200场周赛</h1><p>本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的<code>dp</code>即可做出来，四道题全部AC，周赛排名<code>150</code>。</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png" alt="image-20200802145522515"></p><h2 id="5475-统计好三元组"><a href="#5475-统计好三元组" class="headerlink" title="5475. 统计好三元组"></a>5475. 统计好三元组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> ，以及 <code>a、b 、c</code>三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 好三元组 。</p><a id="more"></a><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code><br>其中 <code>|x|</code> 表示 <code>x</code>的绝对值。</li></ul><p>返回 好三元组的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>], a = <span class="number">7</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一共有 <span class="number">4</span> 个好三元组：[(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-good-triplets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-triplets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力三重循环即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-arr[j]) &lt;= a &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[j]-arr[k]) &lt;= b &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[i]-arr[k]) &lt;= c)&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5476-找出数组游戏的赢家"><a href="#5476-找出数组游戏的赢家" class="headerlink" title="5476. 找出数组游戏的赢家"></a>5476. 找出数组游戏的赢家</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 不同 整数组成的整数数组 <code>arr</code>和一个整数 <code>k</code>。</p><p>每回合游戏都在数组的前两个元素（即<code>arr[0]</code>和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code>与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code>，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code>个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>返回赢得比赛的整数。</p><p>题目数据 保证 游戏存在赢家。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一起看一下本场游戏每回合的情况：</span><br><span class="line"></span><br><span class="line">因此将进行 <span class="number">4</span> 回合比赛，其中 <span class="number">5</span> 是赢家，因为它连胜 <span class="number">2</span> 回合。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 将会在前 <span class="number">10</span> 个回合中连续获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>], k = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">99</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>arr</code> 所含的整数 各不相同 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-winner-of-an-array-game</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5477-排布二进制网格的最少交换次数"><a href="#5477-排布二进制网格的最少交换次数" class="headerlink" title="5477. 排布二进制网格的最少交换次数"></a>5477. 排布二进制网格的最少交换次数</h2><p>给你一个<code>n x n</code>的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 相邻两行 进行交换。</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <code>0</code>。</p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <code>-1</code> 。</p><p>主对角线指的是从 <code>(1, 1)</code>到 <code>(n, n)</code> 的这些格子。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152236.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152257.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：所有行都是一样的，交换相邻行无法使网格符合要求。</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152310.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>grid[i][j]</code>要么是 <code>0</code>要么是 <code>1</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先取出所有行的末尾0的个数。</li><li>如果按照条件要求满足第<code>i</code>行末尾<code>0</code>的个数必须要大于等于<code>n-1-i</code>,如果不存在满足要求的行则认为该矩阵无法变换成满足要求，否则则找到一个满足要求的行<code>j</code>,与第<code>i</code>行进行交换，然后第<code>i</code>行至第<code>j-1</code>行全部往后移动一行即可。</li><li>依次循环下一行，典型的贪心算法，找到第一个满足要求的行，然后交换。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero(row,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) zero[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*mini swap*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zero[i] &gt;= (row<span class="number">-1</span>-i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zero[j] &gt;= (row<span class="number">-1</span>-i))&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t<span class="number">-1</span>; j &gt;= i; --j)&#123;</span><br><span class="line">                swap(zero[j],zero[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (t-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5478-最大得分"><a href="#5478-最大得分" class="headerlink" title="5478. 最大得分"></a>5478. 最大得分</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有两个 有序 且数组内元素互不相同的数组 <code>nums1</code>和 <code>nums2</code>。</p><p>一条 合法路径 定义如下：</p><p>选择数组 <code>nums1</code> 或者 <code>nums2</code>开始遍历（从下标 <code>0</code>处开始）。<br>从左到右遍历当前数组。<br>如果你遇到了<code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。<br>得分定义为合法路径中不同数字的和。</p><p>请你返回所有可能合法路径中的最大得分。</p><p>由于答案可能很大，请你将它对 <code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802155350.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">30</span></span><br><span class="line">解释：合法路径包括：</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>],（从 nums1 开始遍历）</span><br><span class="line">[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  （从 nums2 开始遍历）</span><br><span class="line">最大得分为上图中的绿色路径 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], nums2 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>]</span><br><span class="line">输出：<span class="number">109</span></span><br><span class="line">解释：最大得分由路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], nums2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：nums1 和 nums2 之间无相同数字。</span><br><span class="line">最大得分由路径 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">19</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">61</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 10^5</code></li><li><code>1 &lt;= nums2.length &lt;= 10^5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/get-the-maximum-score" target="_blank" rel="noopener">https://leetcode-cn.com/problems/get-the-maximum-score</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，跟以前的某个题目很想，即两个数组中取最大的路径。</li><li>本身题目一眼看到就直到怎么做，所以肯定可以做出来，直接copy排名第一的代码。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000001</span>;</span><br><span class="line">        boolean[] a = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        boolean[] b = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums1)a[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums2)b[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> da = <span class="number">0</span>, db = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])da += i;</span><br><span class="line">        <span class="keyword">if</span>(b[i])db += i;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">        da = Math.max(da, db);</span><br><span class="line">        db = da;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>)(Math.max(da, db)%<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;200场周赛&quot;&gt;&lt;a href=&quot;#200场周赛&quot; class=&quot;headerlink&quot; title=&quot;200场周赛&quot;&gt;&lt;/a&gt;200场周赛&lt;/h1&gt;&lt;p&gt;本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的&lt;code&gt;dp&lt;/code&gt;即可做出来，四道题全部AC，周赛排名&lt;code&gt;150&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png&quot; alt=&quot;image-20200802145522515&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5475-统计好三元组&quot;&gt;&lt;a href=&quot;#5475-统计好三元组&quot; class=&quot;headerlink&quot; title=&quot;5475. 统计好三元组&quot;&gt;&lt;/a&gt;5475. 统计好三元组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; ，以及 &lt;code&gt;a、b 、c&lt;/code&gt;三个整数。请你统计其中好三元组的数量。&lt;/p&gt;&lt;p&gt;如果三元组 &lt;code&gt;(arr[i], arr[j], arr[k])&lt;/code&gt; 满足下列全部条件，则认为它是一个 好三元组 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 199周赛</title>
    <link href="http://yoursite.com/2020/07/26/185/"/>
    <id>http://yoursite.com/2020/07/26/185/</id>
    <published>2020-07-26T10:17:23.607Z</published>
    <updated>2020-08-02T07:58:45.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199场周赛"><a href="#199场周赛" class="headerlink" title="199场周赛"></a>199场周赛</h1><p>稳定的三道选手，最后一题<code>hard</code>难度不会。</p><h2 id="5472-重新排列字符串"><a href="#5472-重新排列字符串" class="headerlink" title="5472. 重新排列字符串"></a>5472. 重新排列字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个 长度相同 的整数数组 <code>indices</code> 。</p><p>请你重新排列字符串 s ，其中第 i 个字符需要移动到<code>indices[i]</code>指示的位置。</p><p>返回重新排列后的字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"codeleet"</span>, indices = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：如图所示，<span class="string">"codeleet"</span> 重新排列后变为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, indices = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"abc"</span></span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aiohn"</span>, indices = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">"nihao"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaiougrt"</span>, indices = [<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="string">"arigatou"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"art"</span>, indices = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"rat"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/shuffle-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shuffle-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(n,<span class="string">'a'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[indices[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5473-灯泡开关-IV"><a href="#5473-灯泡开关-IV" class="headerlink" title="5473. 灯泡开关 IV"></a>5473. 灯泡开关 IV</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>房间中有 n 个灯泡，编号从 <code>0</code>到 <code>n-1</code> ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。</p><p>请你设法使得灯泡的开关状态和 <code>target</code>描述的状态一致，其中 <code>target[i]</code>等于 <code>1</code>第 <code>i</code>个灯泡是开着的，等于 0 意味着第 <code>i</code>个灯是关着的。</p><p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p><p>选择当前配置下的任意一个灯泡（下标为 i ）<br>翻转下标从<code>i</code>到 <code>n-1</code> 的每个灯泡<br>翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。</p><p>返回达成 <code>target</code>描述的状态所需的 最少 翻转次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"10111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：初始配置 <span class="string">"00000"</span>.</span><br><span class="line">从第 <span class="number">3</span> 个灯泡（下标为 <span class="number">2</span>）开始翻转 <span class="string">"00000"</span> -&gt; <span class="string">"00111"</span></span><br><span class="line">从第 <span class="number">1</span> 个灯泡（下标为 <span class="number">0</span>）开始翻转 <span class="string">"00111"</span> -&gt; <span class="string">"11000"</span></span><br><span class="line">从第 <span class="number">2</span> 个灯泡（下标为 <span class="number">1</span>）开始翻转 <span class="string">"11000"</span> -&gt; <span class="string">"10111"</span></span><br><span class="line">至少需要翻转 <span class="number">3</span> 次才能达成 target 描述的状态</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="string">"000"</span> -&gt; <span class="string">"111"</span> -&gt; <span class="string">"100"</span> -&gt; <span class="string">"101"</span>.</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"00000"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"001011101"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>target[i] == &#39;0&#39; 或者 target[i] == &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iv</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目还是稍微有点<code>corner</code>,最终就是统计连续的<code>1</code>和<code>0</code>即可。</li><li>需要仔细思考一下，实际上我们可以将数目划分成初始状态相同的连续段即可，每一段作为整体翻转即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> curr = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c != curr)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                curr = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5474-好叶子节点对的数量"><a href="#5474-好叶子节点对的数量" class="headerlink" title="5474. 好叶子节点对的数量"></a>5474. 好叶子节点对的数量</h2><p>给你二叉树的根节点<code>root</code> 和一个整数 <code>distance</code>。</p><p>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 <code>distance</code>，那它们就可以构成一组 好叶子节点对 。</p><p>返回树中 好叶子节点对的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：树的叶节点是 <span class="number">3</span> 和 <span class="number">4</span> ，它们之间的最短路径的长度是 <span class="number">3</span> 。这是唯一的好叶子节点对。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好叶子节点对为 [<span class="number">4</span>,<span class="number">5</span>] 和 [<span class="number">6</span>,<span class="number">7</span>] ，最短路径长度都是 <span class="number">2</span> 。但是叶子节点对 [<span class="number">4</span>,<span class="number">6</span>] 不满足要求，因为它们之间的最短路径长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一的好叶子节点对是 [<span class="number">2</span>,<span class="number">5</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">100</span>], distance = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], distance = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>tree</code> 的节点数在<code>[1, 2^10]</code> 范围内。</li><li>每个节点的值都在 <code>[1, 100]</code>之间。</li><li><code>1 &lt;= distance &lt;= 10</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 标准的dfs</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的DFS，每次统计当前节点下，所有叶子节点到该根节点的距离。</li><li>每次DFS时，先计算左子树和右子树下的所有叶子节点到子树根节点的距离。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dfs(TreeNode * root,<span class="keyword">int</span> distance,<span class="keyword">int</span> &amp; res)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            left = dfs(root-&gt;left,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[lv.first + <span class="number">1</span>] += lv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            right = dfs(root-&gt;right,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv : right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[rv.first+<span class="number">1</span>] += rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv: right)&#123;</span><br><span class="line">                <span class="keyword">if</span>((lv.first + rv.first + <span class="number">2</span>) &lt;= distance)&#123;</span><br><span class="line">                    res += lv.second*rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root,distance,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5462-压缩字符串-II"><a href="#5462-压缩字符串-II" class="headerlink" title="5462. 压缩字符串 II"></a>5462. 压缩字符串 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code>，将 “aa” 替换为 “a2” ，”ccc” 替换为<code>&quot;c3&quot;</code>。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code>。</p><p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p><p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p><p>请你返回删除最多 <code>k</code>个字符后，s 行程长度编码的最小长度 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabcccd"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在不删除任何内容的情况下，压缩后的字符串是 <span class="string">"a3bc3d"</span> ，长度为 <span class="number">6</span> 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 <span class="string">"a3c3"</span> ，长度是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabbaa"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 <span class="number">2</span> 的 <span class="string">"a4"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaaaaaaaa"</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：由于 k 等于 <span class="number">0</span> ，不能删去任何字符。压缩后的字符串是 <span class="string">"a11"</span> ，长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= k &lt;= s.length</code></li><li><code>s</code> 仅包含小写英文字母</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/string-compression-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-compression-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始想到的也是<code>dp</code>，但是没有想到<code>dp</code>的递推公式到底该怎么写？</li><li><code>dp</code>或者记忆化搜索。</li><li>动态规划状态转移方程定义为<code>dp[i][j]</code>：</li></ol><ul><li>代表到达当前索引<code>i</code>处，已经选择删除了<code>j</code>个字符的最短长度。</li><li>假设对于当前索引<code>i+1</code>处的字符，如果我们选择删除第<code>i+1</code>个字符，则此时<script type="math/tex; mode=display">dp[i+1][j+1] = dp[i][j]</script>此时因为第<code>i+1</code>个字符已经被删除，所以我们实际上就相当于等于<code>dp[i][j]</code>.</li></ul></blockquote><ul><li>假设我们保留索引<code>i</code>处的字符，则我们应该选择后续与字符<code>i</code>相同的字符进行保留。则此时的状态转移方程为：<script type="math/tex; mode=display">dp[l][j+l-i-same(s[i],i,l)] = min(dp[i][j], len(same(s[i],i,l))]</script></li><li>方程比较难理解，意思假如我们保留当前字符串，则我们尝试在后续过程中连续增加与该字符相同的字符数量。</li></ul><ol><li>不管怎么算，最优解肯定包含在这个递推公式中，这也是动态规划的魅力。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+<span class="number">1</span>] = c[i];</span><br><span class="line">            c[i+<span class="number">1</span>][s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            len[i] = to_string(i).size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">                f[i][j] = INF;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> pos = i+<span class="number">1</span>; pos &lt;= n; ++pos)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">26</span>; ++nxt)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> has = c[pos][nxt]-c[i][nxt];</span><br><span class="line">                        <span class="keyword">if</span> (has == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i)] = min(f[pos][j+(pos-i)], f[i][j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i-has) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i-has)] = min(f[pos][j+(pos-i-has)], f[i][j]+len[has]+<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            res = min(res, f[n][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> dp[N][N][N][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> killed, <span class="keyword">int</span> len, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n) <span class="keyword">return</span> len &lt;= <span class="number">1</span> ? len : to_string(len).size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>&amp; ret = dp[pos][killed][len][last];</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        ret = N;</span><br><span class="line">        <span class="keyword">if</span> (killed + <span class="number">1</span> &lt;= m) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed + <span class="number">1</span>, len, last));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = s[pos] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == last) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed, len + <span class="number">1</span>, k));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = min((<span class="keyword">int</span>)ret, (len &lt;= <span class="number">1</span> ? len : (<span class="keyword">int</span>)to_string(len).size() + <span class="number">1</span>) + solve(pos + <span class="number">1</span>, killed, <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        n = s.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">255</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ret = solve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">1</span> &amp;&amp; k &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt;= <span class="number">10</span> &amp;&amp; k &lt; <span class="number">100</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">2</span>,INF));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; k) dp[i][j+<span class="number">1</span>] = min(dp[i][j+<span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> del = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = i; m &lt;= n; ++m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[m<span class="number">-1</span>] == s[i<span class="number">-1</span>]) same++;</span><br><span class="line">                    <span class="keyword">else</span> del++;</span><br><span class="line">                    <span class="keyword">if</span>(j + del &lt;= k)&#123;</span><br><span class="line">                        dp[m][j+del] = min(dp[m][j+del],len(same) + dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;199场周赛&quot;&gt;&lt;a href=&quot;#199场周赛&quot; class=&quot;headerlink&quot; title=&quot;199场周赛&quot;&gt;&lt;/a&gt;199场周赛&lt;/h1&gt;&lt;p&gt;稳定的三道选手，最后一题&lt;code&gt;hard&lt;/code&gt;难度不会。&lt;/p&gt;&lt;h2 id=&quot;5472-重新排列字符串&quot;&gt;&lt;a href=&quot;#5472-重新排列字符串&quot; class=&quot;headerlink&quot; title=&quot;5472. 重新排列字符串&quot;&gt;&lt;/a&gt;5472. 重新排列字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 s 和一个 长度相同 的整数数组 &lt;code&gt;indices&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;请你重新排列字符串 s ，其中第 i 个字符需要移动到&lt;code&gt;indices[i]&lt;/code&gt;指示的位置。&lt;/p&gt;&lt;p&gt;返回重新排列后的字符串。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如图所示，&lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt; 重新排列后变为 &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：重新排列后，每个字符都还留在原来的位置上。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aiohn&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;nihao&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aaiougrt&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;arigatou&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;art&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;rat&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 31周双周赛</title>
    <link href="http://yoursite.com/2020/07/26/184/"/>
    <id>http://yoursite.com/2020/07/26/184/</id>
    <published>2020-07-26T01:53:36.554Z</published>
    <updated>2020-07-26T01:53:40.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="31场双周赛"><a href="#31场双周赛" class="headerlink" title="31场双周赛"></a>31场双周赛</h1><p>题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名<code>387</code>.</p><h2 id="5456-在区间范围内统计奇数数目"><a href="#5456-在区间范围内统计奇数数目" class="headerlink" title="5456. 在区间范围内统计奇数数目"></a>5456. 在区间范围内统计奇数数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">3</span>, high = <span class="number">7</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 到 <span class="number">7</span> 之间奇数数字为 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">8</span>, high = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">8</span> 到 <span class="number">10</span> 之间奇数数字为 [<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学数学问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>小学数学问题，仔细推理一下就得到结果。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOdds</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> between = high - low;</span><br><span class="line">        <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (between+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> between/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5457-和为奇数的子数组数目"><a href="#5457-和为奇数的子数组数目" class="headerlink" title="5457. 和为奇数的子数组数目"></a>5457. 和为奇数的子数组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> 。请你返回和为 奇数 的子数组数目。</p><p>由于答案可能会很大，请你将结果对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有的子数组为 [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">5</span>]] 。</span><br><span class="line">所有子数组的和为 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>].</span><br><span class="line">奇数和包括 [<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>] ，所以答案为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有子数组为 [[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">4</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">6</span>]] 。</span><br><span class="line">所有子数组和为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>] 。</span><br><span class="line">所有子数组和都是偶数，所以答案为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">99</span>,<span class="number">99</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的动态规划，有两种思路。</li><li>第一种统计直到当前索引处，之前的前缀和中存在的偶数的数目和奇数的数目。</li><li>第二种统计以前一个元素<code>i-1</code>为结尾的子数组的和的数目中有多少个为偶数，有多少个为奇数。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                even++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = odd;</span><br><span class="line">                odd = even+<span class="number">1</span>;</span><br><span class="line">                even = t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + odd)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5458-字符串的好分割数目"><a href="#5458-字符串的好分割数目" class="headerlink" title="5458. 字符串的好分割数目"></a>5458. 字符串的好分割数目</h2><p>给你一个字符串<code>s</code>，一个分割被称为 「好分割」 当它满足：将 s 分割成 <code>2</code>个字符串 <code>p</code>和 <code>q</code>，它们连接起来等于 <code>s</code> 且<code>p</code> 和 <code>q</code>中不同字符的数目相同。</p><p>请你返回 <code>s</code>中好分割的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aacaba"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">5</span> 种分割字符串 <span class="string">"aacaba"</span> 的方法，其中 <span class="number">2</span> 种是好分割。</span><br><span class="line">(<span class="string">"a"</span>, <span class="string">"acaba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aa"</span>, <span class="string">"caba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aac"</span>, <span class="string">"aba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aaca"</span>, <span class="string">"ba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aacab"</span>, <span class="string">"a"</span>) 左边字符串和右边字符串分别包含 <span class="number">3</span> 个和 <span class="number">1</span> 个不同的字符。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcd"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：好分割为将字符串分割成 (<span class="string">"ab"</span>, <span class="string">"cd"</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaa"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有分割都是好分割。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"acbadbaada"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s</code> 只包含小写英文字母。</li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 统计字符个数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次将字符串分裂为两部分，求左右两部分的字符统计个数。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSplits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            right[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            right[s[i]-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[j] &gt; <span class="number">0</span>) l++;</span><br><span class="line">                <span class="keyword">if</span>(right[j] &gt; <span class="number">0</span>) r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5459-形成目标数组的子数组最少增加次数"><a href="#5459-形成目标数组的子数组最少增加次数" class="headerlink" title="5459. 形成目标数组的子数组最少增加次数"></a>5459. 形成目标数组的子数组最少增加次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>target</code>和一个数组 <code>initial</code> ，<code>initial</code> 数组与 <code>target</code>  数组有同样的维度，且一开始全部为 0 。</p><p>请你返回从 <code>initial</code> 得到  <code>target</code> 的最少操作次数，每次操作需遵循以下规则：</p><p>在 <code>initial</code> 中选择 任意 子数组，并将子数组中每个元素增加 1 。<br>答案保证在 <code>32</code>位有符号整数以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们需要至少 <span class="number">3</span> 次操作从 <span class="built_in">int</span>ial 数组得到 target 数组。</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 将下标为 <span class="number">0</span> 到 <span class="number">4</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 将下标为 <span class="number">1</span> 到 <span class="number">3</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 将下表为 <span class="number">2</span> 的元素增加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] 得到了目标数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] (target) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] </span><br><span class="line">                                  -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>] (target)。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>1 &lt;= target[i] &lt;= 10^5</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>仔细分析一下，我们可以将类似的图画出来,数组的上升和下降描述如图所示。<br><img src="https://pic.leetcode-cn.com/3be4e85cf2f773d84ad514812a541ceabe6e333a6ae9a2bb3ed0c572051cc0bd-5.png" alt="1"></li><li>类似于爬坡，由于子数组每次增加的大小为1，我们只需要统计从每个区间从谷底爬到谷峰需要的数目之和即可。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOperations</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == null || target.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = target[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            <span class="comment">//若target[i] - target[i - 1] &gt; 0</span></span><br><span class="line">            ans += Math.max(target[i] - target[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;31场双周赛&quot;&gt;&lt;a href=&quot;#31场双周赛&quot; class=&quot;headerlink&quot; title=&quot;31场双周赛&quot;&gt;&lt;/a&gt;31场双周赛&lt;/h1&gt;&lt;p&gt;题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名&lt;code&gt;387&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;5456-在区间范围内统计奇数数目&quot;&gt;&lt;a href=&quot;#5456-在区间范围内统计奇数数目&quot; class=&quot;headerlink&quot; title=&quot;5456. 在区间范围内统计奇数数目&quot;&gt;&lt;/a&gt;5456. 在区间范围内统计奇数数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://yoursite.com/2020/07/20/183/"/>
    <id>http://yoursite.com/2020/07/20/183/</id>
    <published>2020-07-20T03:39:33.773Z</published>
    <updated>2020-07-20T15:00:57.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在<code>O(lgn)</code>时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下<code>lowbit</code>的概念.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过lowbit本质即快速的求出一个数二进制最低位的1.<br>对于原始数组<code>A[n]</code>,我们定义一个服装数组<code>tr[n]</code>.其中tr[i]为数组中<code>i</code>开始的前<code>lowbit(i)</code>个元素的和，我们可以用以下公式表示:</p><a id="more"></a><script type="math/tex; mode=display">tr[i] = \sum_{j = (i-lowbit(i)+1)}^{i}A[j]</script><p>实际上我们也可以利用前缀和，快速的求出<code>tr[i]</code>.</p><script type="math/tex; mode=display">tr[i] = presum[i] - presum[i-lowbit(i)]</script><p>利用前缀和即可在<code>O(n)</code>的时间复杂度内初始化<code>tr</code>数组。</p><ul><li><strong>单点更新</strong>：数组A[i]单点更新数组中元素单点跟新后，我们只需要找到它的父节点进行传递更新即可，采用累加<code>lowbit</code>即可。原理其实很简单，本质上是递归。将数组中<code>tr</code>中含有<code>A[i]</code>的节点全部进行更新即可。<br>更新的技巧为，我们不断的叠加<code>lowbit</code>直到<code>i</code>的大于<code>n</code>，我们如何快速的查找它的父节点呢？</li></ul><ol><li>比如<code>i</code>为12，我们如何快速找到12的父节点呢，A[12]最近的父节点为<code>tr[12]</code>.</li><li>第一次加上<code>lowbit(12)</code>,<code>i</code>变为<code>16</code>，A[12]的第二个父节点为<code>tr[16]</code>.,</li><li>第一次加上<code>lowbit(16)</code>,<code>i</code>变为<code>32</code>，A[12]的第三个父节点为<code>tr[32]</code>.,</li><li>直到<code>i</code>大于数组的长度<code>n</code>结束。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) </span><br><span class="line">        tr[i] += a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间和获取</strong>：我们可以快速的获取数组A中前<code>i</code>个元素，则区间和即为<code>tr[i]-tr[j]</code>。其实本质上我们是对<code>i</code>按照二进制进行分解，分别求出前$2^{k}$个元素。<script type="math/tex; mode=display">i = \sum_{j = 1}^{k} 2^{a^{j}}</script>可以举个例子来说明，比如数字12的二进制位<code>1100</code>,可以分解位<code>12 = 8 + 4</code>.</li></ul><ol><li>取第一次<code>lowbit(i)</code>为<code>4</code>，这时我们取得数字<code>12</code>的前4个数组中的元素分别为<code>A[12],A[11],A[10],A[9]</code>。</li><li>减掉第一个<code>lowbit(i)</code>，则数字<code>i</code>变为<code>8</code>，我们再次获取<code>i</code>的<code>lowbit(i)</code>个元素,即获取前8个元素，则这时的取得元素为：<code>A[8],A[7],A[6],A[5],A[4],A[3],A[2],A[1]</code>.<br>通过上面这个例子我们即可以看出如何进行分别求合。原理非常巧妙。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))  res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间更新</strong>：区间更新稍微复杂点，比如我们对数组<code>A</code>的区间<code>[i,j]</code>进行更新，比如同时在区间<code>[i,j]</code>中的元素都加上<code>x</code>,这时我们求范围和该如何解决呢？<br>首先我们思考以下，原始数组的前缀和$sum[i]$能否用辅助数组$tr$来表示呢？<script type="math/tex; mode=display">sum[i] = \sum_{k=1}^{i}A[k] = A[1] + A[2] + A[3] + ... + A[i]</script>试想一下，我们假设能够构造出差分数组$C[i]$满足如下所示：<script type="math/tex; mode=display">A[i] = C[i] - C[i-1] \\sum[n] = \sum_{i=1}^{n}A[i] = A[1] + A[2] + A[3] + ... + A[n] \\\qquad \\= (C[1]) + (C[1] + C[2]) + ... + (C[1] + C[2] + ...+ C[n]) \\\qquad \\= n*C[1] + (n-1)*C[2] + (n-2)*C[3] + ... + C[n] \\\qquad= n*(C[1] + C[2] + C[3] + ... + C[n]) - (0*C[1] + 1*C[2] + ...+(n-1)*C[n]) \\\qquad \\= n\sum_{i=1}^{n}C[i] - \sum_{i=1}^{n}C[i]*(i-1)</script>所以我们需要维护再维护两个树状数组，能够利用树状数组快速的求和，我们知道数组<code>C[i]</code>和<code>C[i]*(i-1)</code>很容易求出来。能够快速的求出<code>C[i]</code>和<code>C[i]*(i-1)</code>的区间和即可。<br>我们维护两个树状数组：<script type="math/tex; mode=display">TA[i] = C[i], TB[i] = C[i]*(i-1)</script>我们进行区间更新时，比如我们需要将原始数组<code>A[n]</code>的区间<code>[l,r]</code>中的元素都增加<code>x</code>,此时我们只需要先将<code>A[1]~A[r]</code>的元素都增加<code>x</code>,然后再将<code>A[1]~A[l]</code>中的元素都减少<code>x</code>即可。</li><li>单点更新：在<code>x</code>处增减<code>val</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += (i&amp;-i))<span class="comment">//更新后缀的父节点</span></span><br><span class="line">&#123;</span><br><span class="line">TA[i] += val;</span><br><span class="line">TB[i] += val * (x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h3 id="2-区间求极值"><a href="#2-区间求极值" class="headerlink" title="2. 区间求极值"></a>2. 区间求极值</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot; class=&quot;headerlink&quot; title=&quot;树状数组&quot;&gt;&lt;/a&gt;树状数组&lt;/h1&gt;&lt;p&gt;关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在&lt;code&gt;O(lgn)&lt;/code&gt;时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下&lt;code&gt;lowbit&lt;/code&gt;的概念.&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lowbit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x &amp;amp; -x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;通过lowbit本质即快速的求出一个数二进制最低位的1.&lt;br&gt;对于原始数组&lt;code&gt;A[n]&lt;/code&gt;,我们定义一个服装数组&lt;code&gt;tr[n]&lt;/code&gt;.其中tr[i]为数组中&lt;code&gt;i&lt;/code&gt;开始的前&lt;code&gt;lowbit(i)&lt;/code&gt;个元素的和，我们可以用以下公式表示:&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 198场双周赛</title>
    <link href="http://yoursite.com/2020/07/19/182/"/>
    <id>http://yoursite.com/2020/07/19/182/</id>
    <published>2020-07-19T10:00:25.189Z</published>
    <updated>2020-07-20T03:20:48.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="198场双周赛"><a href="#198场双周赛" class="headerlink" title="198场双周赛"></a>198场双周赛</h1><p>微软的题目果真很难，基本上都有非常不错的技巧性，还是稳定的三题选手。自我感慨还是智商不够，无论刷再多的题目，可能永远都达不到顶尖级选手,说到底还是资质或者天赋的问题。感觉接触算法这类东西一定要早，越早越能够培养自己的思维能力，思维能力到了一定年龄就会定型或者衰退。越早发现锻炼自己思维能力的训练，越早开始。</p><a id="more"></a><h2 id="5464-换酒问题"><a href="#5464-换酒问题" class="headerlink" title="5464. 换酒问题"></a>5464. 换酒问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 <code>numBottles</code> 瓶酒。</p><p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多 能喝到多少瓶酒。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">9</span>, numExchange = <span class="number">3</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：你可以用 <span class="number">3</span> 个空酒瓶兑换 <span class="number">1</span> 瓶酒。</span><br><span class="line">所以最多能喝到 <span class="number">9</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">13</span> 瓶酒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">15</span>, numExchange = <span class="number">4</span></span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：你可以用 <span class="number">4</span> 个空酒瓶兑换 <span class="number">1</span> 瓶酒。</span><br><span class="line">所以最多能喝到 <span class="number">15</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">19</span> 瓶酒。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">5</span>, numExchange = <span class="number">5</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">2</span>, numExchange = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/water-bottles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-bottles</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学奥数问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>小学数学问题<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = numBottles;</span><br><span class="line">        <span class="keyword">while</span>(numBottles &gt;= numExchange)&#123;</span><br><span class="line">            res += (numBottles/numExchange);</span><br><span class="line">            numBottles = (numBottles/numExchange) + (numBottles%numExchange);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5465-子树中标签相同的节点数"><a href="#5465-子树中标签相同的节点数" class="headerlink" title="5465. 子树中标签相同的节点数"></a>5465. 子树中标签相同的节点数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code>到<code>n - 1</code> 的<code>n</code>个节点组成，且恰好有 <code>n - 1</code>条 <code>edges</code> 。树的根节点为节点 <code>0</code>，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p><p>边数组 <code>edges</code> 以<code>edges[i] = [ai, bi]</code>的形式给出，该格式表示节点 <code>ai</code>和 <code>bi</code>之间存在一条边。</p><p>返回一个大小为<code>n</code> 的数组，其中 <code>ans[i]</code>表示第 <code>i</code> 个节点的子树中与节点<code>i</code>标签相同的节点数。</p><p>树<code>T</code> 中的子树是由 <code>T</code>中的某个节点及其所有后代节点组成的树。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], labels = <span class="string">"abaedcd"</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：节点 <span class="number">0</span> 的标签为 'a' ，以 'a' 为根节点的子树中，节点 <span class="number">2</span> 的标签也是 'a' ，因此答案为 <span class="number">2</span> 。注意树中的每个节点都是这棵子树的一部分。</span><br><span class="line">节点 <span class="number">1</span> 的标签为 'b' ，节点 <span class="number">1</span> 的子树包含节点 <span class="number">1</span>、<span class="number">4</span> 和 <span class="number">5</span>，但是节点 <span class="number">4</span>、<span class="number">5</span> 的标签与节点 <span class="number">1</span> 不同，故而答案为 <span class="number">1</span>（即，该节点本身）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]], labels = <span class="string">"bbbb"</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：节点 <span class="number">2</span> 的子树中只有节点 <span class="number">2</span> ，所以答案为 <span class="number">1</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的子树中只有节点 <span class="number">3</span> ，所以答案为 <span class="number">1</span> 。</span><br><span class="line">节点 <span class="number">1</span> 的子树中包含节点 <span class="number">1</span> 和 <span class="number">2</span> ，标签都是 'b' ，因此答案为 <span class="number">2</span> 。</span><br><span class="line">节点 <span class="number">0</span> 的子树中包含节点 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">3</span>，标签都是 'b'，因此答案为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">4</span>]], labels = <span class="string">"aabab"</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], labels = <span class="string">"cbabaa"</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>]], labels = <span class="string">"aaabaaa"</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>labels.length == n</code></li><li><code>labels 仅由小写英文字母组成</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>常规题目DFS，统计子树含有的字母数目，然后向父节点传递。</li><li>该题有点坑的是父节点和子节点的顺序是不确定的，这就需要自己去判断，可以设标志变量什么的。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ans,<span class="built_in">string</span> &amp; labels)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(visit[curr]) <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        visit[curr] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[curr].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[tree[curr][i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = dfs(tree[curr][i],visit,tree,ans,labels);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                cnt[j] += next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[labels[curr]-<span class="string">'a'</span>]++;</span><br><span class="line">        ans[curr] = cnt[labels[curr]-<span class="string">'a'</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSubTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            tree[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            tree[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,visit,tree,ans,labels);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5466-最多的不重叠子字符串"><a href="#5466-最多的不重叠子字符串" class="headerlink" title="5466. 最多的不重叠子字符串"></a>5466. 最多的不重叠子字符串</h2><p>给你一个只包含小写字母的字符串 <code>s</code>，你需要找到<code>s</code>中最多数目的非空子字符串，满足如下条件：</p><ul><li>这些字符串之间互不重叠，也就是说对于任意两个子字符串 <code>s[i..j]</code> 和 <code>s[k..l]</code> ，要么 <code>j &lt; k</code> 要么 <code>i &gt; l</code> 。</li><li>如果一个子字符串包含字符 <code>c</code> ，那么<code>s</code>中所有 <code>c</code>字符都应该在这个子字符串中。<br>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。<br>请注意，你可以以 任意 顺序返回最优解的子字符串。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adefaddaccc"</span></span><br><span class="line">输出：[<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"ccc"</span>]</span><br><span class="line">解释：下面为所有满足第二个条件的子字符串：</span><br><span class="line">[</span><br><span class="line">  <span class="string">"adefaddaccc"</span></span><br><span class="line">  <span class="string">"adefadda"</span>,</span><br><span class="line">  <span class="string">"ef"</span>,</span><br><span class="line">  <span class="string">"e"</span>,</span><br><span class="line">  <span class="string">"f"</span>,</span><br><span class="line">  <span class="string">"ccc"</span>,</span><br><span class="line">]</span><br><span class="line">如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 <span class="number">1</span> 。如果我们选择 <span class="string">"adefadda"</span> ，剩下子字符串中我们只可以选择 <span class="string">"ccc"</span> ，它是唯一不重叠的子字符串，所以答案为 <span class="number">2</span> 。同时我们可以发现，选择 <span class="string">"ef"</span> 不是最优的，因为它可以被拆分成 <span class="number">2</span> 个子字符串。所以最优解是选择 [<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"ccc"</span>] ，答案为 <span class="number">3</span> 。不存在别的相同数目子字符串解。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbaccd"</span></span><br><span class="line">输出：[<span class="string">"d"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>]</span><br><span class="line">解释：注意到解 [<span class="string">"d"</span>,<span class="string">"abba"</span>,<span class="string">"cc"</span>] 答案也为 <span class="number">3</span> ，但它不是最优解，因为它的总长度更长。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 类似于滑动窗口 + 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>先求出所有字母的在字符串位置的左边界和右边界$(l_{a},r_{a})$。</li><li>求出满足题目两个要求的区间段。我们定义这样的区间内$(l_{a},r_{a})$：</li></ol><ul><li>我们在区间内遍历所有的字符，如果区间内的字符<code>x</code>的右边界$r_{x}$大于$r_{a}$，则令$r_{a} = r_{x}$</li><li>我们在区间内遍历所有的字符，如果区间内的字符<code>x</code>的左边界$l_{x}$小于$l_{a}$，则我们认为该区间$(l_{a},r_{a})$可能已经被区间$l_{x},r_{x}$包含，所以这样的区间则认为是非法的，直接去掉。</li></ul><ol><li>我们利用<code>2</code>的做法，找到所有符合的区间集合$\epsilon$。在这区间中再次进行遍历，去掉区间存在包含的区间段，比如对于区间$(l_{a},r_{a})$，如果在集合$\epsilon$中存在区间$l_{x},r_{x}$被区间$(l_{a},r_{a})$包含，满足以下条件：<script type="math/tex; mode=display">l_{a} \le l_{x},r_{x} \le r_{a}</script>则我们去掉该区间$(l_{a},r_{a})$,最后的结果即为所求。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; maxNumOfSubstrings(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(<span class="number">26</span>,n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            left[x] = min(left[x],i);</span><br><span class="line">            right[x] = max(right[x],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = left[i];</span><br><span class="line">            <span class="keyword">int</span> r = right[i];</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[s[j]-<span class="string">'a'</span>] &gt; r)&#123;</span><br><span class="line">                    r = right[s[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left[s[j]-<span class="string">'a'</span>] &lt; l)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                curr.push_back(&#123;l,r&#125;);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;s.substr(l,r-l+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != i &amp;&amp; (curr[i].first &lt;= curr[j].first &amp;&amp; curr[i].second &gt;= curr[j].second))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans.push_back(s.substr(curr[i].first,curr[i].second - curr[i].first + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5467-找到最接近目标值的函数值"><a href="#5467-找到最接近目标值的函数值" class="headerlink" title="5467. 找到最接近目标值的函数值"></a>5467. 找到最接近目标值的函数值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Winston</code>构造了一个如上所示的函数 <code>func</code>。他有一个整数数组<code>arr</code>和一个整数 <code>target</code> ，他想找到让 <code>|func(arr, l, r) - target|</code>最小的 <code>l</code> 和<code>r</code> 。<br><img src="https://mike-box.github.io/images/186-1.png" alt="1"></p><p>请你返回 <code>|func(arr, l, r) - target|</code> 的最小值。</p><p>请注意， <code>func</code>的输入参数 <code>l</code>和 <code>r</code>需要满足<code>0 &lt;= l, r &lt; arr.length</code>。<br>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>], target = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有可能的 [l,r] 数对包括 [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">4</span>]]， Winston 得到的相应结果为 [<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 。最接近 <span class="number">5</span> 的值是 <span class="number">7</span> 和 <span class="number">3</span>，所以最小差值为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1000000</span>,<span class="number">1000000</span>,<span class="number">1000000</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">999999</span></span><br><span class="line">解释：Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 <span class="number">1000000</span> ，所以最小差值为 <span class="number">999999</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>0 &lt;= target &lt;= 10^7</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们需要注意一点，题目中是子序列进行<code>and</code>操作，所以我们知道任何两个数：<script type="math/tex; mode=display">(X \And Y) \le X</script>一个数<code>x</code>与上另外一个数<code>y</code>一定是小于等于<code>x</code>本身的。如果知道这点特性就知道数组与操作是递减的，因此：<script type="math/tex; mode=display">func(arr,l,r) \le func(arr,l,r+1)</script>由于按位与我们知道最终的值是从大到小的，所以我们知道<code>arr[i]</code>的最大值为$10^{6}\eqsim 2^{20}$,按照递减规则我们可知最终与的结果最多也就只有$20$种，因此我们可以直接用暴力搜索即可，每次记录前一次<code>i</code>与<code>(0~i-1)</code>的结果，下次将指针往后移一位即可。</li><li>根据1的推理，我们很容易联想到用二分查找，只需要每次固定<code>l</code>查找最接近<code>target</code>的两个数即可获取到差的绝对值的最小值。但是二分查找，如何先线性时间复杂度内计算出<code>arr[l]&amp;arr[l+1]&amp;...&amp;arr[r-1]&amp;arr[r]</code>的结果，我们可以利用前缀和，求出整数位<code>i</code>的前缀和，我们每次只需要计算出<code>(l,r)</code>第<code>i</code>的<code>1</code>的个数：<script type="math/tex; mode=display">sum[i] = bit[r][i] - bits[l-1][i]</script>如果<code>sum[i] == r - l + 1</code>则我们认为该位的连续与的结果不为<code>0</code>.非常巧妙的办法，然后我们就可以利用二分查找，查找出第一个大于等于<code>target</code>的数。注意题目中的测试用例，我们可以去掉连续相等的元素来加快该算法，否则会超时。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ol><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestToTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ns;</span><br><span class="line">            ns.insert(arr[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a : s)</span><br><span class="line">                ns.insert(a&amp;arr[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a : ns)</span><br><span class="line">                ans=min(ans, <span class="built_in">abs</span>(a-target));</span><br><span class="line">            s=ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; bits,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)&#123;</span><br><span class="line">                x = bits[r][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x = bits[r][i] - bits[l<span class="number">-1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( x == (r-l+<span class="number">1</span>))&#123;</span><br><span class="line">                ans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestToTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*detech the same element*/</span></span><br><span class="line">        arr.push_back(A[l]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.size() &amp;&amp; A[i] == A[l]) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.size() &amp;&amp; A[i] != A[l])&#123;</span><br><span class="line">                arr.push_back(A[i]);</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">             </span><br><span class="line">        <span class="comment">/*calc bits*/</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bits(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">30</span>,<span class="number">0</span>));   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) bits[i][j] += bits[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>((arr[i]&amp;(<span class="number">1</span>&lt;&lt;j))&gt;&gt;j)&#123;</span><br><span class="line">                    bits[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*binary search*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">int</span> last = arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curr = calc(bits,i,mid);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;l&lt;&lt;":"&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;curr&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(curr &gt;= target)&#123;</span><br><span class="line">                    t = mid;   </span><br><span class="line">                    last = curr;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*first less than target*/</span></span><br><span class="line">            ans = min(ans,<span class="built_in">abs</span>(target - last));</span><br><span class="line">            <span class="keyword">if</span>(t &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(target - (last&amp;arr[t+<span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;198场双周赛&quot;&gt;&lt;a href=&quot;#198场双周赛&quot; class=&quot;headerlink&quot; title=&quot;198场双周赛&quot;&gt;&lt;/a&gt;198场双周赛&lt;/h1&gt;&lt;p&gt;微软的题目果真很难，基本上都有非常不错的技巧性，还是稳定的三题选手。自我感慨还是智商不够，无论刷再多的题目，可能永远都达不到顶尖级选手,说到底还是资质或者天赋的问题。感觉接触算法这类东西一定要早，越早越能够培养自己的思维能力，思维能力到了一定年龄就会定型或者衰退。越早发现锻炼自己思维能力的训练，越早开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://yoursite.com/2020/07/16/181/"/>
    <id>http://yoursite.com/2020/07/16/181/</id>
    <published>2020-07-16T04:53:13.896Z</published>
    <updated>2020-07-16T04:53:44.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>今天意外的看到了牛顿迭代法，对这个理论感到很好奇，特意去网上找了下资料，牛顿迭代法<code>（Newton&#39;s method）</code>又称为牛顿-拉夫逊（拉弗森）方法<code>（Newton-Raphson method）</code>，它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。</p><ul><li><p>多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。牛顿迭代法使用函数  的泰勒级数的前面几项来寻找方程  的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程  的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。</p></li><li><p>上面的描述过于偏学术化，我们知道有些一元多次方程的最终解可能非常难求，如果直接求解的话，可能根本就没有解方程的办法，但是我们可以利用牛顿迭代法本质上可以求出方程的近似的一个或者多个解。</p></li></ul><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们设方程函数$f(x) = m$,改方程可以转化为$g(x) = f(x) - m = 0$<br>我们只需要求出函数$g(x) = 0$的解，就可以求出$f(x) = m$的解。</p><h2 id="牛顿迭代公式"><a href="#牛顿迭代公式" class="headerlink" title="牛顿迭代公式"></a>牛顿迭代公式</h2><p>设$r$ 是$f(x) = 0$的根，选取$x_{0}$作为$r$的初始近似值，则我们可以过点$(x_{0},f(x_{0}))$做曲线$y = f(x)$的切线$L$,我们知道切线与$x$轴有交点，我们已知切线$L$的方程为$L : y = f(x_{0}) + f^{‘}(x_{0})(x - x_{0})$我们求的它与$x$轴的交点为$x_{1} = x_{0} - \frac{f(x_{0})}{f^{‘}(x_{0})}$. 我们在以$(x_{1},f({x_{1}}))$斜率为$f^{‘}(x_{1})$做斜线，求出与$x$轴的交点，重复以上过程直到$f(x_{n})$无限接近于0即可。其中第n次的迭代公式为：</p><script type="math/tex; mode=display">x_{n+1} = x_{n} - \frac{f(x_{n})}{f^{'}(x_{n})}</script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>以函数$f(x) = (x-2)^{2}$为例，</p><ol><li>我们可以任意取一点A$(4,4)$,在曲线上做A的切线，求得切线与$x$轴的交点为B。<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105091145041-2070095820.png" alt="1"></li><li>在曲线上做C点的切线，交X轴与D点，在D点做X轴的垂线，交曲线于E点。我们可以看到D点比B点更加接近方程$f(x) = (x - 2) * (x - 2) = 0$ 的根$（x = 2）$.<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105091934676-1885017107.png" alt="2"></li><li>在曲线上做E点的切线，交X轴与F点，在F点做X轴的垂线，交曲线于G点。可以看到G点比D点更加接近方程的根.<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105092153981-1909291306.png" alt="3"></li><li>按照这个方式一直迭代即可得到函数$f(x) = 0$的近似解。</li></ol><h2 id="牛顿法求平方根"><a href="#牛顿法求平方根" class="headerlink" title="牛顿法求平方根"></a>牛顿法求平方根</h2><p>我们对实数<code>n</code>求其开方，即$f(x) = x^{2} - n = 0$得算法平方根。我们可以根据上述方法得到迭代<code>n</code>次的公式为:</p><script type="math/tex; mode=display">x_{n+1} = x_{n} - \frac{f(x_{n})}{f^{'}(x_{n})} = x_{n} - \frac{x_{n}^{2}-n}{2x_{n}} = \frac{1}{2}(x_{n} + \frac{n}{x_{n}})</script><ul><li>以下为实现代码，初始时设$x_{0} = n$.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">1e-15</span>;</span><br><span class="line">    <span class="keyword">double</span> x = c;</span><br><span class="line">    <span class="keyword">double</span> y = (x + c / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(x - y) &gt; e) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = (x + c / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-stream</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">letrec</span></span> ([<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                    (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">next</span> (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x (<span class="name"><span class="builtin-name">/</span></span> n x)) <span class="number">2.0</span>)])</span><br><span class="line">                         (<span class="name"><span class="builtin-name">cons</span></span> next (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> next)))))])</span><br><span class="line">            (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> n))))</span><br><span class="line">                         </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">approx-sqrt</span> n e)</span><br><span class="line">    (<span class="name">stream-until</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">*</span></span> e <span class="number">1.0</span>) (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name"><span class="builtin-name">*</span></span> n <span class="number">1.0</span>) (<span class="name"><span class="builtin-name">*</span></span> x x))))) (<span class="name">sqrt-stream</span> n)))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;牛顿迭代法&quot;&gt;&lt;a href=&quot;#牛顿迭代法&quot; class=&quot;headerlink&quot; title=&quot;牛顿迭代法&quot;&gt;&lt;/a&gt;牛顿迭代法&lt;/h1&gt;&lt;p&gt;今天意外的看到了牛顿迭代法，对这个理论感到很好奇，特意去网上找了下资料，牛顿迭代法&lt;code&gt;（Newton&amp;#39;s method）&lt;/code&gt;又称为牛顿-拉夫逊（拉弗森）方法&lt;code&gt;（Newton-Raphson method）&lt;/code&gt;，它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。牛顿迭代法使用函数  的泰勒级数的前面几项来寻找方程  的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程  的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的描述过于偏学术化，我们知道有些一元多次方程的最终解可能非常难求，如果直接求解的话，可能根本就没有解方程的办法，但是我们可以利用牛顿迭代法本质上可以求出方程的近似的一个或者多个解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 197场双周赛</title>
    <link href="http://yoursite.com/2020/07/13/180/"/>
    <id>http://yoursite.com/2020/07/13/180/</id>
    <published>2020-07-13T05:50:28.686Z</published>
    <updated>2020-07-13T09:42:31.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="197场双周赛"><a href="#197场双周赛" class="headerlink" title="197场双周赛"></a>197场双周赛</h1><p>稳定的三道选手，比赛排名为263名，最后一题实话实说太蛋疼了。解法诡异，<code>python</code>的梯度下降直接可以搞定。前三题都是水题毫无难度。<br><img src="https://mike-box.github.io/images/183-1.png" alt="1"></p><h2 id="5460-好数对的数目"><a href="#5460-好数对的数目" class="headerlink" title="5460. 好数对的数目"></a>5460. 好数对的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code>满足 <code>nums[i] == nums[j]</code>且 <code>i &lt; j</code>，就可以认为这是一组 好数对 。</p><a id="more"></a><p>返回好数对的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 组好数对，分别是 (<span class="number">0</span>,<span class="number">3</span>), (<span class="number">0</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">2</span>,<span class="number">5</span>) ，下标从 <span class="number">0</span> 开始</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-pairs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  统计数目</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计数字的数目即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(x))&#123;</span><br><span class="line">                ans += cnt[x];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5461-仅含-1-的子串数"><a href="#5461-仅含-1-的子串数" class="headerlink" title="5461. 仅含 1 的子串数"></a>5461. 仅含 1 的子串数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code>（仅由<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串）。</p><p>返回所有字符都为 1 的子字符串的数目。</p><p>由于答案可能很大，请你将它对<code>10^9 + 7</code>取模后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0110111"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：共有 <span class="number">9</span> 个子字符串仅由 '<span class="number">1</span>' 组成</span><br><span class="line"><span class="string">"1"</span> -&gt; <span class="number">5</span> 次</span><br><span class="line"><span class="string">"11"</span> -&gt; <span class="number">3</span> 次</span><br><span class="line"><span class="string">"111"</span> -&gt; <span class="number">1</span> 次</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子字符串 <span class="string">"1"</span> 在 s 中共出现 <span class="number">2</span> 次</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"111111"</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：每个子字符串都仅由 '<span class="number">1</span>' 组成</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"000"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s[i] == &#39;0&#39; 或 s[i] == &#39;1&#39;</code></li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-substrings-with-only-1s</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>统计连续<code>1</code>的个数，然后利用求合公式即可，非常简单，没啥好说的。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = (ans + (curr*(curr+<span class="number">1</span>))/<span class="number">2</span>)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5211-概率最大的路径"><a href="#5211-概率最大的路径" class="headerlink" title="5211. 概率最大的路径"></a>5211. 概率最大的路径</h2><p>给你一个由 <code>n</code>个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中<code>edges[i] = [a, b]</code>表示连接节点 <code>a</code> 和 <code>b</code>的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code>。</p><p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code>，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p><p>如果不存在从 <code>start</code>到 <code>end</code>的路径，请 返回 0 。只要答案与标准答案的误差不超过 <code>1e-5</code> ，就会被视作正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]], succProb = [<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.2</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 <span class="number">0.2</span> ，而另一条为 <span class="number">0.5</span> * <span class="number">0.5</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]], succProb = [<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.3</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.30000</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>]], succProb = [<span class="number">0.5</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.00000</span></span><br><span class="line">解释：节点 <span class="number">0</span> 和 节点 <span class="number">2</span> 之间不存在路径</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^4</code></li><li><code>0 &lt;= start, end &lt; n</code></li><li><code>start != end</code></li><li><code>0 &lt;= a, b &lt; n</code></li><li><code>a != b</code></li><li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li><li><code>0 &lt;= succProb[i] &lt;= 1</code></li><li>每两个节点之间最多有一条边</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-with-maximum-probability</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的dijistra算法，去掉概率较小的路径即可。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dp(n,<span class="number">0.0</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;&gt; qu;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(make_pair(edges[i][<span class="number">1</span>],succProb[i]));</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(make_pair(edges[i][<span class="number">0</span>],succProb[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[start] = <span class="number">1.0</span>;</span><br><span class="line">        qu.push(make_pair(start,<span class="number">1.0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">int</span> x = curr.first;</span><br><span class="line">            <span class="keyword">double</span> p = curr.second;</span><br><span class="line">            <span class="keyword">if</span>(x == end)&#123;</span><br><span class="line">                ans = max(ans,p);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[x])&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = v.first;</span><br><span class="line">                <span class="keyword">double</span> nxp = v.second*p;</span><br><span class="line">                <span class="keyword">if</span>(dp[nx] &gt;= nxp) <span class="keyword">continue</span>;</span><br><span class="line">                dp[nx] = nxp;</span><br><span class="line">                qu.push(make_pair(nx,nxp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5463-服务中心的最佳位置"><a href="#5463-服务中心的最佳位置" class="headerlink" title="5463. 服务中心的最佳位置"></a>5463. 服务中心的最佳位置</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。</p><p>给你一个数组 <code>positions</code>，其中 <code>positions[i] = [xi, yi]</code> 表示第 <code>i</code>个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。</p><p>换句话说，请你为服务中心选址，该位置的坐标<code>[xcentre, ycentre]</code>需要使下面的公式取到最小值：</p><p>与真实值误差在<code>10^-5</code>之内的答案将被视作正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4.00000</span></span><br><span class="line">解释：如图所示，你可以选 [xcentre, ycentre] = [<span class="number">1</span>, <span class="number">1</span>] 作为新中心的位置，这样一来到每个客户的距离就都是 <span class="number">1</span>，所有距离之和为 <span class="number">4</span> ，这也是可以找到的最小值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2.82843</span></span><br><span class="line">解释：欧几里得距离可能的最小总和为 sqrt(<span class="number">2</span>) + sqrt(<span class="number">2</span>) = <span class="number">2.82843</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">0.00000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2.73205</span></span><br><span class="line">解释：乍一看，你可能会将中心定在 [<span class="number">1</span>, <span class="number">0</span>] 并期待能够得到最小总和，但是如果选址在 [<span class="number">1</span>, <span class="number">0</span>] 距离总和为 <span class="number">3</span></span><br><span class="line">如果将位置选在 [<span class="number">1.0</span>, <span class="number">0.5773502711</span>] ，距离总和将会变为 <span class="number">2.73205</span></span><br><span class="line">当心精度问题！</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">9</span>],[<span class="number">11</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">32.94036</span></span><br><span class="line">解释：你可以用 [<span class="number">4.3460852395</span>, <span class="number">4.9813795505</span>] 作为新中心的位置</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= positions.length &lt;= 50</code></li><li><code>positions[i].length == 2</code></li><li><code>0 &lt;= positions[i][0], positions[i][1] &lt;= 100</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/best-position-for-a-service-centre" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-position-for-a-service-centre</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>数学问题,凸函数求极值问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>拿到这个题目确实没有想到好办法，好多人都用的机器学习中的梯度下降法来解决这个问题的。以前确实从来没有见到过这种题型，所以不知道该怎么解决这类题目。</li><li>本质题目是凸函数求极值的问题。题目貌似为几何中位数，首先证明该函数为凸函数，如果为凸函数则表明该函数只有一个最优解，因此通过模拟得到的局部最优解也即为全局最优解。设目标函数为$f(x,y)$表示选址为<code>(x,y)</code>时的距离，我们最终求得的是最小的$f(x,y)$.<script type="math/tex; mode=display">f(x,y) = \sum_{i=1}^{n}\sqrt{(a_{i}-x)^{2}+(b_{i}-y)^{2}}</script>对$f(x,y)$分别对x,y进行求导则得到：<script type="math/tex; mode=display">\frac{\partial{f(x,y)}}{\partial{x}} = \sum_{i=1}^{n}\frac{x-a_{i}}{\sqrt{(a_{i}-x)^{2}+(b_{i}-y)^{2}}} \\\frac{\partial^{2}{f(x,y)}}{\partial{x^{2}}} = \sum_{i=1}^{n}\frac{(y-b_{i})^{2}}{((a_{i}-x)^{2}+(b_{i}-y)^{2})^{\frac{3}{2}}} \\\frac{\partial^{2}{f(x,y)}}{\partial{y^{2}}} = \sum_{i=1}^{n}\frac{(x-a_{i})^{2}}{((a_{i}-x)^{2}+(b_{i}-y)^{2})^{\frac{3}{2}}}</script>我们可以看出$f(x,y)$ 对$x$和$y$的二阶导数都大于等于<code>0</code>，因此$f(x,y)$在x方向和y方向上都应该为凸函数。<br>对于凸函数来说，凸函数的局部最优就是全局最优，所以使用基于梯度的优化方法不用担心陷入局部最优的情况。</li><li>实际可能的解法有以下三种：</li></ol><ul><li>三分</li><li>模拟退火</li><li>梯度下降</li></ul><ol><li>以下给的是<code>cuiaoxiang</code>的模拟退火算法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ld = <span class="keyword">double</span>;</span><br><span class="line">    <span class="keyword">const</span> ld pi = <span class="number">3.1415926535897932384626</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        ld x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x += p[i][<span class="number">0</span>];</span><br><span class="line">            y += p[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        x /= n;</span><br><span class="line">        y /= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> go = [&amp;](ld x, ld y)</span><br><span class="line">        &#123;</span><br><span class="line">            ld ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                ret += <span class="built_in">sqrt</span>((x-p[i][<span class="number">0</span>])*(x-p[i][<span class="number">0</span>])+(y-p[i][<span class="number">1</span>])*(y-p[i][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ld T = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">while</span> (T &gt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            T *= <span class="number">0.99</span>;</span><br><span class="line">            ld rd = (rand()%<span class="number">10000</span>+<span class="number">1</span>)/<span class="number">10000.0</span>;</span><br><span class="line">            ld a = <span class="number">2</span>*pi*rd;</span><br><span class="line">            ld tx = x+T*<span class="built_in">cos</span>(a), ty = y+T*<span class="built_in">sin</span>(a);</span><br><span class="line">            <span class="keyword">auto</span> d = go(tx, ty)-go(x, y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = tx, y = ty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> go(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; p, <span class="keyword">const</span> Point&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(p.x - q.x) + sqr(p.y - q.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; a, Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; q : a) &#123;</span><br><span class="line">            ret += dist(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; a(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = Point&#123;(<span class="keyword">double</span>)p[i][<span class="number">0</span>], (<span class="keyword">double</span>)p[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        Point c = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            c.x += p[i][<span class="number">0</span>];</span><br><span class="line">            c.y += p[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        c.x /= n;</span><br><span class="line">        c.y /= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> step = <span class="number">50</span>; step &gt; <span class="number">1e-6</span>; ) &#123;</span><br><span class="line">            Point u = &#123;c.x + step, c.y&#125;;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x - step, c.y&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x, c.y + step&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x, c.y - step&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!found) step /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;197场双周赛&quot;&gt;&lt;a href=&quot;#197场双周赛&quot; class=&quot;headerlink&quot; title=&quot;197场双周赛&quot;&gt;&lt;/a&gt;197场双周赛&lt;/h1&gt;&lt;p&gt;稳定的三道选手，比赛排名为263名，最后一题实话实说太蛋疼了。解法诡异，&lt;code&gt;python&lt;/code&gt;的梯度下降直接可以搞定。前三题都是水题毫无难度。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/183-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5460-好数对的数目&quot;&gt;&lt;a href=&quot;#5460-好数对的数目&quot; class=&quot;headerlink&quot; title=&quot;5460. 好数对的数目&quot;&gt;&lt;/a&gt;5460. 好数对的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;如果一组数字 &lt;code&gt;(i,j)&lt;/code&gt;满足 &lt;code&gt;nums[i] == nums[j]&lt;/code&gt;且 &lt;code&gt;i &amp;lt; j&lt;/code&gt;，就可以认为这是一组 好数对 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 30场双周赛</title>
    <link href="http://yoursite.com/2020/07/13/179/"/>
    <id>http://yoursite.com/2020/07/13/179/</id>
    <published>2020-07-13T00:38:11.940Z</published>
    <updated>2020-07-13T05:52:44.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30场双周赛"><a href="#30场双周赛" class="headerlink" title="30场双周赛"></a>30场双周赛</h1><p>这次双周赛的题目太水了，4个题目都是水题，估计手速快的10分钟搞定。四个题目完全没有难度。</p><h2 id="5177-转变日期格式"><a href="#5177-转变日期格式" class="headerlink" title="5177. 转变日期格式"></a>5177. 转变日期格式</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>date</code> ，它的格式为 <code>Day Month Year</code> ，其中：</p><ul><li><code>Day</code> 是集合 <code>{&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;}</code>中的一个元素。</li><li><code>Month</code> 是集合<code>{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}</code> 中的一个元素。</li><li><code>Year</code>的范围在 <code>​[1900, 2100]</code> 之间。<br>请你将字符串转变为 <code>YYYY-MM-DD</code> 的格式，其中：</li><li><code>YYYY</code> 表示 4 位的年份。</li><li><code>MM</code> 表示 2 位的月份。</li><li><code>DD</code> 表示 2 位的天数。</li></ul><a id="more"></a><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"20th Oct 2052"</span></span><br><span class="line">输出：<span class="string">"2052-10-20"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"6th Jun 1933"</span></span><br><span class="line">输出：<span class="string">"1933-06-06"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"26th May 1960"</span></span><br><span class="line">输出：<span class="string">"1960-05-26"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>给定日期保证是合法的，所以不需要处理异常输入。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/reformat-date/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/reformat-date/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力解析</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>字符串解析<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformatDate</span><span class="params">(self, date: str)</span> -&gt; str:</span></span><br><span class="line">        day, mon, year = date.split()</span><br><span class="line">        mon_map = [<span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>, <span class="string">"May"</span>, <span class="string">"Jun"</span>, <span class="string">"Jul"</span>, <span class="string">"Aug"</span>, <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span>]</span><br><span class="line">        mon_map = &#123;mon_map[i]:i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s-%02d-%02d"</span> % (year, mon_map[mon]+<span class="number">1</span>, int(day[:<span class="number">-2</span>]))</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5445-子数组和排序后的区间和"><a href="#5445-子数组和排序后的区间和" class="headerlink" title="5445. 子数组和排序后的区间和"></a>5445. 子数组和排序后的区间和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 <code>n * (n + 1) / 2</code> 个数字的数组。</p><p>请你返回在新数组中下标为 <code>left</code>到 <code>right</code> （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 <code>10^9 + 7</code>取模后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">1</span>, right = <span class="number">5</span></span><br><span class="line">输出：<span class="number">13</span> </span><br><span class="line">解释：所有的子数组和为 <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span> 。将它们升序排序后，我们得到新的数组 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>] 。下标从 le = <span class="number">1</span> 到 ri = <span class="number">5</span> 的和为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">3</span>, right = <span class="number">4</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：给定数组与示例 <span class="number">1</span> 一样，所以新数组为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>] 。下标从 le = <span class="number">3</span> 到 ri = <span class="number">4</span> 的和为 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">1</span>, right = <span class="number">10</span></span><br><span class="line">输出：<span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^3</code></li><li><code>nums.length == n</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/range-sum-of-sorted-subarray-sums/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/range-sum-of-sorted-subarray-sums/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力排序即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>没啥难度，直接排序暴力就可以过。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                arr.push_back(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            ans = (ans + arr[i<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5446-三次操作后最大值与最小值的最小差"><a href="#5446-三次操作后最大值与最小值的最小差" class="headerlink" title="5446. 三次操作后最大值与最小值的最小差"></a>5446. 三次操作后最大值与最小值的最小差</h2><p>给你一个数组<code>nums</code> ，每次操作你可以选择<code>nums</code>中的任意一个数字并将它改成任意值。</p><p>请你返回三次操作后， <code>nums</code> 中最大值与最小值的差的最小值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：将数组 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] 变成 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>].</span><br><span class="line">最大值与最小值的差为 <span class="number">2</span><span class="number">-2</span> = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：将数组 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>] 变成 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br><span class="line">最大值与最小值的差为 <span class="number">1</span><span class="number">-0</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看起来很唬人，实际非常简单。我们就当作在数组中去掉三个数，然后求最大数与最小数的差。</li><li>去掉三个数，实际上即去掉数组排序后的左边和右边的三个数的组合即可。总共有四种可能：<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num<span class="string">[0]</span>,num<span class="string">[1]</span>,num<span class="string">[2]</span></span><br><span class="line">num<span class="string">[n-1]</span>,num<span class="string">[0]</span>,num<span class="string">[1]</span></span><br><span class="line">num<span class="string">[n-2]</span>,num<span class="string">[n-1]</span>,num<span class="string">[0]</span></span><br><span class="line">num<span class="string">[n-3]</span>,num<span class="string">[n-2]</span>,num<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>将以上四种可能遍历后求最大值与最小值的最小值即可，数组长度小于4的时候直接返回0。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            ans = min(ans,nums[n<span class="number">-4</span>+i] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5447-石子游戏-IV"><a href="#5447-石子游戏-IV" class="headerlink" title="5447. 石子游戏 IV"></a>5447. 石子游戏 IV</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 和 <code>Bob</code>两个人轮流玩一个游戏，<code>Alice</code> 先手。</p><p>一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。</p><p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p><p>给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：Alice 拿走 <span class="number">1</span> 个石子并赢得胜利，因为 Bob 无法进行任何操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Alice 只能拿走 <span class="number">1</span> 个石子，然后 Bob 拿走最后一个石子并赢得胜利（<span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：n 已经是一个平方数，Alice 可以一次全拿掉 <span class="number">4</span> 个石子并赢得胜利（<span class="number">4</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。</span><br><span class="line">如果 Alice 一开始拿走 <span class="number">4</span> 个石子， Bob 会拿走 <span class="number">1</span> 个石子，然后 Alice 只能拿走 <span class="number">1</span> 个石子，Bob 拿走最后一个石子并赢得胜利（<span class="number">7</span> -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br><span class="line">如果 Alice 一开始拿走 <span class="number">1</span> 个石子， Bob 会拿走 <span class="number">4</span> 个石子，然后 Alice 只能拿走 <span class="number">1</span> 个石子，Bob 拿走最后一个石子并赢得胜利（<span class="number">7</span> -&gt; <span class="number">6</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">17</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-30/problems/stone-game-iv/</span></span><br><span class="line">### 题意</span><br><span class="line">dp</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 这个题目烂大街的水题了，dp即可，类似博弈论一样，每次双方都是最优选择，最后看谁能在最优策略下取胜。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> winnerSquareGame(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; dp(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i-j*j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;30场双周赛&quot;&gt;&lt;a href=&quot;#30场双周赛&quot; class=&quot;headerlink&quot; title=&quot;30场双周赛&quot;&gt;&lt;/a&gt;30场双周赛&lt;/h1&gt;&lt;p&gt;这次双周赛的题目太水了，4个题目都是水题，估计手速快的10分钟搞定。四个题目完全没有难度。&lt;/p&gt;&lt;h2 id=&quot;5177-转变日期格式&quot;&gt;&lt;a href=&quot;#5177-转变日期格式&quot; class=&quot;headerlink&quot; title=&quot;5177. 转变日期格式&quot;&gt;&lt;/a&gt;5177. 转变日期格式&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;date&lt;/code&gt; ，它的格式为 &lt;code&gt;Day Month Year&lt;/code&gt; ，其中：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Day&lt;/code&gt; 是集合 &lt;code&gt;{&amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, &amp;quot;4th&amp;quot;, ..., &amp;quot;30th&amp;quot;, &amp;quot;31st&amp;quot;}&lt;/code&gt;中的一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Month&lt;/code&gt; 是集合&lt;code&gt;{&amp;quot;Jan&amp;quot;, &amp;quot;Feb&amp;quot;, &amp;quot;Mar&amp;quot;, &amp;quot;Apr&amp;quot;, &amp;quot;May&amp;quot;, &amp;quot;Jun&amp;quot;, &amp;quot;Jul&amp;quot;, &amp;quot;Aug&amp;quot;, &amp;quot;Sep&amp;quot;, &amp;quot;Oct&amp;quot;, &amp;quot;Nov&amp;quot;, &amp;quot;Dec&amp;quot;}&lt;/code&gt; 中的一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Year&lt;/code&gt;的范围在 &lt;code&gt;​[1900, 2100]&lt;/code&gt; 之间。&lt;br&gt;请你将字符串转变为 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 的格式，其中：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YYYY&lt;/code&gt; 表示 4 位的年份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MM&lt;/code&gt; 表示 2 位的月份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DD&lt;/code&gt; 表示 2 位的天数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 196周比赛</title>
    <link href="http://yoursite.com/2020/07/05/178/"/>
    <id>http://yoursite.com/2020/07/05/178/</id>
    <published>2020-07-05T15:55:47.305Z</published>
    <updated>2020-07-09T02:42:00.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="196周比赛"><a href="#196周比赛" class="headerlink" title="196周比赛"></a>196周比赛</h1><p>对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，<code>hard</code>题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。</p><h2 id="5452-判断能否形成等差数列"><a href="#5452-判断能否形成等差数列" class="headerlink" title="5452. 判断能否形成等差数列"></a>5452. 判断能否形成等差数列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数字数组 <code>arr</code> 。</p><p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。</p><p>如果可以重新排列数组形成等差数列，请返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：对数组重新排序得到 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] 或者 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>] ，任意相邻两项的差分别为 <span class="number">2</span> 或 <span class="number">-2</span> ，可以形成等差数列。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法通过重新排序得到等差数列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 1000</code></li><li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接排序即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) != (arr[i<span class="number">-1</span>]-arr[i<span class="number">-2</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5453-所有蚂蚁掉下来前的最后一刻"><a href="#5453-所有蚂蚁掉下来前的最后一刻" class="headerlink" title="5453. 所有蚂蚁掉下来前的最后一刻"></a>5453. 所有蚂蚁掉下来前的最后一刻</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一块木板，长度为<code>n</code>个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。</p><p>当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p><p>而当蚂蚁在某一时刻 <code>t</code>到达木板的一端时，它立即从木板上掉下来。</p><p>给你一个整数<code>n</code>和两个整数数组 <code>left</code>以及<code>right</code>。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, left = [<span class="number">4</span>,<span class="number">3</span>], right = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：如上图所示：</span><br><span class="line">-下标 <span class="number">0</span> 处的蚂蚁命名为 A 并向右移动。</span><br><span class="line">-下标 <span class="number">1</span> 处的蚂蚁命名为 B 并向右移动。</span><br><span class="line">-下标 <span class="number">3</span> 处的蚂蚁命名为 C 并向左移动。</span><br><span class="line">-下标 <span class="number">4</span> 处的蚂蚁命名为 D 并向左移动。</span><br><span class="line">请注意，蚂蚁在木板上的最后时刻是 t = <span class="number">4</span> 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = <span class="number">4.0000000001</span> 时，木板上没有蚂蚁）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [], right = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向右移动，下标为 <span class="number">0</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], right = []</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向左移动，下标为 <span class="number">7</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, left = [<span class="number">5</span>], right = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：t = <span class="number">1</span> 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, left = [<span class="number">6</span>], right = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>0 &lt;= left.length &lt;= n + 1</code></li><li><code>0 &lt;= left[i] &lt;= n</code></li><li><code>0 &lt;= right.length &lt;= n + 1</code></li><li><code>0 &lt;= right[i] &lt;= n</code></li><li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li><li><code>left</code>和 <code>right</code>中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常类似于一个非常著名的小学奥数题目，信鸽的问题。比如这个信鸽飞行问题：(<a href="http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml" target="_blank" rel="noopener">http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml</a>)</li><li>不管图中有多少只蚂蚁，实际上最终的时间是由最左边且走向向右和最右边且方向向左的两只方向相对的蚂蚁决定的。类似于这样。因为两只蚂蚁调头，并且两只蚂蚁的移动速度相等，则实际就相当于两只蚂蚁调头实际等价于两只蚂蚁直接越过对方。所以总的时间只与某个蚂蚁的最长掉落时间有关。</li><li>我们求出所有蚂蚁的掉落时间，取其中最大的掉落时间即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); ++i) ans = max(ans,left[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.size(); ++i) ans = max(ans,n-right[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5454-统计全-1-子矩形"><a href="#5454-统计全-1-子矩形" class="headerlink" title="5454. 统计全 1 子矩形"></a>5454. 统计全 1 子矩形</h2><p>给你一个只包含 <code>0</code>和<code>1</code>的 <code>rows * columns</code> 矩阵 <code>mat</code> ，请你返回有多少个 子矩形 的元素全部都是 1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 个 <span class="number">1</span>x1 的矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x2 的矩形。</span><br><span class="line">有 <span class="number">3</span> 个 <span class="number">2</span>x1 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">2</span>x2 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x1 的矩形。</span><br><span class="line">矩形数目总共 = <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">8</span> 个 <span class="number">1</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">5</span> 个 <span class="number">1</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x3 的子矩形。</span><br><span class="line">有 <span class="number">4</span> 个 <span class="number">2</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">2</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">3</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x2 的子矩形。</span><br><span class="line">矩形数目总共 = <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rows &lt;= 150</code></li><li><code>1 &lt;= columns &lt;= 150</code></li><li><code>0 &lt;= mat[i][j] &lt;= 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-submatrices-with-all-ones</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的还是非常好，看似这种很简单的题目，但是背后的思考技巧，值得深入思考和思索，时间复杂度为O(n^3).首先看到题目中给定的数量范围即可知道本题的实际的时间复杂度应该为<code>O(n^3)</code>或者 <code>O(n^2lgn)</code>.</li><li>如图<img src="https://mike-box.github.io/images/181-1.png" alt="1">所示,我们每次求出以坐标(i,j)为右下角的顶点的所有矩形个数，<code>rectange(i,j)</code>.<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}rectange(i,j)</script></li><li>求这个有点技巧，我们先求出高度为h且右下角的顶点为(i,j)的矩形个数为<code>rectange(i,j，h)</code>，如图<img src="https://mike-box.github.io/images/181-2.png" alt="2">所示。<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}\sum_{h=1}^{i} rectange(i,j,h)</script>我们只需要求出高位为h的矩形的最大宽度即可。<script type="math/tex; mode=display">w(i,j,h) = min(w(i,j,k)_{k=1}^{h-1})</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + (j == <span class="number">0</span> ? <span class="number">0</span>:dp[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> maxColum = col;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span> &amp;&amp; dp[k][j] &gt; <span class="number">0</span>; --k)&#123;</span><br><span class="line">                    maxColum = min(maxColum,dp[k][j]);</span><br><span class="line">                    ans += maxColum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5455-最多-K-次交换相邻数位后得到的最小整数"><a href="#5455-最多-K-次交换相邻数位后得到的最小整数" class="headerlink" title="5455. 最多 K 次交换相邻数位后得到的最小整数"></a>5455. 最多 K 次交换相邻数位后得到的最小整数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>和一个整数 <code>k</code>。其中，<code>num</code>表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。</p><p>你可以交换这个整数相邻数位的数字 最多 <code>k</code>次。</p><p>请你返回你能得到的最小整数，并以字符串形式返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"4321"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"1342"</span></span><br><span class="line">解释：<span class="number">4321</span> 通过 <span class="number">4</span> 次交换相邻数位得到最小整数的步骤如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"100"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"010"</span></span><br><span class="line">解释：输出可以包含前导 <span class="number">0</span> ，但输入保证不会有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"36789"</span>, <span class="attr">k</span> = <span class="number">1000</span></span><br><span class="line">输出：<span class="string">"36789"</span></span><br><span class="line">解释：不需要做任何交换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"22"</span>, <span class="attr">k</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="string">"22"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"9438957234785635408"</span>, <span class="attr">k</span> = <span class="number">23</span></span><br><span class="line">输出：<span class="string">"0345989723478563548"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 30000</code></li><li><code>num</code> 只包含 数字 且不含有 前导 <code>0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目本身用暴力法很简单，只需要在当前数位<code>i</code>后的<code>k</code>个位置内找到比<code>num[i]</code>小的最小数即可，然后交换，并同时将数位往后移动即可。这个题目确实是个高质量的好题，需要仔细思考和思索，但是遇到这类题目往往都歇菜，需要<code>ACM</code>经验的人，需要对<code>segmentTree</code>应用非常熟悉才可以。</li><li>我们可以以公式代替：<script type="math/tex; mode=display">num[i] = min(num[j]_{j=i+1}^{min(i+k,n-1)})</script>即在连续的k个位置中找到最小的num[i]。</li><li>这题的难点在于找到<code>num[i]</code>后续<code>K</code>位内的目标数<code>num[j]</code>以后,需要对<code>(i+1,j-1)</code>都需要将其索引往后移动一位，这点如何在线性时间复杂度内完成，是完成本题的关键。<br>如图<img src="https://mike-box.github.io/images/181-3.png" alt="3">所示，我们的实际移动示意如图所示。</li><li>难点在于segmentTree的使用，需要仔细学习，该题目用的树状数组可以很快解决。，大概是第2次遇到树状数组的题目了。参考这个<a href="https://www.cnblogs.com/findview/archive/2019/08/01/11281628.html" target="_blank" rel="noopener">博客</a>，写的非常明白。定义数组如下：<br><img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png" alt="1"><br>我们知道设原始数组为<code>A[1...n]</code>。则我们新设置数组C如下令：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C</span>[<span class="number">1</span>] = <span class="symbol">A</span>[<span class="number">1</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">2</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">3</span>] = <span class="symbol">A</span>[<span class="number">3</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">4</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">5</span>] = <span class="symbol">A</span>[<span class="number">5</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">6</span>] = <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">7</span>] = <span class="symbol">A</span>[<span class="number">7</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">8</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>] + <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>] + <span class="symbol">A</span>[<span class="number">7</span>] + <span class="symbol">A</span>[<span class="number">8</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>实际可以归纳为：<script type="math/tex; mode=display">C[i] = A[i - 2^{k}+1] + A[i - 2^{k}+2] + ... + A[i] \\C[i] = \sum_{j = i-2^{k}+1}^{i}A[j]</script>另一个关键是，如果我们需要求出前<code>i</code>项的前缀和，这个才是树状数组的精髓，通过上述的推理如何实现？实际仔细分析一下：<br><img src="https://bkimg.cdn.bcebos.com/pic/960a304e251f95ca5e588459cf177f3e660952ab?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="2"><br>给定<code>i</code>,我们如何知道前<code>i</code>项的前缀和由后缀数组的哪几项组成？<br>举两个例子m7和m6（sum(i)表示求编号为i的前缀和）</li></ol><ul><li>m==7 sum(7) = C7 + C6 + C4<br>那么我们是怎么得到编号7是由哪几个C[i]求和得到呢（C4, C6, C7怎么得到的），这里有介绍一种巧妙的方法：<br>对于查询的m，将它转换成二进制后，不断对末尾的1的位置进行-1的操作，直到全部为0停止<br>7的二进制为0111（C7得到），那么先对0111的末尾1的位置-1，得到0110 == 6（C6得到），再对0110末尾1位置-1，得到0100 == 4（C4得到），最后对0100末尾1位置-1后得到0000（结束信号），计算停止，至此C7，C6，C4全部得到，求和后就是m == 7时它的前缀和。</li><li>m==6 sum(6) = C6 + C4<br>m == 6时也是一样，先转成2进制等于0110，经过两次变换后为0100（C4）和0000（结束信号），那么求和后同样也得到了预计的结果</li></ul><script type="math/tex; mode=display">sum[i] = C[i] + C[i-2^{k_{1}}] + C[i-2^{k_{1}}-2^{k_{2}}] + ...+</script><p>即每次将<code>i</code>上低位的1去掉。<br>其中<code>k</code>为数字<code>i</code>最低位连续0的个数。可以通过快速计算得到$2^{k}$.</p><script type="math/tex; mode=display">2^{k} = i\&(-i)</script><p>其中的原因如下：<br>这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 x&amp;(-x)有：<br>● 当x为0时，即 0 &amp; 0，结果为0；<br>●当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。<br>●当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x&amp; (-x) 得到的就是x。<br>●当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。<br>总结一下：x&amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。以代码形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>知道了以上基层我们可以通过树状数组干很多事情，最重要的即为可以进行区间求合和查询。比如加我们在数组中的某个数更新了<code>num</code>.则我们只需要向上跟新即可，即更新<code>arr[i]</code>的父节点即可, 我们向上循环查找它的父节点，即每次加上<code>lowbit</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;    <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如何求该数组的前<code>i</code>项的前缀和？我们不断的减去<code>i</code>的最低位<code>1</code>即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;        <span class="comment">//求A[1 - i]的和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>假设求区间<code>[i,j]</code>的和，则我们可以利用两个前缀和的组合实现即可。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">i</span>,j) = getsum(<span class="name">j</span>) - getsum(<span class="name">i-1</span>)</span><br></pre></td></tr></table></figure></li><li><p>区间更新如何实现？</p></li><li><p>例题参考：</p></li></ol><ul><li><a href="https://www.luogu.org/problem/show?pid=3368" target="_blank" rel="noopener">https://www.luogu.org/problem/show?pid=3368</a></li><li><a href="https://vjudge.net/problem/POJ-3468" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3468</a></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = 0; i &lt; n &amp;&amp; k &gt; <span class="number">0</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; j &lt;= i + k; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &lt; num[t])&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = num[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &gt; i; --j)&#123;</span><br><span class="line">                num[j] = num[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] = c;</span><br><span class="line">            k -= t - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>SegmentTree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) &#123;</span><br><span class="line">        ret += c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            pos[x].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; pick(n);</span><br><span class="line">        fill(c, c + N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (m) &#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos[k].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'0'</span> + k);</span><br><span class="line">                <span class="keyword">int</span> x = pos[k].front();</span><br><span class="line">                <span class="keyword">int</span> cnt = query(x);</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= cnt) &#123;</span><br><span class="line">                    m -= cnt;</span><br><span class="line">                    add(x + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                    ret += c;</span><br><span class="line">                    pick[x] = <span class="literal">true</span>;</span><br><span class="line">                    pos[k].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pick[i]) ret += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minInteger</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pqs stores the location of each digit.</span></span><br><span class="line">        List&lt;Queue&lt;Integer&gt;&gt; pqs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            pqs.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            pqs.get(num.charAt(i) - <span class="string">'0'</span>).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        SegmentTree seg = <span class="keyword">new</span> SegmentTree(num.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            <span class="comment">// At each location, try to place 0....9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt;= <span class="number">9</span>; ++digit) &#123;</span><br><span class="line">                <span class="comment">// is there any occurrence of digit left?</span></span><br><span class="line">                <span class="keyword">if</span> (pqs.get(digit).size() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// yes, there is a occurrence of digit at pos</span></span><br><span class="line">                    Integer pos = pqs.get(digit).peek();</span><br><span class="line"><span class="comment">// Since few numbers already shifted to left, this `pos` might be outdated.</span></span><br><span class="line">                    <span class="comment">// we try to find how many number already got shifted that were to the left of pos.</span></span><br><span class="line">                    <span class="keyword">int</span> shift = seg.getCountLessThan(pos);</span><br><span class="line">                    <span class="comment">// (pos - shift) is number of steps to make digit move from pos to i.</span></span><br><span class="line">                    <span class="keyword">if</span> (pos - shift &lt;= k) &#123;</span><br><span class="line">                        k -= pos - shift;</span><br><span class="line">                        seg.add(pos); <span class="comment">// Add pos to our segment tree.</span></span><br><span class="line">                        pqs.get(digit).remove();</span><br><span class="line">                        ans += digit;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nodes;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * (max)];</span><br><span class="line">            n = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            addUtil(num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addUtil</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; l || num &gt; r) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                nodes[node]++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            addUtil(num, l, mid, <span class="number">2</span> * node + <span class="number">1</span>);</span><br><span class="line">            addUtil(num, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">            nodes[node] = nodes[<span class="number">2</span> * node + <span class="number">1</span>] + nodes[<span class="number">2</span> * node + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Essentialy it tells number of numbers &lt; num.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCountLessThan</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getUtil(<span class="number">0</span>, num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getUtil</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (qr &lt; l || ql &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes[node];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> getUtil(ql, qr, l, mid, <span class="number">2</span> * node + <span class="number">1</span>) + getUtil(ql, qr, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;196周比赛&quot;&gt;&lt;a href=&quot;#196周比赛&quot; class=&quot;headerlink&quot; title=&quot;196周比赛&quot;&gt;&lt;/a&gt;196周比赛&lt;/h1&gt;&lt;p&gt;对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，&lt;code&gt;hard&lt;/code&gt;题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。&lt;/p&gt;&lt;h2 id=&quot;5452-判断能否形成等差数列&quot;&gt;&lt;a href=&quot;#5452-判断能否形成等差数列&quot; class=&quot;headerlink&quot; title=&quot;5452. 判断能否形成等差数列&quot;&gt;&lt;/a&gt;5452. 判断能否形成等差数列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数字数组 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。&lt;/p&gt;&lt;p&gt;如果可以重新排列数组形成等差数列，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2020年下半年计划（7月）</title>
    <link href="http://yoursite.com/2020/07/05/177/"/>
    <id>http://yoursite.com/2020/07/05/177/</id>
    <published>2020-07-05T14:36:53.225Z</published>
    <updated>2020-07-13T09:52:59.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年全年计划"><a href="#2020年全年计划" class="headerlink" title="2020年全年计划"></a>2020年全年计划</h1><p>2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。</p><h3 id="个人学习计划"><a href="#个人学习计划" class="headerlink" title="个人学习计划"></a>个人学习计划</h3><h4 id="书籍阅读计划"><a href="#书籍阅读计划" class="headerlink" title="书籍阅读计划"></a>书籍阅读计划</h4><p>今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：</p><a id="more"></a><div class="table-container"><table><thead><tr><th>序号</th><th>书籍名称</th><th>进度</th><th>种类</th></tr></thead><tbody><tr><td>1</td><td>少有人走的路</td><td>90%</td><td>心理学相关</td></tr><tr><td>2</td><td>人性的幽微</td><td>100%</td><td>心理学与个人成长相关</td></tr><tr><td>3</td><td>睡眠革命</td><td>100%</td><td>个人习惯养成</td></tr><tr><td>4</td><td>每周工作4小时</td><td>20%</td><td>个人成长系列</td></tr><tr><td>5</td><td>佐贺的超级阿嬷</td><td>100%</td><td>个人纪实成长</td></tr><tr><td>6</td><td>郭鹤年自传</td><td>100%</td><td>个人自传</td></tr><tr><td>7</td><td>自私的基因</td><td>%</td><td></td></tr><tr><td>8</td><td>爱弥儿</td><td>%</td><td></td></tr><tr><td>9</td><td>李光耀观天下</td><td>%</td><td></td></tr><tr><td>10</td><td>金字塔原理</td><td>%</td><td></td></tr><tr><td>11</td><td>怎样解题</td><td>%</td><td></td></tr><tr><td>12</td><td>火与烬</td><td>%</td><td></td></tr><tr><td>13</td><td>人类简史</td><td>%</td><td></td></tr><tr><td>14</td><td>从0到无穷大</td><td>%</td><td></td></tr><tr><td>15</td><td>走出自己的天空</td><td>100%</td><td></td></tr><tr><td>16</td><td></td><td>%</td><td></td></tr><tr><td>17</td><td></td><td>%</td><td></td></tr><tr><td>18</td><td></td><td>%</td><td></td></tr><tr><td>19</td><td></td><td>%</td><td></td></tr><tr><td>20</td><td></td><td>%</td></tr></tbody></table></div><h4 id="课程学习计划"><a href="#课程学习计划" class="headerlink" title="课程学习计划"></a>课程学习计划</h4><p>今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。计划学习人文类的课程和计算机技术的相关课程，以下是大概今年的30门课程计划，计划列表如下，以后每个月会定时更新自己的进度。</p><div class="table-container"><table><thead><tr><th>序号</th><th>课程名称</th><th>进度</th><th>类别</th><th>完成时间</th></tr></thead><tbody><tr><td>1</td><td>coursera: Learning How to Learn: Powerful mental tools to help you master tough subjects</td><td>100%</td><td>人文社科类</td><td>2020.1</td></tr><tr><td>2</td><td>coursera: algorithmic-toolbox</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>3</td><td>coursera: algorithms-on-strings</td><td>100%</td><td>computer scinece</td><td>2020.4</td></tr><tr><td>4</td><td>coursera：algorithms-on-graphs</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>5</td><td>coursera： algorithms-part2</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>6</td><td>coursera： data-structures</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>7</td><td>coursera： algorithms-part1</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>8</td><td>coursera：programming-languages partA</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>9</td><td>coursera：programming-languages partB</td><td>40%</td><td>computer scinece</td><td></td></tr><tr><td>10</td><td>coursera：programming-languages partC</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>11</td><td>coursera：Build a Modern Computer from First Principles: From Nand to Tetris I</td><td>62%</td><td>computer scinece</td><td>2020.7.5</td></tr><tr><td>12</td><td>coursera：Build a Modern Computer from First Principles: From Nand to Tetris II</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>13</td><td>coursera：Machine-learning-techniques</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>14</td><td>coursera：Machine Learning Foundations</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>15</td><td>哈佛大学公开课: 学习失败碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>16</td><td>哈佛大学公开课：立大志</td><td>0%</td><td></td><td></td></tr><tr><td>17</td><td>清华大学：高级数据结构</td><td>0%</td><td></td><td></td></tr><tr><td>18</td><td>哈佛大学公开课：科学与烹饪</td><td>0%</td><td></td><td></td></tr><tr><td>19</td><td>哈佛大学公开课：积极心理学碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>20</td><td>哈佛大学公开课：幸福课</td><td>0%</td><td></td><td></td></tr><tr><td>21</td><td>MIT 6.82 opertion system</td><td>0%</td><td></td><td></td></tr><tr><td>22</td><td>MIT 6.824 distribution System</td><td>0%</td><td></td><td></td></tr><tr><td>23</td><td>MIT DatabaseT Systems:</td><td>0%</td><td></td><td></td></tr><tr><td>24</td><td>MIT Advances in Computer Vision</td><td>0%</td><td></td><td></td></tr><tr><td>25</td><td>Javascript</td><td>0%</td><td></td><td></td></tr><tr><td>26</td><td>TensorFlow in Practice</td><td>0%</td><td></td><td></td></tr><tr><td>27</td><td>MIT:  Structure and Interpretation of Computer Programs</td><td>0%</td><td></td><td></td></tr><tr><td>28</td><td>Princeton : An Introduction to the Analysis of Algorithms</td><td>0%</td><td></td><td></td></tr><tr><td>29</td><td>MIT 6.851</td><td>0%</td><td></td><td></td></tr><tr><td>30</td><td>MIT Multicore Programming Primer</td><td>0%</td><td></td></tr></tbody></table></div><h4 id="考证认证"><a href="#考证认证" class="headerlink" title="考证认证"></a>考证认证</h4><ul><li>完成雅思认证</li><li>完成GRE认证</li><li>完成SAT考试<h4 id="刷题计划"><a href="#刷题计划" class="headerlink" title="刷题计划"></a>刷题计划</h4></li></ul><p>　　仔细看了许多所谓的刷题平台，实际上感觉单纯的枯燥的刷题实在是对进步不大，因为单纯的刷题很容易让人产生枯燥和烦躁的感觉，因为只有自己孤单一个人刷题，遇到问题也没有人跟你一起讨论，一起想解决办法。<br>　　我觉得CP练习的最好方式就是以考代练，先过一遍基础的理论和基础的题目，然后通过不断的参加定期的contest练习，反思的思考，跟他人讨论，总结，反馈，我觉得这样才是进步较快，一方面能够避免单纯刷题的枯燥；另一方面通过参加contest，适当的能够提高自己的紧张感觉，强迫自己思考的快速；第三，因为contest结束之后都有很多人参与一起讨论问题的解法，可以快速的学习他人的解题思路和方法，与高手交流才能快速进步；第四，contest都是定期举行，可以非常有效的防止刷题的偷懒，强迫自己定期的练习和提高，给人以监督感。以上四点我认为是<code>contest</code>作为练习的最大有点。在youtube上看到几个牛人都是定期参加各自<code>contest</code>，来保持自己的水平。<br>　　总和看来，我觉得以下三个平台适合新手难度的平台，<code>leetcode</code>适合程序员面试，<code>Atcoder</code>和<code>codeforces</code> 适合<code>CP</code>初级选手练习，上面有许多非常好的题目和牛人，是一个值得终身去学习和跟随的平台。特别是强调的是，这三个平台的社区都运营的很好，在上面能够碰到许多牛人，能够跟大牛一起讨论学习进步，学习他们的解题思路，学习他们的学习方法，这才是最关键的。</p><ul><li><strong>Leetcode contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td>contest 194</td><td>3</td><td>101</td><td>yes</td></tr><tr><td>2</td><td>biweekly contest 29</td><td>3</td><td>275</td><td>yes</td></tr><tr><td>3</td><td>contest 195</td><td>3</td><td>195</td><td>yes</td></tr><tr><td>4</td><td>contest 196</td><td>2</td><td>2138</td><td>yes</td></tr><tr><td>5</td><td>biweekly contest 30</td><td>4</td><td>128</td><td>yes</td></tr><tr><td>6</td><td>contest 197</td><td>3</td><td>263</td><td>yes</td></tr><tr><td>7</td><td>contest 198</td><td></td><td></td><td></td></tr><tr><td>8</td><td>biweekly contest 31</td><td></td><td></td><td></td></tr><tr><td>9</td><td>contest 199</td><td></td><td></td><td></td></tr><tr><td>10</td><td>contest 200</td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Codeforces contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Atbeginner contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="个人理财计划"><a href="#个人理财计划" class="headerlink" title="个人理财计划"></a>个人理财计划</h3><ul><li><strong>积蓄</strong></li><li><strong>基金</strong></li><li><strong>美股投资</strong></li><li><strong>平台</strong></li></ul><h3 id="个人健康计划"><a href="#个人健康计划" class="headerlink" title="个人健康计划"></a>个人健康计划</h3><ul><li>游泳计划</li></ul><div class="table-container"><table><thead><tr><th>序号</th><th>打卡日期</th><th>时间</th><th>游泳距离</th></tr></thead><tbody><tr><td>1</td><td>2020.7.12</td><td>20</td><td>500米</td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li>健身计划</li></ul><h3 id="个人家庭计划"><a href="#个人家庭计划" class="headerlink" title="个人家庭计划"></a>个人家庭计划</h3><ul><li>放假计划安排</li><li>出游计划安排</li><li>儿女学习安排</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2020年全年计划&quot;&gt;&lt;a href=&quot;#2020年全年计划&quot; class=&quot;headerlink&quot; title=&quot;2020年全年计划&quot;&gt;&lt;/a&gt;2020年全年计划&lt;/h1&gt;&lt;p&gt;2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。&lt;/p&gt;&lt;h3 id=&quot;个人学习计划&quot;&gt;&lt;a href=&quot;#个人学习计划&quot; class=&quot;headerlink&quot; title=&quot;个人学习计划&quot;&gt;&lt;/a&gt;个人学习计划&lt;/h3&gt;&lt;h4 id=&quot;书籍阅读计划&quot;&gt;&lt;a href=&quot;#书籍阅读计划&quot; class=&quot;headerlink&quot; title=&quot;书籍阅读计划&quot;&gt;&lt;/a&gt;书籍阅读计划&lt;/h4&gt;&lt;p&gt;今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人计划" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>为什么要学习著名大学的Open Course</title>
    <link href="http://yoursite.com/2020/07/05/176/"/>
    <id>http://yoursite.com/2020/07/05/176/</id>
    <published>2020-07-04T23:51:36.928Z</published>
    <updated>2020-07-04T23:51:42.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习国外大学的公开课"><a href="#为什么要学习国外大学的公开课" class="headerlink" title="为什么要学习国外大学的公开课"></a>为什么要学习国外大学的公开课</h2><p>今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。为什么要学习大学的公开课，因为目前市面上许多课程的深度和难度不够，我仔细研究和分析了一下，发现世界著名大学的公开课的质量是最好的，为什么它的质量最好：</p><h3 id="1-学习深度较好"><a href="#1-学习深度较好" class="headerlink" title="1. 学习深度较好"></a>1. 学习<strong>深度较好</strong></h3><p>不愧为世界知名学府，很多课程的深度很好，理论性讲解的特别深入，不像市面上许多XX课程只是浮在表面，告诉你该怎么做，但是从来没有告诉你为什么这样做，以及这样做到底有什么好处，这是我选择国外公开课课程作为我主要学习的内容的重要原因之一。目前市面上到处充斥着XX技术解密，XX工程实践，绝大部分都是浮在表面讲使用知识，并没有深入到理论中。<br>我也曾经在所谓的极客时间上付费买过一些课程，学了一两个课程以后，就全部扔到角落里，实在是提不起来兴趣。但是现在再仔细回想起来，这些本来就是营销，所谓的知识付费可能就是一个XX骗局。每个XX课程的特点是起一个很高大上和很流行的技术名称，让人觉得是XX技术热点，然后挂一个技术履历和学历都看似很鲜亮的成功人士简介，然人觉得似乎很高大上，吸引众多刚入门的”小学生”们乖乖上缴智商税。这些所谓的XX课程最大的问题是绝大部分都是所谓的工作经验总结，缺少背后的理论支持，所谓的课程也绝大部分都是文字课程，文字课程的自主学习效率是最低的，因为没有互动性，另一方面这些许多课程的练习和project都没有提供一个正确的评价系统，许多课程只是简单的学习完成了，并没有一个明确的评价标准以检验自己到底有没有正在的掌握这些知识，课程练习题目也没有给出正确的参考答案，缺少作业设计。计算机这门科学是一门实践性较强的课程，“show me the code，talk is cheap”，只有通过扎实的project或者exam才能真正的掌握一门知识或者理论。</p><a id="more"></a><h3 id="2-知识正确性"><a href="#2-知识正确性" class="headerlink" title="2.知识正确性"></a>2.<strong>知识正确性</strong></h3><p>“授之以鱼，不如授之以渔”。没有正确的知识，。却发现部分课程中许多地方错误百出，漏洞百出，可能许多所谓的课程作者自己都没有搞清楚许多细节，难免误导学习者。比如我上过《工业界的python实践》这门课程，作者上来就讲一达通看似很高大上的python的高级特性，却从来没有从读者的角度来思考很多语言学的问题和背后这样设计的原理和思考，感觉就是python的高级特性介绍，学这些东西真心不如自己看“python guide”。毫不客气的说，许多著名大学的课程绝大部分都由该领域的资深教授来讲解，他们的理论深度和知识的正确性几乎可以不容置疑。随着年龄的增长，我越来越喜欢探索许多技术和知识背后的数学理论和历史发展来源问题，利用数学这个工具来理解和分析许多行业知识，当然也越来越体会到数学的重要性。长期的坚持“正确”的知识学习，才能带来事半功倍的效果，如果知识的源头或者接受的信息都错误了，那带来的后果是必然在学习的道路上越走越远。</p><h3 id="3-好的project"><a href="#3-好的project" class="headerlink" title="3. 好的project"></a>3. 好的<strong>project</strong></h3><p>我特别喜欢著名大学的课程的重要原因之一是绝大部分计算机课程都带有非常好的<code>project</code>资源，绝大部分的<code>project</code>难度非常高，感觉比许多真实的<code>project</code>的难度都高，因为在国内绝大部分的工作都不需要像这些课程里面讲解的重新造一遍难度很高轮子，商业公司里面绝大部分都是重复利用这些已经做好的基础轮子技术，大部分商业公司把自己的技术都聚焦在商业业务实践上。实际上这些大学的许多project非常具有含金量的，通过完成这些非常<code>tough</code>的project，对自己的思维提升非常好，对于背后的原理知识掌握非常好。曾经遇到过几个project，从题目都看不懂到最后完成达到100%的testcase全过，那种愉悦感是工作中的某些<code>crond</code>体会不到的，还记得学习<code>princeton</code>算法课程中的几个project,从一开始连最基本的java语法都不知道，到最后掌握基本的<code>java</code>语法，并且最后因为。现在每次选择公开课时，一定要选择哪些带有非常好的且评价很高的<code>project</code>越来学习。另一方面通过这些难度很高的project，你需要自己去找资料找到这些问题的解决方法，要么去网上搜索相关论文，要么在论坛求助，要么查找书籍，要么可以在<code>youtube</code>上搜索相关知识视频学习，要么自己的深入思考，通过这些<code>tough</code>的project的锻炼非常提高你的<code>problem sloving</code>能力，其实这跟<code>compective programing</code>的锻炼的能力相似，非常锻炼自己独立思考问题的能力。</p><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><p>非常推荐常见的公开课学习平台：</p><ol><li>coursera：(<a href="https://www.coursera.org/" target="_blank" rel="noopener">https://www.coursera.org/</a>)</li><li>ocw:(<a href="https://ocw.mit.edu/" target="_blank" rel="noopener">https://ocw.mit.edu/</a>)</li><li>网易公开课:(<a href="http://open.163.com/" target="_blank" rel="noopener">http://open.163.com/</a>)</li><li>可汗学院：(<a href="https://www.khanacademy.org/" target="_blank" rel="noopener">https://www.khanacademy.org/</a>)</li><li>openedx: (<a href="https://open.edx.org/" target="_blank" rel="noopener">https://open.edx.org/</a>)</li><li>cmu:(<a href="https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx" target="_blank" rel="noopener">https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx</a>)</li><li>cmu lab:(<a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/3e/labs.html</a>)</li><li>archive: (<a href="https://archive.org/search.php?query=subject%3A%22UC+Berkeley%22" target="_blank" rel="noopener">https://archive.org/search.php?query=subject%3A%22UC+Berkeley%22</a>)</li><li>SCIP:(<a href="https://github.com/DeathKing/Learning-SICP" target="_blank" rel="noopener">https://github.com/DeathKing/Learning-SICP</a>)</li><li>UCbreakly : (<a href="http://webcast.berkeley.edu/" target="_blank" rel="noopener">http://webcast.berkeley.edu/</a>)</li><li>UW : (<a href="https://courses.cs.washington.edu/courses/cse421/06au/" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse421/06au/</a>)</li><li>UW ：(<a href="https://courses.cs.washington.edu/courses/cse341/13sp/#lectures" target="_blank" rel="noopener">https://courses.cs.washington.edu/courses/cse341/13sp/#lectures</a>)</li><li>UCSD : (<a href="https://podcast.ucsd.edu/default.aspx" target="_blank" rel="noopener">https://podcast.ucsd.edu/default.aspx</a>)</li><li>Youtube : (<a href="https://www.youtube.com/" target="_blank" rel="noopener">https://www.youtube.com/</a>)<br>当然这些以上这些绝大部分都需要翻墙才能观看和学习，推荐一个翻墙软件，发条云：(<a href="http://www.fatiaoyun.live/aff.php?aff=15540)，这个翻墙软件比较稳定，需要付费，大概一年也就不到200块钱，每个月50G的流量，其实足够个人学习应用了，youtube流畅毫无压力。" target="_blank" rel="noopener">http://www.fatiaoyun.live/aff.php?aff=15540)，这个翻墙软件比较稳定，需要付费，大概一年也就不到200块钱，每个月50G的流量，其实足够个人学习应用了，youtube流畅毫无压力。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要学习国外大学的公开课&quot;&gt;&lt;a href=&quot;#为什么要学习国外大学的公开课&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习国外大学的公开课&quot;&gt;&lt;/a&gt;为什么要学习国外大学的公开课&lt;/h2&gt;&lt;p&gt;今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。为什么要学习大学的公开课，因为目前市面上许多课程的深度和难度不够，我仔细研究和分析了一下，发现世界著名大学的公开课的质量是最好的，为什么它的质量最好：&lt;/p&gt;&lt;h3 id=&quot;1-学习深度较好&quot;&gt;&lt;a href=&quot;#1-学习深度较好&quot; class=&quot;headerlink&quot; title=&quot;1. 学习深度较好&quot;&gt;&lt;/a&gt;1. 学习&lt;strong&gt;深度较好&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;不愧为世界知名学府，很多课程的深度很好，理论性讲解的特别深入，不像市面上许多XX课程只是浮在表面，告诉你该怎么做，但是从来没有告诉你为什么这样做，以及这样做到底有什么好处，这是我选择国外公开课课程作为我主要学习的内容的重要原因之一。目前市面上到处充斥着XX技术解密，XX工程实践，绝大部分都是浮在表面讲使用知识，并没有深入到理论中。&lt;br&gt;我也曾经在所谓的极客时间上付费买过一些课程，学了一两个课程以后，就全部扔到角落里，实在是提不起来兴趣。但是现在再仔细回想起来，这些本来就是营销，所谓的知识付费可能就是一个XX骗局。每个XX课程的特点是起一个很高大上和很流行的技术名称，让人觉得是XX技术热点，然后挂一个技术履历和学历都看似很鲜亮的成功人士简介，然人觉得似乎很高大上，吸引众多刚入门的”小学生”们乖乖上缴智商税。这些所谓的XX课程最大的问题是绝大部分都是所谓的工作经验总结，缺少背后的理论支持，所谓的课程也绝大部分都是文字课程，文字课程的自主学习效率是最低的，因为没有互动性，另一方面这些许多课程的练习和project都没有提供一个正确的评价系统，许多课程只是简单的学习完成了，并没有一个明确的评价标准以检验自己到底有没有正在的掌握这些知识，课程练习题目也没有给出正确的参考答案，缺少作业设计。计算机这门科学是一门实践性较强的课程，“show me the code，talk is cheap”，只有通过扎实的project或者exam才能真正的掌握一门知识或者理论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人学习" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="个人学习" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 195周周赛</title>
    <link href="http://yoursite.com/2020/06/28/175/"/>
    <id>http://yoursite.com/2020/06/28/175/</id>
    <published>2020-06-28T13:58:44.283Z</published>
    <updated>2020-06-28T13:58:51.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="195周比赛"><a href="#195周比赛" class="headerlink" title="195周比赛"></a>195周比赛</h1><p><img src="https://mike-box.github.io/images/178-1.png" alt="1"><br>本周周赛时系统出了故障导致一直出问题，还是同样的三题选手，最后一道题目不会做。</p><h2 id="5448-判断路径是否相交"><a href="#5448-判断路径是否相交" class="headerlink" title="5448. 判断路径是否相交"></a>5448. 判断路径是否相交</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>path</code>，其中 <code>path[i]</code>的值可以是<code>&#39;N&#39;、&#39;S&#39;、&#39;E&#39;</code>或者 <code>&#39;W&#39;</code>，分别表示向北、向南、向东、向西移动一个单位。</p><a id="more"></a><p>机器人从二维平面上的原点 <code>(0, 0)</code>处开始出发，按 <code>path</code>所指示的路径行走。</p><p>如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 <code>True</code> ；否则，返回 <code>False</code>。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"NES"</span></span><br><span class="line">输出：<span class="literal">false</span> </span><br><span class="line">解释：该路径没有在任何位置相交。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">path</span> = <span class="string">"NESWW"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：该路径经过原点两次。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= path.length &lt;= 10^4</li><li>path 仅由 {‘N’, ‘S’, ‘E’, ‘W} 中的字符组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/path-crossing" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-crossing</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力hash</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中明确说了每次只走一步，所以我们直接保存已经走过的痕迹，然后用set直接查询即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPathCrossing</span><span class="params">(<span class="built_in">string</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        cnt.insert(make_pair(x,y));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : path)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'N'</span>)&#123;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'S'</span>)&#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'E'</span>)&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'W'</span>)&#123;</span><br><span class="line">                x--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(make_pair(x,y))) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            cnt.insert(make_pair(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5449-检查数组对是否可以被-k-整除"><a href="#5449-检查数组对是否可以被-k-整除" class="headerlink" title="5449. 检查数组对是否可以被 k 整除"></a>5449. 检查数组对是否可以被 k 整除</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>和一个整数 <code>k</code> ，其中数组长度是偶数，值为 <code>n</code>。</p><p>现在需要把数组恰好分成<code>n / 2</code>对，以使每对数字的和都能够被 k 整除。</p><p>如果存在这样的分法，请返回 <code>True</code> ；否则，返回 <code>False</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：划分后的数字对为 (<span class="number">1</span>,<span class="number">9</span>),(<span class="number">2</span>,<span class="number">8</span>),(<span class="number">3</span>,<span class="number">7</span>),(<span class="number">4</span>,<span class="number">6</span>) 以及 (<span class="number">5</span>,<span class="number">10</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：划分后的数字对为 (<span class="number">1</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>) 以及 (<span class="number">3</span>,<span class="number">4</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法在将数组中的数字分为三对的同时满足每对数字和能够被 <span class="number">10</span> 整除的条件。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-10</span>,<span class="number">10</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">3</span>,<span class="number">-4</span>,<span class="number">4</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>arr.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>n</code> 为偶数</li><li><code>-10^9 &lt;= arr[i] &lt;= 10^9</code></li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-array-pairs-are-divisible-by-k</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 取模</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>统计数组中所有的数对k取模的结果x，再比较<code>x</code>的数目是否与<code>k-x</code>的数目是否相等即可。</li><li>因为在实际的分组中，只有余数为<code>x</code>的数与余数为<code>k-x</code>的数才能组成符合条件的一对数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canArrange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(k,<span class="number">0</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">            cnt[(v%k + k)%k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (k/<span class="number">2</span>); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] != cnt[k-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5450-满足条件的子序列数目"><a href="#5450-满足条件的子序列数目" class="headerlink" title="5450. 满足条件的子序列数目"></a>5450. 满足条件的子序列数目</h2><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code>。</p><p>请你统计并返回 <code>nums</code>中能满足其最小元素与最大元素的 和 小于或等于 <code>target</code> 的 非空 子序列的数目。</p><p>由于答案可能很大，请将结果对 <code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 个子序列满足该条件。</span><br><span class="line">[<span class="number">3</span>] -&gt; 最小元素 + 最大元素 &lt;= target (<span class="number">3</span> + <span class="number">3</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>] -&gt; (<span class="number">3</span> + <span class="number">5</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] -&gt; (<span class="number">3</span> + <span class="number">6</span> &lt;= <span class="number">9</span>)</span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>] -&gt; (<span class="number">3</span> + <span class="number">6</span> &lt;= <span class="number">9</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：有 <span class="number">6</span> 个子序列满足该条件。（nums 中可以有重复数字）</span><br><span class="line">[<span class="number">3</span>] , [<span class="number">3</span>] , [<span class="number">3</span>,<span class="number">3</span>], [<span class="number">3</span>,<span class="number">6</span>] , [<span class="number">3</span>,<span class="number">6</span>] , [<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], target = <span class="number">12</span></span><br><span class="line">输出：<span class="number">61</span></span><br><span class="line">解释：共有 <span class="number">63</span> 个非空子序列，其中 <span class="number">2</span> 个不满足条件（[<span class="number">6</span>,<span class="number">7</span>], [<span class="number">7</span>]）</span><br><span class="line">有效序列总数为（<span class="number">63</span> - <span class="number">2</span> = <span class="number">61</span>）</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>], target = <span class="number">16</span></span><br><span class="line">输出：<span class="number">127</span></span><br><span class="line">解释：所有非空子序列都满足条件 (<span class="number">2</span>^<span class="number">7</span> - <span class="number">1</span>) = <span class="number">127</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^6</code></li><li><code>1 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>排序即可，每次找到以<code>nums[i]</code>为最小值的子序列数目。</li><li>利用二分查找找到子序列的最右端即可，则以<code>nums[i]</code>为最小值起点，且最大长度为<code>k</code>的子序列的数目为:<script type="math/tex; mode=display">count_{i} = 2^{k-1}</script></li><li>总的数目即为：<script type="math/tex; mode=display">sum = \sum_{i=1}^{n}2^{len(i)}</script></li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; pow2(<span class="number">100001</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; ++i)&#123;</span><br><span class="line">            pow2[i] = curr;</span><br><span class="line">            curr = (curr*<span class="number">2</span>)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> it = upper_bound(nums.begin(),nums.end(),target-nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == nums.begin()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((--it) &lt; (nums.begin() + i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> len = it - (nums.begin()+i);</span><br><span class="line">            ans = (ans + pow2[len])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5451-满足不等式的最大值"><a href="#5451-满足不等式的最大值" class="headerlink" title="5451. 满足不等式的最大值"></a>5451. 满足不等式的最大值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>points</code> 和一个整数<code>k</code> 。数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 <code>x</code> 的值从小到大排序。也就是说 <code>points[i] = [xi, yi]</code>，并且在<code>1 &lt;= i &lt; j &lt;= points.length</code>的前提下， <code>xi &lt; xj</code>总成立。</p><p>请你找出 <code>yi + yj + |xi - xj|</code>的 最大值，其中 <code>|xi - xj| &lt;= k</code> 且 <code>1 &lt;= i &lt; j &lt;= points.length</code>。</p><p>题目测试数据保证至少存在一对能够满足 <code>|xi - xj| &lt;= k</code> 的点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">10</span>],[<span class="number">6</span>,<span class="number">-10</span>]], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：前两个点满足 |xi - xj| &lt;= <span class="number">1</span> ，带入方程计算，则得到值 <span class="number">3</span> + <span class="number">0</span> + |<span class="number">1</span> - <span class="number">2</span>| = <span class="number">4</span> 。第三个和第四个点也满足条件，得到值 <span class="number">10</span> + <span class="number">-10</span> + |<span class="number">5</span> - <span class="number">6</span>| = <span class="number">1</span> 。</span><br><span class="line">没有其他满足条件的点，所以返回 <span class="number">4</span> 和 <span class="number">1</span> 中最大的那个。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">9</span>,<span class="number">2</span>]], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：只有前两个点满足 |xi - xj| &lt;= <span class="number">3</span> ，带入方程后得到值 <span class="number">0</span> + <span class="number">0</span> + |<span class="number">0</span> - <span class="number">3</span>| = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= points.length &lt;= 10^5</code></li><li><code>points[i].length == 2</code></li><li><code>-10^8 &lt;= points[i][0], points[i][1] &lt;= 10^8</code></li><li><code>0 &lt;= k &lt;= 2 * 10^8</code></li><li>对于所有的<code>1 &lt;= i &lt; j &lt;= points.length</code> ，<code>points[i][0] &lt; points[j][0]</code> 都成立。也就是说，<code>xi</code> 是严格递增的。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/max-value-of-equation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/max-value-of-equation</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>优先级队列</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题竟然没有想出来，真的做出来感觉也太简单了点。。。</li><li>实在是思路重要，而不是刷题。拿到一个题目首先分析改用什么算法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxValueOfEquation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : points)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq.empty() &amp;&amp; v[<span class="number">0</span>] - pq.top().second &gt; k) pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(!pq.empty())&#123;</span><br><span class="line">                ans = max(ans,v[<span class="number">0</span>] + v[<span class="number">1</span>] + pq.top().first);</span><br><span class="line">            &#125;</span><br><span class="line">            pq.push(make_pair(v[<span class="number">1</span>]-v[<span class="number">0</span>],v[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;195周比赛&quot;&gt;&lt;a href=&quot;#195周比赛&quot; class=&quot;headerlink&quot; title=&quot;195周比赛&quot;&gt;&lt;/a&gt;195周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/178-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛时系统出了故障导致一直出问题，还是同样的三题选手，最后一道题目不会做。&lt;/p&gt;&lt;h2 id=&quot;5448-判断路径是否相交&quot;&gt;&lt;a href=&quot;#5448-判断路径是否相交&quot; class=&quot;headerlink&quot; title=&quot;5448. 判断路径是否相交&quot;&gt;&lt;/a&gt;5448. 判断路径是否相交&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;path&lt;/code&gt;，其中 &lt;code&gt;path[i]&lt;/code&gt;的值可以是&lt;code&gt;&amp;#39;N&amp;#39;、&amp;#39;S&amp;#39;、&amp;#39;E&amp;#39;&lt;/code&gt;或者 &lt;code&gt;&amp;#39;W&amp;#39;&lt;/code&gt;，分别表示向北、向南、向东、向西移动一个单位。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 29周双周赛</title>
    <link href="http://yoursite.com/2020/06/28/174/"/>
    <id>http://yoursite.com/2020/06/28/174/</id>
    <published>2020-06-28T08:06:18.361Z</published>
    <updated>2020-06-28T08:06:24.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="29周双周比赛"><a href="#29周双周比赛" class="headerlink" title="29周双周比赛"></a>29周双周比赛</h1><p><img src="https://mike-box.github.io/images/177-1.png" alt="1"><br>本周双周赛前三题莫名奇妙的简单，10分钟搞定三道题，最后一道题目还是不会，看来还是思考的不够或者深度不够，实际也是智商不够。我觉得还是需要提高自己深度思考的能力，当然最后一题莫名奇妙的用贪心算法（按照树的深度和出度的优先顺序）解决了，虽然把问题解决了，但是仔细看了解答，原来这个解法是错误得，这个问题实际位NP-hard问题，所以基本上只能用暴力搜索。<br>其实自己思考来思考去，不得不承认自己在<code>compective programming</code>上没有太大得天赋，每次都是草草收场。之所以还能坚持每周参加周赛，我想最多得还是兴趣，虽然自己并不聪明，并没有天赋，但是如果从内心来说认可一些事，喜欢一些事，能够坚持也是自己得信念与收获，通过<code>CP</code>能够快速的锻炼自己的<code>problem sloving skills</code>,特别是<code>hard problem</code>，真的很难，需要自己能够深入思考一些问题，能够从复杂的条件或者暗示中隐约的得到一些思路，我觉得这个能力可能是<code>CP</code>带给我的最大的收获。</p><a id="more"></a><h2 id="5432-去掉最低工资和最高工资后的工资平均值"><a href="#5432-去掉最低工资和最高工资后的工资平均值" class="headerlink" title="5432. 去掉最低工资和最高工资后的工资平均值"></a>5432. 去掉最低工资和最高工资后的工资平均值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>salary</code> ，数组里每个数都是 唯一 的，其中 <code>salary[i]</code> 是第 <code>i</code> `个员工的工资。</p><p>请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">4000</span>,<span class="number">3000</span>,<span class="number">1000</span>,<span class="number">2000</span>]</span><br><span class="line">输出：<span class="number">2500.00000</span></span><br><span class="line">解释：最低工资和最高工资分别是 <span class="number">1000</span> 和 <span class="number">4000</span> 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (<span class="number">2000</span>+<span class="number">3000</span>)/<span class="number">2</span>= <span class="number">2500</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">1000</span>,<span class="number">2000</span>,<span class="number">3000</span>]</span><br><span class="line">输出：<span class="number">2000.00000</span></span><br><span class="line">解释：最低工资和最高工资分别是 <span class="number">1000</span> 和 <span class="number">3000</span> 。</span><br><span class="line">去掉最低工资和最高工资以后的平均工资是 (<span class="number">2000</span>)/<span class="number">1</span>= <span class="number">2000</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">6000</span>,<span class="number">5000</span>,<span class="number">4000</span>,<span class="number">3000</span>,<span class="number">2000</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">3500.00000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：salary = [<span class="number">8000</span>,<span class="number">9000</span>,<span class="number">2000</span>,<span class="number">3000</span>,<span class="number">6000</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">4750.00000</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= salary.length &lt;= 100</code></li><li><code>10^3 &lt;= salary[i] &lt;= 10^6</code></li><li><code>salary[i]</code> 是唯一的。</li><li>与真实值误差在 <code>10^-5</code> 以内的结果都将视为正确答案。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary" target="_blank" rel="noopener">https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">average</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        sort(salary.begin(),salary.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; salary.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            sum += salary[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum/(salary.size()<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5433-n-的第-k-个因子"><a href="#5433-n-的第-k-个因子" class="headerlink" title="5433. n 的第 k 个因子"></a>5433. n 的第 k 个因子</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code> 。</p><p>如果正整数 <code>i</code> 满足 <code>n % i == 0</code>，那么我们就说正整数<code>i</code>是整数 <code>n</code>的因子。</p><p>考虑整数 <code>n</code> 的所有因子，将它们 升序排列 。请你返回第<code>k</code> 个因子。如果 <code>n</code>的因子数少于<code>k</code>，请你返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">12</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span>]，第 <span class="number">3</span> 个因子是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">7</span>] ，第 <span class="number">2</span> 个因子是 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>] ，只有 <span class="number">3</span> 个因子，所以我们应该返回 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>] ，第 <span class="number">1</span> 个因子为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1000</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：因子列表包括 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">125</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">500</span>, <span class="number">1000</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-kth-factor-of-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-kth-factor-of-n</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力即可。题目数据量太小，连素数因子筛选都不用，直接暴力即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthFactor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; factor;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)&#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5434-删掉一个元素以后全为-1-的最长子数组"><a href="#5434-删掉一个元素以后全为-1-的最长子数组" class="headerlink" title="5434. 删掉一个元素以后全为 1 的最长子数组"></a>5434. 删掉一个元素以后全为 1 的最长子数组</h2><p>给你一个二进制数组 <code>nums</code> ，你需要从中删掉一个元素。</p><p>请你在删掉元素的结果数组中，返回最长的且只包含 <code>1</code> 的非空子数组的长度。</p><p>如果不存在这样的子数组，请返回 0 。</p><p>提示 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：删掉位置 <span class="number">2</span> 的数后，[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 包含 <span class="number">3</span> 个 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：删掉位置 <span class="number">4</span> 的数字后，[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] 的最长全 <span class="number">1</span> 子数组为 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：你必须要删除一个元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>nums[i]</code>要么是 <code>0</code>要么是<code>1</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>此题跟<a href="https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/" target="_blank" rel="noopener">1186</a>题目几乎一样，如果会做这个题目，这个题目基本上也就是小case。</li><li>设<code>left[i]</code>代表从<code>i</code>处往左侧最多的连续<code>1</code>的个数，<code>right[i]</code>代表从<code>i</code>处往右侧最多的连续<code>1</code>的个数，则：<script type="math/tex; mode=display">maxLen[i] = left[i-1] + right[i+1]</script></li><li>本题确实很简单，没有多少好说的。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        left[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        right[n<span class="number">-1</span>] = arr[n<span class="number">-1</span>];</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        ans = max(left[<span class="number">0</span>],right[n<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = arr[i] + max(<span class="number">0</span>,left[i<span class="number">-1</span>]);</span><br><span class="line">            ans = max(ans,left[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = arr[i] + max(<span class="number">0</span>,right[i+<span class="number">1</span>]);</span><br><span class="line">            ans = max(ans,right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">            ans = max(left[i<span class="number">-1</span>]+right[i+<span class="number">1</span>],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5435-并行课程-II"><a href="#5435-并行课程-II" class="headerlink" title="5435. 并行课程 II"></a>5435. 并行课程 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>表示某所大学里课程的数目，编号为 <code>1</code> 到 <code>n</code> ，数组 <code>dependencies</code> 中，<code>dependencies[i] = [xi, yi]</code> 表示一个先修课的关系，也就是课程<code>xi</code> 必须在课程 <code>yi</code>之前上。同时你还有一个整数 <code>k</code> 。</p><p>在一个学期中，你 最多 可以同时上<code>k</code>门课，前提是这些课的先修课在之前的学期里已经上过了。</p><p>请你返回上完所有课最少需要多少个学期。题目保证一定存在一种上完所有课的方式。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, dependencies = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：上图展示了题目输入的图。在第一个学期中，我们可以上课程 <span class="number">2</span> 和课程 <span class="number">3</span> 。然后第二个学期上课程 <span class="number">1</span> ，第三个学期上课程 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, dependencies = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>]], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：上图展示了题目输入的图。一个最优方案是：第一学期上课程 <span class="number">2</span> 和 <span class="number">3</span>，第二学期上课程 <span class="number">4</span> ，第三学期上课程 <span class="number">1</span> ，第四学期上课程 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">11</span>, dependencies = [], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>1 &lt;= k &lt;= n</code></li><li><code>0 &lt;= dependencies.length &lt;= n * (n-1) / 2</code></li><li><code>dependencies[i].length == 2</code></li><li><code>1 &lt;= xi, yi &lt;= n</code></li><li><code>xi != yi</code></li><li>所有先修关系都是不同的，也就是说 <code>dependencies[i] != dependencies[j]</code>。</li><li>题目输入的图是个有向无环图。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/parallel-courses-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/parallel-courses-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>状态压缩DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>其实拿到这个题目开始，看到<code>course</code>的最大数目只有15，刚开始想到的就是位图的状态压缩<code>dp</code>，因为最多有<code>2^15</code>个状态。数量级非常小，感觉应该刚好符合题意。但是状态压缩的递推公式没有想出来，因为需要降低数量级，但是状态压缩dp的解法没有想出来。</li><li>意外的用了贪心算法，即每次优先最大的出度和深度的节点出队列，竟然意外的题目全部AC了，但是早上起来看到答案解析，举出了反例，这个解法明显有错误的。所以归根到底还是要坚持自己一开始的解题思路，一旦解题思路错误，则不可能讲问题解决，所以从一开始的思考的深度度非常重要，解题思路正确才能得出。如何才能找到事物的本性，如何才能提高自己思考的深度，这是自己最最需要提高的。方向错误可能导致事情本身的解决方法错误，找到事物的本因，才能提出正确的解决办法，否则就是干着急不得要领，所以我们在面对问题时，首先做到的是应该多思考，而不是先动手，能够快速的找到正确的方法才能至关重要。</li><li>本题适用于状态压缩dp，用位图表示，总共最多只有15门课程，如果该课程已经完成，我们则用将课程<code>i</code>,即第<code>i</code>位置为<code>1</code>,最终我们求的是dp[(1&lt;&lt;n)-1]的最小值，即为最短时间。<br><a href="https://leetcode-cn.com/problems/parallel-courses-ii/solution/czhuang-tai-ya-suo-dong-tai-gui-hua-by-ujimatsu_ch/" target="_blank" rel="noopener">题解</a><br>4.该题完全利用dp的暴力搜索解决， 我们知道dp[i]代表当前已经学过所有课程状态为<code>i</code>的最短时间，我们计算学完所有的课程集合<code>i</code>后，我们还可以学习哪些课程的集合为<code>b</code>,假如课程集合<code>b</code>中的数目小于等于<code>k</code>，则我们可以直接在一个新的学期中将<code>b</code>中所有的课程都拿来学习。则这时：<script type="math/tex; mode=display">dp[i|b] = min(dp[i|b],dp[i] + 1)</script>否则如果课程集合<code>b</code>中的数目大于<code>k</code>，则我们从集合<code>b</code>中进行枚举，每次最多选出<code>k</code>个课程，假设集合<code>b</code>中有<code>m</code>个课程，则我们可以有以下的枚举种类，本质就是暴力将所有的课程排序可能进行遍历一遍：<script type="math/tex; mode=display">C_{m}^{k}</script>这个暴力过程就很有意思，直接将b从1开始进行遍历一遍即可，代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = b; j ; j = (j<span class="number">-1</span>)&amp;b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_popcount(j) == k)&#123;</span><br><span class="line">        dp[i|j] = min(dp[i|j],dp[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>所有的代码其实看起来很难得题目，实际需要仔细得琢磨和品味。这个题目还是非常不错的题目，需要值得思考的地方很多，需要仔细品味，难得见到许多经典的题目。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfSemesters</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dependencies, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; req(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;v:dependencies)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v[<span class="number">0</span>]<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v[<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">            req[y]|= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;n);i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*计算完成当前的课程状态i后，后续的还可以完成哪些课程的集合*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(((i&gt;&gt;j&amp;<span class="number">1</span>) == <span class="number">0</span>) &amp;&amp; (req[j]&amp;i) == req[j])&#123;</span><br><span class="line">                    b |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(b) &lt;= k)&#123;</span><br><span class="line">                dp[i|b] = min(dp[i|b],dp[i]+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = b; j ; j = (j<span class="number">-1</span>)&amp;b)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(__builtin_popcount(j) == k)&#123;</span><br><span class="line">                        dp[i|j] = min(dp[i|j],dp[i]+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;29周双周比赛&quot;&gt;&lt;a href=&quot;#29周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;29周双周比赛&quot;&gt;&lt;/a&gt;29周双周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/177-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周双周赛前三题莫名奇妙的简单，10分钟搞定三道题，最后一道题目还是不会，看来还是思考的不够或者深度不够，实际也是智商不够。我觉得还是需要提高自己深度思考的能力，当然最后一题莫名奇妙的用贪心算法（按照树的深度和出度的优先顺序）解决了，虽然把问题解决了，但是仔细看了解答，原来这个解法是错误得，这个问题实际位NP-hard问题，所以基本上只能用暴力搜索。&lt;br&gt;其实自己思考来思考去，不得不承认自己在&lt;code&gt;compective programming&lt;/code&gt;上没有太大得天赋，每次都是草草收场。之所以还能坚持每周参加周赛，我想最多得还是兴趣，虽然自己并不聪明，并没有天赋，但是如果从内心来说认可一些事，喜欢一些事，能够坚持也是自己得信念与收获，通过&lt;code&gt;CP&lt;/code&gt;能够快速的锻炼自己的&lt;code&gt;problem sloving skills&lt;/code&gt;,特别是&lt;code&gt;hard problem&lt;/code&gt;，真的很难，需要自己能够深入思考一些问题，能够从复杂的条件或者暗示中隐约的得到一些思路，我觉得这个能力可能是&lt;code&gt;CP&lt;/code&gt;带给我的最大的收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 194周比赛</title>
    <link href="http://yoursite.com/2020/06/22/173/"/>
    <id>http://yoursite.com/2020/06/22/173/</id>
    <published>2020-06-22T02:12:39.353Z</published>
    <updated>2020-06-22T02:23:12.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="194周比赛"><a href="#194周比赛" class="headerlink" title="194周比赛"></a>194周比赛</h1><p><img src="https://mike-box.github.io/images/175-1.png" alt="1"><br>本周周赛的题目还还是创出了新难度，题目全部AC的人数还不到100人。前三题确实有点难度，特别是第二题和第三题都比较绕，第四题除了暴力意外没有好思路。</p><h2 id="1486-数组异或操作"><a href="#1486-数组异或操作" class="headerlink" title="1486. 数组异或操作"></a>1486. 数组异或操作</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数，<code>n</code>和 <code>start</code>。</p><p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code>。</p><a id="more"></a><p>请返回 <code>nums</code> 中所有元素按位异或（<code>XOR</code>）后得到的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, start = <span class="number">0</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：数组 nums 为 [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]，其中 (<span class="number">0</span> ^ <span class="number">2</span> ^ <span class="number">4</span> ^ <span class="number">6</span> ^ <span class="number">8</span>) = <span class="number">8</span> 。</span><br><span class="line">     <span class="string">"^"</span> 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, start = <span class="number">3</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：数组 nums 为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]，其中 (<span class="number">3</span> ^ <span class="number">5</span> ^ <span class="number">7</span> ^ <span class="number">9</span>) = <span class="number">8.</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, start = <span class="number">7</span></span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, start = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>n == nums.length</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xor-operation-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res = res^(start+(i*<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1487-保证文件名唯一"><a href="#1487-保证文件名唯一" class="headerlink" title="1487. 保证文件名唯一"></a>1487. 保证文件名唯一</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code>。你将会在文件系统中创建<code>n</code>个文件夹：在第 <code>i</code>分钟，新建名为 <code>names[i]</code> 的文件夹。</p><p>由于两个文件 不能 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以<code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 k 是能保证文件名唯一的 最小正整数 。</p><p>返回长度为 <code>n</code> 的字符串数组，其中 <code>ans[i]</code>是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p><p>示例 1：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"pes"</span>,<span class="string">"fifa"</span>,<span class="string">"gta"</span>,<span class="string">"pes(2019)"</span>]</span><br><span class="line">输出：[<span class="string">"pes"</span>,<span class="string">"fifa"</span>,<span class="string">"gta"</span>,<span class="string">"pes(2019)"</span>]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line"><span class="string">"pes"</span> --&gt; 之前未分配，仍为 <span class="string">"pes"</span></span><br><span class="line"><span class="string">"fifa"</span> --&gt; 之前未分配，仍为 <span class="string">"fifa"</span></span><br><span class="line"><span class="string">"gta"</span> --&gt; 之前未分配，仍为 <span class="string">"gta"</span></span><br><span class="line"><span class="string">"pes(2019)"</span> --&gt; 之前未分配，仍为 <span class="string">"pes(2019)"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"gta"</span>,<span class="string">"gta(1)"</span>,<span class="string">"gta"</span>,<span class="string">"avalon"</span>]</span><br><span class="line">输出：[<span class="string">"gta"</span>,<span class="string">"gta(1)"</span>,<span class="string">"gta(2)"</span>,<span class="string">"avalon"</span>]</span><br><span class="line">解释：文件系统将会这样创建文件名：</span><br><span class="line"><span class="string">"gta"</span> --&gt; 之前未分配，仍为 <span class="string">"gta"</span></span><br><span class="line"><span class="string">"gta(1)"</span> --&gt; 之前未分配，仍为 <span class="string">"gta(1)"</span></span><br><span class="line"><span class="string">"gta"</span> --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 <span class="string">"gta(1)"</span> 也被占用，所以 k = <span class="number">2</span> 。实际创建的文件名为 <span class="string">"gta(2)"</span> 。</span><br><span class="line"><span class="string">"avalon"</span> --&gt; 之前未分配，仍为 <span class="string">"avalon"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"onepiece"</span>,<span class="string">"onepiece(1)"</span>,<span class="string">"onepiece(2)"</span>,<span class="string">"onepiece(3)"</span>,<span class="string">"onepiece"</span>]</span><br><span class="line">输出：[<span class="string">"onepiece"</span>,<span class="string">"onepiece(1)"</span>,<span class="string">"onepiece(2)"</span>,<span class="string">"onepiece(3)"</span>,<span class="string">"onepiece(4)"</span>]</span><br><span class="line">解释：当创建最后一个文件夹时，最小的正有效 k 为 <span class="number">4</span> ，文件名变为 <span class="string">"onepiece(4)"</span>。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"wano"</span>,<span class="string">"wano"</span>,<span class="string">"wano"</span>,<span class="string">"wano"</span>]</span><br><span class="line">输出：[<span class="string">"wano"</span>,<span class="string">"wano(1)"</span>,<span class="string">"wano(2)"</span>,<span class="string">"wano(3)"</span>]</span><br><span class="line">解释：每次创建文件夹 <span class="string">"wano"</span> 时，只需增加后缀中 k 的值即可。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：names = [<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>,<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>]</span><br><span class="line">输出：[<span class="string">"kaido"</span>,<span class="string">"kaido(1)"</span>,<span class="string">"kaido(2)"</span>,<span class="string">"kaido(1)(1)"</span>]</span><br><span class="line">解释：注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li><li><code>1 &lt;= names[i].length &lt;= 20</code></li><li><code>names[i]</code>由小写英文字母、数字和/或圆括号组成。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/making-file-names-unique" target="_blank" rel="noopener">https://leetcode-cn.com/problems/making-file-names-unique</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目很无聊啊，用hash保存该文件名当前最大的统计数。</li><li>如果该名字没有出现过，则直接返回该文件名；如果该文件名出现，则找到该文件名为开头的最大整数索引，将其加入到文件名中的一部分即可，同时需要将最新的名字也要写入<code>hash</code>表中。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; getFolderNames(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; names) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt.count(names[i]))&#123;</span><br><span class="line">                res.push_back(names[i]);</span><br><span class="line">                cnt[names[i]] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[names[i]] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt.count(names[i] + <span class="string">"("</span> + to_string(x) + <span class="string">")"</span>)) x++;</span><br><span class="line">                <span class="built_in">string</span> newname = names[i] + <span class="string">"("</span> + to_string(x) + <span class="string">")"</span>;</span><br><span class="line">                res.push_back(newname);</span><br><span class="line">                cnt[names[i]] = x;</span><br><span class="line">                cnt[newname] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1488-避免洪水泛滥"><a href="#1488-避免洪水泛滥" class="headerlink" title="1488. 避免洪水泛滥"></a>1488. 避免洪水泛滥</h2><p>你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 <code>n</code>个湖泊下雨的时候，如果第 <code>n</code> 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。</p><p>给你一个整数数组 <code>rains</code> ，其中：</p><ul><li><code>rains[i] &gt; 0</code> 表示第 <code>i</code> 天时，第 <code>rains[i]</code> 个湖泊会下雨。</li><li><code>rains[i] == 0</code> 表示第 <code>i</code> 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。<br>请返回一个数组<code>ans</code> ，满足：</li><li><code>ans.length == rains.length</code></li><li>如果 <code>rains[i] &gt; 0</code>，那么<code>ans[i] == -1</code> 。</li><li>如果 <code>rains[i] == 0</code>，<code>ans[i]</code>是你第 <code>i</code> 天选择抽干的湖泊。</li><li>如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。</li></ul><p>请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">第三天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">第四天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：第一天后，装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">第三天后，我们抽干湖泊 <span class="number">2</span> 。所以剩下装满水的湖泊包括 [<span class="number">1</span>]</span><br><span class="line">第四天后，我们抽干湖泊 <span class="number">1</span> 。所以暂时没有装满水的湖泊了。</span><br><span class="line">第五天后，装满水的湖泊包括 [<span class="number">2</span>]。</span><br><span class="line">第六天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]。</span><br><span class="line">可以看出，这个方案下不会有洪水发生。同时， [<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>] 也是另一个可行的没有洪水的方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：第二天后，装满水的湖泊包括 [<span class="number">1</span>,<span class="number">2</span>]。我们可以在第三天抽干一个湖泊的水。</span><br><span class="line">但第三天后，湖泊 <span class="number">1</span> 和 <span class="number">2</span> 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">69</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">69</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">69</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：任何形如 [<span class="number">-1</span>,<span class="number">69</span>,x,y,<span class="number">-1</span>], [<span class="number">-1</span>,x,<span class="number">69</span>,y,<span class="number">-1</span>] 或者 [<span class="number">-1</span>,x,y,<span class="number">69</span>,<span class="number">-1</span>] 都是可行的解，其中 <span class="number">1</span> &lt;= x,y &lt;= <span class="number">10</span>^<span class="number">9</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rains = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由于湖泊 <span class="number">20</span> 会连续下 <span class="number">2</span> 天的雨，所以没有没有办法阻止洪水。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rains.length &lt;= 10^5</code></li><li><code>0 &lt;= rains[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/avoid-flood-in-the-city" target="_blank" rel="noopener">https://leetcode-cn.com/problems/avoid-flood-in-the-city</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心 + 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们保存未下雨的天数，即可以抽干湖泊的日期<code>dry</code>。我们同时记录湖泊<code>i</code>在哪一天下了雨，记录为<code>rain[i]</code>。</li><li>当我们遇到湖泊<code>i</code>在第<code>j</code>天第二次下雨时，因为此时湖泊已经灌满了水，这时会肯定会发生洪水,此时我们应当在<code>[rain[i]+1,j-1]</code>之间从可以抽干水的日期<code>dry</code>中选择一天来抽干湖泊<code>i</code>,即：<script type="math/tex; mode=display">rain[i]+1 \le select_{i} \le j-1</script></li><li>但是选择日期的时候有一点比较关键，我们需要尽量选择靠前的天数，即在区间<code>[rain[i]+1,j-1]</code>中的最小日期,我们可以用二分查找在<code>O(lgn)</code>的时间复杂度内在<code>dry</code>集合中快速找到第一个大于<code>rain[i]</code>的数,我们可以利用有序集合的<code>upper_bound</code>函数。假如我们不选择靠前的天数可能会影响到后面的湖泊，导致后面的湖泊出现洪水。比如：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>我们在第<code>6</code>天时，湖泊<code>1</code>如果不进行抽干，则该湖泊会导致洪水，而我们可以选择第<code>2</code>天或者第<code>5</code>天进行抽干湖泊<code>1</code>，但我们实际选择时选择第<code>2</code>天进行抽干湖泊<code>1</code>,否则会导致湖泊<code>2</code>没法进行抽干而产生洪水。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; avoidFlood(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rains) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = rains.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; flood;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; dry;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rains[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dry.insert(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rains[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(flood.count(rains[i]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dry.empty()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                    <span class="keyword">auto</span> it = dry.upper_bound(flood[rains[i]]);</span><br><span class="line">                    <span class="keyword">if</span>(it == dry.end()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">                    ans[*it] = rains[i];</span><br><span class="line">                    dry.erase(*it);</span><br><span class="line">                &#125;</span><br><span class="line">                flood[rains[i]] = i;</span><br><span class="line">                ans[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a>1489. 找到最小生成树里的关键边和伪关键边</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>n</code>个点的带权无向连通图，节点编号为 <code>0</code>到 <code>n-1</code> ，同时还有一个数组<code>edges</code>，其中<code>edges[i] = [fromi, toi, weighti]</code> 表示在 <code>fromi</code>和<code>toi</code>节点之间有一条带权无向边。最小生成树 <code>(MST)</code>是给定图中边的一个子集，它连接了所有节点且没有环，而且这些边的权值和最小。</p><p>请你找到给定图中最小生成树的所有关键边和伪关键边。如果最小生成树中删去某条边，会导致最小生成树的权值和增加，那么我们就说它是一条关键边。伪关键边则是可能会出现在某些最小生成树中但不会出现在所有最小生成树中的边。</p><p>请注意，你可以分别以任意顺序返回关键边的下标和伪关键边的下标。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">解释：上图描述了给定图。</span><br><span class="line">下图是所有的最小生成树。</span><br><span class="line"></span><br><span class="line">注意到第 <span class="number">0</span> 条边和第 <span class="number">1</span> 条边出现在了所有最小生成树中，所以它们是关键边，我们将这两个下标作为输出的第一个列表。</span><br><span class="line">边 <span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span> 和 <span class="number">5</span> 是所有 MST 的剩余边，所以它们是伪关键边。我们将它们作为输出的第二个列表。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[[],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：可以观察到 <span class="number">4</span> 条边都有相同的权值，任选它们中的 <span class="number">3</span> 条可以形成一棵 MST 。所以 <span class="number">4</span> 条边都是伪关键边。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>0 &lt;= fromi &lt; toi &lt; n</code></li><li><code>1 &lt;= weighti &lt;= 1000</code></li><li><code>所有 (fromi, toi) 数对都是互不相同的。</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>最小生成树算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><code>contest</code>时没有做出来，后来看了解答，感觉竟然时暴力<code>check</code>每条边。</li><li>首先跑一边最小生成树<code>kruskal</code>算法，求出最小生成树的<code>weight</code>为<code>best</code>.</li><li>如果去掉某条边<code>e</code>,再运行一遍最小生成树算法，如果发现求出的最小生成树的<code>weight</code>如果不等于<code>best</code>，则我们认为边<code>e</code>为<code>critical egde</code>.</li><li>如果我们在最小生成树中，初始化时每次加入某条边<code>e</code>（去掉<code>critical edge</code>),再运行一遍最小生成树算法，如果发现求出的最小生成树的<code>weight</code>如果等于<code>best</code>，则我们认为边<code>e</code>为<code>pseudo critical egde</code>.</li><li>题目非常暴力，不过当时竟然没有想到这种暴力解法，题目中最重要的提示为<code>1 &lt;= edges.length &lt;= min(200, n * (n - 1) / 2)</code>,说明<code>edge</code>的数量级非常小，完全可以暴力<code>check</code>每条边，还是智商不够，没有<code>get</code>到<code>point</code>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x]) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findCriticalAndPseudoCriticalEdges(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            edges[k].push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; u, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v) &#123;</span><br><span class="line">                <span class="keyword">return</span> u[<span class="number">2</span>] &lt; v[<span class="number">2</span>];</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = e[<span class="number">0</span>], y = e[<span class="number">1</span>], z = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (find(f,x) != find(f,y)) &#123;</span><br><span class="line">                best += z;</span><br><span class="line">                uni(f,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; best &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; retA, retB;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; A(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = edges[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = edges[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> w = edges[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">                    uni(f,x,y);</span><br><span class="line">                    curr += w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr != best)&#123;</span><br><span class="line">                retA.push_back(edges[k][<span class="number">3</span>]);</span><br><span class="line">                A[k] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[k]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">            uni(f,edges[k][<span class="number">0</span>],edges[k][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> curr = edges[k][<span class="number">2</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> x = edges[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = edges[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> w = edges[j][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">                    uni(f,x,y);</span><br><span class="line">                    curr += w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == best)&#123;</span><br><span class="line">                retB.push_back(edges[k][<span class="number">3</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;retA, retB&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;194周比赛&quot;&gt;&lt;a href=&quot;#194周比赛&quot; class=&quot;headerlink&quot; title=&quot;194周比赛&quot;&gt;&lt;/a&gt;194周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/175-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛的题目还还是创出了新难度，题目全部AC的人数还不到100人。前三题确实有点难度，特别是第二题和第三题都比较绕，第四题除了暴力意外没有好思路。&lt;/p&gt;&lt;h2 id=&quot;1486-数组异或操作&quot;&gt;&lt;a href=&quot;#1486-数组异或操作&quot; class=&quot;headerlink&quot; title=&quot;1486. 数组异或操作&quot;&gt;&lt;/a&gt;1486. 数组异或操作&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数，&lt;code&gt;n&lt;/code&gt;和 &lt;code&gt;start&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;数组 &lt;code&gt;nums&lt;/code&gt; 定义为：&lt;code&gt;nums[i] = start + 2*i&lt;/code&gt;（下标从 0 开始）且 &lt;code&gt;n == nums.length&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 193周比赛</title>
    <link href="http://yoursite.com/2020/06/14/172/"/>
    <id>http://yoursite.com/2020/06/14/172/</id>
    <published>2020-06-14T15:39:03.891Z</published>
    <updated>2020-06-14T15:39:08.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="193周比赛"><a href="#193周比赛" class="headerlink" title="193周比赛"></a>193周比赛</h1><p><img src="https://mike-box.github.io/images/174-1.png" alt="1"><br>本周周赛的题目还是出的非常好，有一定的难度和拔高，部分经典问题非常值得探讨。比较坑的是竟然第三题连二分查找都忘了，用了一个非常复杂的办法，虽然AC了，但是效率和性能并不高。</p><h2 id="55436-一维数组的动态和"><a href="#55436-一维数组的动态和" class="headerlink" title="55436. 一维数组的动态和"></a>55436. 一维数组的动态和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>。数组「动态和」的计算公式为：<code>runningSum[i] = sum(nums[0]…nums[i])</code>。</p><a id="more"></a><p>请返回 <code>nums</code>的动态和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>]</span><br><span class="line">解释：动态和计算过程为 [<span class="number">1</span>, <span class="number">1</span>+<span class="number">2</span>, <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>, <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：动态和计算过程为 [<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>, <span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>+<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">16</span>,<span class="number">17</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/running-sum-of-1d-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目没啥好说的，直接相加即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; runningSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5437-不同整数的最少数目"><a href="#5437-不同整数的最少数目" class="headerlink" title="5437. 不同整数的最少数目"></a>5437. 不同整数的最少数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>和一个整数 <code>k</code> 。现需要从数组中恰好移除<code>k</code>个元素，请找出移除后数组中不同整数的最少数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：移除 <span class="number">1</span> 个 <span class="number">4</span> ，数组中只剩下 <span class="number">5</span> 一种整数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：先移除 <span class="number">4</span>、<span class="number">2</span> ，然后再移除两个 <span class="number">1</span> 中的任意 <span class="number">1</span> 个或者三个 <span class="number">3</span> 中的任意 <span class="number">1</span> 个，最后剩下 <span class="number">1</span> 和 <span class="number">3</span> 两种整数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>0 &lt;= k &lt;= arr.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals" target="_blank" rel="noopener">https://leetcode-cn.com/problems/least-number-of-unique-integers-after-k-removals</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>若要使的数的种类最少，则我们优先减少数量统计最少个数的数。</li><li>我们统计出所有数字的个数，然后按照个数从小到大进行排序，依次去掉数目的个数，直到达到<code>k</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeastNumOfUniqueInts</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remove = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; A;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : arr)&#123;</span><br><span class="line">            cnt[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            A.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            k -= A[i].second;</span><br><span class="line">            <span class="keyword">if</span>(k &gt;= <span class="number">0</span>) remove++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> A.size() - remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5438-制作-m-束花所需的最少天数"><a href="#5438-制作-m-束花所需的最少天数" class="headerlink" title="5438. 制作 m 束花所需的最少天数"></a>5438. 制作 m 束花所需的最少天数</h2><p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code>。</p><p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 相邻的 <code>k</code> 朵花 。</p><p>花园中有 <code>n</code> 朵花，第 <code>i</code>朵花会在 <code>bloomDay[i]</code> 时盛开，恰好 可以用于 一束 花中。</p><p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 <span class="number">3</span> 束花，每束只需要 <span class="number">1</span> 朵。</span><br><span class="line"><span class="number">1</span> 天后：[x, _, _, _, _]   <span class="comment">// 只能制作 1 束花</span></span><br><span class="line"><span class="number">2</span> 天后：[x, _, _, _, x]   <span class="comment">// 只能制作 2 束花</span></span><br><span class="line"><span class="number">3</span> 天后：[x, _, x, _, x]   <span class="comment">// 可以制作 3 束花，答案为 3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>], m = <span class="number">3</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：要制作 <span class="number">3</span> 束花，每束需要 <span class="number">2</span> 朵花，也就是一共需要 <span class="number">6</span> 朵花。而花园中只有 <span class="number">5</span> 朵花，无法满足制作要求，返回 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">12</span>,<span class="number">7</span>,<span class="number">7</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：要制作 <span class="number">2</span> 束花，每束需要 <span class="number">3</span> 朵。</span><br><span class="line">花园在 <span class="number">7</span> 天后和 <span class="number">12</span> 天后的情况如下：</span><br><span class="line"><span class="number">7</span> 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 <span class="number">3</span> 朵盛开的花制作第一束花。但不能使用后 <span class="number">3</span> 朵盛开的花，因为它们不相邻。</span><br><span class="line"><span class="number">12</span> 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1000000000</span>,<span class="number">1000000000</span>], m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1000000000</span></span><br><span class="line">解释：需要等 <span class="number">1000000000</span> 天才能采到花来制作花束</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：bloomDay = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>], m = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>bloomDay.length == n</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= bloomDay[i] &lt;= 10^9</code></li><li><code>1 &lt;= m &lt;= 10^6</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口或者二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们将所有花的盛开时间按照先后进行排序。</li><li>我们设数组<code>left[i]</code>代表从<code>i</code>处开始左边有连续多少朵花已经开放，<code>right[i]</code>代表从<code>i</code>处开始右边有连续多少朵花已经开放，每次第<code>i</code>朵花开放时，则：<script type="math/tex; mode=display">\begin{array}{l}left[i] = left[i-1] + 1 \\\\right[i] = right[i+1] + 1\\\\right[i-left[i]+1] = left[i] + right[i] - 1 \\\\left[i+right[i]-1] = left[i] + right[i] - 1 \\\end{array}</script>新加入的第<code>i</code>朵盛开的花能否增加制作一束花，只需要判断如下条件即可：<script type="math/tex; mode=display">(left[i-1] \bmod k + right[i+1] \bmod k + 1) >= k</script>如果满足以上条件则我们将可以制作花束的统计数目进行加1.</li><li>判断当前统计数目大于m时即满足题目要求。</li><li>另外一种高效率的解法为二分查找，非常简单。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = bloomDay.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; days;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            days[bloomDay[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : days)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : d.second)&#123;</span><br><span class="line">                right[x] = <span class="number">1</span>;</span><br><span class="line">                left[x] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; n - <span class="number">1</span>) right[x] += right[x+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">0</span>) left[x] += left[x<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(((left[x]<span class="number">-1</span>)%k + (right[x]<span class="number">-1</span>)%k + <span class="number">1</span>) &gt;= k)&#123;</span><br><span class="line">                    curr++;</span><br><span class="line">                    <span class="keyword">if</span>(curr == m) <span class="keyword">return</span> d.first;</span><br><span class="line">                &#125;</span><br><span class="line">                right[x-left[x]+<span class="number">1</span>] = left[x] + right[x] - <span class="number">1</span>;</span><br><span class="line">                left[x+right[x]<span class="number">-1</span>] = left[x] + right[x] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k,<span class="keyword">int</span> days)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bloomDay.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomDay[i] &lt;= days)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                total += curr/k;</span><br><span class="line">                curr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        total += curr/k;</span><br><span class="line">        <span class="keyword">return</span> total &gt;= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bloomDay, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(bloomDay,m,k,mid))&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5188-树节点的第-K-个祖先"><a href="#5188-树节点的第-K-个祖先" class="headerlink" title="5188. 树节点的第 K 个祖先"></a>5188. 树节点的第 K 个祖先</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵树，树上有 <code>n</code>个节点，按从 <code>0</code> 到 <code>n-1</code> 编号。树以父节点数组的形式给出，其中 <code>parent[i]</code>是节点<code>i</code> 的父节点。树的根节点是编号为<code>0</code>的节点。<br>请你设计并实现<code>getKthAncestor(int node, int k)</code>函数，函数返回节点 <code>node</code>的第 <code>k</code>个祖先节点。如果不存在这样的祖先节点，返回 <code>-1</code>。<br>树节点的第<code>k</code>个祖先节点是从该节点到根节点路径上的第 <code>k</code> 个节点。</p><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"TreeAncestor"</span>,<span class="string">"getKthAncestor"</span>,<span class="string">"getKthAncestor"</span>,<span class="string">"getKthAncestor"</span>]</span><br><span class="line">[[<span class="number">7</span>,[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TreeAncestor treeAncestor = new TreeAncestor(<span class="number">7</span>, [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">3</span>, <span class="number">1</span>);  <span class="comment">// 返回 1 ，它是 3 的父节点</span></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">5</span>, <span class="number">2</span>);  <span class="comment">// 返回 0 ，它是 5 的祖父节点</span></span><br><span class="line">treeAncestor.getKthAncestor(<span class="number">6</span>, <span class="number">3</span>);  <span class="comment">// 返回 -1 因为不存在满足要求的祖先节点</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= n &lt;= 5*10^4</code></li><li><code>parent[0] == -1</code> 表示编号为 <code>0</code>的节点是根节点。</li><li>对于所有的 <code>0 &lt; i &lt; n ，0 &lt;= parent[i] &lt; n</code>总成立</li><li><code>0 &lt;= node &lt; n</code></li><li>至多查询 <code>5*10^4</code>次</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-ancestor-of-a-tree-node</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>lca倍增</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>从来没有见过类似的题目，第一次见到，感觉真心牛逼，不过感觉后缀数组中的倍增有的一拼，后缀数组中的倍增排序算法更复杂。</li><li>首先需要理解这个递推关系,node的第k个父节点等于node的第x个父节点的第k-x个父节点。<script type="math/tex; mode=display">parent[node][k] = parent[parent[node][x]][k-x]</script>知道这个原理后我们就可以利用倍增原理,非常类似于求开方的计算方法，不断的进行除2迭代即可得到结果。<script type="math/tex; mode=display">parent[node][k] = parent[parent[node][\frac{k}{2}]][k-\frac{k}{2}]</script></li><li>我们可以很快的求出每个节点的2次幂的父节点。<script type="math/tex; mode=display">fa[x][i] = parent[x][2^{i}] \\\\fa[x][i+1] = parent[x][2^{i+1}]  \\\\parent[x][2^{i+1}]  = parent[parent[x][2^{i}]][2^{i}] = fa[fa[x][i]][i]</script>我们刚好即可利用上述的递推公式很快的求出所有距离为2次幂的节点。</li><li>我们实际计算时，将k进行2次幂的分解，我们知道k一定能够被分解为2次幂的组合。<script type="math/tex; mode=display">k = \sum_{i=1}^{m} 2^{x^{i}}</script><script type="math/tex; mode=display">parent[node][k] = parent[fa[node][x_{1}]][k-2^{x_{1}}] \\node_{1} = fa[node][x_{1}] \\parent[node][k] = parent[node_{1}][k-2^{x_{1}}]</script>我们依次按照上述的计算过程依次进行迭代，最终能够在O(lgk)的时间复杂度内求出最终的<code>k</code>个父节点。</li><li>第一次见到这个题目还是非常牛逼的。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeAncestor</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fa[<span class="number">100005</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeAncestor(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parent) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            fa[i][<span class="number">0</span>] = parent[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> ffa = fa[i][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ffa &lt; <span class="number">0</span>) fa[i][j] = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> fa[i][j] = fa[ffa][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthAncestor</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">while</span>(k &gt;= curr &amp;&amp; node &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                k -= curr;</span><br><span class="line">                node = fa[node][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your TreeAncestor object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * TreeAncestor* obj = new TreeAncestor(n, parent);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;getKthAncestor(node,k);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;193周比赛&quot;&gt;&lt;a href=&quot;#193周比赛&quot; class=&quot;headerlink&quot; title=&quot;193周比赛&quot;&gt;&lt;/a&gt;193周比赛&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mike-box.github.io/images/174-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周周赛的题目还是出的非常好，有一定的难度和拔高，部分经典问题非常值得探讨。比较坑的是竟然第三题连二分查找都忘了，用了一个非常复杂的办法，虽然AC了，但是效率和性能并不高。&lt;/p&gt;&lt;h2 id=&quot;55436-一维数组的动态和&quot;&gt;&lt;a href=&quot;#55436-一维数组的动态和&quot; class=&quot;headerlink&quot; title=&quot;55436. 一维数组的动态和&quot;&gt;&lt;/a&gt;55436. 一维数组的动态和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;。数组「动态和」的计算公式为：&lt;code&gt;runningSum[i] = sum(nums[0]…nums[i])&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
