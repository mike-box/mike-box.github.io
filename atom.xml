<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-11-15T04:00:06.040Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 Leetcode Weekly Contest 267</title>
    <link href="http://yoursite.com/2021/11/15/344/"/>
    <id>http://yoursite.com/2021/11/15/344/</id>
    <published>2021-11-15T03:21:04.506Z</published>
    <updated>2021-11-15T04:00:06.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-267"><a href="#leetcode-contest-267" class="headerlink" title="leetcode contest 267"></a>leetcode contest 267</h1><p>最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.</p><h3 id="2073-买票需要的时间"><a href="#2073-买票需要的时间" class="headerlink" title="2073. 买票需要的时间"></a>2073. 买票需要的时间</h3><p>有 <code>n</code> 个人前来排队买票，其中第 <code>0</code> 人站在队伍 最前方 ，第 <code>(n - 1)</code> 人站在队伍 最后方 。</p><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>tickets</code> ，数组长度为 <code>n</code> ，其中第 <code>i</code> 人想要购买的票数为 <code>tickets[i]</code> 。</p><a id="more"></a><p>每个人买票都需要用掉 恰好 <code>1</code> 秒 。一个人 一次只能买一张票 ，如果需要购买更多票，他必须走到  队尾 重新排队（瞬间 发生，不计时间）。如果一个人没有剩下需要买的票，那他将会 离开 队伍。</p><p>返回位于位置 <code>k</code>（下标从 <code>0</code> 开始）的人完成买票需要的时间（以秒为单位）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释： </span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>] 。</span><br><span class="line">- 第二轮，队伍中的每个都又都买到一张票，队伍变为 [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] 。</span><br><span class="line">位置 <span class="number">2</span> 的人成功买到 <span class="number">2</span> 张票，用掉 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 秒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tickets = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line">- 第一轮，队伍中的每个人都买到一张票，队伍变为 [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>] 。</span><br><span class="line">- 接下来的 <span class="number">4</span> 轮，只有位置 <span class="number">0</span> 的人在买票。</span><br><span class="line">位置 <span class="number">0</span> 的人成功买到 <span class="number">5</span> 张票，用掉 <span class="number">4</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">8</span> 秒。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tickets.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= tickets[i] &lt;= 100</code></li><li><code>0 &lt;= k &lt; n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-buy-tickets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-buy-tickets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 模拟队列或者数学问题均可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接模拟即可实现所有的排队完成.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(K \times N)$,其中 $N$ 为数组的长度。</li><li>空间复杂度: $O(N)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeRequiredToBuy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tickets, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = tickets.size();</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            qu.push(make_pair(tickets[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pii curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ans++;</span><br><span class="line">            curr.first--;</span><br><span class="line">            <span class="keyword">if</span>(curr.first &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(curr);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr.second == k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2074-反转偶数长度组的节点"><a href="#2074-反转偶数长度组的节点" class="headerlink" title="2074. 反转偶数长度组的节点"></a>2074. 反转偶数长度组的节点</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表的头节点 <code>head</code> 。</p><p>链表中的节点 按顺序 划分成若干 非空 组，这些非空组的长度构成一个自然数序列<code>（1, 2, 3, 4, ...）</code>。一个组的 长度 就是组中分配到的节点数目。换句话说：</p><ul><li>节点 1 分配给第一组</li><li>节点 2 和 3 分配给第二组</li><li>节点 4、5 和 6 分配给第三组，以此类推</li><li>注意，最后一组的长度可能小于或者等于 1 + 倒数第二组的长度 。</li></ul><p>反转 每个 偶数 长度组中的节点，并返回修改后链表的头节点 <code>head</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，奇数，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，偶数，节点反转。</span><br><span class="line">- 第三组长度为 <span class="number">3</span> ，奇数，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">4</span> ，偶数，节点反转。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 第二组长度为 <span class="number">2</span> ，节点反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：</span><br><span class="line">- 第一组长度为 <span class="number">1</span> ，没有发生反转。</span><br><span class="line">- 最后一组长度为 <span class="number">1</span> ，没有发生反转。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">8</span>]</span><br><span class="line">解释：只有一个长度为 <span class="number">1</span> 的组，没有发生反转。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点数目范围是 <code>[1, 105]</code></li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-nodes-in-even-length-groups</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 链表转数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身比较奇葩的问题，真心不如转换成数组，然后进行翻转，题目本上就变得非常简单.我们将链表转换为数组，然后按照题目要求进行分组翻转，然后再重建链表即可，比较坑的一点在于：</li></ol><ul><li>特别需要注意最后一组的长度可能为偶数,此时我们需要进行翻转.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li><li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为链表的长度.</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseEvenLengthGroups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(ListNode * node = head; node; node = node-&gt;next)&#123;</span><br><span class="line">            arr.emplace_back(node-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; n &gt; <span class="number">0</span> ; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = (i<span class="number">-1</span>)*i/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> r = min((<span class="keyword">int</span>)arr.size(),(i+<span class="number">1</span>)*i/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span>((r - l)%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                reverse(arr.begin() + l,arr.begin() + r);</span><br><span class="line">            &#125;</span><br><span class="line">            n -= r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * newhead = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode * curr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;           </span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                curr = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                newhead = curr;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr-&gt;next = <span class="keyword">new</span> ListNode(arr[i]);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2075-解码斜向换位密码"><a href="#2075-解码斜向换位密码" class="headerlink" title="2075. 解码斜向换位密码"></a>2075. 解码斜向换位密码</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>字符串 <code>originalText</code> 使用 斜向换位密码 ，经由 行数固定 为 rows 的矩阵辅助，加密得到一个字符串 <code>encodedText</code> 。</p><p><code>originalText</code> 先按从左上到右下的方式放置到矩阵中。</p><p>先填充蓝色单元格，接着是红色单元格，然后是黄色单元格，以此类推，直到到达 <code>originalText</code> 末尾。箭头指示顺序即为单元格填充顺序。所有空单元格用 ‘ ‘ 进行填充。矩阵的列数需满足：用 <code>originalText</code> 填充之后，最右侧列 不为空 。</p><p>接着按行将字符附加到矩阵中，构造 <code>encodedText</code> 。</p><p>先把蓝色单元格中的字符附加到 <code>encodedText</code> 中，接着是红色单元格，最后是黄色单元格。箭头指示单元格访问顺序。</p><p>例如，如果 <code>originalText = &quot;cipher&quot;</code> 且 <code>rows = 3</code> ，那么我们可以按下述方法将其编码：</p><p>蓝色箭头标识 <code>originalText</code> 是如何放入矩阵中的，红色箭头标识形成 <code>encodedText</code> 的顺序。在上述例子中，<code>encodedText = &quot;ch   ie   pr&quot;</code>。</p><p>给你编码后的字符串 encodedText 和矩阵的行数 rows ，返回源字符串 originalText 。</p><p>注意：<code>originalText</code> 不 含任何尾随空格 ‘ ‘ 。生成的测试用例满足 仅存在一个 可能的 <code>originalText</code> 。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">"ch   ie   pr"</span>, <span class="attr">rows</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"cipher"</span></span><br><span class="line">解释：此示例与问题描述中的例子相同。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"iveo    eed   l te   olc"</span>, rows = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"i love leetcode"</span></span><br><span class="line">解释：上图标识用于编码 <span class="keyword">originalText </span>的矩阵。 </span><br><span class="line">蓝色箭头展示如何从 encodedText 找到 <span class="keyword">originalText </span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：encodedText = <span class="string">"coding"</span>, rows = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"coding"</span></span><br><span class="line">解释：由于只有 <span class="number">1</span> 行，所以 originalText 和 encodedText 是相同的。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">encodedText</span> = <span class="string">" b  ac"</span>, <span class="attr">rows</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="string">" abc"</span></span><br><span class="line">解释：originalText 不能含尾随空格，但它可能会有一个或者多个前置空格。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= encodedText.length &lt;= 106</code></li><li><code>encodedText</code> 仅由小写英文字母和 ‘ ‘ 组成</li><li><code>encodedText</code> 是对某个 不含 尾随空格的 <code>originalText</code> 的一个有效编码</li><li><code>1 &lt;= rows &lt;= 1000</code></li><li>生成的测试用例满足 仅存在一个 可能的 <code>originalText</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/decode-the-slanted-ciphertext" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-the-slanted-ciphertext</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 对字符串进行还原即可</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>少点这种奇奇怪怪的题目,还是能够多一点思考和智力的题目,题目本身感觉非常怪异,题目本省其实也比较简答.我们首先可以确定矩阵的列数为 $cols = \frac{n}{rows}$,然后我们就可以知道 $originalText$ 的第 $i$ 个字符对应矩阵的位置坐标为 $(i/cols,i\%cols)$,我们还原矩阵后,就按照斜行的访问方式还原原始字符串,最终需要去掉字符串末尾的空格.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$,其中 $N$ 为字符串的个数．</li><li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeCiphertext</span><span class="params">(<span class="built_in">string</span> encodedText, <span class="keyword">int</span> rows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = encodedText.size();</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> cols = n/rows;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; mat(rows,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(cols,<span class="string">'#'</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mat[i/cols][i%cols] = encodedText[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cols; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> y = i;</span><br><span class="line">            <span class="keyword">while</span>(x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; mat[x][y] != <span class="string">'#'</span>)&#123;</span><br><span class="line">                ans.push_back(mat[x][y]);</span><br><span class="line">                x++;</span><br><span class="line">                y++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = ans.size(); i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans.back() == <span class="string">' '</span>) ans.pop_back();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2076-处理含限制条件的好友请求"><a href="#2076-处理含限制条件的好友请求" class="headerlink" title="2076. 处理含限制条件的好友请求"></a>2076. 处理含限制条件的好友请求</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> ，表示网络上的用户数目。每个用户按从 <code>0</code> 到 <code>n - 1</code>进行编号。</p><p>给你一个下标从 0 开始的二维整数数组 <code>restrictions</code> ，其中<code>restrictions[i] = [xi, yi]</code> 意味着用户 <code>xi</code> 和用户 <code>yi</code> 不能 成为 朋友 ，不管是 直接 还是通过其他用户 间接 。</p><p>最初，用户里没有人是其他用户的朋友。给你一个下标从 0 开始的二维整数数组 <code>requests</code> 表示好友请求的列表，其中 <code>requests[j] = [uj, vj]</code>是用户 <code>uj</code>和用户 vj 之间的一条好友请求。</p><p>如果<code>uj</code> 和 <code>vj</code> 可以成为 朋友 ，那么好友请求将会 成功 。每个好友请求都会按列表中给出的顺序进行处理（即，<code>requests[j]</code> 会在 <code>requests[j + 1]</code>前）。一旦请求成功，那么对所有未来的好友请求而言， <code>uj</code> 和 <code>vj</code> 将会 成为直接朋友 。</p><p>返回一个 布尔数组 <code>result</code> ，其中元素遵循此规则：如果第 j 个好友请求 成功 ，那么 <code>result[j]</code> 就是 <code>true</code> ；否则，为 <code>false</code> 。</p><p>注意：如果 <code>uj</code>和<code>vj</code> 已经是直接朋友，那么他们之间的请求将仍然 成功 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">2</span> 和 用户 <span class="number">1</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">1</span>-<span class="number">-2</span>-<span class="number">-0</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>]], requests = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-2</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, restrictions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]], requests = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">解释：</span><br><span class="line">请求 <span class="number">0</span> ：用户 <span class="number">0</span> 和 用户 <span class="number">4</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">1</span> ：用户 <span class="number">1</span> 和 用户 <span class="number">2</span> 不能成为朋友，因为他们之间存在限制。</span><br><span class="line">请求 <span class="number">2</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">1</span> 可以成为朋友，所以他们成为直接朋友。 </span><br><span class="line">请求 <span class="number">3</span> ：用户 <span class="number">3</span> 和 用户 <span class="number">4</span> 不能成为朋友，因为这会使 用户 <span class="number">0</span> 和 用户 <span class="number">1</span> 成为间接朋友 (<span class="number">0</span>-<span class="number">-4</span>-<span class="number">-3</span>-<span class="number">-1</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>0 &lt;= restrictions.length &lt;= 1000</code></li><li><code>restrictions[i].length == 2</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li><code>xi != yi</code></li><li><code>1 &lt;= requests.length &lt;= 1000</code></li><li><code>requests[j].length == 2</code></li><li><code>0 &lt;= uj, vj &lt;= n - 1</code></li><li><code>uj != vj</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/process-restricted-friend-requests" target="_blank" rel="noopener">https://leetcode-cn.com/problems/process-restricted-friend-requests</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目可以算是中等题目．难点在于如何判断两个人是否通过朋友圈链接合法性,我们可以利用集合的特性,如果两个人 $x,y$ 不能成为朋友,我们只需要判断这两个人是否在同一个集合中即可.</li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度：$O(mn \cdot \alpha(n))$，其中 mm 是数组 $\textit{restrictions}$ 的长度，$\alpha(\cdot)$ 是反阿克曼函数，表示在路径压缩和按秩合并优化下的并查集的单次操作时间复杂度。</li><li>空间复杂度分析: $O(n)$，即为并查集需要使用的空间.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[x] == f[y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        f[x1] = y1;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; friendRequests(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; restrictions, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = restrictions.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = requests[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = requests[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> fx = find(f,x);</span><br><span class="line">            <span class="keyword">int</span> fy = find(f,y);</span><br><span class="line">            <span class="keyword">if</span>(fx == fy)&#123;</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> fa = find(f,restrictions[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">int</span> fb = find(f,restrictions[j][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>((fa == fx &amp;&amp; fb == fy) || (fa == fy &amp;&amp; fb == fx))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                uni(f,x,y);</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-267&quot;&gt;&lt;a href=&quot;#leetcode-contest-267&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 267&quot;&gt;&lt;/a&gt;leetcode contest 267&lt;/h1&gt;&lt;p&gt;最后一题果真没有区分度,基本上都做出来了,就是一个简单集合合并的问题.&lt;/p&gt;&lt;h3 id=&quot;2073-买票需要的时间&quot;&gt;&lt;a href=&quot;#2073-买票需要的时间&quot; class=&quot;headerlink&quot; title=&quot;2073. 买票需要的时间&quot;&gt;&lt;/a&gt;2073. 买票需要的时间&lt;/h3&gt;&lt;p&gt;有 &lt;code&gt;n&lt;/code&gt; 个人前来排队买票，其中第 &lt;code&gt;0&lt;/code&gt; 人站在队伍 最前方 ，第 &lt;code&gt;(n - 1)&lt;/code&gt; 人站在队伍 最后方 。&lt;/p&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;tickets&lt;/code&gt; ，数组长度为 &lt;code&gt;n&lt;/code&gt; ，其中第 &lt;code&gt;i&lt;/code&gt; 人想要购买的票数为 &lt;code&gt;tickets[i]&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 65</title>
    <link href="http://yoursite.com/2021/11/14/343/"/>
    <id>http://yoursite.com/2021/11/14/343/</id>
    <published>2021-11-14T15:30:25.886Z</published>
    <updated>2021-11-15T01:45:37.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-65"><a href="#leetcode-biweekly-contest-65" class="headerlink" title="leetcode biweekly contest 65"></a>leetcode biweekly contest 65</h1><p>双周赛的难度还是挺大的,</p><h3 id="5910-检查两个字符串是否几乎相等"><a href="#5910-检查两个字符串是否几乎相等" class="headerlink" title="5910. 检查两个字符串是否几乎相等"></a>5910. 检查两个字符串是否几乎相等</h3><p>如果两个字符串 <code>word1</code> 和 <code>word2</code> 中从 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 <code>word1</code> 和 <code>word2</code> 几乎相等 。</p><a id="more"></a><p>给你两个长度都为 <code>n</code> 的字符串 <code>word1</code> 和 <code>word2</code> ，如果 <code>word1</code> 和 <code>word2</code> 几乎相等 ，请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p>一个字母 <code>x</code> 的出现 频率 指的是它在字符串中出现的次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"aaaa"</span>, word2 = <span class="string">"bccb"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 <span class="string">"aaaa"</span> 中有 <span class="number">4</span> 个 'a' ，但是 <span class="string">"bccb"</span> 中有 <span class="number">0</span> 个 'a' 。</span><br><span class="line">两者之差为 <span class="number">4</span> ，大于上限 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"abcdeef"</span>, word2 = <span class="string">"abaaacc"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">1</span> 次，差为 <span class="number">0</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">2</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br><span class="line">- 'e' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'f' 在 word1 中出现了 <span class="number">1</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 = <span class="string">"cccddabba"</span>, word2 = <span class="string">"babababab"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：word1 和 word2 中每个字母出现频率之差至多为 <span class="number">3</span> ：</span><br><span class="line">- 'a' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">4</span> 次，差为 <span class="number">2</span> 。</span><br><span class="line">- 'b' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">5</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'c' 在 word1 中出现了 <span class="number">3</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">3</span> 。</span><br><span class="line">- 'd' 在 word1 中出现了 <span class="number">2</span> 次，在 word2 中出现了 <span class="number">0</span> 次，差为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == word1.length == word2.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>word1</code> 和 <code>word2</code> 都只包含小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-whether-two-strings-are-almost-equivalent</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力统计</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计两个字符串中所有字符的统计个数,然后检测每个字符的统计个数的差的绝对值.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度。</li><li>空间复杂度: $O(C)$,其中 $C = 26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkAlmostEquivalent</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt1(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt2(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word1)&#123;</span><br><span class="line">            cnt1[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word2)&#123;</span><br><span class="line">            cnt2[c - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt1[i] - cnt2[i]) &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5911-模拟行走机器人-II"><a href="#5911-模拟行走机器人-II" class="headerlink" title="5911. 模拟行走机器人 II"></a>5911. 模拟行走机器人 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个在 <code>XY</code> 平面上的 <code>width x height</code> 的网格图，左下角 的格子为 <code>(0, 0)</code> ，右上角 的格子为 <code>(width - 1, height - 1)</code> 。网格图中相邻格子为四个基本方向之一<code>（&quot;North&quot;，&quot;East&quot;，&quot;South&quot; 和 &quot;West&quot;）</code>。一个机器人 初始 在格子 <code>(0, 0)</code>，方向为 “East” 。</p><p>机器人可以根据指令移动指定的 步数 。每一步，它可以执行以下操作。</p><ul><li>沿着当前方向尝试 往前一步 。</li><li>如果机器人下一步将到达的格子 超出了边界 ，机器人会 逆时针 转 90 度，然后再尝试往前一步。</li><li>如果机器人完成了指令要求的移动步数，它将停止移动并等待下一个指令。</li></ul><p>请你实现 <code>Robot</code> 类：</p><ul><li><code>Robot(int width, int height)</code> 初始化一个 width x height 的网格图，机器人初始在 (0, 0) ，方向朝 “East” 。</li><li><code>void move(int num)</code> 给机器人下达前进 num 步的指令。</li><li><code>int[] getPos()</code> 返回机器人当前所处的格子位置，用一个长度为 2 的数组 [x, y] 表示。</li><li><code>String getDir()</code> 返回当前机器人的朝向，为 “North” ，”East” ，”South” 或者 “West” 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"Robot"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"move"</span>, <span class="string">"getPos"</span>, <span class="string">"getDir"</span>]</span><br><span class="line">[[<span class="number">6</span>, <span class="number">3</span>], [<span class="number">2</span>], [<span class="number">2</span>], [], [], [<span class="number">2</span>], [<span class="number">1</span>], [<span class="number">4</span>], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, [<span class="number">4</span>, <span class="number">0</span>], <span class="string">"East"</span>, null, null, null, [<span class="number">1</span>, <span class="number">2</span>], <span class="string">"West"</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Robot robot = new Robot(<span class="number">6</span>, <span class="number">3</span>); <span class="comment">// 初始化网格图，机器人在 (0, 0) ，朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (2, 0) ，并朝东。</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 机器人朝东移动 2 步，到达 (4, 0) ，并朝东。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [4, 0]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "East"</span></span><br><span class="line">robot.move(<span class="number">2</span>);  <span class="comment">// 朝东移动 1 步到达 (5, 0) ，并朝东。</span></span><br><span class="line">                <span class="comment">// 下一步继续往东移动将出界，所以逆时针转变方向朝北。</span></span><br><span class="line">                <span class="comment">// 然后，往北移动 1 步到达 (5, 1) ，并朝北。</span></span><br><span class="line">robot.move(<span class="number">1</span>);  <span class="comment">// 朝北移动 1 步到达 (5, 2) ，并朝 北 （不是朝西）。</span></span><br><span class="line">robot.move(<span class="number">4</span>);  <span class="comment">// 下一步继续往北移动将出界，所以逆时针转变方向朝西。</span></span><br><span class="line">                <span class="comment">// 然后，移动 4 步到 (1, 2) ，并朝西。</span></span><br><span class="line">robot.getPos(); <span class="comment">// 返回 [1, 2]</span></span><br><span class="line">robot.getDir(); <span class="comment">// 返回 "West"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= width, height &lt;= 100</code></li><li><code>1 &lt;= num &lt;= 105</code></li><li><code>move</code> ，<code>getPos</code> 和 <code>getDir</code> 总共 调用次数不超过 104 次。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/walking-robot-simulation-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/walking-robot-simulation-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>真心是个很蛋疼的题目, 我们仔细分析一下即可得知,机器人始终会在最外圈一直循环行走, 因此我们可以求出最外圈的坐标的数组及方向的数组, 机器人的移动实际等价于数组上的循环移动,因此就比较简单了,有两点比较坑的是:</li></ol><ul><li>每个拐角处的方向需要注意实际上在四个拐角处不会切换方向,在拐角处的下一个方块需要切换方向, 及这四个坐标方向会改变 $(1,0),(width-1,1),(widht-2,height-1),(0,height-2)$.</li><li>机器人起始的坐标和移动方向需要特别注意,当它下一次移动到 $(0,0)$ 坐标时的方向实际应该是向南.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $Robot$ 函数的时间复杂度为 $0(width \times height)$，$move,getPos，getDir$的时间复杂度均为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(width \times height)$．</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Robot(<span class="keyword">int</span> width, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; width; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,<span class="number">0</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height; ++i)&#123;</span><br><span class="line">            arr.push_back(&#123;width<span class="number">-1</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = width<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;i,height<span class="number">-1</span>&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = height<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            arr.push_back(&#123;<span class="number">0</span>,i&#125;);</span><br><span class="line">            arrd.push_back(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;curr = arr.size()<span class="number">-1</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        num = num%arr.size();</span><br><span class="line">        curr = (curr + num)%arr.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getPos() &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;arr[curr].first,arr[curr].second&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getDir</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"East"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dirstr[arrd[curr]];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> curr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dirstr = &#123;<span class="string">"East"</span>,<span class="string">"North"</span>,<span class="string">"West"</span>,<span class="string">"South"</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pii&gt; arr;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Robot object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Robot* obj = new Robot(width, height);</span></span><br><span class="line"><span class="comment"> * obj-&gt;move(num);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;getPos();</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;getDir();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="5912-每一个查询的最大美丽值"><a href="#5912-每一个查询的最大美丽值" class="headerlink" title="5912. 每一个查询的最大美丽值"></a>5912. 每一个查询的最大美丽值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维整数数组 <code>items</code> ，其中 <code>items[i] = [pricei, beautyi]</code> 分别表示每一个物品的 价格 和 美丽值 。</p><p>同时给你一个下标从 <code>0</code> 开始的整数数组 <code>queries</code> 。对于每个查询 <code>queries[j]</code> ，你想求出价格小于等于 <code>queries[j]</code> 的物品中，最大的美丽值 是多少。如果不存在符合条件的物品，那么查询的结果为<code>0</code> 。</p><p>请你返回一个长度与 <code>queries</code> 相同的数组 <code>answer</code>，其中 <code>answer[j]</code>是第 <code>j</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], queries = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>]=<span class="number">1</span> ，[<span class="number">1</span>,<span class="number">2</span>] 是唯一价格 &lt;= <span class="number">1</span> 的物品。所以这个查询的答案为 <span class="number">2</span> 。</span><br><span class="line">- queries[<span class="number">1</span>]=<span class="number">2</span> ，符合条件的物品有 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">4</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">4</span> 。</span><br><span class="line">- queries[<span class="number">2</span>]=<span class="number">3</span> 和 queries[<span class="number">3</span>]=<span class="number">4</span> ，符合条件的物品都为 [<span class="number">1</span>,<span class="number">2</span>] ，[<span class="number">3</span>,<span class="number">2</span>] ，[<span class="number">2</span>,<span class="number">4</span>] 和 [<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">  它们中的最大美丽值为 <span class="number">5</span> 。</span><br><span class="line">- queries[<span class="number">4</span>]=<span class="number">5</span> 和 queries[<span class="number">5</span>]=<span class="number">6</span> ，所有物品都符合条件。</span><br><span class="line">  所以，答案为所有物品中的最大美丽值，为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>]], queries = [<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">每个物品的价格均为 <span class="number">1</span> ，所以我们选择最大美丽值 <span class="number">4</span> 。</span><br><span class="line">注意，多个物品可能有相同的价格和美丽值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：items = [[<span class="number">10</span>,<span class="number">1000</span>]], queries = [<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">没有物品的价格小于等于 <span class="number">5</span> ，所以没有物品可以选择。</span><br><span class="line">因此，查询的结果为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= items.length, queries.length &lt;= 105</code></li><li><code>items[i].length == 2</code></li><li><code>1 &lt;= pricei, beautyi, queries[j] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-beautiful-item-for-each-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-beautiful-item-for-each-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>应该可以说是简单题目，我们首先将所有的物品按照价格进行排序，我们用 $prefix[i]$ 表示排序的物品中前 $i$ 个物品的最大美丽值. 我们每次进行查询 $x$ 时,我们找到物品价格小于等于 $x$ 的最大的索引 $j$, $prefix[j]$ 即为本次需要查询的结果.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O((m+n) \log n)$,其中 $n$ 为商品的个数, $m$ 为查询的此时．</li><li>空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maximumBeauty(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; items, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = items.size();</span><br><span class="line">        sort(items.begin(),items.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                prefix[i] = items[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prefix[i] = max(prefix[i<span class="number">-1</span>], items[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(items[mid][<span class="number">0</span>] &lt;= queries[i])&#123;</span><br><span class="line">                    curr = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(prefix[curr]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5913-你可以安排的最多任务数目"><a href="#5913-你可以安排的最多任务数目" class="headerlink" title="5913. 你可以安排的最多任务数目"></a>5913. 你可以安排的最多任务数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 $n$ 个任务和 $m$ 个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <code>0</code> 开始的整数数组 <code>tasks</code> 中，第 <code>i</code> 个任务需要 <code>tasks[i]</code> 的力量才能完成。每个工人的力量值保存在下标从 0 开始的整数数组 <code>workers</code> 中，第 <code>j</code> 个工人的力量值为 <code>workers[j]</code> 。每个工人只能完成 一个 任务，且力量值需要 大于等于 该任务的力量要求值（即 <code>workers[j] &gt;= tasks[i]</code> ）。</p><p>除此以外，你还有 <code>pills</code> 个神奇药丸，可以给 一个工人的力量值 增加 <code>strength</code> 。你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸。</p><p>给你下标从 <code>0</code> 开始的整数数组<code>tasks</code> 和 <code>workers</code> 以及两个整数 <code>pills</code> 和 <code>strength</code> ，请你返回 最多 有多少个任务可以被完成。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], workers = [<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>], pills = <span class="number">1</span>, strength = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">2</span>（<span class="number">0</span> + <span class="number">1</span> &gt;= <span class="number">1</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">3</span> &gt;= <span class="number">2</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">0</span>（<span class="number">3</span> &gt;= <span class="number">3</span>）</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">4</span>], workers = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">5</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">10</span>,<span class="number">15</span>,<span class="number">30</span>], workers = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], pills = <span class="number">3</span>, strength = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">0</span> 号和 <span class="number">1</span> 号工人药丸。</span><br><span class="line">- <span class="number">0</span> 号工人完成任务 <span class="number">0</span>（<span class="number">0</span> + <span class="number">10</span> &gt;= <span class="number">10</span>）</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">1</span>（<span class="number">10</span> + <span class="number">10</span> &gt;= <span class="number">15</span>）</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">9</span>], workers = [<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>], pills = <span class="number">1</span>, strength = <span class="number">5</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">我们可以按照如下方案安排药丸：</span><br><span class="line">- 给 <span class="number">2</span> 号工人药丸。</span><br><span class="line">- <span class="number">1</span> 号工人完成任务 <span class="number">0</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br><span class="line">- <span class="number">2</span> 号工人完成任务 <span class="number">2</span>（<span class="number">4</span> + <span class="number">5</span> &gt;= <span class="number">8</span>）</span><br><span class="line">- <span class="number">4</span> 号工人完成任务 <span class="number">3</span>（<span class="number">6</span> &gt;= <span class="number">5</span>）</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == tasks.length</code></li><li><code>m == workers.length</code></li><li><code>1 &lt;= n, m &lt;= 5 * 104</code></li><li><code>0 &lt;= pills &lt;= m</code></li><li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 109</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找 + 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们可以想到最优的解，肯定可以用二分查找找到最多可以完成多少个任务，重点是在于检测当前给定的条件下可以完成 $n$ 个任务. 首先我们想到一点的是,假设我们当前可以完全 $n$ 个人任务,那么根据贪心算法,可以知道我们一定是可以完成需要力量值最小的 $n$ 个任务.因此我们将任务按照所需要的力量值的大小进行排序,每次尝试是安排最强的 $x$ 个人完成前 $x$ 个任务.可以参考下官方题解，感觉写的非常清楚，证明也非常清晰．</li><li>我们如何检测给定条件下, 是否能够完成前 $n$ 个任务，需要一定的贪心策略．</li></ol><ul><li>当我们考虑当前任务值最大的任务时，此时我们的选择策略有贪心策略，能够不用药丸的情况下我们应该尽量避免使用药丸，因此我们应当从任务值最大的任务开始检测起：</li><li><ul><li>a. 要么直接选择当前力量值刚好能够大于等于这个任务的工人，此时我们有能够满足条件的工人，此时我们直接选择最小能够满足该任务的工人，避免使用药丸;</li></ul></li><li><ul><li>b. 要么选择一个工人吃一颗药丸后的力量值刚好能够大于等于这个任务.则此时我们应当选择满足条件下力量值最小的工人．<br>我们按照上述的贪心策略进行选择即可．</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(m \log m + n \log n + min(m,n) \times \log n\times log m)$, 其中 $m$ 表示任务的个数, $n$ 表示工人的数量.</li><li>空间复杂度分析: $O(n + \log n + \log m)$,其中 $m$ 表示任务的个数, $n$ 表示工人的数量.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTaskAssign</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tasks, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; workers, <span class="keyword">int</span> pills, <span class="keyword">int</span> strength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = tasks.size();</span><br><span class="line">        <span class="keyword">int</span> n = workers.size();</span><br><span class="line">        sort(tasks.begin(), tasks.end());</span><br><span class="line">        sort(workers.begin(), workers.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> x)-&gt;<span class="keyword">bool</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> p = pills;</span><br><span class="line">            <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : workers) cnt.insert(v);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = x - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = cnt.lower_bound(tasks[i]);</span><br><span class="line">                <span class="keyword">if</span>(it != cnt.end())&#123;</span><br><span class="line">                    cnt.erase(it);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">auto</span> it1 = cnt.lower_bound(tasks[i] - strength);</span><br><span class="line">                    <span class="keyword">if</span>(it1 == cnt.end()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt.erase(it1);</span><br><span class="line">                    p--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = m;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-65&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-65&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly contest 65&quot;&gt;&lt;/a&gt;leetcode biweekly contest 65&lt;/h1&gt;&lt;p&gt;双周赛的难度还是挺大的,&lt;/p&gt;&lt;h3 id=&quot;5910-检查两个字符串是否几乎相等&quot;&gt;&lt;a href=&quot;#5910-检查两个字符串是否几乎相等&quot; class=&quot;headerlink&quot; title=&quot;5910. 检查两个字符串是否几乎相等&quot;&gt;&lt;/a&gt;5910. 检查两个字符串是否几乎相等&lt;/h3&gt;&lt;p&gt;如果两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 中从 &lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt; 每一个字母出现频率之差都 不超过 3 ，那么我们称这两个字符串 &lt;code&gt;word1&lt;/code&gt; 和 &lt;code&gt;word2&lt;/code&gt; 几乎相等 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 266</title>
    <link href="http://yoursite.com/2021/11/07/342/"/>
    <id>http://yoursite.com/2021/11/07/342/</id>
    <published>2021-11-07T08:28:00.218Z</published>
    <updated>2021-11-09T15:47:16.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-266"><a href="#leetcode-contest-266" class="headerlink" title="leetcode contest 266"></a>leetcode contest 266</h1><p>今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.</p><h3 id="5918-统计字符串中的元音子字符串"><a href="#5918-统计字符串中的元音子字符串" class="headerlink" title="5918. 统计字符串中的元音子字符串"></a>5918. 统计字符串中的元音子字符串</h3><p>子字符串 是字符串中的一个连续（非空）的字符序列。</p><p>元音子字符串 是 仅 由元音<code>（&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39; 和 &#39;u&#39;）6</code>组成的一个子字符串，且必须包含 全部五种 元音。</p><a id="more"></a><p>给你一个字符串 word ，统计并返回 word 中 元音子字符串的数目 。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aeiouu"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：下面列出 <span class="built_in">word</span> 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">- <span class="string">"aeiouu"</span></span><br><span class="line">- <span class="string">"aeiouu"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"unicornarihan"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="built_in">word</span> 中不含 <span class="number">5</span> 种元音，所以也不会存在元音子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：word = "cuaieuouac"</span><br><span class="line">输出：7</span><br><span class="line">解释：下面列出 word 中的元音子字符串（斜体加粗部分）：</span><br><span class="line">-<span class="ruby"> <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br><span class="line"><span class="ruby">- <span class="string">"cuaieuouac"</span></span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">word</span> = <span class="string">"bbaeixoubb"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有包含全部五种元音的子字符串都含有辅音，所以不存在元音子字符串。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= <span class="keyword">word</span>.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="keyword">word</span>` 仅由小写英文字母组成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/count-vowel-substrings-of-a-string/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  枚举</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 枚举每个子字符串，检测每个字符串是否满足元音要求。</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度: $O(N^<span class="number">3</span>)$,其中 $N$ 为字符串的长度。</span><br><span class="line">+ 空间复杂度: $O(<span class="number">1</span>)$。</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> countVowelSubstrings(<span class="keyword">string</span> <span class="keyword">word</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="keyword">word</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="keyword">char</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">int</span> j = i + <span class="number">4</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">bool</span> <span class="built_in">isValid</span> = true;</span><br><span class="line">                unordered_set&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">                <span class="built_in">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                    <span class="built_in">if</span>(!cnt.count(<span class="keyword">word</span>[k]))&#123;</span><br><span class="line">                        <span class="built_in">isValid</span> = false;</span><br><span class="line">                        <span class="built_in">break</span>;</span><br><span class="line">                    &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">                        curr.insert(<span class="keyword">word</span>[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">if</span>(<span class="built_in">isValid</span> &amp;&amp; curr.<span class="built_in">size</span>() == <span class="number">5</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5919-所有子字符串中的元音"><a href="#5919-所有子字符串中的元音" class="headerlink" title="5919. 所有子字符串中的元音"></a>5919. 所有子字符串中的元音</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>word</code> ，返回 <code>word</code> 的所有子字符串中 元音的总数 ，元音是指 <code>&#39;a&#39;、&#39;e&#39;、&#39;i&#39;、&#39;o&#39;</code> 和 <code>&#39;u&#39;</code> 。</p><p>子字符串 是字符串中一个连续（非空）的字符序列。</p><p>注意：由于对 <code>word</code> 长度的限制比较宽松，答案可能超过有符号 <code>32</code> 位整数的范围。计算时需当心。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"aba"</span>、<span class="string">"b"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 。</span><br><span class="line">- <span class="string">"b"</span> 中有 <span class="number">0</span> 个元音</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"ba"</span> 和 <span class="string">"a"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"aba"</span> 中有 <span class="number">2</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">0</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">2</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">所有子字符串是：<span class="string">"a"</span>、<span class="string">"ab"</span>、<span class="string">"abc"</span>、<span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 。</span><br><span class="line">- <span class="string">"a"</span>、<span class="string">"ab"</span> 和 <span class="string">"abc"</span> 每个都有 <span class="number">1</span> 个元音</span><br><span class="line">- <span class="string">"b"</span>、<span class="string">"bc"</span> 和 <span class="string">"c"</span> 每个都有 <span class="number">0</span> 个元音</span><br><span class="line">因此，元音总数 = <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">0</span> + <span class="number">0</span> + <span class="number">0</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"ltcd"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"ltcd"</span> 的子字符串均不含元音。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"noosabasboosa"</span></span><br><span class="line">输出：<span class="number">237</span></span><br><span class="line">解释：所有子字符串中共有 <span class="number">237</span> 个元音。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= word.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `word` 由小写英文字母组成</span><br><span class="line"></span><br><span class="line"><span class="comment">### 地址</span></span><br><span class="line"><span class="symbol">https:</span>/<span class="regexp">/leetcode-cn.com/contest</span><span class="regexp">/weekly-contest-266/problems</span><span class="regexp">/vowels-of-all-substrings/</span></span><br><span class="line"><span class="comment">### 题意</span></span><br><span class="line">&gt;  DP</span><br><span class="line"><span class="comment">### 思路</span></span><br><span class="line"><span class="number">1</span>. 题目为一个比较简单的动态规划,我们设 <span class="variable">$dp</span>[i]<span class="variable">$ </span>表示以字符串中第 <span class="variable">$i</span><span class="variable">$ </span>个元素为结尾的连续子字符串包含的元音字母. 则我们可以知道分为以下两种情况<span class="symbol">:</span></span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为非元音字母: 则我们知道以第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个字母为结尾的字符中包含的原因字符刚好等于 <span class="variable">$dp</span>[i]<span class="variable">$,</span> 则此时可以知道 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i].</span><br><span class="line">+ 如果第 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个子母为元音字母: 则我们知道以 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>为结尾的字符串有 <span class="variable">$i</span>+<span class="number">1</span><span class="variable">$ </span>个, 同时包含之前以 <span class="variable">$i</span><span class="variable">$ </span>为结尾的子字符串中的元音字母, 因此 <span class="variable">$dp</span>[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span><span class="variable">$.</span></span><br><span class="line">总的子字符串中包含的元音字母的个数为 <span class="variable">$sum</span> = \sum<span class="number">_</span>&#123;i=<span class="number">0</span>&#125;^&#123;n-<span class="number">1</span>&#125;dp[i]<span class="variable">$.</span></span><br><span class="line"><span class="number">2</span>. 复杂度分析<span class="symbol">:</span></span><br><span class="line">+ 时间复杂度分析: 时间复杂度为 <span class="variable">$O</span>(N)<span class="variable">$.</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度.</span><br><span class="line">+ 空间复杂度分析: 空间复杂度为<span class="variable">$O</span>(N)<span class="variable">$,</span> 其中 <span class="variable">$N</span><span class="variable">$ </span>为字符串的长度．</span><br><span class="line"></span><br><span class="line"><span class="comment">### 代码</span></span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    long long countVowels(string word) &#123;</span><br><span class="line">        int n = word.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;long long&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        int curr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        unordered_set&lt;char&gt; cnt;</span><br><span class="line">        cnt.insert(<span class="string">'a'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'e'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'i'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'o'</span>);</span><br><span class="line">        cnt.insert(<span class="string">'u'</span>);</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            if(cnt.count(word[i]))&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i] + i + <span class="number">1</span>;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>] = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5920-分配给商店的最多商品的最小值"><a href="#5920-分配给商店的最多商品的最小值" class="headerlink" title="5920. 分配给商店的最多商品的最小值"></a>5920. 分配给商店的最多商品的最小值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 间零售商店。总共有 <code>m</code> 种产品，每种产品的数目用一个下标从 <code>0</code> 开始的整数数组 <code>quantities</code> 表示，其中 <code>quantities[i]</code> 表示第 <code>i</code> 种商品的数目。</p><p>你需要将 所有商品 分配到零售商店，并遵守这些规则：</p><ul><li>一间商店 至多 只能有 一种商品 ，但一间商店拥有的商品数目可以为 任意 件。</li><li>分配后，每间商店都会被分配一定数目的商品（可能为 <code>0</code> 件）。用 <code>x</code> 表示所有商店中+ 分配商品数目的最大值，你希望 <code>x</code> 越小越好。也就是说，你想 最小化 分配给任意商店商品数目的最大值 。<br>请你返回最小的可能的 <code>x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, quantities = [<span class="number">11</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： 一种最优方案为：</span><br><span class="line">- <span class="number">11</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">4</span> 间商店，分配数目分别为：<span class="number">2</span>，<span class="number">3</span>，<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">- <span class="number">6</span> 件种类为 <span class="number">1</span> 的商品被分配到另外 <span class="number">2</span> 间商店，分配数目分别为：<span class="number">3</span>，<span class="number">3</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>) = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, quantities = [<span class="number">15</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一种最优方案为：</span><br><span class="line">- <span class="number">15</span> 件种类为 <span class="number">0</span> 的商品被分配到前 <span class="number">3</span> 间商店，分配数目为：<span class="number">5</span>，<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">1</span> 的商品被分配到接下来 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">- <span class="number">10</span> 件种类为 <span class="number">2</span> 的商品被分配到最后 <span class="number">2</span> 间商店，数目为：<span class="number">5</span>，<span class="number">5</span> 。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>) = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, quantities = [<span class="number">100000</span>]</span><br><span class="line">输出：<span class="number">100000</span></span><br><span class="line">解释：唯一一种最优方案为：</span><br><span class="line">- 所有 <span class="number">100000</span> 件商品 <span class="number">0</span> 都分配到唯一的商店中。</span><br><span class="line">分配给所有商店的最大商品数目为 max(<span class="number">100000</span>) = <span class="number">100000</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == quantities.length</code></li><li><code>1 &lt;= m &lt;= n &lt;= 105</code></li><li><code>1 &lt;= quantities[i] &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-convert-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>如果直接来做,肯定比麻烦. 因为题目中要求每个零售店最多只能持有一种商品, 我们知道对于最大上限的$x$, 对于第 $i$ 个商品总量为 $quantities[i]$,我们知道最少需要配备 $\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$ 个商店来分配该商品, 总共需要配备的商调的数目为 $\sum_{i=0}^{n-1}\lfloor \frac{quantities[i] + x - 1}{x} \rfloor$. 所以我们采用二分法测试 $x$,每次检测对于 $x$ 最少需要配备多少个商店来满足分配要求, 如果需要的商店的个数小于等于 $n$,则满足题目要求,否则我们需要增大 $x$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(M\log(\max(quantities)))$,其中 $M$ 为商品的个数, $MAX(quantities)$ 为商品的个数的最大值．</li><li>空间复杂度为 $O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities,<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : quantities)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr += (v + val - <span class="number">1</span>)/val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr &lt;= n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimizedMaximum</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quantities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = quantities.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = *max_element(quantities.begin(),quantities.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(n,quantities,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5921-最大化一张图中的路径价值"><a href="#5921-最大化一张图中的路径价值" class="headerlink" title="5921. 最大化一张图中的路径价值"></a>5921. 最大化一张图中的路径价值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一张 无向 图，图中有 <code>n</code> 个节点，节点编号从 <code>0</code> 到 <code>n - 1</code> （都包括）。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>values</code> ，其中 <code>values[i]</code> 是第 <code>i</code> 个节点的 价值 。同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>edges</code> ，其中 <code>edges[j] = [uj, vj, timej]</code> 表示节点 <code>uj</code> 和 <code>vj</code> 之间有一条需要 <code>timej</code> 秒才能通过的无向边。最后，给你一个整数 <code>maxTime</code> 。</p><p>合法路径 指的是图中任意一条从节点 <code>0</code> 开始，最终回到节点<code>0</code>，且花费的总时间 不超过<code>maxTime</code> 秒的一条路径。你可以访问一个节点任意次。一条合法路径的 价值 定义为路径中 不同节点 的价值 之和 （每个节点的价值 至多 算入价值总和中一次）。</p><p>请你返回一条合法路径的 最大 价值。</p><p>注意：每个节点 至多 有 四条 边与之相连。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">32</span>,<span class="number">10</span>,<span class="number">43</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">49</span></span><br><span class="line">输出：<span class="number">75</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> + <span class="number">10</span> = <span class="number">40</span> &lt;= <span class="number">49</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">0</span> + <span class="number">32</span> + <span class="number">43</span> = <span class="number">75</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">10</span>]], maxTime = <span class="number">30</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">10</span> = <span class="number">20</span> &lt;= <span class="number">30</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">5</span> + <span class="number">20</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">13</span>]], maxTime = <span class="number">50</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：</span><br><span class="line">一条可能的路径为：<span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">3</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> 。总花费时间为 <span class="number">10</span> + <span class="number">13</span> + <span class="number">13</span> + <span class="number">10</span> = <span class="number">46</span> &lt;= <span class="number">50</span> 。</span><br><span class="line">访问过的节点为 <span class="number">0</span> ，<span class="number">1</span> 和 <span class="number">3</span> ，最大路径价值为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], edges = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>]], maxTime = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">唯一一条路径为 <span class="number">0</span> 。总花费时间为 <span class="number">0</span> 。</span><br><span class="line">唯一访问过的节点为 <span class="number">0</span> ，最大路径价值为 <span class="number">0</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == values.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= values[i] &lt;= <span class="number">108</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= edges.length &lt;= <span class="number">2000</span>`</span><br><span class="line">+ `edges[j].length == <span class="number">3</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= uj &lt; vj &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ `<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`</span><br><span class="line">+ `[uj, vj]` 所有节点对 互不相同 。</span><br><span class="line">+ 每个节点至多有四条 边。</span><br><span class="line">+ 图可能不连通。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-266/problems/maximum-path-quality-of-a-graph/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  BFS+减枝或者DFS</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 题目中关键的提示在于`<span class="number">10</span> &lt;= timej, maxTime &lt;= <span class="number">100</span>`,这就意味着最大路径的节点最多不会超过 $<span class="number">10</span>$ 步,每个节点最多有 $<span class="number">4</span>$ 条边,实际意味着最多可能的路径选择空间在 $<span class="number">4</span>^<span class="number">10</span>$ 以内,因此这个数量级就决定了我们可以用暴力的 $DFS$ 或者 $BFS$ 来进行搜索,找到符合要求的最大路径即可.</span><br><span class="line"><span class="number">2.</span> 稍微麻烦的是需要涉及到减枝的优化：</span><br><span class="line">+ 对路径上每个节点进行标记,如果已经访问过的,则计算价值时不再做计算.</span><br><span class="line">+ 可以记录在某个节点在某个时间内到达时的最大价值,如果当前的价值小于该值则直接返回.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: $O(D^&#123;\frac&#123;maxt&#125;&#123;t&#125;&#125;)$, 其中 $D$ 为节点的最大度数.</span><br><span class="line">+ 空间复杂度分析: $O(V+E)$,其中 $V$ 为节点的个数, $E$ 为边的数目.</span><br><span class="line">### 代码</span><br><span class="line">+ `BFS`</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line">struct Node&#123;</span><br><span class="line">    <span class="built_in">int</span> x;</span><br><span class="line">    <span class="built_in">int</span> cost;</span><br><span class="line">    <span class="built_in">int</span> val;</span><br><span class="line">    unordered_set&lt;<span class="built_in">int</span>&gt; visit;</span><br><span class="line">    Node(<span class="built_in">int</span> x,<span class="built_in">int</span> cost,<span class="built_in">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maximalPathQuality(vector&lt;<span class="built_in">int</span>&gt;&amp; values, vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; edges, <span class="built_in">int</span> maxTime) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = values.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;pii&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(n,vector&lt;long long&gt;(maxTime + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        queue&lt;Node&gt; qu;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = values[<span class="number">0</span>];</span><br><span class="line">        Node node(<span class="number">0</span>,<span class="number">0</span>,values[<span class="number">0</span>]);</span><br><span class="line">        node.visit.insert(<span class="number">0</span>);</span><br><span class="line">        qu.push(node);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">auto</span> [x, time] : graph[curr.x])&#123;</span><br><span class="line">                <span class="built_in">int</span> cost = curr.cost + time;</span><br><span class="line">                <span class="keyword">if</span>(cost &gt; maxTime) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">int</span> val = curr.val;</span><br><span class="line">                <span class="keyword">if</span>(!curr.visit.count(x))&#123;</span><br><span class="line">                    val += values[x];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[x][cost] &lt;= val)&#123;</span><br><span class="line">                    dp[x][cost] = val;</span><br><span class="line">                    Node nx(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                    nx.x = x;</span><br><span class="line">                    nx.cost = cost;</span><br><span class="line">                    nx.val = val;</span><br><span class="line">                    nx.visit = curr.visit;</span><br><span class="line">                    nx.visit.insert(x);</span><br><span class="line">                    qu.push(nx);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><ul><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; graph;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> curTime, <span class="keyword">int</span> curValue, <span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curTime &gt; maxTime) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start == <span class="number">0</span>) &#123; <span class="comment">/* 回到起点, 更新最大值 */</span></span><br><span class="line">            ans = fmax(ans, curValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [v, w] : graph[start]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123; <span class="comment">/* 目标节点没有访问过 */</span></span><br><span class="line">                visited[v] = <span class="number">1</span>;</span><br><span class="line">                dfs(v, curTime + w, curValue + values[v], maxTime, values);</span><br><span class="line">                visited[v] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">/* 目标节点已经访问过 */</span></span><br><span class="line">                dfs(v, curTime + w, curValue, maxTime, values);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalPathQuality</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> maxTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = values.size();</span><br><span class="line">        graph = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;(n);</span><br><span class="line">        visited = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">int</span> curTime  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curValue = <span class="number">0</span>;</span><br><span class="line">        ans = values[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : edges) &#123; <span class="comment">/* 建立连接表 */</span></span><br><span class="line">            graph[e[<span class="number">0</span>]].emplace_back(e[<span class="number">1</span>], e[<span class="number">2</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].emplace_back(e[<span class="number">0</span>], e[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, curTime, curValue, maxTime, values);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-266&quot;&gt;&lt;a href=&quot;#leetcode-contest-266&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 266&quot;&gt;&lt;/a&gt;leetcode contest 266&lt;/h1&gt;&lt;p&gt;今天周赛的题目比较简单，前三题基本上没有什么难度的题目，最后一题做法上想的太复杂了点，最后用一个简单的$BFS$ 搞定.&lt;/p&gt;&lt;h3 id=&quot;5918-统计字符串中的元音子字符串&quot;&gt;&lt;a href=&quot;#5918-统计字符串中的元音子字符串&quot; class=&quot;headerlink&quot; title=&quot;5918. 统计字符串中的元音子字符串&quot;&gt;&lt;/a&gt;5918. 统计字符串中的元音子字符串&lt;/h3&gt;&lt;p&gt;子字符串 是字符串中的一个连续（非空）的字符序列。&lt;/p&gt;&lt;p&gt;元音子字符串 是 仅 由元音&lt;code&gt;（&amp;#39;a&amp;#39;、&amp;#39;e&amp;#39;、&amp;#39;i&amp;#39;、&amp;#39;o&amp;#39; 和 &amp;#39;u&amp;#39;）6&lt;/code&gt;组成的一个子字符串，且必须包含 全部五种 元音。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 265</title>
    <link href="http://yoursite.com/2021/10/31/341/"/>
    <id>http://yoursite.com/2021/10/31/341/</id>
    <published>2021-10-31T11:19:28.168Z</published>
    <updated>2021-11-07T08:28:18.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-265"><a href="#leetcode-contest-265" class="headerlink" title="leetcode contest 265"></a>leetcode contest 265</h1><p>题目质量还可以,还是三道题的节奏,最后一题质量真心很高, 确实是非常好的思考的题目. </p><h3 id="2057-值相等的最小索引"><a href="#2057-值相等的最小索引" class="headerlink" title="2057. 值相等的最小索引"></a>2057. 值相等的最小索引</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，返回 <code>nums</code> 中满足 <code>i mod 10 == nums[i]</code> 的最小下标 <code>i</code> ；如果不存在这样的下标，返回 <code>-1</code> 。<br><code>x mod y</code> 表示 <code>x</code> 除以 <code>y</code> 的 余数 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">0</span>: <span class="number">0</span> mod <span class="number">10</span> = <span class="number">0</span> == nums[<span class="number">0</span>].</span><br><span class="line">i=<span class="number">1</span>: <span class="number">1</span> mod <span class="number">10</span> = <span class="number">1</span> == nums[<span class="number">1</span>].</span><br><span class="line">i=<span class="number">2</span>: <span class="number">2</span> mod <span class="number">10</span> = <span class="number">2</span> == nums[<span class="number">2</span>].</span><br><span class="line">所有下标都满足 i mod <span class="number">10</span> == nums[i] ，所以返回最小下标 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">0</span>: <span class="number">0</span> mod <span class="number">10</span> = <span class="number">0</span> != nums[<span class="number">0</span>].</span><br><span class="line">i=<span class="number">1</span>: <span class="number">1</span> mod <span class="number">10</span> = <span class="number">1</span> != nums[<span class="number">1</span>].</span><br><span class="line">i=<span class="number">2</span>: <span class="number">2</span> mod <span class="number">10</span> = <span class="number">2</span> == nums[<span class="number">2</span>].</span><br><span class="line">i=<span class="number">3</span>: <span class="number">3</span> mod <span class="number">10</span> = <span class="number">3</span> != nums[<span class="number">3</span>].</span><br><span class="line"><span class="number">2</span> 唯一一个满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：不存在满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">1</span> 是唯一一个满足 i mod <span class="number">10</span> == nums[i] 的下标</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-index-with-equal-value" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-index-with-equal-value</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>枚举每个元素，找到第一个元素 $i$ 满足 $i \mod 10 == nums[i]$返回即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两遍即可。</li><li>空间复杂度: $O(1)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">10</span> == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2058-找出临界点之间的最小和最大距离"><a href="#2058-找出临界点之间的最小和最大距离" class="headerlink" title="2058. 找出临界点之间的最小和最大距离"></a>2058. 找出临界点之间的最小和最大距离</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>链表中的 临界点 定义为一个 局部极大值点 或 局部极小值点 。</p><ul><li><p>如果当前节点的值 严格大于 前一个节点和后一个节点，那么这个节点就是一个  局部极大值点 。</p></li><li><p>如果当前节点的值 严格小于 前一个节点和后一个节点，那么这个节点就是一个  局部极小值点 。</p></li><li><p>注意：节点只有在同时存在前一个节点和后一个节点的情况下，才能成为一个 局部极大值点 / 极小值点 。</p></li></ul><p>给你一个链表 <code>head</code> ，返回一个长度为 <code>2</code> 的数组 <code>[minDistance, maxDistance]</code> ，其中 <code>minDistance</code> 是任意两个不同临界点之间的最小距离，<code>maxDistance</code> 是任意两个不同临界点之间的最大距离。如果临界点少于两个，则返回 <code>[-1，-1]</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：链表 [<span class="number">3</span>,<span class="number">1</span>] 中不存在临界点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：存在三个临界点：</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第三个节点是一个局部极小值点，因为 <span class="number">1</span> 比 <span class="number">3</span> 和 <span class="number">2</span> 小。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第五个节点是一个局部极大值点，因为 <span class="number">5</span> 比 <span class="number">2</span> 和 <span class="number">1</span> 大。</span><br><span class="line">- [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]：第六个节点是一个局部极小值点，因为 <span class="number">1</span> 比 <span class="number">5</span> 和 <span class="number">2</span> 小。</span><br><span class="line">第五个节点和第六个节点之间距离最小。minDistance = <span class="number">6</span> - <span class="number">5</span> = <span class="number">1</span> 。</span><br><span class="line">第三个节点和第六个节点之间距离最大。maxDistance = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：存在两个临界点：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]：第二个节点是一个局部极大值点，因为 <span class="number">3</span> 比 <span class="number">1</span> 和 <span class="number">2</span> 大。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">7</span>]：第五个节点是一个局部极大值点，因为 <span class="number">3</span> 比 <span class="number">2</span> 和 <span class="number">2</span> 大。</span><br><span class="line">最小和最大距离都存在于第二个节点和第五个节点之间。</span><br><span class="line">因此，minDistance 和 maxDistance 是 <span class="number">5</span> - <span class="number">2</span> = <span class="number">3</span> 。</span><br><span class="line">注意，最后一个节点不算一个局部极大值点，因为它之后就没有节点了。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">解释：链表 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 中不存在临界点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中节点的数量在范围 <code>[2, 105]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较无聊, 感觉真心直接把链表转化成数组,什么问题都解决了, 这个题目可以说是个简单题.当然链表的操作确实复杂了一点,不过确实很无趣.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N)$. 其中 $N$ 为链表的长度.</li><li>空间复杂度分析: 空间复杂度为$O(n)$, 如果直接用链表操作空间复杂度可以做到 $O(1)$．</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodesBetweenCriticalPoints(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>,INT_MAX);</span><br><span class="line">        <span class="keyword">for</span>(ListNode * curr = head; curr != <span class="literal">nullptr</span>; curr = curr-&gt;next) &#123;</span><br><span class="line">            arr.push_back(curr-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; critical;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[i<span class="number">-1</span>] &amp;&amp; arr[i] &gt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                critical.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[i<span class="number">-1</span>] &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                critical.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; critical.size(); ++i) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = min(ans[<span class="number">0</span>],critical[i] - critical[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(critical.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[<span class="number">1</span>] = critical.back() - critical[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2059-转化数字的最小运算数"><a href="#2059-转化数字的最小运算数" class="headerlink" title="2059. 转化数字的最小运算数"></a>2059. 转化数字的最小运算数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，该数组由 互不相同 的数字组成。另给你两个整数 <code>start</code> 和 <code>goal</code> 。</p><p>整数 <code>x</code> 的值最开始设为 <code>start</code> ，你打算执行一些运算使 <code>x</code> 转化为 <code>goal</code> 。你可以对数字 <code>x</code> 重复执行下述运算：</p><p>如果 <code>0 &lt;= x &lt;= 1000</code> ，那么，对于数组中的任一下标 <code>i（0 &lt;= i &lt; nums.length）</code>，可以将 <code>x</code> 设为下述任一值：</p><ul><li><code>x + nums[i]</code></li><li><code>x - nums[i]</code></li><li><code>x ^ nums[i]</code>（按位异或 <code>XOR</code>）<br>注意，你可以按任意顺序使用每个 <code>nums[i]</code> 任意次。使 <code>x</code> 越过 <code>0 &lt;= x &lt;= 1000</code> 范围的运算同样可以生效，但该该运算执行后将不能执行其他运算。</li></ul><p>返回将 <code>x = start</code> 转化为 <code>goal</code> 的最小操作数；如果无法完成转化，则返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>], start = <span class="number">6</span>, goal = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">6</span> → <span class="number">7</span> → <span class="number">4</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">6</span> ^ <span class="number">1</span> = <span class="number">7</span></span><br><span class="line">- <span class="number">7</span> ^ <span class="number">3</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">12</span>], start = <span class="number">2</span>, goal = <span class="number">12</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">2</span> → <span class="number">14</span> → <span class="number">12</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">2</span> + <span class="number">12</span> = <span class="number">14</span></span><br><span class="line">- <span class="number">14</span> - <span class="number">2</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>], start = <span class="number">0</span>, goal = <span class="number">-4</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">0</span> → <span class="number">3</span> → <span class="number">-4</span> 的转化路径进行，只需执行下述 <span class="number">2</span> 次运算：</span><br><span class="line">- <span class="number">0</span> + <span class="number">3</span> = <span class="number">3</span></span><br><span class="line">- <span class="number">3</span> - <span class="number">7</span> = <span class="number">-4</span></span><br><span class="line">注意，最后一步运算使 x 超过范围 <span class="number">0</span> &lt;= x &lt;= <span class="number">1000</span> ，但该运算仍然可以生效。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">8</span>,<span class="number">16</span>], start = <span class="number">0</span>, goal = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">无法将 <span class="number">0</span> 转化为 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], start = <span class="number">0</span>, goal = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">可以按 <span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">3</span> 的转化路径进行，只需执行下述 <span class="number">3</span> 次运算：</span><br><span class="line">- <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span> </span><br><span class="line">- <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">- <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>-109 &lt;= nums[i], goal &lt;= 109</code></li><li><code>0 &lt;= start &lt;= 1000</code></li><li><code>start != goal</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-convert-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-convert-number</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>作完这个题目感觉很无语，想了半天感觉到貌似变换过程没啥规律，只能暴力搜索．首先我们设 $dp[x]$ 表示从 $start$ 转换到 $x$ 的最小操作步数且满足 $0 \le x \le 1000$, 我们根据题目给定的转换规则可以知道 $goal$ 分为以下两种情况:</li></ol><ul><li>我们知道如果 $0 \le goal \le 1000$, 则此时最小的转换步数为 $minStep = dp[goal]$； </li><li>我们知道如果 $ goal &gt; 1000$, 我们假设可以通过 $0 \le y \le 1000$ 再经过一步变换即可到大 $goal$, 则此时最小的转换步数为 $minStep = dp[y] + 1$；<br>如果不满足上述两种情况,则我们直接返回 $-1$.</li></ul><ol><li>我们可以很容易的利用 $BFS$ 来求得所有满足变换的最小步骤, 然后根据 $1$ 中的两个规则来求解即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N*1000)$,其中 $N$ 为数组的个数．</li><li>空间复杂度为 $O(C)$, 在此 $C = 1000$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(<span class="number">1001</span>,<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start == goal)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.push(start);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// add</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr + nums[j] &lt;= <span class="number">1000</span> &amp;&amp; curr + nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[curr + nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr + nums[j]] = step;</span><br><span class="line">                        qu.push(curr + nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(curr - nums[j] &lt;= <span class="number">1000</span> &amp;&amp; curr - nums[j] &gt;= <span class="number">0</span> &amp;&amp; dp[curr - nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr - nums[j]] = step;</span><br><span class="line">                        qu.push(curr - nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>((curr^nums[j]) &lt;= <span class="number">1000</span> &amp;&amp; (curr^nums[j]) &gt;= <span class="number">0</span> &amp;&amp; dp[curr^nums[j]] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[curr^nums[j]] = step;</span><br><span class="line">                        qu.push(curr^nums[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(goal &gt;= <span class="number">0</span> &amp;&amp; goal &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[goal];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i + nums[j] == goal || i - nums[j] == goal || (i^nums[j]) == goal)&#123;</span><br><span class="line">                        ans = min(ans,dp[i] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span>: ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2060-同源字符串检测"><a href="#2060-同源字符串检测" class="headerlink" title="2060. 同源字符串检测"></a>2060. 同源字符串检测</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>原字符串由小写字母组成，可以按下述步骤编码：</p><ul><li>任意将其 分割 为由若干 非空 子字符串组成的一个 序列 。</li><li>任意选择序列中的一些元素（也可能不选择），然后将这些元素替换为元素各自的长度（作为一个数字型的字符串）。</li><li>重新 顺次连接 序列，得到编码后的字符串。<br>例如，编码 <code>&quot;abcdefghijklmnop&quot;</code> 的一种方法可以描述为：</li></ul><p>将原字符串分割得到一个序列：[<code>&quot;ab&quot;</code>, <code>&quot;cdefghijklmn&quot;</code>, <code>&quot;o&quot;</code>, <code>&quot;p&quot;</code>] 。<br>选出其中第二个和第三个元素并分别替换为它们自身的长度。序列变为 <code>[&quot;ab&quot;, &quot;12&quot;, &quot;1&quot;, &quot;p&quot;]</code>。<br>重新顺次连接序列中的元素，得到编码后的字符串：<code>&quot;ab121p&quot;</code>。<br>给你两个编码后的字符串 <code>s1</code> 和 <code>s2</code> ，由小写英文字母和数字 1-9 组成。如果存在能够同时编码得到 <code>s1</code> 和 <code>s2</code> 原字符串，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>注意：生成的测试用例满足 <code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code> 。</p><p>示例 1：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"internationalization"</span>, s2 = <span class="string">"i18n"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"internationalization"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"internationalization"</span> </span><br><span class="line">  -&gt; 分割：      [<span class="string">"internationalization"</span>]</span><br><span class="line">  -&gt; 不替换任何元素</span><br><span class="line">  -&gt; 连接：      <span class="string">"internationalization"</span>，得到 s1</span><br><span class="line">- <span class="string">"internationalization"</span></span><br><span class="line">  -&gt; 分割：      [<span class="string">"i"</span>, <span class="string">"nternationalizatio"</span>, <span class="string">"n"</span>]</span><br><span class="line">  -&gt; 替换：      [<span class="string">"i"</span>, <span class="string">"18"</span>,                 <span class="string">"n"</span>]</span><br><span class="line">  -&gt; 连接：      <span class="string">"i18n"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"l123e"</span>, s2 = <span class="string">"44"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"leetcode"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"leetcode"</span> </span><br><span class="line">  -&gt; 分割：       [<span class="string">"l"</span>, <span class="string">"e"</span>, <span class="string">"et"</span>, <span class="string">"cod"</span>, <span class="string">"e"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"l"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>,  <span class="string">"3"</span>,   <span class="string">"e"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"l123e"</span>，得到 s1</span><br><span class="line">- <span class="string">"leetcode"</span> </span><br><span class="line">  -&gt; 分割：       [<span class="string">"leet"</span>, <span class="string">"code"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"4"</span>,    <span class="string">"4"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"44"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"a5b"</span>, <span class="built_in">s2</span> = <span class="string">"c5b"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：不存在这样的原字符串</span><br><span class="line">- 编码为 <span class="built_in">s1</span> 的字符串必须以字母 <span class="string">'a'</span> 开头</span><br><span class="line">- 编码为 <span class="built_in">s2</span> 的字符串必须以字母 <span class="string">'c'</span> 开头</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"112s"</span>, s2 = <span class="string">"g841"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：<span class="string">"gaaaaaaaaaaaas"</span> 可以作为原字符串</span><br><span class="line">- <span class="string">"gaaaaaaaaaaaas"</span></span><br><span class="line">  -&gt; 分割：       [<span class="string">"g"</span>, <span class="string">"aaaaaaaaaaaa"</span>, <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"1"</span>, <span class="string">"12"</span>,           <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 连接：       <span class="string">"112s"</span>，得到 s1</span><br><span class="line">- <span class="string">"gaaaaaaaaaaaas"</span></span><br><span class="line">  -&gt; 分割：       [<span class="string">"g"</span>, <span class="string">"aaaaaaaa"</span>, <span class="string">"aaaa"</span>, <span class="string">"s"</span>]</span><br><span class="line">  -&gt; 替换：       [<span class="string">"g"</span>, <span class="string">"8"</span>,        <span class="string">"4"</span>,    <span class="string">"1"</span>]</span><br><span class="line">  -&gt; 连接         <span class="string">"g841"</span>，得到 s2</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"ab"</span>, <span class="built_in">s2</span> = <span class="string">"a2"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：不存在这样的原字符串</span><br><span class="line">- 编码为 <span class="built_in">s1</span> 的字符串由两个字母组成</span><br><span class="line">- 编码为 <span class="built_in">s2</span> 的字符串由三个字母组成</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s1.length, s2.length &lt;= 40</code></li><li><code>s1</code> 和 <code>s2</code> 仅由数字 <code>1-9</code> 和小写英文字母组成</li><li><code>s1</code> 和 <code>s2</code> 中连续数字数不超过 <code>3</code><br>。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS　或者 dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉算是比较难的题目,非常有难度的思考的题目,非常喜欢这类的动态规划思考的题目, 自我感觉非常喜欢这类思考的题目．这个<a href="https://leetcode-cn.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/solution/dong-tai-gui-hua-ji-lu-ke-neng-de-chang-o87gp/" target="_blank" rel="noopener">题解</a>写的很好,代码也写的非常优雅,确实是非常好的解法. 后面为优化后的记忆化搜索 $DFS$.</li><li>设 $dp[i][j]$ 表示前 $s1$的前 $i$ 个字符与 $s2$ 的前 $j$ 个字符匹配后的二者可能的长度的差值, 我们设 $ d = dp[i][j]$.</li></ol><ul><li>如果当下一个匹配的是数字,则我们尽可能的匹配数字;</li><li>如果当前匹配的为字符,则我们尽可能的调整去匹配字符与差值;</li><li>中间涉及到贪心算法,如果当前匹配的差值大于 $0$, 则此时我们应该增加 $s2$ 的字符来减小差值; 如果当前匹配的差值小于 $0$, 则此时我们应该增加 $s1$ 的字符来加大差值.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(nC^{n})$, 其中 $C$ 为某个常数, $n$ 为棋子的个数.</li><li>空间复杂度分析: $O(nC)$,其中 $C$ 为某个常数, $n$ 为棋子的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possiblyEquals</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size();</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(m + <span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;(n + <span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>].emplace(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> d : dp[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; min(m,i+<span class="number">3</span>); ++k)&#123;</span><br><span class="line">                        num = num*<span class="number">10</span> + s1[k] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isDigit(s1[k]))&#123;</span><br><span class="line">                            dp[k+<span class="number">1</span>][j].emplace(d + num);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; min(n,j+<span class="number">3</span>); ++k) &#123;</span><br><span class="line">                        num = num*<span class="number">10</span> + s2[k] - <span class="string">'0'</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isDigit(s2[k]))&#123;</span><br><span class="line">                            dp[i][k+<span class="number">1</span>].emplace(d - num);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; m &amp;&amp; d &lt; <span class="number">0</span> &amp;&amp; isAlpha(s1[i])) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j].emplace(d + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j &lt; n &amp;&amp; d &gt; <span class="number">0</span> &amp;&amp; isAlpha(s2[j])) &#123;</span><br><span class="line">                        dp[i][j+<span class="number">1</span>].emplace(d - <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt; m &amp;&amp; j &lt; n &amp;&amp; d == <span class="number">0</span> &amp;&amp; s1[i] == s2[j]) &#123;</span><br><span class="line">                        dp[i+<span class="number">1</span>][j+<span class="number">1</span>].emplace(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n].count(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; s1, <span class="built_in">string</span> &amp; s2,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[make_pair(l1,l2)].count(res))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 == s1.size() &amp;&amp; l2 == s2.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[make_pair(l1,l2)].emplace(res);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[make_pair(l1,l2)].emplace(res);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l1; i &lt; s1.size() &amp;&amp; i &lt; l1 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(s1[i]))&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s1[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s1,s2,i + <span class="number">1</span>,l2,res + num))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l2; i &lt; s2.size() &amp;&amp; i &lt; l2 + <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isDigit(s2[i]))&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + s2[i] - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">if</span>(dfs(s1,s2,l1,i + <span class="number">1</span>,res - num))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; s1.size() &amp;&amp; res &lt; <span class="number">0</span> &amp;&amp; isAlpha(s1[l1]))&#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1 + <span class="number">1</span>,l2, res + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 &lt; s2.size() &amp;&amp; res &gt; <span class="number">0</span> &amp;&amp; isAlpha(s2[l2])) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1, l2 + <span class="number">1</span>, res - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1 &lt; s1.size() &amp;&amp; l2 &lt; s2.size() &amp;&amp; res == <span class="number">0</span> &amp;&amp; s1[l1] == s2[l2]) &#123;</span><br><span class="line">            <span class="keyword">return</span> dfs(s1, s2, l1 + <span class="number">1</span>, l2 + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possiblyEquals</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s1.size();</span><br><span class="line">        <span class="keyword">int</span> n = s2.size();</span><br><span class="line">        <span class="keyword">return</span> dfs(s1,s2,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-265&quot;&gt;&lt;a href=&quot;#leetcode-contest-265&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 265&quot;&gt;&lt;/a&gt;leetcode contest 265&lt;/h1&gt;&lt;p&gt;题目质量还可以,还是三道题的节奏,最后一题质量真心很高, 确实是非常好的思考的题目. &lt;/p&gt;&lt;h3 id=&quot;2057-值相等的最小索引&quot;&gt;&lt;a href=&quot;#2057-值相等的最小索引&quot; class=&quot;headerlink&quot; title=&quot;2057. 值相等的最小索引&quot;&gt;&lt;/a&gt;2057. 值相等的最小索引&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，返回 &lt;code&gt;nums&lt;/code&gt; 中满足 &lt;code&gt;i mod 10 == nums[i]&lt;/code&gt; 的最小下标 &lt;code&gt;i&lt;/code&gt; ；如果不存在这样的下标，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;br&gt;&lt;code&gt;x mod y&lt;/code&gt; 表示 &lt;code&gt;x&lt;/code&gt; 除以 &lt;code&gt;y&lt;/code&gt; 的 余数 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest Biweekly 64</title>
    <link href="http://yoursite.com/2021/10/31/340/"/>
    <id>http://yoursite.com/2021/10/31/340/</id>
    <published>2021-10-31T11:19:22.290Z</published>
    <updated>2021-11-02T15:04:30.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-biweekly-64"><a href="#leetcode-contest-biweekly-64" class="headerlink" title="leetcode contest biweekly 64"></a>leetcode contest biweekly 64</h1><p>题目质量还可以,还是三道题的节奏,最后一题确实不会做．</p><h3 id="5898-数组中第-K-个独一无二的字符串"><a href="#5898-数组中第-K-个独一无二的字符串" class="headerlink" title="5898. 数组中第 K 个独一无二的字符串"></a>5898. 数组中第 K 个独一无二的字符串</h3><p>独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。</p><p>给你一个字符串数组 <code>arr</code> 和一个整数 <code>k</code> ，请你返回 <code>arr</code>中第 <code>k</code> 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 “” 。</p><a id="more"></a><p>注意，按照字符串在原数组中的 顺序 找到第 k 个独一无二字符串。</p><p>示例 1:<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="comment">"d"</span>,<span class="comment">"b"</span>,<span class="comment">"c"</span>,<span class="comment">"b"</span>,<span class="comment">"c"</span>,<span class="comment">"a"</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="comment">"a"</span></span><br><span class="line">解释：</span><br><span class="line">arr 中独一无二字符串包括 <span class="comment">"d"</span> 和 <span class="comment">"a"</span> 。</span><br><span class="line"><span class="comment">"d"</span> 首先出现，所以它是第 <span class="number">1</span> 个独一无二字符串。</span><br><span class="line"><span class="comment">"a"</span> 第二个出现，所以它是 <span class="number">2</span> 个独一无二字符串。</span><br><span class="line">由于 k == <span class="number">2</span> ，返回 <span class="comment">"a"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="string">"aaa"</span>,<span class="string">"aa"</span>,<span class="string">"a"</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"aaa"</span></span><br><span class="line">解释：</span><br><span class="line">arr 中所有字符串都是独一无二的，所以返回第 <span class="number">1</span> 个字符串 <span class="string">"aaa"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：</span><br><span class="line">唯一一个独一无二字符串是 <span class="string">"b"</span> 。由于少于 <span class="number">3</span> 个独一无二字符串，我们返回空字符串 <span class="string">""</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i].length &lt;= 5</code></li><li><code>arr[i]</code> 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-distinct-string-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-distinct-string-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>哈希统计字符的次数，然后依次遍历字符串找到第 $k$ 只出现一次的字符;</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历两遍即可。</li><li>空间复杂度: $O(C)$,其中 $C$ 为字符串的个数,在这里为 $26$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">kthDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                k--;</span><br><span class="line">                <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5899-两个最好的不重叠活动"><a href="#5899-两个最好的不重叠活动" class="headerlink" title="5899. 两个最好的不重叠活动"></a>5899. 两个最好的不重叠活动</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>events</code> ，其中 <code>events[i] = [startTimei, endTimei, valuei]</code> 。第 <code>i</code> 个活动开始于 <code>startTimei</code> ，结束于 <code>endTimei</code> ，如果你参加这个活动，那么你可以得到价值 <code>valuei</code> 。你 最多 可以参加 两个时间不重叠 活动，使得它们的价值之和 最大 。</p><p>请你返回价值之和的 最大值 。注意，活动的开始时间和结束时间是 包括 在活动时间内的，也就是说，你不能参加两个活动且它们之一的开始时间等于另一个活动的结束时间。更具体的，如果你参加一个活动，且结束时间为<code>t</code> ，那么下一个活动必须在 <code>t + 1</code> 或之后的时间开始。</p><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：选择绿色的活动 <span class="number">0</span> 和 <span class="number">1</span> ，价值之和为 <span class="number">2</span> + <span class="number">2</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：选择活动 <span class="number">2</span> ，价值和为 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：events = [[<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：选择活动 <span class="number">0</span> 和 <span class="number">2</span> ，价值之和为 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= events.length &lt;= 105</code></li><li><code>events[i].length == 3</code></li><li><code>1 &lt;= startTimei &lt;= endTimei &lt;= 109</code></li><li><code>1 &lt;= valuei &lt;= 106</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-best-non-overlapping-events" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-best-non-overlapping-events</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 枚举 +　二分差值</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们首先按照会议的开始时间进行排序，然后我们枚举每个会议 $i$, 其中会议 $i$ 的起始时间为 $start_{i}$, 结束时间为 $end_{i}$, 我们找到会议起始时间大于等于 $end_{i}$ 且价值最大的会议 $j$, 我们可以知道价值最大的等于：<script type="math/tex; mode=display">maxVal = \max(value_{i}, value_{i} + value_{j}) \qquad (i \in [0,n-1], end_{i} \leq start_{j})</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N\log{N})$. 其中 $N$ 为数组的长度, 我们每次枚举, 然后利用二分差值,找到会议起始时间大于等于当前会议的结束时间的最大值.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTwoEvents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; events)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = events.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; events.size(); ++i)&#123;</span><br><span class="line">            events[i][<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(events.begin(),events.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr[i] = events[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            suffix[i] = max(events[i][<span class="number">2</span>], suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = events[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr.begin(),arr.end(),events[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(it != arr.end())&#123;</span><br><span class="line">                curr += suffix[it-arr.begin()];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,curr);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5900-蜡烛之间的盘子"><a href="#5900-蜡烛之间的盘子" class="headerlink" title="5900. 蜡烛之间的盘子"></a>5900. 蜡烛之间的盘子</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 <code>0</code> 开始的字符串 <code>s</code> ，它只包含字符 <code>&#39;*&#39;</code> 和 <code>&#39;|&#39;</code> ，其中 <code>&#39;*&#39;</code> 表示一个 盘子 ，’|’ 表示一支 蜡烛 。</p><p>同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [lefti, righti]</code> 表示 子字符串 <code>s[lefti...righti]</code> （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。</p><p>比方说，<code>s = &quot;||**||**|*&quot;</code> ，查询 <code>[3, 8]</code>，表示的是子字符串 <code>&quot;*||**|&quot;</code> 。子字符串中在两支蜡烛之间的盘子数目为 <code>2</code> ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。<br>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例 1:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"**|**|***|"</span>, queries = [[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>] 有两个盘子在蜡烛之间。</span><br><span class="line">- queries[<span class="number">1</span>] 有三个盘子在蜡烛之间。</span><br></pre></td></tr></table></figure><br>示例 2:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"***|**|*****|**||**|*"</span>, queries = [[<span class="number">1</span>,<span class="number">17</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">14</span>,<span class="number">17</span>],[<span class="number">5</span>,<span class="number">11</span>],[<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">- queries[<span class="number">0</span>] 有 <span class="number">9</span> 个盘子在蜡烛之间。</span><br><span class="line">- 另一个查询没有盘子在蜡烛之间。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code> 只包含字符<code>&#39;*&#39;</code>和 <code>&#39;|&#39;</code> 。</li><li><code>1 &lt;= queries.length &lt;= 105</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= lefti &lt;= righti &lt; s.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/plates-between-candles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plates-between-candles</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和或者二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>对于每个查询 $[l,r]$,我们只需要找到最小的索引 $j$ 满足 $j \ge l$ 且 $s[i] = \texttt{‘|’}$, 我们只需要找到最大的索引 $k$ 满足 $k \le r$ 且 $s[k] = \texttt{‘|’}$, 类似的我们可以利用前缀或者后缀,或者二分查找的方法快速找到索引 $j,k$, 然后我们可以利用前缀和,快速的求出 $[j,k]$ 之间的 $\texttt{‘*’}$ 的个数即可.我们需要提前预处理数组即可,$left[i]$ 记录左侧距离索引 $i$ 最近的 $\texttt{‘|’}$ 的位置,$right[i]$ 记录右侧侧距离索引 $i$ 最近的 $\texttt{‘|’}$ 的位置.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N + M)$,其中 $N$ 为数组的个数，$M$ 为查询的次数,我们需要提前与</li><li>空间复杂度为 $O(2N)$,其中 $N$ 为节点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li>前缀后缀<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; platesBetweenCandles(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (s[<span class="number">0</span>] == <span class="string">'|'</span> ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                left[i] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right[n<span class="number">-1</span>] = (s[n<span class="number">-1</span>] == <span class="string">'|'</span> ? <span class="number">0</span> : <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                right[i] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                sum[i+<span class="number">1</span>] = sum[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum[i+<span class="number">1</span>] = sum[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right[v[<span class="number">0</span>]] &lt; left[v[<span class="number">1</span>]])&#123;</span><br><span class="line">                ans.push_back(sum[left[v[<span class="number">1</span>]] + <span class="number">1</span>] - sum[right[v[<span class="number">0</span>]]]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; platesBetweenCandles(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> n = queries.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                arr1.push_back(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr2.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = v[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> r = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it1 = lower_bound(arr2.begin(),arr2.end(),l);</span><br><span class="line">            <span class="keyword">if</span>(it1 == arr2.end())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l = arr2[it1-arr2.begin()];</span><br><span class="line">            <span class="keyword">auto</span> it2 = lower_bound(arr2.begin(),arr2.end(),r+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(it2 == arr2.begin())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it2--;</span><br><span class="line">            r = arr2[it2-arr2.begin()];</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it3 = lower_bound(arr1.begin(),arr1.end(),l);</span><br><span class="line">            <span class="keyword">if</span>(it3 == arr1.end())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it4 = lower_bound(arr1.begin(),arr1.end(),r);</span><br><span class="line">            <span class="keyword">if</span>(it4 == arr1.begin())&#123;</span><br><span class="line">                ans.push_back(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(it4-it3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5901-棋盘上有效移动组合的数目"><a href="#5901-棋盘上有效移动组合的数目" class="headerlink" title="5901. 棋盘上有效移动组合的数目"></a>5901. 棋盘上有效移动组合的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一个 <code>8 x 8</code> 的棋盘，它包含 <code>n</code> 个棋子（棋子包括车，后和象三种）。给你一个长度为 <code>n</code> 的字符串数组 <code>pieces</code> ，其中 <code>pieces[i]</code> 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 <code>n</code> 的二维整数数组 <code>positions</code> ，其中 <code>positions[i] = [ri, ci]</code> 表示第 <code>i</code> 个棋子现在在棋盘上的位置为 <code>(ri, ci)</code> ，棋盘下标从 <code>1</code> 开始。</p><p>棋盘上每个棋子都可以移动 至多一次 。每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：</p><p>车可以 水平或者竖直 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)，(r-1, c)，(r, c+1)</code> 或者 <code>(r, c-1)</code> 移动。<br>后可以 水平竖直或者斜对角 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1)</code> 移动。<br>象可以 斜对角 从 <code>(r, c)</code> 沿着方向 <code>(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1)</code> 移动。<br>移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 <code>0</code> 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。</p><p>请你返回 有效 移动组合的数目。</p><p>注意：</p><ul><li>初始时，不会有两个棋子 在 同一个位置 。</li><li>有可能在一个移动组合中，有棋子不移动。</li><li>如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。</li></ul><p>示例 1:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"rook"</span>], positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"queen"</span>], positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 3:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"bishop"</span>], positions = <span class="string">[[4,3]]</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：上图展示了棋子所有可能的移动。</span><br></pre></td></tr></table></figure><br>示例 4:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"rook"</span>,<span class="string">"rook"</span>], positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">223</span></span><br><span class="line">解释：每个车有 <span class="number">15</span> 种移动，所以总共有 <span class="number">15</span> * <span class="number">15</span> = <span class="number">225</span> 种移动组合。</span><br><span class="line">但是，有两个是不有效的移动组合：</span><br><span class="line">- 将两个车都移动到 (<span class="number">8</span>, <span class="number">1</span>) ，会导致它们在同一个格子相遇。</span><br><span class="line">- 将两个车都移动到 (<span class="number">1</span>, <span class="number">8</span>) ，会导致它们在同一个格子相遇。</span><br><span class="line">所以，总共有 <span class="number">225</span> - <span class="number">2</span> = <span class="number">223</span> 种有效移动组合。</span><br><span class="line">注意，有两种有效的移动组合，分别是一个车在 (<span class="number">1</span>, <span class="number">8</span>) ，另一个车在 (<span class="number">8</span>, <span class="number">1</span>) 。</span><br><span class="line">即使棋盘状态是相同的，这两个移动组合被视为不同的，因为每个棋子移动操作是不相同的。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：pieces = [<span class="string">"queen"</span>,<span class="string">"bishop"</span>], positions = [[<span class="number">5</span>,<span class="number">7</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">281</span></span><br><span class="line">解释：总共有 <span class="number">12</span> * <span class="number">24</span> = <span class="number">288</span> 种移动组合。</span><br><span class="line">但是，有一些不有效的移动组合：</span><br><span class="line">- 如果后停在 (<span class="number">6</span>, <span class="number">7</span>) ，它会阻挡象到达 (<span class="number">6</span>, <span class="number">7</span>) 或者 (<span class="number">7</span>, <span class="number">8</span>) 。</span><br><span class="line">- 如果后停在 (<span class="number">5</span>, <span class="number">6</span>) ，它会阻挡象到达 (<span class="number">5</span>, <span class="number">6</span>) ，(<span class="number">6</span>, <span class="number">7</span>) 或者 (<span class="number">7</span>, <span class="number">8</span>) 。</span><br><span class="line">- 如果象停在 (<span class="number">5</span>, <span class="number">2</span>) ，它会阻挡后到达 (<span class="number">5</span>, <span class="number">2</span>) 或者 (<span class="number">5</span>, <span class="number">1</span>) 。</span><br><span class="line">在 <span class="number">288</span> 个移动组合当中，<span class="number">281</span> 个是有效的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == pieces.length</code></li><li><code>n == positions.length</code></li><li><code>1 &lt;= n &lt;= 4</code></li><li><code>pieces</code> 只包含字符串 <code>&quot;rook&quot;</code> ，<code>&quot;queen&quot;</code> 和 <code>&quot;bishop&quot;</code> 。</li><li>棋盘上总共最多只有一个后。</li><li><code>1 &lt;= xi, yi &lt;= 8</code></li><li>每一个 <code>positions[i]</code> 互不相同。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-valid-move-combinations-on-chessboard</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目还算是比较新颖的题目，首先我们可以测算皇后的可能走的方法有 $28$ 种, 题目种给定数据大小 $ n \le 4 $, 因此最多只有 $22^4 = 234256$种可能的走法组合,因此我们可以利用暴力求解, 找到所有可能的组合,然后检测每种组合是否合法.</li><li>每种棋子我们定义每种走法的状态为 ($s, d)$ ,其中 $s$ 代表该棋子会移动多少步后停止, $d$ 代表该棋子移动的方法．同时我们还需要检测每种状态组合是否合法, 如果该状态组合为非法需要满足以下任意一个:</li></ol><ul><li>棋子 $i$ 与棋子 $j$ 经过相同的移动步数进入同一个格子;</li><li>棋子 $i$ 的刚好进入棋子 $j$ 停留的格子.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(nC^{n})$, 其中 $C$ 为某个常数, $n$ 为棋子的个数.</li><li>空间复杂度分析: $O(nC)$,其中 $C$ 为某个常数, $n$ 为棋子的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions, <span class="built_in">vector</span>&lt;pii&gt; &amp; curr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = positions.size();</span><br><span class="line">        <span class="keyword">int</span> mx = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = curr[i].first;</span><br><span class="line">            <span class="keyword">int</span> d = curr[i].second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = positions[i][<span class="number">0</span>] + j*dx[d];</span><br><span class="line">                <span class="keyword">int</span> y = positions[i][<span class="number">1</span>] + j*dy[d];</span><br><span class="line">                cnt[i].push_back(x*<span class="number">8</span> + y);</span><br><span class="line">            &#125;</span><br><span class="line">            mx = min(mx, <span class="keyword">int</span>(cnt[i].size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mx; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j][i] == cnt[j+<span class="number">1</span>][i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i][j] == cnt[k].back()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; arr, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions, <span class="built_in">vector</span>&lt;pii&gt; &amp; curr, <span class="keyword">int</span> &amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == arr.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(check(positions, curr)) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr[x].size(); ++i) &#123;</span><br><span class="line">            curr.emplace_back(arr[x][i]);</span><br><span class="line">            dfs(x + <span class="number">1</span>, arr, positions, curr, res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCombinations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pieces, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; positions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = pieces.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pii&gt;&gt; arr(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; curr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*initial*/</span></span><br><span class="line">        dirs[<span class="string">"queen"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">        dirs[<span class="string">"rook"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">        dirs[<span class="string">"bishop"</span>] = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            arr[i].push_back(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d : dirs[pieces[i]]) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = positions[i][<span class="number">0</span>] + dx[d]*k;</span><br><span class="line">                    <span class="keyword">int</span> y = positions[i][<span class="number">1</span>] + dy[d]*k;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= <span class="number">8</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= <span class="number">8</span>) &#123;</span><br><span class="line">                        arr[i].push_back(&#123;k, d&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* deap first search*/</span></span><br><span class="line">        dfs(<span class="number">0</span>, arr, positions, curr, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-biweekly-64&quot;&gt;&lt;a href=&quot;#leetcode-contest-biweekly-64&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest biweekly 64&quot;&gt;&lt;/a&gt;leetcode contest biweekly 64&lt;/h1&gt;&lt;p&gt;题目质量还可以,还是三道题的节奏,最后一题确实不会做．&lt;/p&gt;&lt;h3 id=&quot;5898-数组中第-K-个独一无二的字符串&quot;&gt;&lt;a href=&quot;#5898-数组中第-K-个独一无二的字符串&quot; class=&quot;headerlink&quot; title=&quot;5898. 数组中第 K 个独一无二的字符串&quot;&gt;&lt;/a&gt;5898. 数组中第 K 个独一无二的字符串&lt;/h3&gt;&lt;p&gt;独一无二的字符串 指的是在一个数组中只出现过 一次 的字符串。&lt;/p&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;arr&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回 &lt;code&gt;arr&lt;/code&gt;中第 &lt;code&gt;k&lt;/code&gt; 个 独一无二的字符串 。如果 少于 k 个独一无二的字符串，那么返回 空字符串 “” 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 建信金科</title>
    <link href="http://yoursite.com/2021/10/30/339/"/>
    <id>http://yoursite.com/2021/10/30/339/</id>
    <published>2021-10-30T04:27:29.486Z</published>
    <updated>2021-11-11T15:09:41.566Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-建信金科"><a href="#leetcode-contest-建信金科" class="headerlink" title="leetcode contest 建信金科"></a>leetcode contest 建信金科</h1><p>题目质量还是非常高的，只做出两道的节奏，最后两道题目没有做出来，但是又从中学到了新的知识点和技能．第四题可能是我最喜欢的题目类型了，带有思考性质和数学问题，非常喜欢这种思维加数学的题型，通过算法和计算可以学习到数学的问题．</p><h3 id="建信01-间隔删除链表结点"><a href="#建信01-间隔删除链表结点" class="headerlink" title="建信01. 间隔删除链表结点"></a>建信01. 间隔删除链表结点</h3><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">蓝色结点为删除的结点</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">8</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>链表中结点的数目在<code>[1, 5000]</code>范围内。</li><li><code>1 &lt;= Node.val &lt;= 10000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  遍历</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的比较无聊，我们每隔一个节点删除一个节点即可，将节点的指针指向下一个节点的下一个节点即可。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为链表的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(1)$,我们指针保存中间变量即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            ListNode * prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="建信02-柱状图分析"><a href="#建信02-柱状图分析" class="headerlink" title="建信02. 柱状图分析"></a>建信02. 柱状图分析</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>某柱状图上共有 <code>N</code>个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>], cnt = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 与 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 返回。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">10</span>], cnt = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">解释：柱形组 [<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>] 满足最大高度与最小高度的差值为最小条件。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= cnt &lt; heights.length &lt;= 10^5</code></li><li><code>0 &lt;= heights[i] &lt;= 10^6</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>所谓任选 $cnt$ 个柱形使得最大高度与最小高度最小，则此时我们按照排序从小到大，最大值与最小值之差的最小值肯定是在选择连续 $cnt$ 个元素中．</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n\log(n))$，其中 $n$ 表示数组的长度．</li><li>空间复杂度分析: 空间复杂度为 $O(1)$，我们只需要常数个变量保存中间变量．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; analysisHistogram(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights, <span class="keyword">int</span> cnt) &#123;</span><br><span class="line">        sort(heights.begin(),heights.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> mindiff = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> n = heights.size();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-cnt; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i+cnt<span class="number">-1</span>] - heights[i] &lt; mindiff)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                mindiff = heights[i+cnt<span class="number">-1</span>] - heights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt; idx+cnt; ++i)&#123;</span><br><span class="line">            ans.push_back(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="建信03-地铁路线规划"><a href="#建信03-地铁路线规划" class="headerlink" title="建信03. 地铁路线规划"></a>建信03. 地铁路线规划</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某城市有若干条地铁线路，<code>lines</code> 记录了每条地铁线路依次停靠的站点（每条线路均是双向的）<br>李林想从站点 <code>start</code> 出发前往 <code>end</code>，请规划一条可行路线使得他可以以最小的换乘次数到达目的站点。若有多条路线满足要求，请返回字典序最小的路线（要求路线上无重复的站点）。</p><p>注意：</p><ul><li>输入数据保证存在 <code>start</code> 到 <code>end</code> 的路线</li><li>任意路线上的点在该条路线上仅出现一次（即任意一条路线均不是环线）</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>],[<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">13</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">11</span>]], start = <span class="number">1</span>, end = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 <span class="number">1</span> 到站点 <span class="number">7</span> 的最少换乘 <span class="number">1</span> 次，路线为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：lines = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">16</span>,<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">18</span>]], start = <span class="number">9</span>, end = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 <span class="number">9</span> 到站点 <span class="number">1</span> 的最少换乘 <span class="number">0</span> 次，路线为 [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= lines.length, lines[i].length &lt;= 100</code></li><li><code>1 &lt;= lines[i][j], start, end &lt;= 10000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra 或者　DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>感觉这个题目当时拿到时确实没有特别好的思路, 感觉可以通过暴力搜索即可解决该题目，最后看到几个解答，发现有直接 $DFS$ 加减枝就可以搞定的. 其实想想这个题目最难的地方有两点需要注意:</li></ol><ul><li>字典序最小的路径如何求出,最后看了下别人的解法竟然都是直接记录下当前的路径,然后比较两个整数数组的字典序大小即可，当初拿到题目的时候一直在想如何记录最小的字典序，结果都是使用暴力来记录．</li><li>如何记录两个站点之间的线路切换，我们在遍历的时候需要记录上一站的站点 $x$ 和路线 $y$，在下一站点切换时，我们会遍历站点 $x$ 周围所有的站点和路线, 这个需要稍微用点技巧, 我们在记录站点的邻接站点时,同时记录下它的站点号和路线号.</li></ul><ol><li>$DFS$ 暴力搜索的解法就感觉比较简单, 利用回溯记录下所有从 $start$ 可能的路径,并同时记录该路径经历的换乘次数, 同时记录下路径用来比较字典序,感觉这个解法确实没有什么难度,但是感觉复杂度还挺高的,感觉需要用到欧拉拓扑之类的，这个解法的时间复杂度应该挺高的，感觉应该在 $O(n^{3})$.当时感觉应该用 $BFS$ 来解决的,但是确实没有想到 $BFS$ 解决的好办法.</li><li>$BFS$: 我们可以使用 $dijistra$ 算法快速收敛,每次记录下当前路线的换站次数，路线号，已经经过的站点路劲，每次选择下一跳时，我们优先选择切换站点次数最少，且路径字典序最小的路径．实际 $BFS$ 写起来非常简洁.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(MN\times log(MN))$,其中 $N$ 为站点的个数, $M$ 为线路的个数.</li><li>空间复杂度为 $O(N^2)$,其中 $N$ 为站点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3></li><li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; vis, <span class="keyword">int</span> last, <span class="keyword">int</span> cost, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(cost &gt; ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; ans || (cost == ans &amp;&amp; path &lt; ret)) &#123;</span><br><span class="line">                ans = cost;</span><br><span class="line">                ret = path;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [next, route] : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[next]) &#123;</span><br><span class="line">                vis[next] = <span class="literal">true</span>;</span><br><span class="line">                path.push_back(next);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(route != last) &#123;</span><br><span class="line">                    dfs(next, target, g, vis, route, cost + <span class="number">1</span>, path);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dfs(next, target, g, vis, route, cost, path);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                path.pop_back();</span><br><span class="line">                vis[next] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; metroRouteDesignI(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; a, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = a.size(); <span class="comment">// 路线个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;&gt; g(<span class="number">10005</span>); <span class="comment">// 邻接表</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a[i].size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">                    g[a[i][j]].push_back(&#123;a[i][j + <span class="number">1</span>], i&#125;);</span><br><span class="line">                    g[a[i][j + <span class="number">1</span>]].push_back(&#123;a[i][j], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis(<span class="number">10005</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        </span><br><span class="line">        path.push_back(start);</span><br><span class="line">        vis[start] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [next, route] : g[start]) &#123;</span><br><span class="line">            vis[next] = <span class="literal">true</span>;</span><br><span class="line">            path.push_back(next);</span><br><span class="line">            </span><br><span class="line">            dfs(next, end, g, vis, route, <span class="number">0</span>, path);</span><br><span class="line">            </span><br><span class="line">            path.pop_back();</span><br><span class="line">            vis[next] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>BFS</code>:</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> line;</span><br><span class="line">    <span class="keyword">int</span> change;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.change == b.change)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.path &gt; b.path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.change &gt; b.change;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; metroRouteDesignI(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; lines, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = lines.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nodes;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : lines[i])&#123;</span><br><span class="line">                nodes[v].emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; lines[i].size(); ++j)&#123;</span><br><span class="line">                graph[lines[i][j<span class="number">-1</span>]].push_back(make_pair(i,lines[i][j]));</span><br><span class="line">                graph[lines[i][j]].push_back(make_pair(i,lines[i][j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nodes[start])&#123;</span><br><span class="line">            Node t;</span><br><span class="line">            t.line = v;</span><br><span class="line">            t.change = <span class="number">0</span>;</span><br><span class="line">            t.path.emplace_back(start);</span><br><span class="line">            pq.push(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr.path.back() == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.path;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr.path)&#123;</span><br><span class="line">                visited.insert(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neg : graph[curr.path.back()])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.count(neg.second)) <span class="keyword">continue</span>;</span><br><span class="line">                Node next;</span><br><span class="line">                next.line = neg.first;</span><br><span class="line">                next.path = curr.path;</span><br><span class="line">                next.path.emplace_back(neg.second);</span><br><span class="line">                <span class="comment">//change line*/</span></span><br><span class="line">                <span class="keyword">if</span>(neg.first != curr.line)&#123;</span><br><span class="line">                    next.change = curr.change + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// the same line</span></span><br><span class="line">                    next.change = curr.change;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="建信04-电学实验课"><a href="#建信04-电学实验课" class="headerlink" title="建信04. 电学实验课"></a>建信04. 电学实验课</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某电学实验使用了 <code>row * col</code> 个插孔的面包板，可视作二维矩阵，左上角记作 <code>(0,0)</code>。老师设置了若干「目标插孔」，它们位置对应的矩阵下标记于二维数组 <code>position</code>。实验目标要求同学们用导线连接所有「目标插孔」，即从任意一个「目标插孔」沿导线可以到达其他任意「目标插孔」。受实验导线长度所限，导线的连接规则如下：</p><ul><li>一条导线可连接相邻两列的且行间距不超过 1 的两个插孔</li><li>每一列插孔中最多使用其中一个插孔（包括「目标插孔」）<br>若实验目标可达成，请返回使用导线数量最少的连接所有目标插孔的方案数；否则请返回 0。</li></ul><p>注意：</p><ul><li>输入数据保证每列最多仅有一个「目标插孔」；</li><li>答案需要以 <code>1e9 + 7 (1000000007)</code> 为底取模， 如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code><br>示例 1：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">5</span>, col = <span class="number">6</span>, position = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则无法达成实验目标。</span><br></pre></td></tr></table></figure>示例 2：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">3</span>，col = <span class="number">4</span>, position = [[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有三种方案达成目标。</span><br></pre></td></tr></table></figure></li></ul><p>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">5</span>, col = <span class="number">6</span>, position = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有六种方案达成目标。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= row &lt;= 20</code></li><li><code>3 &lt;= col &lt;= 10^9</code></li><li><code>1 &lt; position.length &lt;= 1000</code></li><li><code>0 &lt;= position[i][0] &lt; row</code></li><li><code>0 &lt;= position[i][1] &lt; col</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划 + 数学问题　</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目,我非常喜欢的类型, 用数学方法解决类似于动态规划的题目，与<a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a>的数学解法非常相似．我们知道斐波那契数数列的递推关系为$f[i] = f[i-1] + f[i-2]$, 然后我们可以利用利用矩阵乘法,求解公式如下:<script type="math/tex; mode=display">[f(n+1),f(n)] = [f(n) + f(n-1), f(n)] \\= [f(n),f(n-1)] \times \left[\begin{array}{l}1 & 1 \\1 & 0 \\\end{array}\right]</script></li><li>首先在本题中我们需要分析一下, 每个目标插孔连接时一定是按照列的大小依次进行相连的, 因为题目的约束规则是一条导线可连接相邻两列的且行间距不超过 1 的两个插孔且每一列插孔中最多使用其中一个插孔,这就意味着我们不可能先连接列数较大的目标孔后,再来连接列数较小的目标控. 因此首先我们需要按照列数的大小对目标孔进行排序, 然后依次按照列数大小开始连接.</li><li>我们知道对于递推关系如下,设$f[i][j]$ 表示第 $i$ 行 $j$ 列的导线的穿线数目，则我们可以知道:<script type="math/tex; mode=display">f[i][j] = f[i-1][j-1] + f[i][j-1] + f[i+1][j-1]</script>我们可以归纳递推关系为:<script type="math/tex; mode=display">\left\{\begin{array}{lr}f[0][j] = f[0][j-1] + f[1][j-1]\\f[1][j] = f[0][j-1] + f[1][j-1] + f[2][j-1]\\\cdots \\f[n-2][j] = f[n-3][j-1] + f[n-2][j-1] + f[n-1][j-1]\\f[n-1][j] = f[n-2][j-1] + f[n-1][j-1]\\\end{array}\right.</script>转换为矩阵乘法即为:<script type="math/tex; mode=display">[f[0][j], f[1][j], \cdots,f[n-2][j],f[n-1][j]] = [f[0][j-1], f[1][j-1], \cdots,f[n-2][j-1],f[n-1][j-1]] \times\left[\begin{array}{lr}1 & 1 & 0 & \cdots 0 & 0 \\1 & 1 & 1 & \cdots 0 & 0 \\0 & 1 & 1 & \cdots 0 & 0 \\0 & 0 & 1 & \cdots 0 & 0 \\0 & 0 & 0 & \cdots 0 & 0 \\\vdots & \vdots & \vdots & \ddots & \vdots \\0 & 0 & 0 & \cdots 1 & 0 \\0 & 0 & 0 & \cdots 1 & 1 \\0 & 0 & 0 & \cdots 1 & 1 \\\end{array}\right]</script>我们设矩阵 $A$ 满足:<script type="math/tex; mode=display">A = \left[\begin{array}{lr}1 & 1 & 0 & \cdots 0 & 0 \\1 & 1 & 1 & \cdots 0 & 0 \\0 & 1 & 1 & \cdots 0 & 0 \\0 & 0 & 1 & \cdots 0 & 0 \\0 & 0 & 0 & \cdots 0 & 0 \\\vdots & \vdots & \vdots & \ddots & \vdots \\0 & 0 & 0 & \cdots 1 & 0 \\0 & 0 & 0 & \cdots 1 & 1 \\0 & 0 & 0 & \cdots 1 & 1 \\\end{array}\right]</script>则此时我们可以知道对于第 $i$ 列的元素设为矩阵 $f[j]$, 对于第 $j$ 列的方法数的元素为矩阵 $f[i]$, 我们假设 $ i \le j$, 则我们可以知道递推关系为:<script type="math/tex; mode=display">f[j] = f[i]\times A^{j-i}</script>此时我们则将方法数的计算转换为矩阵的乘法运算, 我们只需要每次求出第到达 $i$ 列的目标控的方法数，然后根据矩阵的乘法可以计算出处在第 $j$ 列的目标孔的方法数.</li><li>实际计算过程中,我们还需要利用快速幂法,快速的计算出矩阵的 $n$ 次幂.　我们可以进行预处离．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(C\times n \times row^{3}$, 其中 $n$ 为点的个数, $C = 32$, $row$ 为矩阵的行数.</li><li>空间复杂度分析: $O(C\times row \times col)$,其中 $C=32$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>数学问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mult(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat2, <span class="keyword">long</span> <span class="keyword">long</span> mod)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat1.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat1[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> n = mat2[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; res(m,<span class="built_in">vector</span>&lt;ll&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    res[i][j] = (res[i][j] + mat1[i][k]*mat2[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; fastpow(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; &amp; mat, <span class="keyword">int</span> p, <span class="keyword">long</span> <span class="keyword">long</span> mod)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.size();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; res(m,<span class="built_in">vector</span>&lt;ll&gt;(m));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; curr = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; p != <span class="number">0</span>; p = (p&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(p%<span class="number">2</span>)&#123;</span><br><span class="line">                res = mult(res,curr,mod);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = mult(curr,curr,mod);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">electricityExperiment</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = position.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        sort(position.begin(),position.end(),[&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; mat(row,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt;&gt; arr(<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span>) mat[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; row) mat[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>] = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">            arr[i] = mult(arr[i<span class="number">-1</span>],arr[i<span class="number">-1</span>],mod);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;ll&gt;&gt; curr(<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        curr[<span class="number">0</span>][position[<span class="number">0</span>][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p = position[i][<span class="number">1</span>] - position[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr = mult(curr,arr[j],mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != position[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    curr[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr[<span class="number">0</span>][position[n<span class="number">-1</span>][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-建信金科&quot;&gt;&lt;a href=&quot;#leetcode-contest-建信金科&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 建信金科&quot;&gt;&lt;/a&gt;leetcode contest 建信金科&lt;/h1&gt;&lt;p&gt;题目质量还是非常高的，只做出两道的节奏，最后两道题目没有做出来，但是又从中学到了新的知识点和技能．第四题可能是我最喜欢的题目类型了，带有思考性质和数学问题，非常喜欢这种思维加数学的题型，通过算法和计算可以学习到数学的问题．&lt;/p&gt;&lt;h3 id=&quot;建信01-间隔删除链表结点&quot;&gt;&lt;a href=&quot;#建信01-间隔删除链表结点&quot; class=&quot;headerlink&quot; title=&quot;建信01. 间隔删除链表结点&quot;&gt;&lt;/a&gt;建信01. 间隔删除链表结点&lt;/h3&gt;&lt;p&gt;给你一个链表的头结点 &lt;code&gt;head&lt;/code&gt;，每隔一个结点删除另一个结点（要求保留头结点）。&lt;br&gt;请返回最终链表的头结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest  264</title>
    <link href="http://yoursite.com/2021/10/24/338/"/>
    <id>http://yoursite.com/2021/10/24/338/</id>
    <published>2021-10-24T03:51:53.603Z</published>
    <updated>2021-10-24T05:03:33.436Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-264"><a href="#leetcode-contest-264" class="headerlink" title="leetcode contest 264"></a>leetcode contest 264</h1><p>本周的题目出的题目真心不好,质量严重下降,比前几次的题目差不少,缺少太多的思考难点.感觉题目确实放水严重．<br><img src="https://i.loli.net/2021/10/24/YqfN8P2clJCm3Za.png" alt></p><h3 id="5906-句子中的有效单词数"><a href="#5906-句子中的有效单词数" class="headerlink" title="5906. 句子中的有效单词数"></a>5906. 句子中的有效单词数</h3><p>句子仅由小写字母（<code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>）、数字（<code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code>）、连字符（<code>&#39;-&#39;</code>）、标点符号（<code>&#39;!&#39;</code>、<code>&#39;.&#39;</code> 和 <code>&#39;,&#39;</code>）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 <code>token</code> ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。</p><a id="more"></a><p>如果一个 <code>token</code> 同时满足下述条件，则认为这个 <code>token</code> 是一个有效单词：</p><p>仅由小写字母、连字符和/或标点（不含数字）。<br>至多一个 连字符 ‘-‘ 。如果存在，连字符两侧应当都存在小写字母（<code>&quot;a-b&quot;</code> 是一个有效单词，但 <code>&quot;-ab&quot;</code> 和 <code>&quot;ab-&quot;</code> 不是有效单词）。<br>至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。<br>这里给出几个有效单词的例子：<code>&quot;a-b.&quot;、&quot;afad&quot;、&quot;ba-c&quot;、&quot;a!&quot; 和 &quot;!&quot;</code> 。</p><p>给你一个字符串 <code>sentence</code> ，请你找出并返回 <code>sentence</code> 中 有效单词的数目 。</p><p>示例 1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"cat and  dog"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：句子中的有效单词是 <span class="string">"cat"</span>、<span class="string">"and"</span> 和 <span class="string">"dog"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"!this  1-s b8d!"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：句子中没有有效单词</span><br><span class="line"><span class="string">"!this"</span> 不是有效单词，因为它以一个标点开头</span><br><span class="line"><span class="string">"1-s"</span> 和 <span class="string">"b8d"</span> 也不是有效单词，因为它们都包含数字</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="comment">"alice and  bob are playing stone-game10"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：句子中的有效单词是 <span class="comment">"alice"</span>、<span class="comment">"and"</span>、<span class="comment">"bob"</span>、<span class="comment">"are"</span> 和 <span class="comment">"playing"</span></span><br><span class="line"><span class="comment">"stone-game10"</span> 不是有效单词，因为它含有数字</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">sentence</span> = <span class="string">"he bought 2 pencils, 3 erasers, and 1  pencil-sharpener."</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：句子中的有效单词是 <span class="string">"he"</span>、<span class="string">"bought"</span>、<span class="string">"pencils,"</span>、<span class="string">"erasers,"</span>、<span class="string">"and"</span> 和 <span class="string">"pencil-sharpener."</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 1000</code></li><li><code>sentence</code> 由小写英文字母、数字<code>（0-9）</code>、以及字符<code>（&#39; &#39;、&#39;-&#39;、&#39;!&#39;、&#39;.&#39; 和 &#39;,&#39;）</code>组成</li><li>句子中至少有 <code>1</code> 个 <code>token</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/number-of-valid-words-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/number-of-valid-words-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的比较无聊，确实只能算是 $curd$。</li><li>首先我们解析出字符串中的每个 $token$，然后对每个 $token$ 进行检查:</li></ol><ul><li>如果为分割符<code>-</code>,则检查该分割符的是否是该 $token$ 的第一个元素还是最末尾的元素,同时检测 $token$ 的前后字符是否是字母;</li><li>如果为标点符<code>!</code>,<code>.</code>,<code>,</code>,则检查该标点符号是否为该 $token$ 的最后一个字符;</li><li>既不是分割符也不是标点符号的字符是否为字母;</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们需要保留每个 $token$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countValidWords</span><span class="params">(<span class="built_in">string</span> sentence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = sentence.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*split*/</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] == <span class="string">' '</span>) pos++;</span><br><span class="line">            <span class="keyword">int</span> curr = pos;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] != <span class="string">' '</span>) pos++;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; n) &#123;</span><br><span class="line">                arr.push_back(sentence.substr(curr,pos-curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check every token*/</span></span><br><span class="line">        <span class="keyword">int</span> m = arr.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> connect = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] == <span class="string">'-'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == <span class="number">0</span> || j == arr[i].size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!isAlpha(arr[i][j<span class="number">-1</span>]) || !isAlpha(arr[i][j+<span class="number">1</span>]))&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    connect++;</span><br><span class="line">                    <span class="keyword">if</span>(connect &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr[i][j] == <span class="string">'!'</span> || arr[i][j] == <span class="string">'.'</span> || arr[i][j] == <span class="string">','</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j != arr[i].size() - <span class="number">1</span>) &#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!isAlpha(arr[i][j]))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5907-下一个更大的数值平衡数"><a href="#5907-下一个更大的数值平衡数" class="headerlink" title="5907. 下一个更大的数值平衡数"></a>5907. 下一个更大的数值平衡数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果整数  <code>x</code> 满足：对于每个数位 <code>d</code> ，这个数位 恰好 在 <code>x</code>中出现 <code>d</code>次。那么整数 <code>x</code>就是一个 数值平衡数 。</p><p>给你一个整数 <code>n</code>，请你返回 严格大于<code>n</code>的 最小数值平衡数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">22</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">2</span> 出现 <span class="number">2</span> 次 </span><br><span class="line">这也是严格大于 <span class="number">1</span> 的最小数值平衡数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1000</span></span><br><span class="line">输出：<span class="number">1333</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">1333</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">1</span> 出现 <span class="number">1</span> 次。</span><br><span class="line">- 数字 <span class="number">3</span> 出现 <span class="number">3</span> 次。 </span><br><span class="line">这也是严格大于 <span class="number">1000</span> 的最小数值平衡数。</span><br><span class="line">注意，<span class="number">1022</span> 不能作为本输入的答案，因为数字 <span class="number">0</span> 的出现次数超过了 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3000</span></span><br><span class="line">输出：<span class="number">3133</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">3133</span> 是一个数值平衡数，因为：</span><br><span class="line">- 数字 <span class="number">1</span> 出现 <span class="number">1</span> 次。</span><br><span class="line">- 数字 <span class="number">3</span> 出现 <span class="number">3</span> 次。 </span><br><span class="line">这也是严格大于 <span class="number">3000</span> 的最小数值平衡数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>0 &lt;= n &lt;= 106</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/next-greater-numerically-balanced-number/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目也不知大有什么规律，想来想去，最后干脆直接暴力，因为 $n$ 的数量级很小．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">10</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[x%<span class="number">10</span>]++;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span> &amp;&amp; cnt[i] != i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nextBeautifulNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">for</span>(++n;; ++n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check(n)) </span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5908-统计最高分的节点数目"><a href="#5908-统计最高分的节点数目" class="headerlink" title="5908. 统计最高分的节点数目"></a>5908. 统计最高分的节点数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵根节点为 <code>0</code> 的 二叉树 ，它总共有 <code>n</code> 个节点，节点编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>parents</code> 表示这棵树，其中 <code>parents[i]</code> 是节点 <code>i</code> 的父节点。由于节点 0 是根，所以 <code>parents[0] == -1</code> 。</p><p>一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。</p><p>请你返回有 最高得分 节点的 数目 。</p><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- 节点 <span class="number">0</span> 的分数为：<span class="number">3</span> * <span class="number">1</span> = <span class="number">3</span></span><br><span class="line">- 节点 <span class="number">1</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 节点 <span class="number">2</span> 的分数为：<span class="number">1</span> * <span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">3</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">- 节点 <span class="number">4</span> 的分数为：<span class="number">4</span> = <span class="number">4</span></span><br><span class="line">最高得分为 <span class="number">4</span> ，有三个节点得分为 <span class="number">4</span> （分别是节点 <span class="number">1</span>，<span class="number">3</span> 和 <span class="number">4</span> ）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 节点 <span class="number">0</span> 的分数为：<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">1</span> 的分数为：<span class="number">2</span> = <span class="number">2</span></span><br><span class="line">- 节点 <span class="number">2</span> 的分数为：<span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">最高分数为 <span class="number">2</span> ，有两个节点分数为 <span class="number">2</span> （分别为节点 <span class="number">0</span> 和 <span class="number">1</span> ）。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parents.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>parents[0] == -1</code></li><li>对于 <code>i != 0</code> ，有 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents</code> 表示一棵二叉树。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-264/problems/count-nodes-with-the-highest-score/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的 $DFS$, 我们利用 $DFS$ 求出每个节点的子树所含有的节点的个数．我们在设节点的总数为 $n$, 设以节点 $i$ 为子数的节点数目为 $tree(i)$,则每个节点 $i$ 的分计算公式为: <script type="math/tex; mode=display">score(i) = (n-tree(i)) \times tree(left(i)) \times tree(right(i))</script></li><li>计算出每个节点的分数,然后找到最大值的个数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$,其中 $N$ 为节点的个数，我们只需要遍历一遍二叉树即可 .</li><li>空间复杂度为 $O(2N)$,其中 $N$ 为节点的个数.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr)</span> </span>&#123;</span><br><span class="line">        arr[root] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[root])&#123;</span><br><span class="line">            dfs(v,graph,arr);</span><br><span class="line">            arr[root] += arr[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[root];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countHighestScoreNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(n);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            graph[parents[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,graph,arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                curr *= (n - arr[i]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[i])&#123;</span><br><span class="line">                curr *= arr[v];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[curr]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5909-并行课程-III"><a href="#5909-并行课程-III" class="headerlink" title="5909. 并行课程 III"></a>5909. 并行课程 III</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> ，表示有 <code>n</code> 节课，课程编号从 <code>1</code> 到 <code>n</code> 。同时给你一个二维整数数组 <code>relations</code> ，其中 <code>relations[j] = [prevCoursej, nextCoursej]</code> ，表示课程 <code>prevCoursej</code>必须在课程 <code>nextCoursej</code> 之前 完成（先修课的关系）。同时给你一个下标从 <code>0</code> 开始的整数数组 <code>time</code> ，其中 <code>time[i]</code> 表示完成第 <code>(i+1)</code> 门课程需要花费的月份数。</p><p>请你根据以下规则算出完成所有课程所需要的 最少 月份数：</p><ul><li>如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。</li><li>你可以 同时 上 任意门课程 。</li><li>请你返回完成所有课程所需要的 最少 月份数。<br>注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）。</li></ul><p>示例 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, relations = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]], time = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 <span class="number">0</span> 同时开始课程 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br><span class="line">课程 <span class="number">1</span> 花费 <span class="number">3</span> 个月，课程 <span class="number">2</span> 花费 <span class="number">2</span> 个月。</span><br><span class="line">所以，最早开始课程 <span class="number">3</span> 的时间是月份 <span class="number">3</span> ，完成所有课程所需时间为 <span class="number">3</span> + <span class="number">5</span> = <span class="number">8</span> 个月。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, relations = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], time = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：上图展示了输入数据所表示的先修关系图，以及完成每门课程需要花费的时间。</span><br><span class="line">你可以在月份 <span class="number">0</span> 同时开始课程 <span class="number">1</span> ，<span class="number">2</span> 和 <span class="number">3</span> 。</span><br><span class="line">在月份 <span class="number">1</span>，<span class="number">2</span> 和 <span class="number">3</span> 分别完成这三门课程。</span><br><span class="line">课程 <span class="number">4</span> 需在课程 <span class="number">3</span> 之后开始，也就是 <span class="number">3</span> 个月后。课程 <span class="number">4</span> 在 <span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span> 月完成。</span><br><span class="line">课程 <span class="number">5</span> 需在课程 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> 和 <span class="number">4</span> 之后开始，也就是在 max(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>) = <span class="number">7</span> 月开始。</span><br><span class="line">所以完成所有课程所需的最少时间为 <span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span> 个月。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>0 &lt;= relations.length &lt;= min(n * (n - 1) / 2, 5 * 104)</code></li><li><code>relations[j].length == 2</code></li><li><code>1 &lt;= prevCoursej, nextCoursej &lt;= n</code></li><li><code>prevCoursej != nextCoursej</code></li><li>所有的先修课程对 <code>[prevCoursej, nextCoursej]</code> 都是 互不相同 的。</li><li><code>time.length == n</code></li><li><code>1 &lt;= time[i] &lt;= 104</code></li><li>先修课程图是一个有向无环图。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP + 拓扑排序</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目感觉只能算是中等难度题目了,非常经典的模板题. 首先我们知道课程的先后顺序,肯定需要用到拓扑排序才能解决该问题,我们设 $dp[i]$ 表示完成该课程所需要的最少月份，则我们知道对于以来关系为 $[i,j]$ 的课程来说,即课程 $j$ 需要依赖课程 $i$ 的完成,则我们知道递推关系为: <script type="math/tex">dp[j] = max(dp[j],dp[i] + time[j])</script>，我们知道题目中一定存在拓扑关系，我们按照拓扑关系的要求，依次求出每个课程完成所需要的最少月份即可．</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(V + E)$, 其中 $V$ 为课程的个数, $E$ 为课程的依赖关系个数,因为我们只需要要一次拓扑排序即可.</li><li>空间复杂度分析: $O(V)$,其中 $V$ 为课程的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relations, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : relations) &#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = time[i];</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neg : graph[curr])&#123;</span><br><span class="line">                indegree[neg]--;</span><br><span class="line">                dp[neg] = max(dp[neg],dp[curr] + time[neg]);</span><br><span class="line">                <span class="keyword">if</span>(indegree[neg] == <span class="number">0</span>)&#123;</span><br><span class="line">                    qu.push(neg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mike-box.github.io/" target="_blank" rel="noopener">http://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-264&quot;&gt;&lt;a href=&quot;#leetcode-contest-264&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 264&quot;&gt;&lt;/a&gt;leetcode contest 264&lt;/h1&gt;&lt;p&gt;本周的题目出的题目真心不好,质量严重下降,比前几次的题目差不少,缺少太多的思考难点.感觉题目确实放水严重．&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/10/24/YqfN8P2clJCm3Za.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5906-句子中的有效单词数&quot;&gt;&lt;a href=&quot;#5906-句子中的有效单词数&quot; class=&quot;headerlink&quot; title=&quot;5906. 句子中的有效单词数&quot;&gt;&lt;/a&gt;5906. 句子中的有效单词数&lt;/h3&gt;&lt;p&gt;句子仅由小写字母（&lt;code&gt;&amp;#39;a&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;z&amp;#39;&lt;/code&gt;）、数字（&lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt; 到 &lt;code&gt;&amp;#39;9&amp;#39;&lt;/code&gt;）、连字符（&lt;code&gt;&amp;#39;-&amp;#39;&lt;/code&gt;）、标点符号（&lt;code&gt;&amp;#39;!&amp;#39;&lt;/code&gt;、&lt;code&gt;&amp;#39;.&amp;#39;&lt;/code&gt; 和 &lt;code&gt;&amp;#39;,&amp;#39;&lt;/code&gt;）以及空格（’ ‘）组成。每个句子可以根据空格分解成 一个或者多个 &lt;code&gt;token&lt;/code&gt; ，这些 token 之间由一个或者多个空格 ‘ ‘ 分隔。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 Round G</title>
    <link href="http://yoursite.com/2021/10/17/337/"/>
    <id>http://yoursite.com/2021/10/17/337/</id>
    <published>2021-10-17T09:26:12.823Z</published>
    <updated>2021-10-27T14:06:24.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-round-G"><a href="#kickstart-2021-round-G" class="headerlink" title="kickstart 2021 round G"></a>kickstart 2021 round G</h1><p><code>kickstart</code>的算法果真还是非常的有难度,比力扣的难度大太多了.感觉还是智商不够，现在感觉 $\textit{leetcode}$ 上面只有 $\textit{hard}$ 题目比较感兴趣了，中等难度及以下，感觉基本上就是重复了。感觉每次比赛的第二题和第三题的质量非常高，非常适合新手练习和比赛．</p><a id="more"></a><h3 id="problem-B"><a href="#problem-B" class="headerlink" title="problem B"></a>problem B</h3><p>With online classes in full swing, it is important for Grace to take breaks and keep herself hydrated at all times. She has decided to place a water bottle in her room in the most convenient place. This means that the position of this water bottle should be close to all the places in the room where she generally hangs out like the study desk, bed and coffee table among other places.</p><p>The room is represented in the form of a coordinate plane. The number of steps Grace needs to go from Point A to Point B is equal to the Manhattan distance between the 2 points. This means, Grace can only walk parallel to the axes of the coordinate plane and with each step, she can move one unit in either of the four directions.</p><p>Can you help her find a position in the room to keep the bottle, such that the sum of steps from the bottle to all her favourite furniture pieces will be minimum?</p><p><strong>Notes</strong>:</p><ul><li>All the furniture (like study desk, bed, or coffee table) can be represented as rectangles of non-zero area in the plane with edges parallel to the axes.</li><li>It is possible for furniture pieces to overlap, as she likes to work on her bed-table too.</li><li>Assume that Grace can simply pass through the furniture while walking and does not need to go around them.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>The first line of each test case contains an integer K which represents the number of objects in Grace’s room.<br>K lines follow, each of them describing one object. The i-th line contains four integers, xi,1, yi,1, xi,2, yi,2, where (xi,1, yi,1) represents coordinates of the bottom left corner and (xi,2, yi,2) represents coordinates of the top right corner of the i-th rectangular object.<br><strong>Output</strong><br>For each test case, output one line containing Case #i: x y, where i is the test case number (starting from 1) and x and y are coordinates of the water bottle such that the sum of steps from these coordinates to all the furniture pieces will be minimum.<br>Note, the bottle can lie on the floor or on top of any furniture but should be placed on integer coordinates only.<br>If multiple solutions exist, output the one with minimum x coordinate, if multiple solutions have the same x coordinate output the one with minimum y coordinate.</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  前缀和</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题意大概是说有一堆物体为长方形，散落在二维坐标系中，我们在二维坐标系中找打一个点使得该点到所有物体的曼哈顿距离之和最小．题目难度本身不是特别难，但是感觉有许多值得思考的地方，特别锻炼思维能力．</li><li>题目看似很难,实际上我们将曼哈顿距离分解为横坐标与总坐标,横坐标与纵坐标之间时间上处于独立的关系,因此我们可以分别求出横坐标与纵坐标.点$P=(x,y)$到矩形 $R$ 的曼哈顿距离计算公式为 $d(P,R) = max(x_{1}−x,x−x_{2},0) + max(y_{1}−y,y−y_{2},0)$, 其中矩形的左下端点为$(x_{1}, y_{1})$, 矩形的右上端点为$(x_{2}, y_{2})$.我们将所有的横坐标进行排列，假设分布如下：<br><img src="https://i.loli.net/2021/10/27/5SxOZ7VNnGRX1Dm.png" alt="1"><br>对于给定的 $x$ 我们只需要找到所有右侧小于 $x$ 的矩形数目 $a(x)$, 以及找到所有左侧大于 $x$ 的矩形数目 $b(x)$.我们可以知道它的计算公式为:<script type="math/tex; mode=display">d(x) = (a(x)\times x - \sum_{j=0}^{a(x)}x_j) + (\sum_{i=0}^{b(x)}x_i - b(x)\times x) \qquad (x_j < x < x_i)</script>对于给定的 $y$ 我们只需要找到所上边缘小于 $y$ 的矩形数目 $a(y)$, 以及找到所有下边缘大于 $y$ 的矩形数目 $b(y)$.我们可以知道它的计算公式为:<script type="math/tex; mode=display">d(y) = (a(y)\times y - \sum_{j=0}^{a(y)}y_j) + (\sum_{i=0}^{b(y)}y_i - b(y)\times y) \qquad (y_j < y < y_i)</script></li><li>我们可以找到最小的 $d(x) + d(y)$ 即可.我们可以依次遍历所有的可能的坐标，对于每个一个坐标 $x$ 我们依次求即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N\lg(N))$,其中 $N$ 为所有矩形物品的数目.</li><li>空间复杂度: $O(N)$,其中 $N$ 为所有矩形物品的数目.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    ll x1,y1,x2,y2;</span><br><span class="line">    ll x,y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; px1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; px2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; py1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; py2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; sumx(k+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; sumy(k+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arrx;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        px1.push_back(x1);</span><br><span class="line">        px2.push_back(x2);</span><br><span class="line">        arrx.push_back(x1);</span><br><span class="line">        arrx.push_back(x2);</span><br><span class="line">        py1.push_back(y1);</span><br><span class="line">        py2.push_back(y2);</span><br><span class="line">        arry.push_back(y1);</span><br><span class="line">        arry.push_back(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    ll distx = LLONG_MAX;</span><br><span class="line">    ll disty = LLONG_MAX;</span><br><span class="line">    sort(px1.begin(),px1.end());</span><br><span class="line">    sort(px2.begin(),px2.end());</span><br><span class="line">    sort(py1.begin(),py1.end());</span><br><span class="line">    sort(py2.begin(),py2.end());</span><br><span class="line">    sort(arrx.begin(),arrx.end());</span><br><span class="line">    sort(arry.begin(),arry.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sumx[i] = sumx[i+<span class="number">1</span>] + px1[i];</span><br><span class="line">        sumy[i] = sumy[i+<span class="number">1</span>] + py1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll pre = <span class="number">0</span>;</span><br><span class="line">    ll l1 = <span class="number">0</span>;</span><br><span class="line">    ll l2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrx.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; k &amp;&amp; px2[l2] &lt;= arrx[i])&#123;</span><br><span class="line">            pre += px2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; k &amp;&amp; px1[l1] &lt;= arrx[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arrx[i] - pre + (sumx[l1] - (k-l1)*arrx[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; distx) &#123;</span><br><span class="line">            distx = curr;</span><br><span class="line">            x = arrx[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arry.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt; k &amp;&amp; py2[l2] &lt;= arry[i]) &#123;</span><br><span class="line">            pre += py2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt; k &amp;&amp; py1[l1] &lt;= arry[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arry[i] - pre + (sumy[l1] - (k-l1)*arry[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; disty) &#123;</span><br><span class="line">            disty = curr;</span><br><span class="line">            y = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="problem-C"><a href="#problem-C" class="headerlink" title="problem C"></a>problem C</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Problem<br>Barbara goes to Alan’s banana farm, where the N banana trees are organized in one long line represented by an array B. The tree at position i has Bi banana bunches. Each tree has the same cost. Once Barbara buys a tree, she gets all the banana bunches on that tree.<br>Alan has a special rule: because he does not want too many gaps in his line, he allows Barbara to buy at most 2 contiguous sections of his banana tree line.</p><p>Barbara wants to buy some number of trees such that the total number of banana bunches on these purchased trees equals the capacity K of her basket. She wants to do this while spending as little money as possible. How many trees should she buy?</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>Each test case begins with a line containing two integers integer N, the number of trees on Alan’s farm, and K, the capacity of Barbara’s basket.<br>The next line contains N non-negative integers $B1,B2,…,BN$ representing array B, where the i-th integer represents the number of banana bunches on the i-th tree on Alan’s farm.<br><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of trees Barbara must purchase to obtain K banana bunches using at most 2 contiguous sections of the farm, or -1 if it is impossible to do so.</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目虽然不是很难, 但是感觉出的非常好.题目要求找到最多两个非重复的连续子序列的和等于 $k$ 的最短长度,我们设 $dp[i]$ 表示连续子序列的和等于 $i$ 的最短长度.</li><li>我们每次从 $i$ 开始往后遍历, 找到从 $i$ 到 $n$ 的连续子序列的和等于 $x$ 的最短长度. 我们从 $i$ 往前开始往前遍历,依次遍历每一个截至到 $i$ 的连续子序列的和 $curr$ ,同时我们从 $i+1$ 往后找到 $dp[k-curr]$.<br><img src="https://i.loli.net/2021/10/27/fg5rpOQyvUw3iIc.png" alt><br>我们找到递推公式如下:<script type="math/tex; mode=display">dp[k] = min(dp[k], x + d[k-i])</script></li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n\times k)$ , 其中 $n$ 为数组的长度, $k$ 为目标要求的和.</li><li>空间复杂度分析: 空间复杂度为$O(k)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    arr = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(k+<span class="number">1</span>,n+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k) &#123;</span><br><span class="line">                dp[k] = min(dp[k],dp[k-curr]+i+<span class="number">1</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k)&#123;</span><br><span class="line">                dp[curr] = min(dp[curr],j+<span class="number">1</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(dp[k] &gt; n ? <span class="number">-1</span> : dp[k])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-round-G&quot;&gt;&lt;a href=&quot;#kickstart-2021-round-G&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 round G&quot;&gt;&lt;/a&gt;kickstart 2021 round G&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kickstart&lt;/code&gt;的算法果真还是非常的有难度,比力扣的难度大太多了.感觉还是智商不够，现在感觉 $\textit{leetcode}$ 上面只有 $\textit{hard}$ 题目比较感兴趣了，中等难度及以下，感觉基本上就是重复了。感觉每次比赛的第二题和第三题的质量非常高，非常适合新手练习和比赛．&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest  263</title>
    <link href="http://yoursite.com/2021/10/17/336/"/>
    <id>http://yoursite.com/2021/10/17/336/</id>
    <published>2021-10-17T04:47:30.652Z</published>
    <updated>2021-10-24T04:57:47.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-263"><a href="#leetcode-contest-263" class="headerlink" title="leetcode contest 263"></a>leetcode contest 263</h1><p>终于做出了四题,真心是智商不够,勤奋来补.前三题真心比较简单的题目．<br><img src="https://i.loli.net/2021/10/17/EUrTcu1xCHyNWbY.png" alt></p><h3 id="5902-检查句子中的数字是否递增"><a href="#5902-检查句子中的数字是否递增" class="headerlink" title="5902. 检查句子中的数字是否递增"></a>5902. 检查句子中的数字是否递增</h3><p>句子是由若干 <code>token</code> 组成的一个列表，<code>token</code> 间用 单个 空格分隔，句子没有前导或尾随空格。每个 <code>token</code> 要么是一个由数字 <code>0-9</code> 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。</p><a id="more"></a><p>示例，<code>&quot;a puppy has 2 eyes 4 legs&quot;</code> 是一个由 7 个 <code>token</code> 组成的句子：<code>&quot;2&quot;</code> 和 <code>&quot;4&quot;</code> 是数字，其他像 <code>&quot;puppy&quot;</code> 这样的 <code>tokens</code> 属于单词。<br>给你一个表示句子的字符串 <code>s</code>，你需要检查 <code>s</code>中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，<code>s</code> 中的 每个 数字都严格小于它 右侧 的数字）。</p><p>如果满足题目要求，返回 <code>true</code>，否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">example<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"1 box has 3 blue 4 red 6 green and 12 yellow marbles"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：句子中的数字是：<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">12</span> 。</span><br><span class="line">这些数字是按从左到右严格递增的 <span class="number">1</span> &lt; <span class="number">3</span> &lt; <span class="number">4</span> &lt; <span class="number">6</span> &lt; <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hello world 5 x 5"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：句子中的数字是：<span class="number">5</span>, <span class="number">5</span> 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">example<span class="number">-3</span></span><br><span class="line"></span><br><span class="line">输入：s = <span class="string">"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 中的数字是：<span class="number">7</span>, <span class="number">51</span>, <span class="number">50</span>, <span class="number">60</span> 。这些数字不是严格递增的。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"4 5 11 26"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 中的数字是：<span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">26</span> 。</span><br><span class="line">这些数字是按从左到右严格递增的：<span class="number">4</span> &lt; <span class="number">5</span> &lt; <span class="number">11</span> &lt; <span class="number">26</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 200</code></li><li><code>s</code> 由小写英文字母、空格和数字 0 到 9 组成（包含 0 和 9）</li><li><code>s</code> 中数字 <code>token</code> 的数目在 <code>2</code> 和 <code>100</code> 之间（包含 2 和 100）</li><li><code>s</code> 中的 <code>token</code> 之间由单个空格分隔</li><li><code>s</code> 中至少有 两个 数字</li><li><code>s</code> 中的每个数字都是一个 小于 <code>100</code> 的 正 数，且不含前导零</li><li><code>s</code> 不含前导或尾随空格</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-263/problems/check-if-numbers-are-ascending-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  字符串</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们取出字符串中的所有数字即可,然后判断数组是否严格递增。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为字符串的长度,我们此时需要遍历一遍即可。</li><li>空间复杂度: $O(N)$,其中 $N$ 为字符串的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">areNumbersAscending</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; s.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; s.size() &amp;&amp; !(s[pos] &gt;= <span class="string">'0'</span> &amp;&amp; s[pos] &lt;= <span class="string">'9'</span>))&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(pos &lt; s.size())&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; s.size() &amp;&amp; s[pos] &gt;= <span class="string">'0'</span> &amp;&amp; s[pos] &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                    curr = curr*<span class="number">10</span> + s[pos] - <span class="string">'0'</span>;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">                arr.push_back(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5903-简易银行系统"><a href="#5903-简易银行系统" class="headerlink" title="5903. 简易银行系统"></a>5903. 简易银行系统</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 <code>n</code>个账户，编号从 <code>1</code>到 <code>n</code> 。每个账号的初始余额存储在一个下标从 <code>0</code>开始的整数数组 <code>balance</code> 中，其中第 <code>(i + 1)</code>个账户的初始余额是 <code>balance[i]</code> 。</p><p>请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：</p><ul><li>指定的账户数量在 <code>1</code> 和 <code>n</code> 之间，且</li><li>取款或者转账需要的钱的总数 小于或者等于 账户余额。<br>实现<code>Bank</code> 类：</li><li><code>Bank(long[] balance)</code> 使用下标从 0 开始的整数数组 <code>balance</code> 初始化该对象。</li><li><code>boolean transfer(int account1, int account2, long money)</code> 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。</li><li><code>boolean deposit(int account, long money)</code> 向编号为 <code>account</code> 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 <code>false</code> 。</li><li><code>boolean withdraw(int account, long money)</code> 从编号为 <code>account</code> 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。</li></ul><p>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"Bank"</span>, <span class="string">"withdraw"</span>, <span class="string">"transfer"</span>, <span class="string">"deposit"</span>, <span class="string">"transfer"</span>, <span class="string">"withdraw"</span>]</span><br><span class="line">[[[<span class="number">10</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">30</span>]], [<span class="number">3</span>, <span class="number">10</span>], [<span class="number">5</span>, <span class="number">1</span>, <span class="number">20</span>], [<span class="number">5</span>, <span class="number">20</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">15</span>], [<span class="number">10</span>, <span class="number">50</span>]]</span><br><span class="line">输出：</span><br><span class="line">[<span class="literal">null</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">Bank bank = new Bank([<span class="number">10</span>, <span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">30</span>]);</span><br><span class="line">bank.withdraw(<span class="number">3</span>, <span class="number">10</span>);    <span class="comment">// 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。</span></span><br><span class="line">                         <span class="comment">// 账户 3 余额为 $20 - $10 = $10 。</span></span><br><span class="line">bank.transfer(<span class="number">5</span>, <span class="number">1</span>, <span class="number">20</span>); <span class="comment">// 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。</span></span><br><span class="line">                         <span class="comment">// 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。</span></span><br><span class="line">bank.deposit(<span class="number">5</span>, <span class="number">20</span>);     <span class="comment">// 返回 true ，可以向账户 5 存款 $20 。</span></span><br><span class="line">                         <span class="comment">// 账户 5 的余额为 $10 + $20 = $30 。</span></span><br><span class="line">bank.transfer(<span class="number">3</span>, <span class="number">4</span>, <span class="number">15</span>); <span class="comment">// 返回 false ，账户 3 的当前余额是 $10 。</span></span><br><span class="line">                         <span class="comment">// 所以无法转账 $15 。</span></span><br><span class="line">bank.withdraw(<span class="number">10</span>, <span class="number">50</span>);   <span class="comment">// 返回 false ，交易无效，因为账户 10 并不存在。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == balance.length</code></li><li><code>1 &lt;= n, account, account1, account2 &lt;= 105</code></li><li><code>0 &lt;= balance[i], money &lt;= 1012</code></li><li><code>transfer</code>, <code>deposit</code>, <code>withdraw</code> 三个函数，每个 最多调用 104 次</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/simple-bank-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/simple-bank-system</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,用数组记录记录相同当前拥有的钱的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(1)$.</li><li>空间复杂度分析: 空间复杂度为$O(n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Bank(<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&amp; balance) &#123;</span><br><span class="line">        arr = balance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> account1, <span class="keyword">int</span> account2, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account1--;</span><br><span class="line">        account2--;</span><br><span class="line">        <span class="keyword">if</span>(account1 &gt;= arr.size()||account2 &gt;= arr.size()) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[account1] &lt; money)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[account1] -= money;</span><br><span class="line">        arr[account2] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account--;</span><br><span class="line">        <span class="keyword">if</span>(account &gt;= arr.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[account] += money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> account, <span class="keyword">long</span> <span class="keyword">long</span> money)</span> </span>&#123;</span><br><span class="line">        account--;</span><br><span class="line">        <span class="keyword">if</span>(account &gt;= arr.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[account] &lt; money)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        arr[account] -= money;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Bank object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Bank* obj = new Bank(balance);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;transfer(account1,account2,money);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;deposit(account,money);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;withdraw(account,money);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5904-统计按位或能得到最大值的子集数目"><a href="#5904-统计按位或能得到最大值的子集数目" class="headerlink" title="5904. 统计按位或能得到最大值的子集数目"></a>5904. 统计按位或能得到最大值的子集数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你找出 <code>nums</code> 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。</p><p>如果数组 <code>a</code> 可以由数组 <code>b</code> 删除一些元素（或不删除）得到，则认为数组 a 是数组 <code>b</code> 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。</p><p>对数组 <code>a</code> 执行 按位或 ，结果等于 <code>a[0] OR a[1] OR ... OR a[a.length - 1]</code>（下标从 0 开始）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子集按位或能得到的最大值是 <span class="number">3</span> 。有 <span class="number">2</span> 个子集按位或可以得到 <span class="number">3</span> ：</span><br><span class="line">- [<span class="number">3</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] 的所有非空子集的按位或都可以得到 <span class="number">2</span> 。总共有 <span class="number">23</span> - <span class="number">1</span> = <span class="number">7</span> 个子集。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：子集按位或可能的最大值是 <span class="number">7</span> 。有 <span class="number">6</span> 个子集按位或可以得到 <span class="number">7</span> ：</span><br><span class="line">- [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">- [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 16</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 状态子集</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先我们需要找到或的最大值，此时我们只需要将数组中所有元素进行或运算，即可得到最大元素 $maxV$．</li><li>其次我们遍历该数组的所有子集,对所有子集的元素进行或运算,检测子集元素或运算后的结果是否与 $maxV$ 相等.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(2^N + N)$,其中 $N$ 为数组的长度 .</li><li>空间复杂度为 $O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countMaxOrSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            maxnum |= v;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr |= nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == maxnum)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5905-到达目的地的第二短时间"><a href="#5905-到达目的地的第二短时间" class="headerlink" title="5905. 到达目的地的第二短时间"></a>5905. 到达目的地的第二短时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>城市用一个 双向连通 图表示，图中有 <code>n</code> 个节点，从 1 到 <code>n</code> 编号（包含 1 和 <code>n</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中每个 <code>edges[i] = [ui, vi]</code> 表示一条节点 <code>ui</code> 和节点 <code>vi</code> 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 <code>time</code> 分钟。</p><p>每个节点都有一个交通信号灯，每 <code>change</code> 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。</p><p>第二小的值 是 严格大于 最小值的所有值中最小的值。</p><p>例如，<code>[2, 3, 4]</code> 中第二小的值是 <code>3</code> ，而 <code>[2, 2, 4]</code> 中第二小的值是 4 。<br>给你 <code>n、edges、time</code> 和 <code>change</code> ，返回从节点 1 到节点 n 需要的 第二短时间 。</p><p>注意：</p><ul><li>你可以 任意次 穿过任意顶点，包括<code>1</code>和 <code>n</code> 。</li><li>你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], time = <span class="number">3</span>, change = <span class="number">5</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">上面的左图展现了给出的城市交通图。</span><br><span class="line">右图中的蓝色路径是最短时间路径。</span><br><span class="line">花费的时间是：</span><br><span class="line">- 从节点 <span class="number">1</span> 开始，总花费时间=<span class="number">0</span></span><br><span class="line">- <span class="number">1</span> -&gt; <span class="number">4</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">3</span></span><br><span class="line">- <span class="number">4</span> -&gt; <span class="number">5</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">6</span></span><br><span class="line">因此需要的最小时间是 <span class="number">6</span> 分钟。</span><br><span class="line"></span><br><span class="line">右图中的红色路径是第二短时间路径。</span><br><span class="line">- 从节点 <span class="number">1</span> 开始，总花费时间=<span class="number">0</span></span><br><span class="line">- <span class="number">1</span> -&gt; <span class="number">3</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">3</span></span><br><span class="line">- <span class="number">3</span> -&gt; <span class="number">4</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">6</span></span><br><span class="line">- 在节点 <span class="number">4</span> 等待 <span class="number">4</span> 分钟，总花费时间=<span class="number">10</span></span><br><span class="line">- <span class="number">4</span> -&gt; <span class="number">5</span>：<span class="number">3</span> 分钟，总花费时间=<span class="number">13</span></span><br><span class="line">因此第二短时间是 <span class="number">13</span> 分钟。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>]], time = <span class="number">3</span>, change = <span class="number">2</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">最短时间路径是 <span class="number">1</span> -&gt; <span class="number">2</span> ，总花费时间 = <span class="number">3</span> 分钟</span><br><span class="line">最短时间路径是 <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> ，总花费时间 = <span class="number">11</span> 分钟</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 104</code></li><li><code>n - 1 &lt;= edges.length &lt;= min(2 * 104, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= ui, vi &lt;= n</code></li><li><code>ui != vi</code></li><li>不含重复边</li><li>每个节点都可以从其他节点直接或者间接到达</li><li><code>1 &lt;= time, change &lt;= 103</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination" target="_blank" rel="noopener">https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra求最短路径</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先我们来分析如何求从节点 $1$ 到节点 $n$ 的花费的最小时间,这个实际上我们利用 <code>dijistra</code>求最短距离即可,　难点在已知达到当前节点 $i$ 的时间为 $t_{i}$,我们需要需要计算到底相邻节点的 $j$ 的时间为多少,分为以下两种情形:</li></ol><ul><li>达到当前节点如果刚好处于绿灯时,则我们到达节点 $j$ 的时间为 $t_{j} = t_{i} + time$. 此时我们只需要判断当前时间$t_{i} + change - 1$ 除以 $change$ 之后的轮次为奇数. </li><li>达到当前节点如果刚好处于红灯时,首先我们需要等待红灯变为绿灯,等待的时间计算公式为 $wait = change - t_{i} \% change$,则我们到达节点 $j$ 的时间为 $t_{j} = t_{i} + change - t_{i} \% change + time$. 此时我们只需要判断当前时间$t_{i} + change - 1$ 除以 $change$ 之后的轮次为偶数. </li></ul><ol><li>我们通过一的分析可以看出,如果求出花费的最短时间,还是非常容易的,但是题目中要求求出花费的第二少的,则此时我们只需要记录每个访问每个节点花费最少的两个时间值,而我们这样计算的过程中肯定可以得到到达节点 $n$ 的花费时间时间第二小的值.我们对于每个节点的花费时间更新如下,我们设 $dp[i][0],dp[i][1]$ 表示到达节点 $i$ 的最小和第二小的花费的时间,则我们每次更新规则如下: </li></ol><ul><li>如果当前计算的时间$t_{i}$小于到节点 $i$ 的最小时间 $dp[i][0]$,即$t_{i} &lt; dp[i][0]$,则我们将 $dp[i][0] = t_{i},dp[i][1] = dp[i][0]$.</li><li>如果当前计算的时间$t_{i}$大于到节点 $i$ 的最小时间 $dp[i][0]$且小于到节点 $i$ 的第二小的时间 $dp[i][1]$,即此时满足 $dp[i][0] &lt; t_{i} &lt; dp[i][1]$,则我们将 $dp[i][1] = t_{i}$.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(2*N + M)$, 其中 $N$ 为节点的个数, $M$ 为边的个数.</li><li>空间复杂度分析: $O(N)$,其中 $N$ 为节点的个数.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">secondMinimum</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> time, <span class="keyword">int</span> change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,INF));</span><br><span class="line">        priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            v[<span class="number">0</span>]--;</span><br><span class="line">            v[<span class="number">1</span>]--;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        pq.push(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            pii curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr.second == n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans.insert(curr.first);</span><br><span class="line">                <span class="keyword">if</span>(ans.size() &gt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.second])&#123;</span><br><span class="line">                <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((curr.first/change)%<span class="number">2</span> == <span class="number">0</span>)&#123; <span class="comment">// current round is green</span></span><br><span class="line">                    cost = curr.first + time;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">//current round is red</span></span><br><span class="line">                    cost = curr.first + time + (change - curr.first%change);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cost &lt; dp[v][<span class="number">0</span>])&#123;</span><br><span class="line">                    swap(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]);</span><br><span class="line">                    dp[v][<span class="number">0</span>] = cost;</span><br><span class="line">                    pq.push(make_pair(cost,v));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[v][<span class="number">0</span>] &lt; cost &amp;&amp; cost &lt; dp[v][<span class="number">1</span>] )&#123;</span><br><span class="line">                    dp[v][<span class="number">1</span>] = cost;</span><br><span class="line">                    pq.push(make_pair(cost,v));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *ans.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://https://mike-box.github.io/" target="_blank" rel="noopener">http://https://mike-box.github.io/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-263&quot;&gt;&lt;a href=&quot;#leetcode-contest-263&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 263&quot;&gt;&lt;/a&gt;leetcode contest 263&lt;/h1&gt;&lt;p&gt;终于做出了四题,真心是智商不够,勤奋来补.前三题真心比较简单的题目．&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/10/17/EUrTcu1xCHyNWbY.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;5902-检查句子中的数字是否递增&quot;&gt;&lt;a href=&quot;#5902-检查句子中的数字是否递增&quot; class=&quot;headerlink&quot; title=&quot;5902. 检查句子中的数字是否递增&quot;&gt;&lt;/a&gt;5902. 检查句子中的数字是否递增&lt;/h3&gt;&lt;p&gt;句子是由若干 &lt;code&gt;token&lt;/code&gt; 组成的一个列表，&lt;code&gt;token&lt;/code&gt; 间用 单个 空格分隔，句子没有前导或尾随空格。每个 &lt;code&gt;token&lt;/code&gt; 要么是一个由数字 &lt;code&gt;0-9&lt;/code&gt; 组成的不含前导零的 正整数 ，要么是一个由小写英文字母组成的 单词 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest Biweekly 63</title>
    <link href="http://yoursite.com/2021/10/17/335/"/>
    <id>http://yoursite.com/2021/10/17/335/</id>
    <published>2021-10-16T16:15:37.295Z</published>
    <updated>2021-10-17T09:07:45.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-63"><a href="#leetcode-biweekly-63" class="headerlink" title="leetcode biweekly 63"></a>leetcode biweekly 63</h1><p>还是继续三道题的节奏。最后一题一开始的方法都弄错了,真心是智商不够.前三题确实太简单了.</p><h3 id="5885-使每位学生都有座位的最少移动次数"><a href="#5885-使每位学生都有座位的最少移动次数" class="headerlink" title="5885. 使每位学生都有座位的最少移动次数"></a>5885. 使每位学生都有座位的最少移动次数</h3><p>一个房间里有 <code>n</code>个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 <code>seats[i]</code> 是第 i 个座位的位置。同时给你一个长度为 n 的数组 <code>students</code> ，其中<code>students[j]</code> 是第 <code>j</code> 位学生的位置。</p><a id="more"></a><p>你可以执行以下操作任意次：</p><p>增加或者减少第<code>i</code>位学生的位置，每次变化量为 <code>1</code> （也就是将第 <code>i</code> 位学生从位置 <code>x</code> 移动到 <code>x + 1</code> 或者 <code>x - 1</code>）<br>请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。</p><p>请注意，初始时有可能有多个座位或者多位学生在 同一 位置。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>], students = [<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生从位置 <span class="number">2</span> 移动到位置 <span class="number">1</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第二位学生从位置 <span class="number">7</span> 移动到位置 <span class="number">5</span> ，移动 <span class="number">2</span> 次。</span><br><span class="line">- 第三位学生从位置 <span class="number">4</span> 移动到位置 <span class="number">3</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">总共 <span class="number">1</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">4</span> 次移动。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>], students = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生不移动。</span><br><span class="line">- 第二位学生从位置 <span class="number">3</span> 移动到位置 <span class="number">4</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第三位学生从位置 <span class="number">2</span> 移动到位置 <span class="number">5</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">- 第四位学生从位置 <span class="number">6</span> 移动到位置 <span class="number">9</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">总共 <span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">3</span> = <span class="number">7</span> 次移动。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">输入：seats = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>], students = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：学生移动方式如下：</span><br><span class="line">- 第一位学生从位置 <span class="number">1</span> 移动到位置 <span class="number">2</span> ，移动 <span class="number">1</span> 次。</span><br><span class="line">- 第二位学生从位置 <span class="number">3</span> 移动到位置 <span class="number">6</span> ，移动 <span class="number">3</span> 次。</span><br><span class="line">- 第三位学生不移动。</span><br><span class="line">- 第四位学生不移动。</span><br><span class="line">总共 <span class="number">1</span> + <span class="number">3</span> + <span class="number">0</span> + <span class="number">0</span> = <span class="number">4</span> 次移动。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ `n == seats.length == students.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= seats[i], students[j] &lt;= <span class="number">100</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/minimum-number-of-moves-to-seat-everyone/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 最小交换次数一定是按照编号的大小与位置的大小是一一对应的，可以用反证法来证明。</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度: $O(N \lg N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</span><br><span class="line">+ 空间复杂度: $O(<span class="number">1</span>)$.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minMovesToSeat(vector&lt;<span class="built_in">int</span>&gt;&amp; seats, vector&lt;<span class="built_in">int</span>&gt;&amp; students) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = seats.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(seats.begin(),seats.end());</span><br><span class="line">        sort(students.begin(),students.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += abs(students[i] - seats[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5886-如果相邻两个颜色均相同则删除当前颜色"><a href="#5886-如果相邻两个颜色均相同则删除当前颜色" class="headerlink" title="5886. 如果相邻两个颜色均相同则删除当前颜色"></a>5886. 如果相邻两个颜色均相同则删除当前颜色</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>总共有 <code>n</code> 个颜色片段排成一列，每个颜色片段要么是 <code>&#39;A&#39;</code> 要么是 <code>&#39;B&#39;</code>。给你一个长度为 <code>n</code> 的字符串 <code>colors</code>，其中 <code>colors[i]</code> 表示第 <code>i</code> 个颜色片段的颜色。</p><p><code>Alice</code> 和 <code>Bob</code> 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。<code>Alice</code> 先手 。</p><p>如果一个颜色片段为 ‘A’ 且 相邻两个颜色 都是颜色 ‘A’ ，那么 <code>Alice</code> 可以删除该颜色片段。Alice 不可以 删除任何颜色 ‘B’ 片段。<br>如果一个颜色片段为 ‘B’ 且 相邻两个颜色 都是颜色 ‘B’ ，那么 <code>Bob</code> 可以删除该颜色片段。<code>Bob</code> 不可以 删除任何颜色 ‘A’ 片段。<br><code>Alice</code> 和 <code>Bob</code> 不能 从字符串两端删除颜色片段。<br>如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。<br>假设 <code>Alice</code> 和 <code>Bob</code> 都采用最优策略，如果 <code>Alice</code> 获胜，请返回 <code>true</code>，否则 <code>Bob</code> 获胜，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"AAABABB"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：</span><br><span class="line">AAABABB -&gt; AABABB</span><br><span class="line">Alice 先操作。</span><br><span class="line">她删除从左数第二个 <span class="string">'A'</span> ，这也是唯一一个相邻颜色片段都是 <span class="string">'A'</span> 的 <span class="string">'A'</span> 。</span><br><span class="line"></span><br><span class="line">现在轮到 Bob 操作。</span><br><span class="line">Bob 无法执行任何操作，因为没有相邻位置都是 <span class="string">'B'</span> 的颜色片段 <span class="string">'B'</span> 。</span><br><span class="line">因此，Alice 获胜，返回 <span class="keyword">true</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：colors = <span class="string">"AA"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">Alice 先操作。</span><br><span class="line">只有 <span class="number">2</span> 个 <span class="string">'A'</span> 且它们都在字符串的两端，所以她无法执行任何操作。</span><br><span class="line">因此，Bob 获胜，返回 <span class="keyword">false</span> 。</span><br><span class="line">示例 <span class="number">3</span>：</span><br><span class="line"></span><br><span class="line">输入：colors = <span class="string">"ABBBBBBBAAA"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">ABBBBBBBAAA -&gt; ABBBBBBBAA</span><br><span class="line">Alice 先操作。</span><br><span class="line">她唯一的选择是删除从右数起第二个 <span class="string">'A'</span> 。</span><br><span class="line"></span><br><span class="line">ABBBBBBBAA -&gt; ABBBBBBAA</span><br><span class="line">接下来轮到 Bob 操作。</span><br><span class="line">他有许多选择，他可以选择任何一个 <span class="string">'B'</span> 删除。</span><br><span class="line"></span><br><span class="line">然后轮到 Alice 操作，她无法删除任何片段。</span><br><span class="line">所以 Bob 获胜，返回 <span class="keyword">false</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= colors.length &lt;= 105</code></li><li><code>colors</code> 只包含字母 <code>&#39;A&#39;</code> 和 <code>&#39;B&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数组</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,我们只需要求出字符串中<code>&quot;AAA&quot;</code>与<code>&quot;BBB&quot;</code>的个数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n)$，需要一次遍历即可.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">winnerOfGame</span><span class="params">(<span class="built_in">string</span> colors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = colors.size();</span><br><span class="line">        <span class="keyword">int</span> acnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bcnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; colors[pos] == colors[curr]) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> len = pos - curr;</span><br><span class="line">            <span class="keyword">if</span>(curr &lt; n &amp;&amp; len &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(colors[curr] == <span class="string">'A'</span>) &#123;</span><br><span class="line">                    acnt += len - <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    bcnt += len - <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">             curr = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> acnt &gt; bcnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5888-网络空闲的时刻"><a href="#5888-网络空闲的时刻" class="headerlink" title="5888. 网络空闲的时刻"></a>5888. 网络空闲的时刻</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个有 <code>n</code>个服务器的计算机网络，服务器编号为 <code>0</code> 到 <code>n - 1</code>。同时给你一个二维整数数组 <code>edges</code>，其中 <code>edges[i] = [ui, vi]</code> 表示服务器 <code>ui</code> 和 <code>vi</code> 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 <code>patience</code> 。</p><p>题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p><p>编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。</p><p>在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p><ul><li>如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 <code>patience[i]</code> 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 <code>patience[i]</code> 秒 后 会重发一条信息给主服务器。</li><li>否则，该数据服务器 不会重发 信息。<br>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</li></ul><p>请返回计算机网络变为 空闲 状态的 最早秒数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]], patience = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">0</span> 秒最开始时，</span><br><span class="line">- 数据服务器 <span class="number">1</span> 给主服务器发出信息（用 <span class="number">1</span>A 表示）。</span><br><span class="line">- 数据服务器 <span class="number">2</span> 给主服务器发出信息（用 <span class="number">2</span>A 表示）。</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 秒时，</span><br><span class="line">- 信息 <span class="number">1</span>A 到达主服务器，主服务器立刻处理信息 <span class="number">1</span>A 并发出 <span class="number">1</span>A 的回复信息。</span><br><span class="line">- 数据服务器 <span class="number">1</span> 还没收到任何回复。距离上次发出信息过去了 <span class="number">1</span> 秒（<span class="number">1</span> &lt; patience[<span class="number">1</span>] = <span class="number">2</span>），所以不会重发信息。</span><br><span class="line">- 数据服务器 <span class="number">2</span> 还没收到任何回复。距离上次发出信息过去了 <span class="number">1</span> 秒（<span class="number">1</span> == patience[<span class="number">2</span>] = <span class="number">1</span>），所以它重发一条信息（用 <span class="number">2</span>B 表示）。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 秒时，</span><br><span class="line">- 回复信息 <span class="number">1</span>A 到达服务器 <span class="number">1</span> ，服务器 <span class="number">1</span> 不会再重发信息。</span><br><span class="line">- 信息 <span class="number">2</span>A 到达主服务器，主服务器立刻处理信息 <span class="number">2</span>A 并发出 <span class="number">2</span>A 的回复信息。</span><br><span class="line">- 服务器 <span class="number">2</span> 重发一条信息（用 <span class="number">2</span>C 表示）。</span><br><span class="line">...</span><br><span class="line"><span class="number">4</span> 秒时，</span><br><span class="line">- 回复信息 <span class="number">2</span>A 到达服务器 <span class="number">2</span> ，服务器 <span class="number">2</span> 不会再重发信息。</span><br><span class="line">...</span><br><span class="line"><span class="number">7</span> 秒时，回复信息 <span class="number">2</span>D 到达服务器 <span class="number">2</span> 。</span><br><span class="line"></span><br><span class="line">从第 <span class="number">8</span> 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。</span><br><span class="line">所以第 <span class="number">8</span> 秒是网络变空闲的最早时刻。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">输入：edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>]], patience = [<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：数据服务器 <span class="number">1</span> 和 <span class="number">2</span> 第 <span class="number">2</span> 秒初收到回复信息。</span><br><span class="line">从第 <span class="number">3</span> 秒开始，网络变空闲。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == patience.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `patience[<span class="number">0</span>] == <span class="number">0</span>`</span><br><span class="line">+ 对于 `<span class="number">1</span> &lt;= i &lt; n ，满足 <span class="number">1</span> &lt;= patience[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= edges.length &lt;= min(<span class="number">105</span>, n * (n - <span class="number">1</span>) / <span class="number">2</span>)`</span><br><span class="line">+ `edges[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= ui, vi &lt; n`</span><br><span class="line">+ `ui != vi`</span><br><span class="line">+ 不会有重边。</span><br><span class="line">+ 每个服务器都直接或间接与别的服务器相连。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学问题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 题目很简答,首先我们利用`BFS`求出主服务器到各个服务器的最短距离,本质上我们需要求某个服务器 $i$ 从发出在第一个消息到收到主服务器的回复的时间为 $<span class="number">2</span>*dist[i]$,然后我们可以看到在等地回复消息的这段时间内总共重发了 $\frac&#123;<span class="number">2</span>*dist[i]<span class="number">-1</span>&#125;&#123;patience[i]&#125;$ 次消息,因此我们只需要找到最后一次发送消息后,且该服务器最后一次收到回复的时间的下一秒,网络即变为空闲.我们可以知道最后一次发送消息的时间为 $\frac&#123;<span class="number">2</span>*dist[i]<span class="number">-1</span>&#125;&#123;patience[i]&#125; * patience[i]$,消息发出后等待回复的时间总共为 $<span class="number">2</span>*dist[i] + <span class="number">1</span>$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度为 $O(N)$, 我们只需要一遍`BFS`即可.</span><br><span class="line">+ 空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> networkBecomesIdle(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="built_in">int</span>&gt;&amp; patience) &#123;</span><br><span class="line">        <span class="built_in">int</span> m = edges.size();</span><br><span class="line">        <span class="built_in">int</span> n = patience.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; graph(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; dist(n,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;<span class="built_in">int</span>&gt; qu;</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="built_in">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="built_in">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : graph[curr])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    dist[v] = step;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">2</span>*dist[i] &lt;= patience[i])&#123;</span><br><span class="line">                ans = max(ans,<span class="number">2</span>*dist[i] + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = max(ans,patience[i]*((<span class="number">2</span>*dist[i] - <span class="number">1</span>)/patience[i]) + dist[i]*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5887-两个有序数组的第-K-小乘积"><a href="#5887-两个有序数组的第-K-小乘积" class="headerlink" title="5887. 两个有序数组的第 K 小乘积"></a>5887. 两个有序数组的第 K 小乘积</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个 从小到大排好序 且下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> 以及一个整数 <code>k</code> ，请你返回第 <code>k</code> （从 <code>1</code> 开始编号）小的 <code>nums1[i] * nums2[j]</code> 的乘积，其中 <code>0 &lt;= i &lt; nums1.length</code> 且 <code>0 &lt;= j &lt; nums2.length</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">5</span>], nums2 = [<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：第 <span class="number">2</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">0</span>] = <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">1</span>] = <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span></span><br><span class="line">第 <span class="number">2</span> 小的乘积为 <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>,<span class="number">4</span>], k = <span class="number">6</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：第 <span class="number">6</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">1</span>] = (<span class="number">-4</span>) * <span class="number">4</span> = <span class="number">-16</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">0</span>] = (<span class="number">-4</span>) * <span class="number">2</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">1</span>] * nums2[<span class="number">1</span>] = (<span class="number">-2</span>) * <span class="number">4</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">1</span>] * nums2[<span class="number">0</span>] = (<span class="number">-2</span>) * <span class="number">2</span> = <span class="number">-4</span></span><br><span class="line">- nums1[<span class="number">2</span>] * nums2[<span class="number">0</span>] = <span class="number">0</span> * <span class="number">2</span> = <span class="number">0</span></span><br><span class="line">- nums1[<span class="number">2</span>] * nums2[<span class="number">1</span>] = <span class="number">0</span> * <span class="number">4</span> = <span class="number">0</span></span><br><span class="line">第 <span class="number">6</span> 小的乘积为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], nums2 = [<span class="number">-3</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-6</span></span><br><span class="line">解释：第 <span class="number">3</span> 小的乘积计算如下：</span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">4</span>] = (<span class="number">-2</span>) * <span class="number">5</span> = <span class="number">-10</span></span><br><span class="line">- nums1[<span class="number">0</span>] * nums2[<span class="number">3</span>] = (<span class="number">-2</span>) * <span class="number">4</span> = <span class="number">-8</span></span><br><span class="line">- nums1[<span class="number">4</span>] * nums2[<span class="number">0</span>] = <span class="number">2</span> * (<span class="number">-3</span>) = <span class="number">-6</span></span><br><span class="line">第 <span class="number">3</span> 小的乘积为 <span class="number">-6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 5 * 104</code></li><li><code>-105 &lt;= nums1[i], nums2[j] &lt;= 105</code></li><li><code>1 &lt;= k &lt;= nums1.length * nums2.length</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是从小到大排好序的。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-smallest-product-of-two-sorted-arrays</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本题没有做出来，借鉴别人的解题思路．利用优先级队列,暴力解法,这个时间复杂度肯定会超时.我们只能考虑其他的方法，考虑二分查找．我们可以利用双指针很快的求出两个数组中的元素相乘，小于等给定元素的组合有多少个．</li><li>我们利用二分查找，每次选定一个数 $C$，然后在给定数组中查找小于等于数组的元素$C$的乘法组合个数有多少个.题目最重要的处理是对正负数的处理问题．<br>把两个数列分为正负两个部分，并且把负数的部分全部取相反数并且翻转。我们假设 <code>nums1</code> 数列被分为了 <code>p1</code> 和 <code>n1</code> 数组，<code>nums2</code> 数列被分为了 <code>p2</code> 和 <code>n2</code> 数组，随后我们统计答案的方式改为：</li></ol><ul><li><code>p1</code> 和 <code>n1</code> 的乘积中小于 $x$ 的个数</li><li><code>p2</code> 和 <code>n2</code> 的乘积中小于 $x$ 的个数</li><li><code>p1</code> 和 <code>n2</code> 的乘积中大于 $-x$ 的个数</li><li><code>p2</code> 和 <code>n1</code> 的乘积中大于 $-x$ 的个数</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*\log C)$, 利用二分查找.</li><li>空间复杂度分析: $O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3></li><li>暴力解法,超时<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">long</span> <span class="keyword">long</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a, <span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &gt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; visit;</span><br><span class="line">        </span><br><span class="line">        visit.insert(make_pair(m<span class="number">-1</span>,<span class="number">0</span>));</span><br><span class="line">        visit.insert(make_pair(<span class="number">0</span>,n<span class="number">-1</span>));</span><br><span class="line">        pq.push(Node(m<span class="number">-1</span>,<span class="number">0</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[m<span class="number">-1</span>]*nums2[<span class="number">0</span>]));</span><br><span class="line">        pq.push(Node(<span class="number">0</span>,n<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[<span class="number">0</span>]*nums2[n<span class="number">-1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(m &gt; <span class="number">1</span> &amp;&amp; n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            visit.insert(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">            pq.push(Node(<span class="number">0</span>,<span class="number">0</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[<span class="number">0</span>]*nums2[<span class="number">0</span>]));</span><br><span class="line">            visit.insert(make_pair(m<span class="number">-1</span>,n<span class="number">-1</span>));</span><br><span class="line">            pq.push(Node(m<span class="number">-1</span>,n<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[m<span class="number">-1</span>]*nums2[n<span class="number">-1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            k--;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.val;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(curr.x &lt; m<span class="number">-1</span> &amp;&amp; !visit.count(make_pair(curr.x+<span class="number">1</span>,curr.y)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x+<span class="number">1</span>,curr.y));</span><br><span class="line">                pq.push(Node(curr.x+<span class="number">1</span>,curr.y,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x+<span class="number">1</span>]*nums2[curr.y]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.y &lt; n<span class="number">-1</span> &amp;&amp; !visit.count(make_pair(curr.x,curr.y+<span class="number">1</span>)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x,curr.y+<span class="number">1</span>));</span><br><span class="line">                pq.push(Node(curr.x,curr.y+<span class="number">1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x]*nums2[curr.y+<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.x &gt; <span class="number">0</span> &amp;&amp; !visit.count(make_pair(curr.x<span class="number">-1</span>,curr.y)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x<span class="number">-1</span>,curr.y));</span><br><span class="line">                pq.push(Node(curr.x<span class="number">-1</span>,curr.y,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x<span class="number">-1</span>]*nums2[curr.y]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr.y &gt; <span class="number">0</span> &amp;&amp; !visit.count(make_pair(curr.x,curr.y<span class="number">-1</span>)))&#123;</span><br><span class="line">                visit.insert(make_pair(curr.x,curr.y<span class="number">-1</span>));</span><br><span class="line">                pq.push(Node(curr.x,curr.y<span class="number">-1</span>,(<span class="keyword">long</span> <span class="keyword">long</span>)nums1[curr.x]*nums2[curr.y<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)nums1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; <span class="number">1l</span>l * nums2[p<span class="number">-1</span>] * nums1[i] &gt;= m)</span><br><span class="line">                -- p;</span><br><span class="line">            cnt += p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p = nums2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;(<span class="keyword">int</span>)nums1.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(p != <span class="number">0</span> &amp;&amp; <span class="number">1l</span>l * nums2[p<span class="number">-1</span>] * nums1[i] &gt; m)</span><br><span class="line">                -- p;</span><br><span class="line">            cnt += nums2.size() - p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kthSmallestProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">long</span> <span class="keyword">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">0</span>), b(<span class="number">0</span>), c(<span class="number">0</span>), d(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums1)</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   a.push_back(-x);</span><br><span class="line">            <span class="keyword">else</span>    b.push_back(x);</span><br><span class="line">        reverse(a.begin(), a.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: nums2)</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span>)   c.push_back(-x);</span><br><span class="line">            <span class="keyword">else</span>    d.push_back(x);</span><br><span class="line">        reverse(c.begin(), c.end());</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">-1e18</span>, r = <span class="number">1e18</span>, m;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r - <span class="number">1</span>)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">            cnt += get(b, d, m);</span><br><span class="line">            cnt += get(a, c, m);</span><br><span class="line">            cnt += get2(a, d, -m);</span><br><span class="line">            cnt += get2(c, b, -m);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= k)</span><br><span class="line">                r = m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-63&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-63&quot; class=&quot;headerlink&quot; title=&quot;leetcode biweekly 63&quot;&gt;&lt;/a&gt;leetcode biweekly 63&lt;/h1&gt;&lt;p&gt;还是继续三道题的节奏。最后一题一开始的方法都弄错了,真心是智商不够.前三题确实太简单了.&lt;/p&gt;&lt;h3 id=&quot;5885-使每位学生都有座位的最少移动次数&quot;&gt;&lt;a href=&quot;#5885-使每位学生都有座位的最少移动次数&quot; class=&quot;headerlink&quot; title=&quot;5885. 使每位学生都有座位的最少移动次数&quot;&gt;&lt;/a&gt;5885. 使每位学生都有座位的最少移动次数&lt;/h3&gt;&lt;p&gt;一个房间里有 &lt;code&gt;n&lt;/code&gt;个座位和 n 名学生，房间用一个数轴表示。给你一个长度为 n 的数组 seats ，其中 &lt;code&gt;seats[i]&lt;/code&gt; 是第 i 个座位的位置。同时给你一个长度为 n 的数组 &lt;code&gt;students&lt;/code&gt; ，其中&lt;code&gt;students[j]&lt;/code&gt; 是第 &lt;code&gt;j&lt;/code&gt; 位学生的位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 262</title>
    <link href="http://yoursite.com/2021/10/11/334/"/>
    <id>http://yoursite.com/2021/10/11/334/</id>
    <published>2021-10-11T15:28:37.583Z</published>
    <updated>2021-10-11T15:28:45.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-262"><a href="#leetcode-contest-262" class="headerlink" title="leetcode contest 262"></a>leetcode contest 262</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.</p><h2 id="5894-至少在两个数组中出现的值"><a href="#5894-至少在两个数组中出现的值" class="headerlink" title="5894. 至少在两个数组中出现的值"></a>5894. 至少在两个数组中出现的值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">3</span> ，在全部三个数组中都出现过。</span><br><span class="line">- <span class="number">2</span> ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">2</span> ，在数组 nums2 和 nums3 中出现过。</span><br><span class="line">- <span class="number">3</span> ，在数组 nums1 和 nums2 中出现过。</span><br><span class="line">- <span class="number">1</span> ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], nums3 = [<span class="number">5</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li><li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-out-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-out-of-three</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接对每个元素统计它所在的数组的标记，如果标记大于等等于$2$,则我们认为该元素满足题目要求。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</li><li>空间复杂度: $O(N*M)$,其中 $N$ 为每个数组的最长长度, $M$ 为数组的个数.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoOutOfThree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums3) &#123;</span><br><span class="line">            cnt[v].insert(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.push_back(v.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a>5895. 获取单值网格的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 加 <code>x</code> 或 减 <code>x</code>。<br>单值网格 是全部元素都相等的网格。<br>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：可以执行下述操作使所有元素都等于 <span class="number">4</span> ： </span><br><span class="line">- <span class="number">2</span> 加 x 一次。</span><br><span class="line">- <span class="number">6</span> 减 x 一次。</span><br><span class="line">- <span class="number">8</span> 减 x 两次。</span><br><span class="line">共计 <span class="number">4</span> 次操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>]], x = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以使所有元素都等于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,典型的数学问题，首先我们需要检测该数组是否能够变成同一个元素：</li></ol><ul><li>需要满足单元格中的任意两个元素的差的绝对值可以被 $v$ 整除.</li><li>我们只需要依次检测相邻的元素的差可以被 $v$ 整除即可.</li><li>我们可以证明,最终的变换元素一定为单元格中的某个元素.</li></ul><ol><li>我们依次尝试每一个元素 $v$,尝试将网格中所有的元素都变为 $v$, 则我们需要所有小于 $v$ 的元素都加上 $x$,所有大于 $v$ 的元素都减去 $x$,$prefix[i]$ 表示前$i$个元素的前缀和,$suffix[i]$ 表示从$i$开始以后的元素的后缀和,我们依次计算得到最小的 $cost[i]$ 即可．计算$cost[i]$的公式为:<script type="math/tex; mode=display">cost[i] = \frac{(i-1)*nums[i] - prefix[i-1]}{x} + \frac{suffix[i+1]-(n-i)*nums[i]}{x}</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n<em>m</em>\lg(m<em>n))$，由于需要一次排序,因此时间复杂度为 $O(n</em>m<em>\lg(m</em>n))$.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> k = m*n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i] - arr[i<span class="number">-1</span>])%x != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            left[i+<span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">            l = (arr[i]*i - left[i])/x;</span><br><span class="line">            r = (right[i+<span class="number">1</span>] - arr[i]*(k<span class="number">-1</span>-i))/x;</span><br><span class="line">            ans = min(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a>5896. 股票价格波动</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p><p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p><p>请你设计一个算法，实现：</p><ul><li>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。</li><li>找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。</li><li>找到当前记录里股票的 最高价格 。</li><li>找到当前记录里股票的 最低价格 。<br>请你实现 <code>StockPrice</code> 类：</li><li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li><li><code>void update(int timestamp, int price)</code> 在时间点 timestamp 更新股票价格为 <code>price</code> 。</li><li><code>int current()</code> 返回股票 最新价格 。</li><li><code>int maximum()</code> 返回股票 最高价格 。</li><li><code>int minimum()</code> 返回股票 最低价格 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"StockPrice"</span>, <span class="string">"update"</span>, <span class="string">"update"</span>, <span class="string">"current"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"minimum"</span>]</span><br><span class="line">[[], [<span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">5</span>], [], [], [<span class="number">1</span>, <span class="number">3</span>], [], [<span class="number">4</span>, <span class="number">2</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">5</span>, <span class="number">10</span>, null, <span class="number">5</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 时间戳为 [1] ，对应的股票价格为 [10] 。</span></span><br><span class="line">stockPrice.update(<span class="number">2</span>, <span class="number">5</span>);  <span class="comment">// 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span></span><br><span class="line">stockPrice.current();     <span class="comment">// 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span></span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 之前时间戳为 1 的价格错误，价格更新为 3 。</span></span><br><span class="line">                          <span class="comment">// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 5 ，更正后最高价格为 5 。</span></span><br><span class="line">stockPrice.update(<span class="number">4</span>, <span class="number">2</span>);  <span class="comment">// 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span></span><br><span class="line">stockPrice.minimum();     <span class="comment">// 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= timestamp, price &lt;= 109</code></li><li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> 总 调用次数不超过 105 。</li><li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 至少 已经被调用过一次. </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stock-price-fluctuation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stock-price-fluctuation</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>Treemap</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目感觉比第二题要简单一些,我们用<code>TreeMap</code>存储股票的时间戳对应的股票价格即可,会自动按照时间早晚进行存储和更新.</li><li>我们用<code>multiset</code>存储存储股票的所有价格,当出现股票更新操作时,需要将将股票的价格从 $x$ 更新到 $y$ 时,则我们从<code>multiset</code>中删除$x$,并同时插入$y$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(\lg n)$, $\texttt{update}$的时间复杂度为$O(\lg n)$,其余的操作时间复杂度为 $O(1)$.</li><li>空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockPrice() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(timestamp))&#123;</span><br><span class="line">            <span class="built_in">log</span>.erase(<span class="built_in">log</span>.find(cnt[timestamp]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.insert(price);</span><br><span class="line">        cnt[timestamp] = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a>5897. 将数组分成两个数组并最小化数组和的差</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 两个 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。<code>nums</code> 中每个元素都需要放入两个数组之一。<br>请你返回 最小 的数组和之差。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">3</span>,<span class="number">9</span>] 和 [<span class="number">7</span>,<span class="number">3</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">3</span> + <span class="number">9</span>) - (<span class="number">7</span> + <span class="number">3</span>)) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-36</span>,<span class="number">36</span>]</span><br><span class="line">输出：<span class="number">72</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">-36</span>] 和 [<span class="number">36</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">-36</span>) - (<span class="number">36</span>)) = <span class="number">72</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">-2</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">-9</span>] 和 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">2</span> + <span class="number">4</span> + <span class="number">-9</span>) - (<span class="number">-1</span> + <span class="number">0</span> + <span class="number">-2</span>)) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>nums.length == 2 * n</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的很好,还是非常有深度的思考题目,既考虑了状态压缩,也考虑了二分查找.</li><li>如果我们直接枚举所有的含有$n$个元素的子数组的话,时间复杂度为$C_{m}^{n}$,d当$m = 30$时,则总的耗费的时间约为$C_{30}^{15}$，这时肯定会超时.</li><li>此时我们想到用折半的办法,假设数组的长度为$2n$,我们在前$n$个元素中选择$x$个元素,设这$x$个元素的和为$left[x]$;我们在后$n$个元素中选择$n-x$个元素,设这$n-x$个元素的和为$right[n-x]$,则此时我们共选出$n$个元素,这$n$个元素的和为<script type="math/tex">left[x] + right[n-x]</script>,我们设$sum$表示整个数组的元素的和,则我们此时知道两个子数组的差为<script type="math/tex">sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])|</script>,因此我们选取子数组使的上述等式的结果最小即可.</li><li>我们对上式进行变形可以得到:<script type="math/tex; mode=display">\begin{aligned}sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])| \\= |2*left[x]+2*right[n-x] - sum| \\= |(sum - 2*left[x]) - 2*right[n-x]| \\\end{aligned}</script>因此我们只需要找到满足 $(sum - 2<em>left[x])$ 与 $2</em>right[n-x]$ 尽可能的接近即可.因此我们可以对每一个$left[x]$进行枚举,然后我们可以利用二分查找找到最接近的值$2<em>right[n-x]$即可,我们利用状态压缩枚举所有的$(sum - 2</em>left[x])$的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*2^{n})$，其中$2n$表示数组的长度.</li><li>空间复杂度分析: $O(2^{n})$，其中$2n$表示数组的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = m/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    left += nums[j];</span><br><span class="line">                    right += nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[__builtin_popcount(i)].push_back(<span class="number">2</span>*right);</span><br><span class="line">            dp[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sort(arr[i].begin(),arr[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = n - __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = sum - <span class="number">2</span>*dp[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr[x].begin(),arr[x].end(),curr);</span><br><span class="line">            <span class="keyword">if</span>(it == arr[x].begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr[x].end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-262&quot;&gt;&lt;a href=&quot;#leetcode-contest-262&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 262&quot;&gt;&lt;/a&gt;leetcode contest 262&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.&lt;/p&gt;&lt;h2 id=&quot;5894-至少在两个数组中出现的值&quot;&gt;&lt;a href=&quot;#5894-至少在两个数组中出现的值&quot; class=&quot;headerlink&quot; title=&quot;5894. 至少在两个数组中出现的值&quot;&gt;&lt;/a&gt;5894. 至少在两个数组中出现的值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你三个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt; 和 &lt;code&gt;nums3&lt;/code&gt; ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 262</title>
    <link href="http://yoursite.com/2021/10/09/333/"/>
    <id>http://yoursite.com/2021/10/09/333/</id>
    <published>2021-10-09T08:29:33.238Z</published>
    <updated>2021-10-10T10:58:52.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-262"><a href="#leetcode-contest-262" class="headerlink" title="leetcode contest 262"></a>leetcode contest 262</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.</p><h2 id="5894-至少在两个数组中出现的值"><a href="#5894-至少在两个数组中出现的值" class="headerlink" title="5894. 至少在两个数组中出现的值"></a>5894. 至少在两个数组中出现的值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数数组 <code>nums1</code>、<code>nums2</code> 和 <code>nums3</code> ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">3</span> ，在全部三个数组中都出现过。</span><br><span class="line">- <span class="number">2</span> ，在数组 nums1 和 nums2 中出现过。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">1</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>], nums3 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">解释：至少在两个数组中出现的所有值为：</span><br><span class="line">- <span class="number">2</span> ，在数组 nums2 和 nums3 中出现过。</span><br><span class="line">- <span class="number">3</span> ，在数组 nums1 和 nums2 中出现过。</span><br><span class="line">- <span class="number">1</span> ，在数组 nums1 和 nums3 中出现过。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], nums2 = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>], nums3 = [<span class="number">5</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：不存在至少在两个数组中出现的值。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100</code></li><li><code>1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/two-out-of-three" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-out-of-three</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接对每个元素统计它所在的数组的标记，如果标记大于等等于$2$,则我们认为该元素满足题目要求。</li><li>复杂度分析:</li></ol><ul><li>时间复杂度: $O(N)$,其中 $N$ 为数组的长度,我们此时需要遍历两边即可。</li><li>空间复杂度: $O(N*M)$,其中 $N$ 为每个数组的最长长度, $M$ 为数组的个数.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoOutOfThree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums1)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums2)&#123;</span><br><span class="line">            cnt[v].insert(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums3) &#123;</span><br><span class="line">            cnt[v].insert(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans.push_back(v.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5895-获取单值网格的最小操作数"><a href="#5895-获取单值网格的最小操作数" class="headerlink" title="5895. 获取单值网格的最小操作数"></a>5895. 获取单值网格的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的二维整数网格 <code>grid</code> 和一个整数 <code>x</code> 。每一次操作，你可以对 <code>grid</code> 中的任一元素 加 <code>x</code> 或 减 <code>x</code>。<br>单值网格 是全部元素都相等的网格。<br>返回使网格化为单值网格所需的 最小 操作数。如果不能，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">8</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：可以执行下述操作使所有元素都等于 <span class="number">4</span> ： </span><br><span class="line">- <span class="number">2</span> 加 x 一次。</span><br><span class="line">- <span class="number">6</span> 减 x 一次。</span><br><span class="line">- <span class="number">8</span> 减 x 两次。</span><br><span class="line">共计 <span class="number">4</span> 次操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>]], x = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：可以使所有元素都等于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], x = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法使所有元素相等。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>1 &lt;= x, grid[i][j] &lt;= 104</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-a-uni-value-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目非常简答,典型的数学问题，首先我们需要检测该数组是否能够变成同一个元素：</li></ol><ul><li>需要满足单元格中的任意两个元素的差的绝对值可以被 $v$ 整除.</li><li>我们只需要依次检测相邻的元素的差可以被 $v$ 整除即可.</li><li>我们可以证明,最终的变换元素一定为单元格中的某个元素.</li></ul><ol><li>我们依次尝试每一个元素 $v$,尝试将网格中所有的元素都变为 $v$, 则我们需要所有小于 $v$ 的元素都加上 $x$,所有大于 $v$ 的元素都减去 $x$,$prefix[i]$ 表示前$i$个元素的前缀和,$suffix[i]$ 表示从$i$开始以后的元素的后缀和,我们依次计算得到最小的 $cost[i]$ 即可．计算$cost[i]$的公式为:<script type="math/tex; mode=display">cost[i] = \frac{(i-1)*nums[i] - prefix[i-1]}{x} + \frac{suffix[i+1]-(n-i)*nums[i]}{x}</script></li></ol></blockquote><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(n<em>m</em>\lg(m<em>n))$，由于需要一次排序,因此时间复杂度为 $O(n</em>m<em>\lg(m</em>n))$.</li><li>空间复杂度分析: 空间复杂度为$O(m*n)$．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> k = m*n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i] - arr[i<span class="number">-1</span>])%x != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; left(k+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; right(k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            left[i+<span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">            l = (arr[i]*i - left[i])/x;</span><br><span class="line">            r = (right[i+<span class="number">1</span>] - arr[i]*(k<span class="number">-1</span>-i))/x;</span><br><span class="line">            ans = min(ans,l + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5896-股票价格波动"><a href="#5896-股票价格波动" class="headerlink" title="5896. 股票价格波动"></a>5896. 股票价格波动</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。</p><p>不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。</p><p>请你设计一个算法，实现：</p><ul><li>更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。</li><li>找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。</li><li>找到当前记录里股票的 最高价格 。</li><li>找到当前记录里股票的 最低价格 。<br>请你实现 <code>StockPrice</code> 类：</li><li><code>StockPrice()</code> 初始化对象，当前无股票价格记录。</li><li><code>void update(int timestamp, int price)</code> 在时间点 timestamp 更新股票价格为 <code>price</code> 。</li><li><code>int current()</code> 返回股票 最新价格 。</li><li><code>int maximum()</code> 返回股票 最高价格 。</li><li><code>int minimum()</code> 返回股票 最低价格 。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"StockPrice"</span>, <span class="string">"update"</span>, <span class="string">"update"</span>, <span class="string">"current"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"maximum"</span>, <span class="string">"update"</span>, <span class="string">"minimum"</span>]</span><br><span class="line">[[], [<span class="number">1</span>, <span class="number">10</span>], [<span class="number">2</span>, <span class="number">5</span>], [], [], [<span class="number">1</span>, <span class="number">3</span>], [], [<span class="number">4</span>, <span class="number">2</span>], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, <span class="number">5</span>, <span class="number">10</span>, null, <span class="number">5</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">StockPrice stockPrice = new StockPrice();</span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">10</span>); <span class="comment">// 时间戳为 [1] ，对应的股票价格为 [10] 。</span></span><br><span class="line">stockPrice.update(<span class="number">2</span>, <span class="number">5</span>);  <span class="comment">// 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。</span></span><br><span class="line">stockPrice.current();     <span class="comment">// 返回 5 ，最新时间戳为 2 ，对应价格为 5 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。</span></span><br><span class="line">stockPrice.update(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">// 之前时间戳为 1 的价格错误，价格更新为 3 。</span></span><br><span class="line">                          <span class="comment">// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。</span></span><br><span class="line">stockPrice.maximum();     <span class="comment">// 返回 5 ，更正后最高价格为 5 。</span></span><br><span class="line">stockPrice.update(<span class="number">4</span>, <span class="number">2</span>);  <span class="comment">// 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。</span></span><br><span class="line">stockPrice.minimum();     <span class="comment">// 返回 2 ，最低价格时间戳为 4 ，价格为 2 。</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= timestamp, price &lt;= 109</code></li><li><code>update</code>，<code>current</code>，<code>maximum</code> 和 <code>minimum</code> 总 调用次数不超过 105 。</li><li><code>current</code>，<code>maximum</code> 和 <code>minimum</code> 被调用时，<code>update</code> 操作 至少 已经被调用过一次. </li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stock-price-fluctuation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stock-price-fluctuation</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> <code>Treemap</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目感觉比第二题要简单一些,我们用<code>TreeMap</code>存储股票的时间戳对应的股票价格即可,会自动按照时间早晚进行存储和更新.</li><li>我们用<code>multiset</code>存储存储股票的所有价格,当出现股票更新操作时,需要将将股票的价格从 $x$ 更新到 $y$ 时,则我们从<code>multiset</code>中删除$x$,并同时插入$y$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(\lg n)$, $\texttt{update}$的时间复杂度为$O(\lg n)$,其余的操作时间复杂度为 $O(1)$.</li><li>空间复杂度为 $O(N)$,我们需要存储所有的股票的价格.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockPrice() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(timestamp))&#123;</span><br><span class="line">            <span class="built_in">log</span>.erase(<span class="built_in">log</span>.find(cnt[timestamp]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>.insert(price);</span><br><span class="line">        cnt[timestamp] = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.rbegin()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.rbegin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">log</span>.begin();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">log</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5897-将数组分成两个数组并最小化数组和的差"><a href="#5897-将数组分成两个数组并最小化数组和的差" class="headerlink" title="5897. 将数组分成两个数组并最小化数组和的差"></a>5897. 将数组分成两个数组并最小化数组和的差</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>2 * n</code> 的整数数组。你需要将 <code>nums</code> 分成 两个 长度为 <code>n</code> 的数组，分别求出两个数组的和，并 最小化 两个数组和之 差的绝对值 。<code>nums</code> 中每个元素都需要放入两个数组之一。<br>请你返回 最小 的数组和之差。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">3</span>,<span class="number">9</span>] 和 [<span class="number">7</span>,<span class="number">3</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">3</span> + <span class="number">9</span>) - (<span class="number">7</span> + <span class="number">3</span>)) = <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-36</span>,<span class="number">36</span>]</span><br><span class="line">输出：<span class="number">72</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">-36</span>] 和 [<span class="number">36</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">-36</span>) - (<span class="number">36</span>)) = <span class="number">72</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">-2</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最优分组方案是分成 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">-9</span>] 和 [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">-2</span>] 。</span><br><span class="line">数组和之差的绝对值为 abs((<span class="number">2</span> + <span class="number">4</span> + <span class="number">-9</span>) - (<span class="number">-1</span> + <span class="number">0</span> + <span class="number">-2</span>)) = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 15</code></li><li><code>nums.length == 2 * n</code></li><li><code>-107 &lt;= nums[i] &lt;= 107</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩 + 二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的很好,还是非常有深度的思考题目,既考虑了状态压缩,也考虑了二分查找.</li><li>如果我们直接枚举所有的含有$n$个元素的子数组的话,时间复杂度为$C_{m}^{n}$,d当$m = 30$时,则总的耗费的时间约为$C_{30}^{15}$，这时肯定会超时.</li><li>此时我们想到用折半的办法,假设数组的长度为$2n$,我们在前$n$个元素中选择$x$个元素,设这$x$个元素的和为$left[x]$;我们在后$n$个元素中选择$n-x$个元素,设这$n-x$个元素的和为$right[n-x]$,则此时我们共选出$n$个元素,这$n$个元素的和为<script type="math/tex">left[x] + right[n-x]</script>,我们设$sum$表示整个数组的元素的和,则我们此时知道两个子数组的差为<script type="math/tex">sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])|</script>,因此我们选取子数组使的上述等式的结果最小即可.</li><li>我们对上式进行变形可以得到:<script type="math/tex; mode=display">\begin{aligned}sub = |(left[x]+right[n-x]) - (sum - left[x]-right[n-x])| \\= |2*left[x]+2*right[n-x] - sum| \\= |(sum - 2*left[x]) - 2*right[n-x]| \\\end{aligned}</script>因此我们只需要找到满足 $(sum - 2<em>left[x])$ 与 $2</em>right[n-x]$ 尽可能的接近即可.因此我们可以对每一个$left[x]$进行枚举,然后我们可以利用二分查找找到最接近的值$2<em>right[n-x]$即可,我们利用状态压缩枚举所有的$(sum - 2</em>left[x])$的值即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(n*2^{n})$，其中$2n$表示数组的长度.</li><li>空间复杂度分析: $O(2^{n})$，其中$2n$表示数组的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = m/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> right = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    left += nums[j];</span><br><span class="line">                    right += nums[n+j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[__builtin_popcount(i)].push_back(<span class="number">2</span>*right);</span><br><span class="line">            dp[i] = left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>].push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            sort(arr[i].begin(),arr[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = n - __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = sum - <span class="number">2</span>*dp[i];</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(arr[x].begin(),arr[x].end(),curr);</span><br><span class="line">            <span class="keyword">if</span>(it == arr[x].begin())&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it == arr[x].end())&#123;</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">                it--;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(curr - *it));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-262&quot;&gt;&lt;a href=&quot;#leetcode-contest-262&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 262&quot;&gt;&lt;/a&gt;leetcode contest 262&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。最后一题,最后五分钟才想出思路来,可惜没有时间了.&lt;/p&gt;&lt;h2 id=&quot;5894-至少在两个数组中出现的值&quot;&gt;&lt;a href=&quot;#5894-至少在两个数组中出现的值&quot; class=&quot;headerlink&quot; title=&quot;5894. 至少在两个数组中出现的值&quot;&gt;&lt;/a&gt;5894. 至少在两个数组中出现的值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你三个整数数组 &lt;code&gt;nums1&lt;/code&gt;、&lt;code&gt;nums2&lt;/code&gt; 和 &lt;code&gt;nums3&lt;/code&gt; ，请你构造并返回一个 不同 数组，且由 至少 在 两个 数组中出现的所有值组成。数组中的元素可以按 任意 顺序排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab7 Thread</title>
    <link href="http://yoursite.com/2021/10/08/332/"/>
    <id>http://yoursite.com/2021/10/08/332/</id>
    <published>2021-10-08T15:30:08.810Z</published>
    <updated>2021-10-09T05:25:32.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>感觉<code>thread lab</code>是我做的基本上最简单的<code>lab</code>了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合<code>lab</code>完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.</p><ul><li><p>时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过<code>context</code>切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．</p></li><li><p>在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到<code>CPU</code>中,而该内核线程又通过<code>trapret</code>，<code>cpu</code>恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入<code>usertrap</code>中,在<code>usertrap</code>中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃<code>CPU</code>,另一种方式是当前的进程可能需要等待挂起,主动的放弃<code>CPU</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    intr_on();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      intr_on();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>进程调度的实现原理: 在<code>xv6</code>系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的<code>Linux</code>系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.</li><li>上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的<code>ra</code>以及<code>sp</code>以及几个常用的由<code>callee</code>保存的寄存器进行保存相关的值即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li><li>本章还讲述了<code>spin lock</code>的实现原理,感觉非常清晰明了.首先我们需要知道<code>CPU</code>支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考<code>gcc</code>的文档:<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">Gcc手册中《Using the GNU Compiler Collection (GCC)》</a>.</li></ul><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line"><span class="keyword">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span></span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值</span></span><br><span class="line">__sync_synchronize (...)</span><br><span class="line"><span class="comment">// 发出完整内存栅栏</span></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义</span></span><br><span class="line"><span class="keyword">void</span> __sync_lock_release (type *ptr, ...)</span><br><span class="line"><span class="comment">// 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义</span></span><br></pre></td></tr></table></figure><ul><li>典型的<code>spin lock</code>的实现，仔细分析一下源代码：</li><li><ul><li><code>acquire</code>期间会关闭中断,这是为了防止死锁.并同时将计数加<code>1</code>.<code>release</code>时,将计数减<code>1</code>,同时会恢复中断.</li></ul></li><li><ul><li>我们会一直等待<code>lk-&gt;locked</code>变为<code>0</code>,如果<code>lk-&gt;locked</code>为<code>1</code>则会一直等待,<code>lk-&gt;locked</code>为<code>0</code>,则我们会继续进程到下一步.</li></ul></li><li><ul><li>从自旋锁的实现方式上来看,我们可以看到自旋锁的资源的消耗还是非常大的,这就需要我们谨慎的使用锁.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  push_off(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(holding(lk))</span><br><span class="line">    panic(<span class="string">"acquire"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section's memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = mycpu();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">release(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holding(lk))</span><br><span class="line">    panic(<span class="string">"release"</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn't use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">holding(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == mycpu());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">push_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> old = intr_get();</span><br><span class="line"></span><br><span class="line">  intr_off();</span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    mycpu()-&gt;intena = old;</span><br><span class="line">  mycpu()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">pop_off(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  <span class="keyword">if</span>(intr_get())</span><br><span class="line">    panic(<span class="string">"pop_off - interruptible"</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"pop_off"</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    intr_on();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>线程的切换：在XV6中，任何时候都需要经历：</p></li></ul><ol><li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存<br>用户进程的状态并运行第一个用户进程的内核线程。</li><li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li><li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li><li>最后返回到第二个用户进程继续执行。<br><img src="https://i.loli.net/2021/10/09/OuJrW8gPRQfx9nU.png" alt></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是非常简单.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Your job <span class="keyword">is</span> <span class="keyword">to</span> come up <span class="keyword">with</span> a plan <span class="keyword">to</span> create threads <span class="keyword">and</span> save/restore registers <span class="keyword">to</span> switch between threads, <span class="keyword">and</span> implement that plan. <span class="keyword">When</span> you<span class="comment">'re done, make grade should say that your solution passes the uthread test.</span></span><br></pre></td></tr></table></figure><p>实现几个基本线程的切换：上下文切换这部分最难，但是我们可以直接可以参考<code>switch.S</code>的实现，直接<code>copy</code>过来即可.关于线程切换时．每个线程都有独立的栈，我们在初始化线程时，会将线程的上下文中<code>sp</code>和<code>ra</code>进行初始化,分别指向当前线程的栈的高位地址,返回地址则指向线程的起始函数地址.</p><ul><li>最坑的一个<code>bug</code>是: 线程的栈的地址是从高地址向低地址增长,刚开始没有发现这个问题,直接将低地址赋给$sp$,然后总是出错.莫名奇妙的会改写线程的状态,总是找不到原因,最终查看,由于栈的地址是从高往低增长,我们在对栈进行操作时会覆盖掉$thread$结构体中的其他信息和内容.</li><li>关于线程的定义:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>       <span class="built_in">stack</span>[STACK_SIZE]; <span class="comment">/* the thread's stack */</span></span><br><span class="line">  <span class="keyword">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>       <span class="comment">/* thread context */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ol><li><strong>thread_switch</strong>定义：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line"><span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">    </span><br><span class="line">ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure></li><li>线程初始化：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_create(<span class="keyword">void</span> (*func)())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;t-&gt;context,<span class="number">0</span>,<span class="keyword">sizeof</span>(struct context));</span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span> + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>线程调度与切换:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">thread_schedule(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>, *<span class="title">next_thread</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread_schedule: no runnable threads\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)&amp;t-&gt;context,(uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">     next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will explore <span class="keyword">parallel</span> programming <span class="keyword">with</span> threads <span class="keyword">and</span> locks <span class="keyword">using</span> a hash table. You should <span class="keyword">do</span> this assignment <span class="keyword">on</span> a real Linux <span class="keyword">or</span> MacOS computer (<span class="keyword">not</span> xv6, <span class="keyword">not</span> qemu) that <span class="keyword">has</span> multiple cores. Most recent laptops have multicore processors.</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>在多线程下,多个线程同时更新和查找<code>hash table</code>,会出现数据竞争的问题,如何去解决该问题?很明显就是加锁，在更新<code>hash table</code>时加锁,防止两个线程同时更新<code>hash tbale</code>即可.</p></li><li><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> = 0;</span></span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pthread_mutex_lock(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you<span class="symbol">'ll</span> implement a barrier: a point <span class="keyword">in</span> an application at which <span class="keyword">all</span> participating threads must <span class="keyword">wait</span> <span class="keyword">until</span> <span class="keyword">all</span> other participating threads reach that point too. You<span class="symbol">'ll</span> <span class="keyword">use</span> pthread condition variables, which are a <span class="keyword">sequence</span> coordination technique similar <span class="keyword">to</span> xv6<span class="symbol">'s</span> sleep <span class="keyword">and</span> wakeup.</span><br></pre></td></tr></table></figure><ul><li>题目中用了多个线程的同步,实际上利用了条件变量<code>cond</code>,这个与<code>C++</code>中的条件变量实现原理类似<code>condition_variable</code>, 可以参考<code>pthread_cond_wait</code>与<code>pthread_cond_timedwait</code>的用法.<a href="https://baike.baidu.com/item/pthread_cond_wait/3011997?fr=aladdin" target="_blank" rel="noopener">cond</a></li><li><ul><li>阻塞功能: 必须和一个互斥锁配合，以防止多个线程同时请求<code>pthread_cond_wait()</code>（或<code>pthread_cond_timedwait()</code>，下同）的竞争条件（<code>Race Condition</code>）。<code>mutex</code>互斥锁必须是普通锁（<code>PTHREAD_MUTEX_TIMED_NP</code>）或者适应锁（<code>PTHREAD_MUTEX_ADAPTIVE_NP</code>），且在调用pthread_cond_wait()前必须由本线程加锁（<code>pthread_mutex_lock()</code>），而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。阻塞时处于解锁状态。</li></ul></li><li><ul><li>pthread_cond_wait进入阻塞时,则会释放锁,从而别的线程可以获取到该锁;当<code>pthread_cond_wait</code>被唤醒时,则又会加锁,因此当它唤醒后,还需要释放锁的操作.</li></ul></li><li><ul><li>在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应</li></ul></li><li><ul><li>激活功能: 激发条件有两种形式，<code>pthread_cond_signal()</code>激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而<code>pthread_cond_broadcast()</code>则激活所有等待线程。</li></ul></li><li><p>重要函数的使用说明:　使用<code>pthread_mutex_lock(&amp;mutex1)</code>;加互斥所，然后在<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;这样可以保证这期间没有<code>pthread_cond_broadcast</code>或者<code>pthread_cond_signal</code>操作，从而保证条件不会丢失，当<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line">pthread_cond_broadcast(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">barrier()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">　<span class="comment">// acquire mutex</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread)&#123;</span><br><span class="line">  bstate.round += <span class="number">1</span>;</span><br><span class="line">  bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  pthread_cond_wait(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul><li>通过这一章几个重要的原理讲解,非常清晰的了解操作系统进程调度的第层实现原理与锁的实现原理.</li><li>通过学习<code>pthread_cond_wait</code>的原理从而能够学习<code>c++</code>中<code>conditional_variable</code>的原理.</li><li>下一步计划:</li><li><ul><li>完成<code>option chanllenge</code>的<code>project</code>;</li></ul></li><li><ul><li>学习<code>conditional_variable</code>的实现原理;</li></ul></li><li><ul><li>阅读<code>pthread_cond_wait</code>的源代码.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ul></li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;thread&quot;&gt;&lt;a href=&quot;#thread&quot; class=&quot;headerlink&quot; title=&quot;thread&quot;&gt;&lt;/a&gt;thread&lt;/h1&gt;&lt;p&gt;感觉&lt;code&gt;thread lab&lt;/code&gt;是我做的基本上最简单的&lt;code&gt;lab&lt;/code&gt;了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合&lt;code&gt;lab&lt;/code&gt;完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过&lt;code&gt;context&lt;/code&gt;切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到&lt;code&gt;CPU&lt;/code&gt;中,而该内核线程又通过&lt;code&gt;trapret&lt;/code&gt;，&lt;code&gt;cpu&lt;/code&gt;恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入&lt;code&gt;usertrap&lt;/code&gt;中,在&lt;code&gt;usertrap&lt;/code&gt;中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃&lt;code&gt;CPU&lt;/code&gt;,另一种方式是当前的进程可能需要等待挂起,主动的放弃&lt;code&gt;CPU&lt;/code&gt;.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;usertrap(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; which_dev = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((r_sstatus() &amp;amp; SSTATUS_SPP) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    panic(&lt;span class=&quot;string&quot;&gt;&quot;usertrap: not from user mode&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// send interrupts and exceptions to kerneltrap(),&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// since we&#39;re now in the kernel.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  w_stvec((uint64)kernelvec);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;myproc&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// save user program counter.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  p-&amp;gt;trapframe-&amp;gt;epc = r_sepc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(r_scause() == &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// system call&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// sepc points to the ecall instruction,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// but we want to return to the next instruction.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;epc += &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// an interrupt will change sstatus &amp;amp;c registers,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// so don&#39;t enable until done with those registers.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    syscall();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;((which_dev = devintr()) != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ok&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;usertrap(): unexpected scause %p pid=%d\n&quot;&lt;/span&gt;, r_scause(), p-&amp;gt;pid);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;            sepc=%p stval=%p\n&quot;&lt;/span&gt;, r_sepc(), r_stval());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;killed = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;killed)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// give up the CPU if this is a timer interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(which_dev == &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    yield();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  usertrapret();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Avoid deadlock by ensuring that devices can interrupt.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; nproc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(p = proc; p &amp;lt; &amp;amp;proc[NPROC]; p++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      acquire(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state != UNUSED) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nproc++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;state == RUNNABLE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Switch to chosen process.  It is the process&#39;s job&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// to release its lock and then reacquire it&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// before jumping back to us.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p-&amp;gt;state = RUNNING;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        swtch(&amp;amp;c-&amp;gt;context, &amp;amp;p-&amp;gt;context);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Process is done running for now.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// It should have changed its p-&amp;gt;state before coming back.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        c-&amp;gt;proc = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      release(&amp;amp;p-&amp;gt;lock);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(nproc &amp;lt;= &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;) &amp;#123;   &lt;span class=&quot;comment&quot;&gt;// only init and sh exist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      intr_on();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;asm&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;volatile&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;string&quot;&gt;&quot;wfi&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;进程调度的实现原理: 在&lt;code&gt;xv6&lt;/code&gt;系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的&lt;code&gt;Linux&lt;/code&gt;系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.&lt;/li&gt;
&lt;li&gt;上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的&lt;code&gt;ra&lt;/code&gt;以及&lt;code&gt;sp&lt;/code&gt;以及几个常用的由&lt;code&gt;callee&lt;/code&gt;保存的寄存器进行保存相关的值即可.&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.globl swtch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;swtch:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sd s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld ra, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld sp, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s0, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s1, &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s2, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s3, &lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s4, &lt;span class=&quot;number&quot;&gt;48&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s5, &lt;span class=&quot;number&quot;&gt;56&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s6, &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s7, &lt;span class=&quot;number&quot;&gt;72&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s8, &lt;span class=&quot;number&quot;&gt;80&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s9, &lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s10, &lt;span class=&quot;number&quot;&gt;96&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ld s11, &lt;span class=&quot;number&quot;&gt;104&lt;/span&gt;(a1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;本章还讲述了&lt;code&gt;spin lock&lt;/code&gt;的实现原理,感觉非常清晰明了.首先我们需要知道&lt;code&gt;CPU&lt;/code&gt;支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考&lt;code&gt;gcc&lt;/code&gt;的文档:&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Gcc手册中《Using the GNU Compiler Collection (GCC)》&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Contest 261</title>
    <link href="http://yoursite.com/2021/10/05/331/"/>
    <id>http://yoursite.com/2021/10/05/331/</id>
    <published>2021-10-05T03:14:03.459Z</published>
    <updated>2021-10-05T08:09:41.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-261"><a href="#leetcode-contest-261" class="headerlink" title="leetcode contest 261"></a>leetcode contest 261</h1><p>周赛题目质量非常不错，还是继续三道题的节奏。</p><h2 id="2027-转换字符串的最少操作次数"><a href="#2027-转换字符串的最少操作次数" class="headerlink" title="2027. 转换字符串的最少操作次数"></a>2027. 转换字符串的最少操作次数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，由 <code>n</code> 个字符组成，每个字符不是 <code>&#39;X&#39;</code> 就是 <code>&#39;O&#39;</code> 。</p><p>一次 操作 定义为从<code>s</code>中选出 三个连续字符 并将选中的每个字符都转换为 <code>&#39;O&#39;</code>。注意，如果字符已经是 <code>&#39;O&#39;</code>，只需要保持 不变 。</p><a id="more"></a><p>返回将 <code>s</code>中所有字符均转换为 <code>&#39;O</code>‘ 需要执行的 最少 操作次数。</p><p>示例 1：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXX"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：XXX -&gt; OOO</span><br><span class="line">一次操作，选中全部 <span class="number">3</span> 个字符，并将它们转换为 <span class="string">'O'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"XXOX"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：XXOX -&gt; OOOX -&gt; OOOO</span><br><span class="line">第一次操作，选择前 <span class="number">3</span> 个字符，并将这些字符转换为 <span class="string">'O'</span> 。</span><br><span class="line">然后，选中后 <span class="number">3</span> 个字符，并执行转换。最终得到的字符串全由字符 <span class="string">'O'</span> 组成。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"OOOO"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：s 中不存在需要转换的 'X' 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 1000</code></li><li><code>s[i]</code> 为 <code>&#39;X&#39;</code> 或 <code>&#39;O&#39;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-convert-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-moves-to-convert-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接转化即可，每次尝试改变三个字符即可。</li><li>尝试所有可能性即可，时间复杂度为 $O(N)$。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumMoves</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'O'</span>) pos++;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; s[pos] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans += (curr + <span class="number">2</span>)/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(curr%<span class="number">3</span>)&#123;</span><br><span class="line">                pos += <span class="number">3</span>-(curr%<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2028-找出缺失的观测数据"><a href="#2028-找出缺失的观测数据" class="headerlink" title="2028. 找出缺失的观测数据"></a>2028. 找出缺失的观测数据</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>现有一份 <code>n + m</code> 次投掷单个 六面 骰子的观测数据，骰子的每个面从 <code>1</code>到 <code>6</code>编号。观测数据中缺失了 <code>n</code>份，你手上只拿到剩余 <code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 平均值 。</p><p>给你一个长度为<code>m</code>的整数数组 <code>rolls</code> ，其中 <code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code>。</p><p>返回一个长度为 <code>n</code> 的数组，包含所有缺失的观测数据，且满足这 <code>n + m</code> 次投掷的 平均值 是 <code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p><p><code>k</code>个数字的 平均值 为这些数字求和后再除以 <code>k</code>。</p><p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被 <code>n + m</code>整除。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], mean = <span class="number">4</span>, n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">6</span> + <span class="number">6</span>) / <span class="number">6</span> = <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], mean = <span class="number">3</span>, n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">2</span>) / <span class="number">7</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], mean = <span class="number">6</span>, n = <span class="number">4</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无论丢失的 <span class="number">4</span> 次数据是什么，平均值都不可能是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rolls = [<span class="number">1</span>], mean = <span class="number">3</span>, n = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">5</span>]</span><br><span class="line">解释：所有 n + m 次投掷的平均值是 (<span class="number">1</span> + <span class="number">5</span>) / <span class="number">2</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示:</p><ul><li><code>m == rolls.length</code></li><li><code>1 &lt;= n, m &lt;= 105</code></li><li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-missing-observations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-missing-observations</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简答，首先我们需要求出缺失的 $n$ 份数据的总和 $sum$，$sum$ 满足合法的条件为 $6 \le sum \le 6*n$.</li><li>我们可以选择任意一种方法分配即可,一种比较直接的简单方法为 $n$ 份数据中的每个元素 $nums[i] = \frac{sum}{n} + sum \mod n$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为 $O(N + M)$，所有数据的总量．</li><li>空间复杂度分析: 空间复杂度为$O(N)$,其中$N$为缺失数据的长度．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; missingRolls(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rolls, <span class="keyword">int</span> mean, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = rolls.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : rolls) sum += v;</span><br><span class="line">        <span class="keyword">int</span> tot = mean*(n+m) - sum;</span><br><span class="line">        <span class="keyword">if</span>(tot &gt; <span class="number">6</span>*n || tot &lt; n) <span class="keyword">return</span> ans;</span><br><span class="line">        ans = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[i] = tot/n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (tot%n); ++i)&#123;</span><br><span class="line">            ans[i] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2029-石子游戏-IX"><a href="#2029-石子游戏-IX" class="headerlink" title="2029. 石子游戏 IX"></a>2029. 石子游戏 IX</h2><p><code>Alice</code> 和 <code>Bob</code> 再次设计了一款新的石子游戏。现有一行 <code>n</code> 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 <code>stones</code> ，其中 <code>stones[i]</code>是第 <code>i</code>个石子的价值。</p><p><code>Alice</code> 和 <code>Bob</code> 轮流进行自己的回合，<code>Alice</code> 先手。每一回合，玩家需要从 <code>stones</code> 中移除任一石子。</p><ul><li>如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 <code>3</code> 整除，那么该玩家就 输掉游戏 。</li><li>如果不满足上一条，且移除后没有任何剩余的石子，那么 <code>Bob</code>将会直接获胜（即便是在<code>Alice</code> 的回合）。<br>假设两位玩家均采用 最佳 决策。如果<code>Alice</code> 获胜，返回 <code>true</code> ；如果 <code>Bob</code> 获胜，返回 <code>false</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：游戏进行如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除任意一个石子。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 移除剩下的石子。 </span><br><span class="line">已移除的石子的值总和为 <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> 且可以被 <span class="number">3</span> 整除。因此，Bob 输，Alice 获胜。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Alice 会移除唯一一个石子，已移除石子的值总和为 <span class="number">2</span> 。 </span><br><span class="line">由于所有石子都已移除，且值总和无法被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：</span><br><span class="line">- 回合 <span class="number">1</span>：Alice 可以移除值为 <span class="number">1</span> 的第 <span class="number">2</span> 个石子。已移除石子值总和为 <span class="number">1</span> 。</span><br><span class="line">- 回合 <span class="number">2</span>：Bob 可以移除值为 <span class="number">3</span> 的第 <span class="number">5</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> 。</span><br><span class="line">- 回合 <span class="number">3</span>：Alices 可以移除值为 <span class="number">4</span> 的第 <span class="number">4</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">8</span> 。</span><br><span class="line">- 回合 <span class="number">4</span>：Bob 可以移除值为 <span class="number">2</span> 的第 <span class="number">3</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> = <span class="number">10.</span></span><br><span class="line">- 回合 <span class="number">5</span>：Alice 可以移除值为 <span class="number">5</span> 的第 <span class="number">1</span> 个石子。已移除石子值总和为 = <span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">5</span> = <span class="number">15.</span></span><br><span class="line">Alice 输掉游戏，因为已移除石子值总和（<span class="number">15</span>）可以被 <span class="number">3</span> 整除，Bob 获胜。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stones.length &lt;= 105</code></li><li><code>1 &lt;= stones[i] &lt;= 104</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-ix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-ix</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>贪心算法，每个人都会防止当前已经取得的石子总和能够被 $3$ 整除，则 $\textit{Bob}$ 和 $\textit{Alice}$ 的最优选择一定如下:</li></ol><ul><li>如果 $\textit{Alice}$ 第一次选择的是 $1$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $1$,紧接着 $\textit{Alice}$ 选择 $2$,$Bob$会选择 $1$,二者的选择序列一定为:$1,1,2,1,2,1,2,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>如果 $\textit{Alice}$ 第一次选择的是 $2$，我们暂时不考虑能被 $3$ 整除的数，则 $Bob$ 的选择一定为 $2$,紧接着 $\textit{Alice}$ 选择 $1$,$Bob$会选择 $2$,二者的选择序列一定为:$2,2,1,2,1,2,1,…$.直达无法按照上述规律继续取石头为止,而能被 $3$ 整除的数则可以在上述序列中的任意为止插入即可,因此我们只需要找到按照上述规律组成的序列的最长长度即可.如果组成的最长长度能够被 $2$ 整除,则表示 $Bob$为最后一个取,下一次轮到 $ALICE$ 取时一定会打破上述规律,导致已经取的数据的和被 $3$ 整除.</li><li>特殊情况需要考虑的是,假如$ALICE$ 取最后一个剩余得数,则此时$ALICE$会失败.</li><li>我们只需要按照贪心算法,如果 $\textit{Alice}$ 尝试先手取 $1$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $1$;如果 $\textit{Alice}$ 尝试先手取 $2$ 能够保证 $ALICE$ 一定赢,则我们直接先手取 $2$,</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$, 其中 $N$ 表示数组的长度.</li><li>空间复杂度为 $O(1)$, 我们只需要三个变量分别存储当前数组中.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGameIX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : stones) &#123;</span><br><span class="line">            cnt[v%<span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first one:1121212....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>]<span class="number">-1</span>,cnt[<span class="number">2</span>]);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">1</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*first two:2212121....*/</span></span><br><span class="line">        <span class="keyword">if</span> (cnt[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = min(cnt[<span class="number">1</span>],cnt[<span class="number">2</span>]<span class="number">-1</span>);</span><br><span class="line">            maxlen = <span class="number">1</span> + a*<span class="number">2</span> + cnt[<span class="number">0</span>] + ((cnt[<span class="number">2</span>] - <span class="number">1</span>) &gt; a ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>((maxlen%<span class="number">2</span>) &amp;&amp; maxlen != n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="2030-含特定字母的最小子序列"><a href="#2030-含特定字母的最小子序列" class="headerlink" title="2030. 含特定字母的最小子序列"></a>2030. 含特定字母的最小子序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，一个整数 <code>k</code> ，一个字母 <code>letter</code> 以及另一个整数 <code>repetition</code>。</p><p>返回 <code>s</code>中长度为 <code>k</code>且 字典序最小 的子序列，该子序列同时应满足字母 <code>letter</code>出现 至少 <code>repetition</code> 次。生成的测试用例满足 <code>letter</code>在 <code>s</code> 中出现 至少 <code>repetition</code> 次。</p><p>子序列 是由原字符串删除一些（或不删除）字符且不改变剩余字符顺序得到的剩余字符串。</p><p>字符串 <code>a</code> 字典序比字符串 <code>b</code> 小的定义为：在 <code>a</code> 和<code>b</code>出现不同字符的第一个位置上，字符串<code>a</code>的字符在字母表中的顺序早于字符串 b 的字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leet"</span>, k = <span class="number">3</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"eet"</span></span><br><span class="line">解释：存在 <span class="number">4</span> 个长度为 <span class="number">3</span> ，且满足字母 'e' 出现至少 <span class="number">1</span> 次的子序列：</span><br><span class="line">- <span class="string">"lee"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"let"</span>（<span class="string">"leet"</span>）</span><br><span class="line">- <span class="string">"eet"</span>（<span class="string">"leet"</span>）</span><br><span class="line">其中字典序最小的子序列是 <span class="string">"eet"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">4</span>, letter = <span class="string">"e"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"ecde"</span></span><br><span class="line">解释：<span class="string">"ecde"</span> 是长度为 <span class="number">4</span> 且满足字母 <span class="string">"e"</span> 出现至少 <span class="number">2</span> 次的字典序最小的子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bb"</span>, k = <span class="number">2</span>, letter = <span class="string">"b"</span>, repetition = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"bb"</span></span><br><span class="line">解释：<span class="string">"bb"</span> 是唯一一个长度为 <span class="number">2</span> 且满足字母 <span class="string">"b"</span> 出现至少 <span class="number">2</span> 次的子序列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= repetition &lt;= k &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由小写英文字母组成</li><li><code>letter</code> 是一个小写英文字母，在 <code>s</code> 中至少出现 <code>repetition</code> 次</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们贪心算法，依次尝试 $k$个位置处所有可能的字符组合,找到索引最小且满足题目要求的组合即可.我们记录当前目标字符中已经压入到栈中的最后一个字符的索引为 $last$,我们记录当前已经压入到栈中的字符 $\textit{letter}$ 的个数,我们记录当前栈中的长度为$len$.假设我们已经找到的目标字符串的长度为 $i$, 最后一个字符的索引为 $last$,当前的目标字符串中已经包含 $\textit{letter}$ 的个数为 $repetition$,则我们在寻找第$i+1$ 个字符时,应当按照如下规则进行尝试:</li></ol><ul><li>我们从原始字符串的索引 $0$ 开始依次尝试.</li><li>我们按照字符的从小到大的顺序开始尝试,即我们从 $\texttt{‘a’}$ 到 $\texttt{‘z’}$ 开始尝试,这样才能保证字符串的字典序最小;</li><li>索引小于当前字符串的最后的索引 $last$ 的字符全部需要跳过, 这样才能保证子序列的正确顺序；</li><li>假设我们可以将当前的索引 $k$ 的字符加入到字符串中的第 $i+1$ 个字符,则必须满足以下几个条件:<ul><li>索引 $k+1$ 以后的字符串中至少还需要包含 $n - k - 1$ 个字符;</li><li>索引 $k$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$;</li><li>如果索引 $k$ 的对应的字符为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition-1$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition-1$ 个字符;如果索引 $k$ 的对应的字符不为 $letter$,则索引 $k+1$ 以后的字符串中至少还需要包含 $repetition$ 个$\textit{letter}$,且目标字符串中剩余的位置还能够满足可以放置$repetition$ 个字符;</li></ul></li></ul><ol><li>非常典型的贪心算法,感觉还算非常不错的题目,值得好好思考的题目,扩展提示如何找到满足要求且字典序最大的字符串？</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(26*K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.</li><li>空间复杂度分析: $O(K + |S|)$，其中 |S| 表示字符串的长度，$K$ 表示目标字符串的长度.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k, <span class="keyword">char</span> letter, <span class="keyword">int</span> repetition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rem(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            rem[i] = rem[i+<span class="number">1</span>] + (s[i] == letter ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">26</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[s[i] - <span class="string">'a'</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!pos[j].empty() &amp;&amp; pos[j].front() &lt; last) pos[j].pop();</span><br><span class="line">                <span class="comment">// 下一个索引处最少需要 need 个 letter</span></span><br><span class="line">                <span class="keyword">int</span> need = (j == letter - <span class="string">'a'</span>) ? repetition - <span class="number">1</span> : repetition;</span><br><span class="line">                <span class="keyword">if</span>(pos[j].empty() || rem[pos[j].front() + <span class="number">1</span>] &lt; need) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">// 剩余的字符中至少需要预留 need 个位置, 且剩余的索引中至少应该包含k - i个元素</span></span><br><span class="line">                <span class="keyword">if</span>(k - i - <span class="number">1</span> &gt;= need &amp;&amp; n - pos[j].front() &gt;= k - i) &#123;</span><br><span class="line">                    ans.push_back(<span class="string">'a'</span> + j);</span><br><span class="line">                    <span class="keyword">if</span>(j == letter - <span class="string">'a'</span>) &#123;</span><br><span class="line">                        repetition--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    last = pos[j].front();</span><br><span class="line">                    pos[j].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-261&quot;&gt;&lt;a href=&quot;#leetcode-contest-261&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 261&quot;&gt;&lt;/a&gt;leetcode contest 261&lt;/h1&gt;&lt;p&gt;周赛题目质量非常不错，还是继续三道题的节奏。&lt;/p&gt;&lt;h2 id=&quot;2027-转换字符串的最少操作次数&quot;&gt;&lt;a href=&quot;#2027-转换字符串的最少操作次数&quot; class=&quot;headerlink&quot; title=&quot;2027. 转换字符串的最少操作次数&quot;&gt;&lt;/a&gt;2027. 转换字符串的最少操作次数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，由 &lt;code&gt;n&lt;/code&gt; 个字符组成，每个字符不是 &lt;code&gt;&amp;#39;X&amp;#39;&lt;/code&gt; 就是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一次 操作 定义为从&lt;code&gt;s&lt;/code&gt;中选出 三个连续字符 并将选中的每个字符都转换为 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;。注意，如果字符已经是 &lt;code&gt;&amp;#39;O&amp;#39;&lt;/code&gt;，只需要保持 不变 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 62</title>
    <link href="http://yoursite.com/2021/10/03/330/"/>
    <id>http://yoursite.com/2021/10/03/330/</id>
    <published>2021-10-02T23:49:21.792Z</published>
    <updated>2021-10-03T06:32:30.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-62"><a href="#leetcode-biweekly-contest-62" class="headerlink" title="leetcode  biweekly contest 62"></a>leetcode  biweekly contest 62</h1><p>双周赛的题目质量还算不错，第三题竟然卡壳了好久，第四题感觉应该只能算一个中等难度题目．模拟比赛做了一下，大概排名<code>200</code>多名.</p><h2 id="5871-将一维数组转变成二维数组"><a href="#5871-将一维数组转变成二维数组" class="headerlink" title="5871. 将一维数组转变成二维数组"></a>5871. 将一维数组转变成二维数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的一维整数数组 <code>original</code> 和两个整数 <code>m</code> 和  <code>n</code>。你需要使用 <code>original</code> 中 所有 元素创建一个 <code>m</code> 行 <code>n</code> 列的二维数组。</p><a id="more"></a><p><code>original</code> 中下标从 <code>0</code> 到 <code>n - 1</code> （都 包含 ）的元素构成二维数组的第一行，下标从 <code>n</code> 到 <code>2 * n - 1</code> （都 包含 ）的元素构成二维数组的第二行，依此类推。</p><p>请你根据上述过程返回一个<code>m x n</code>的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], m = <span class="number">2</span>, n = <span class="number">2</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 <span class="number">2</span> 行 <span class="number">2</span> 列。</span><br><span class="line">original 中第一个 n=<span class="number">2</span> 的部分为 [<span class="number">1</span>,<span class="number">2</span>] ，构成二维数组的第一行。</span><br><span class="line">original 中第二个 n=<span class="number">2</span> 的部分为 [<span class="number">3</span>,<span class="number">4</span>] ，构成二维数组的第二行。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], m = <span class="number">1</span>, n = <span class="number">3</span></span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">解释：</span><br><span class="line">构造出的二维数组应该包含 <span class="number">1</span> 行 <span class="number">3</span> 列。</span><br><span class="line">将 original 中所有三个元素放入第一行中，构成要求的二维数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">1</span>,<span class="number">2</span>], m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中有 <span class="number">2</span> 个元素。</span><br><span class="line">无法将 <span class="number">2</span> 个元素放入到一个 <span class="number">1</span>x1 的二维数组中，所以返回一个空的二维数组。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">输入：original = [<span class="number">3</span>], m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">original 中只有 <span class="number">1</span> 个元素。</span><br><span class="line">无法将 <span class="number">1</span> 个元素放满一个 <span class="number">1</span>x2 的二维数组，所以返回一个空的二维数组。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= original.length &lt;= <span class="number">5</span> * <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= original[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= m, n &lt;= <span class="number">4</span> * <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-62/problems/convert-1d-array-into-2d-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接转化即可.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(N)$,空间复杂度$O(N)$，其中 $N$ 表示数组的长度.</span><br><span class="line">### 代码</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; construct2DArray(vector&lt;<span class="built_in">int</span>&gt;&amp; original, <span class="built_in">int</span> m, <span class="built_in">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">int</span> tot = original.size();</span><br><span class="line">        <span class="keyword">if</span>(m*n != tot) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        ans = vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;(m,vector&lt;<span class="built_in">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                ans[i][j] = original[i*n + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5872-连接后等于目标字符串的字符串对"><a href="#5872-连接后等于目标字符串的字符串对" class="headerlink" title="5872. 连接后等于目标字符串的字符串对"></a>5872. 连接后等于目标字符串的字符串对</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 数字 字符串数组 <code>nums</code> 和一个 数字 字符串 <code>target</code>，请你返回 <code>nums[i] + nums[j]</code> （两个字符串连接）结果等于 <code>target</code> 的下标 <code>(i, j)</code>（需满足 <code>i != j</code>）的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"777"</span>,<span class="string">"7"</span>,<span class="string">"77"</span>,<span class="string">"77"</span>], target = <span class="string">"7777"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：符合要求的下标对包括：</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"777"</span> + <span class="string">"7"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">0</span>)：<span class="string">"7"</span> + <span class="string">"777"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">3</span>)：<span class="string">"77"</span> + <span class="string">"77"</span></span><br><span class="line">- (<span class="number">3</span>, <span class="number">2</span>)：<span class="string">"77"</span> + <span class="string">"77"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"123"</span>,<span class="string">"4"</span>,<span class="string">"12"</span>,<span class="string">"34"</span>], target = <span class="string">"1234"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：符合要求的下标对包括</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"123"</span> + <span class="string">"4"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">3</span>)：<span class="string">"12"</span> + <span class="string">"34"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>], target = <span class="string">"11"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：符合要求的下标对包括</span><br><span class="line">- (<span class="number">0</span>, <span class="number">1</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">0</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">0</span>, <span class="number">2</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">0</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">1</span>, <span class="number">2</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">- (<span class="number">2</span>, <span class="number">1</span>)：<span class="string">"1"</span> + <span class="string">"1"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= nums.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i].length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">2</span> &lt;= target.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `nums[i]` 和 `target` 只包含数字。</span><br><span class="line">+ `nums[i]` 和 `target` 不含有任何前导 <span class="number">0</span> 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的滑动滑动窗口实现．我们保存所有的字符串，用`hashmap`存储，我们试着尝试`target`的每一种可能的分解，将其分解的前缀和后缀在`hashmap`中查找对应的统计数量即可.</span><br><span class="line">+ 需要注意的是当前字符串的前缀与后缀相同时,此时需要特殊处理一下,假设符合前缀的字符串数量为$n$,则此时符合的组合数量应该为$A_&#123;n&#125;^&#123;<span class="number">2</span>&#125;$.</span><br><span class="line"><span class="number">2.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度分析: 时间复杂度为$O(N*M)$，其中$N$为字符串数组的长度，$M$表示为字符串$\textit&#123;target&#125;$的长度．</span><br><span class="line">+ 空间复杂度分析:　空间复杂度为$O(N*C)$,其中$N$为字符串数组的长度, 其中$C$为字符串数组中每个元素的平均长度.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> numOfPairs(vector&lt;<span class="built_in">string</span>&gt;&amp; nums, <span class="built_in">string</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = target.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : nums) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> a = target.substr(<span class="number">0</span>,i);</span><br><span class="line">            <span class="built_in">string</span> b = target.substr(i);</span><br><span class="line">            <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line">                <span class="built_in">int</span> x = cnt[a];</span><br><span class="line">                ans += x*(x<span class="number">-1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans += cnt[a]*cnt[b];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5873-考试的最大困扰度"><a href="#5873-考试的最大困扰度" class="headerlink" title="5873. 考试的最大困扰度"></a>5873. 考试的最大困扰度</h2><p>一位老师正在出一场由<code>n</code>道判断题构成的考试，每道题的答案为 <code>true</code>（用 <code>&#39;T&#39;</code> 表示）或者 <code>false</code> （用 <code>&#39;F&#39;</code> 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 <code>true</code> 或者连续出现 <code>false</code>）。</p><p>给你一个字符串 <code>answerKey</code>，其中 <code>answerKey[i]</code>是第 <code>i</code> 个问题的正确结果。除此以外，还给你一个整数 <code>k</code> ，表示你能进行以下操作的最多次数：</p><ul><li>每次操作中，将问题的正确答案改为 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> （也就是将 <code>answerKey[i]</code> 改为 <code>&#39;T&#39;</code>或者 <code>&#39;F&#39;</code> ）。<br>请你返回在不超过 <code>k</code> 次操作的情况下，最大 连续 <code>&#39;T&#39;</code> 或者 <code>&#39;F&#39;</code> 的数目。</li></ul><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TTFF"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：我们可以将两个 'F' 都变为 'T' ，得到 answerKey = <span class="string">"TTTT"</span> 。</span><br><span class="line">总共有四个连续的 'T' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TFFT"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以将最前面的 'T' 换成 'F' ，得到 answerKey = <span class="string">"FFFT"</span> 。</span><br><span class="line">或者，我们可以将第二个 'T' 换成 'F' ，得到 answerKey = <span class="string">"TFFF"</span> 。</span><br><span class="line">两种情况下，都有三个连续的 'F' 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：answerKey = <span class="string">"TTFTTFTT"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：我们可以将第一个 'F' 换成 'T' ，得到 answerKey = <span class="string">"TTTTTFTT"</span> 。</span><br><span class="line">或者我们可以将第二个 'F' 换成 'T' ，得到 answerKey = <span class="string">"TTFTTTTT"</span> 。</span><br><span class="line">两种情况下，都有五个连续的 'T' 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == answerKey.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>answerKey[i]</code> 要么是 <code>&#39;T&#39;</code> ，要么是 <code>&#39;F&#39;</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找或者滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>二分查找的思路比较直接和简单,思路如下:</li></ol><ul><li>每次尝试当前可能的最大窗口长度 $\textit{m}$,在当前窗口中检测统计是否满足<code>F</code>或者<code>T</code>的统计数目小于等于<code>k</code>；</li><li>如果满足符合要求的窗口,则我们直接返回即可；</li></ul><ol><li>滑动窗口思路如下:</li></ol><ul><li>我们尝试扩展当前的窗口，如果发现当前的窗口无法满足题目中的要求时，则此时我们尝试收缩窗口．</li><li>我们用 $r$ 指向当前窗口的最右端, $l$ 指向当前窗口的最左段，每次我们扩展最右端;</li><li>当发现当前窗口无法变为连续相同的字符时,则此时我们收获最左端直达当前窗口满足要求即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度为 $O(N)$, 其中 $N$ 表示字符串的长度.</li><li>空间复杂度为 $O(1)$, 我们只需要保存当前字符中<code>T</code>或者<code>F</code>的统计数目即可.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s,<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                curr[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i-len] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                    pre[<span class="number">0</span>]++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pre[<span class="number">1</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= len - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[<span class="number">0</span>] - pre[<span class="number">0</span>] &lt;= k || curr[<span class="number">1</span>] - pre[<span class="number">1</span>] &lt;= k)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(<span class="built_in">string</span> answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = answerKey.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(answerKey,k,mid)) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>滑动窗口<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(<span class="built_in">string</span> answerKey, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = answerKey.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(answerKey[pos] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                cnt[<span class="number">0</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt[<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(cnt[<span class="number">0</span>] &gt; k &amp;&amp; cnt[<span class="number">1</span>] &gt; k) &#123;</span><br><span class="line">                <span class="keyword">if</span>(answerKey[curr] == <span class="string">'T'</span>)&#123;</span><br><span class="line">                    cnt[<span class="number">0</span>]--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt[<span class="number">1</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,pos-curr+<span class="number">1</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5874-分割数组的最多方案数"><a href="#5874-分割数组的最多方案数" class="headerlink" title="5874. 分割数组的最多方案数"></a>5874. 分割数组的最多方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始且长度为 <code>n</code> 的整数数组 <code>nums</code> 。分割 数组 nums 的方案数定义为符合以下两个条件的 <code>pivot</code> 数目：</p><ul><li><code>1 &lt;= pivot &lt; n</code></li><li><code>nums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]</code><br>同时给你一个整数 <code>k</code> 。你可以将 <code>nums</code> 中 一个 元素变为 k 或 不改变 数组。</li></ul><p>请你返回在 至多 改变一个元素的前提下，最多 有多少种方法 分割 <code>nums</code> 使得上述两个条件都满足。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：一个最优的方案是将 nums[<span class="number">0</span>] 改为 k 。数组变为 [<span class="number">3</span>,<span class="number">-1</span>,<span class="number">2</span>] 。</span><br><span class="line">有一种方法分割数组：</span><br><span class="line">- pivot = <span class="number">2</span> ，我们有分割 [<span class="number">3</span>,<span class="number">-1</span> | <span class="number">2</span>]：<span class="number">3</span> + <span class="number">-1</span> == <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：一个最优的方案是不改动数组。</span><br><span class="line">有两种方法分割数组：</span><br><span class="line">- pivot = <span class="number">1</span> ，我们有分割 [<span class="number">0</span> | <span class="number">0</span>,<span class="number">0</span>]：<span class="number">0</span> == <span class="number">0</span> + <span class="number">0</span> 。</span><br><span class="line">- pivot = <span class="number">2</span> ，我们有分割 [<span class="number">0</span>,<span class="number">0</span> | <span class="number">0</span>]: <span class="number">0</span> + <span class="number">0</span> == <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">22</span>,<span class="number">4</span>,<span class="number">-25</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">15</span>,<span class="number">-16</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">-10</span>,<span class="number">0</span>,<span class="number">-13</span>,<span class="number">-14</span>], k = <span class="number">-33</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一个最优的方案是将 nums[<span class="number">2</span>] 改为 k 。数组变为 [<span class="number">22</span>,<span class="number">4</span>,<span class="number">-33</span>,<span class="number">-20</span>,<span class="number">-15</span>,<span class="number">15</span>,<span class="number">-16</span>,<span class="number">7</span>,<span class="number">19</span>,<span class="number">-10</span>,<span class="number">0</span>,<span class="number">-13</span>,<span class="number">-14</span>] 。</span><br><span class="line">有四种方法分割数组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>-105 &lt;= k, nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-62/problems/maximum-number-of-ways-to-partition-an-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口 + 前缀和</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们统计所有的索引 $i$ 的前缀和 $prefix[i]$ 和后缀和 $suffix[i]$，我们用 $prefix[i]$ 表示索引从 $0$ 到 $i$ 的元素之和, $suffix[i]$ 表示索引从 $i$ 到 $n-1$ 的元素之和.</li><li>题目中要求替换其中一个元素为 $k$，假设我们将 $nums[j]$ 替换为 $k$, 则二者替换后元素的变化为 $k-nums[j]$,我们只需要找到所有前缀和和后缀和的差值刚好等于元素替换之和的值即可．</li></ol><ul><li>此时我们只需要找到所有满足如下等式的索引 $i$:<script type="math/tex; mode=display">prefix[i] - suffix[i+1] = k - nums[j] \quad ( if  \quad i\ge j) \\suffix[i] - prefix[i-1] = k - nums[j] \quad ( if  \quad i\le j) \\</script></li><li>我们用<code>map</code>存储所有的 $prefix[i] - suffix[i+1]$和$suffix[i] - prefix[i-1]$的值，每次进行查询,并同时更新更新．</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: $O(N)$，其中 $N$ 表示数组的长度.</li><li>空间复杂度分析: $O(N)$，其中 $N$ 表示数组的长度.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prefix(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; suffix(n);</span><br><span class="line"></span><br><span class="line">        prefix[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        suffix[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            prefix[i] = prefix[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">            suffix[n-i<span class="number">-1</span>] = suffix[n-i] + nums[n-i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix[i] == suffix[i+<span class="number">1</span>]) ans++;</span><br><span class="line">            right[suffix[i+<span class="number">1</span>] - prefix[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = k - nums[i];</span><br><span class="line">            ans = max(ans,right[x] + left[x]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                left[prefix[i] - suffix[i+<span class="number">1</span>]]++;</span><br><span class="line">                right[suffix[i+<span class="number">1</span>] - prefix[i]]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-62&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-62&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 62&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 62&lt;/h1&gt;&lt;p&gt;双周赛的题目质量还算不错，第三题竟然卡壳了好久，第四题感觉应该只能算一个中等难度题目．模拟比赛做了一下，大概排名&lt;code&gt;200&lt;/code&gt;多名.&lt;/p&gt;&lt;h2 id=&quot;5871-将一维数组转变成二维数组&quot;&gt;&lt;a href=&quot;#5871-将一维数组转变成二维数组&quot; class=&quot;headerlink&quot; title=&quot;5871. 将一维数组转变成二维数组&quot;&gt;&lt;/a&gt;5871. 将一维数组转变成二维数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的一维整数数组 &lt;code&gt;original&lt;/code&gt; 和两个整数 &lt;code&gt;m&lt;/code&gt; 和  &lt;code&gt;n&lt;/code&gt;。你需要使用 &lt;code&gt;original&lt;/code&gt; 中 所有 元素创建一个 &lt;code&gt;m&lt;/code&gt; 行 &lt;code&gt;n&lt;/code&gt; 列的二维数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 260</title>
    <link href="http://yoursite.com/2021/09/26/329/"/>
    <id>http://yoursite.com/2021/09/26/329/</id>
    <published>2021-09-26T14:36:48.576Z</published>
    <updated>2021-09-26T15:22:17.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-260"><a href="#leetcode-contest-260" class="headerlink" title="leetcode  contest 260"></a>leetcode  contest 260</h1><p>还是三道题目的节奏,无奈太菜了. 感觉中间两道题目出的很水,第四题其实出的还算比较有水平的题目,不过感觉不算太难.</p><h2 id="5881-增量元素之间的最大差值"><a href="#5881-增量元素之间的最大差值" class="headerlink" title="5881. 增量元素之间的最大差值"></a>5881. 增量元素之间的最大差值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，该数组的大小为 <code>n</code> ，请你计算 <code>nums[j] - nums[i]</code> 能求得的 最大差值 ，其中 <code>0 &lt;= i &lt; j &lt; n</code>且 <code>nums[i] &lt; nums[j]</code> 。</p><a id="more"></a><p>返回 最大差值 。如果不存在满足要求的 <code>i</code> 和 <code>j</code> ，返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">最大差值出现在 i = <span class="number">1</span> 且 j = <span class="number">2</span> 时，nums[j] - nums[i] = <span class="number">5</span> - <span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">注意，尽管 i = <span class="number">1</span> 且 j = <span class="number">0</span> 时 ，nums[j] - nums[i] = <span class="number">7</span> - <span class="number">1</span> = <span class="number">6</span> &gt; <span class="number">4</span> ，但 i &gt; j 不满足题面要求，所以 <span class="number">6</span> 不是有效的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">不存在同时满足 <span class="built_in">i</span> &lt; <span class="built_in">j</span> 和 nums[<span class="built_in">i</span>] &lt; nums[<span class="built_in">j</span>] 这两个条件的 <span class="built_in">i</span>, <span class="built_in">j</span> 组合。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line">最大差值出现在 i = <span class="number">0</span> 且 j = <span class="number">3</span> 时，nums[j] - nums[i] = <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == nums.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">109</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/maximum-difference-between-increasing-elements/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力检测</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接暴力检测即可,数据量较小.</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(N^&#123;<span class="number">2</span>&#125;)$,空间复杂度$O(<span class="number">1</span>)$.当然另一种可以采用排序的方法,时间复杂度可以优化到 $O(n\lg(n))$.</span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maximumDifference(vector&lt;<span class="built_in">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    ans = max(ans,nums[j]-nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5882-网格游戏"><a href="#5882-网格游戏" class="headerlink" title="5882. 网格游戏"></a>5882. 网格游戏</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的二维数组 <code>grid</code> ，数组大小为 <code>2 x n</code> ，其中 <code>grid[r][c]</code> 表示矩阵中 <code>(r, c)</code> 位置上的点数。现在有两个机器人正在矩阵上参与一场游戏。</p><p>两个机器人初始位置都是 <code>(0, 0)</code> ，目标位置是 <code>(1, n-1)</code> 。每个机器人只会 向右 <code>((r, c)</code> 到 <code>(r, c + 1))</code> 或 向下 <code>((r, c)</code> 到 <code>(r + 1, c))</code> 。</p><p>游戏开始，第一个 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code>，并收集路径上单元格的全部点数。对于路径上所有单元格 <code>(r, c)</code> ，途经后 <code>grid[r][c]</code> 会重置为 <code>0</code>。然后，第二个 机器人从 <code>(0, 0)</code> 移动到 <code>(1, n-1)</code> ，同样收集路径上单元的全部点数。注意，它们的路径可能会存在相交的部分。</p><p>第一个 机器人想要打击竞争对手，使 第二个 机器人收集到的点数 最小化 。与此相对，第二个 机器人想要 最大化 自己收集到的点数。两个机器人都发挥出自己的 最佳水平 的前提下，返回 第二个 机器人收集到的 点数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。</span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">0</span> + <span class="number">4</span> + <span class="number">0</span> = <span class="number">4</span> 个点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">8</span>,<span class="number">5</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。 </span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">0</span> = <span class="number">4</span> 个点。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">15</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：第一个机器人的最佳路径如红色所示，第二个机器人的最佳路径如蓝色所示。</span><br><span class="line">第一个机器人访问过的单元格将会重置为 <span class="number">0</span> 。</span><br><span class="line">第二个机器人将会收集到 <span class="number">0</span> + <span class="number">1</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">0</span> = <span class="number">7</span> 个点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>grid.length == 2</code></li><li><code>n == grid[r].length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li><code>1 &lt;= grid[r][c] &lt;= 105</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-260/problems/grid-game/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-260/problems/grid-game/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，设二位数组的长度为 $n$,题目中的关键在于数组只有两行，则我们可以知道第一个机器人最多只有 $n$ 种走法,因此我们可以遍历第一个机器人所有的走法．</li><li>题目中要求,第一个机器人的走法使得第二个机器人收集到的点数最小化 。与此相对，第二个机器人想要最大化自己收集到的点数.因此我们遍历第一个机器人在不同得走法下,使得第二个机器所能收集的最大点数尽可能的小即可. 我们利用前缀和即可,我们假设第一个机器人在第 $i$ 处从第一行走到了第二行,则此时第一个机器人的所收集的点数我们利用前缀和即可得到 $prefix[i+1][0] + prefix[n][1] - prefix[i][1]$，即第一行的前 $i$ 个元素的点数加上第二行的后 $n-i$ 个元素; 此时第二个机器人只有两种可能的走法,要么一直沿着第一行走，要么一直严着第二行走，则其要么获取第一行的后 $n-i$个元素的点数,要么获取第二行的前 $i$ 个元素.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$, 其中$N$为数组的长度.</li><li>空间复杂度为$O(N)$,其中$N$为数组的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gridGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">1e10</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; prefix(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                prefix[i+<span class="number">1</span>][j] = prefix[i][j] + grid[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p1 = prefix[i+<span class="number">1</span>][<span class="number">0</span>] + prefix[n][<span class="number">1</span>] - prefix[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> p2 = max(prefix[n][<span class="number">0</span>]-prefix[i+<span class="number">1</span>][<span class="number">0</span>],prefix[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(p2 &lt; curr) &#123;</span><br><span class="line">                curr = p2;</span><br><span class="line">                ans = p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5883-判断单词是否能放入填字游戏内"><a href="#5883-判断单词是否能放入填字游戏内" class="headerlink" title="5883. 判断单词是否能放入填字游戏内"></a>5883. 判断单词是否能放入填字游戏内</h2><p>给你一个 <code>m x n</code>的矩阵 <code>board</code> ，它代表一个填字游戏 当前 的状态。填字游戏格子中包含小写英文字母（已填入的单词），表示 空 格的 ‘ ‘ 和表示 障碍 格子的 ‘#’ 。</p><p>如果满足以下条件，那么我们可以 水平 （从左到右 或者 从右到左）或 竖直 （从上到下 或者 从下到上）填入一个单词：</p><p>该单词不占据任何 <code>&#39;#&#39;</code> 对应的格子。<br>每个字母对应的格子要么是 ‘ ‘ （空格）要么与 board 中已有字母 匹配 。<br>如果单词是 水平 放置的，那么该单词左边和右边 相邻 格子不能为 ‘ ‘ 或小写英文字母。<br>如果单词是 竖直 放置的，那么该单词上边和下边 相邻 格子不能为 ‘ ‘ 或小写英文字母。<br>给你一个字符串 <code>word</code>，如果 <code>word</code> 可以被放入 <code>board</code> 中，请你返回 <code>true</code> ，否则请返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">" "</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">"#"</span>, <span class="string">"c"</span>, <span class="string">" "</span>]], word = <span class="string">"abc"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：单词 <span class="string">"abc"</span> 可以如上图放置（从上往下）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"a"</span>], [<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"c"</span>], [<span class="string">" "</span>, <span class="string">"#"</span>, <span class="string">"a"</span>]], word = <span class="string">"ac"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：无法放置单词，因为放置该单词后上方或者下方相邻格会有空格。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">" "</span>, <span class="string">" "</span>, <span class="string">"#"</span>], [<span class="string">"#"</span>, <span class="string">" "</span>, <span class="string">"c"</span>]], word = <span class="string">"ca"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：单词 <span class="string">"ca"</span> 可以如上图放置（从右到左）。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `m == board.length`</span><br><span class="line">+ `n == board[i].length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= m * n &lt;= <span class="number">2</span> * <span class="number">105</span>`</span><br><span class="line">+ `board[i][j]` 可能为 <span class="string">' '</span> ，<span class="string">'#'</span> 或者一个小写英文字母。</span><br><span class="line">+ `<span class="number">1</span> &lt;= word.length &lt;= max(m, n)`</span><br><span class="line">+ `word` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/check-if-word-can-be-placed-in-crossword/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;  遍历</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 这个题目感觉好无聊，感觉只能算是非常简单的难度，我们遍历所有符合单词的长度的连续格子，然后判断该连续的格子是否满足题目中单词的要求：</span><br><span class="line">+ 设字符串的长度为 $n$ ,该水平或者垂直连续的格子的长度为 $n$, 且满足连续的格子两端只能为障碍物.</span><br><span class="line">+ 判断连续的格子中要么为空格,要么为字符.</span><br><span class="line">+ 我们判断字符的位置是否符合字符串中字符位置的要求</span><br><span class="line"><span class="number">2.</span> 时间复杂度为 $O(N)$, 其中 $N$ 表示矩阵中元素的个数.空间复杂度为 $O(<span class="number">1</span>)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> placeWordInCrossword(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">string</span> word) &#123;</span><br><span class="line">        <span class="keyword">int</span>　n = word.size();</span><br><span class="line">        <span class="keyword">int</span> row = board.size();</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*check row*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; col)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; col &amp;&amp; board[i][pos] == <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">int</span> l = pos;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*check space*/</span></span><br><span class="line">                <span class="keyword">while</span>(pos &lt; col &amp;&amp; board[i][pos]!= <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos - l == n)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid1 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> valid2 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; pos; ++j)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][j] != <span class="string">' '</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[j-l])&#123;</span><br><span class="line">                                valid1 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[n<span class="number">-1</span>-(j-l)])&#123;</span><br><span class="line">                                valid2 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(valid1||valid2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*check col*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; row)&#123;</span><br><span class="line">                <span class="keyword">while</span>(pos &lt; row &amp;&amp; board[pos][j] == <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">int</span> l = pos;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(pos &lt; row &amp;&amp; board[pos][j] != <span class="string">'#'</span>) pos++;</span><br><span class="line">                <span class="keyword">if</span>(pos - l == n)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> valid1 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> valid2 = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt; pos; ++i)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(board[i][j] != <span class="string">' '</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[i-l])&#123;</span><br><span class="line">                                valid1 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(board[i][j] != word[n<span class="number">-1</span>-(i-l)])&#123;</span><br><span class="line">                                valid2 = <span class="literal">false</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(valid1||valid2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5884-解出数学表达式的学生分数"><a href="#5884-解出数学表达式的学生分数" class="headerlink" title="5884. 解出数学表达式的学生分数"></a>5884. 解出数学表达式的学生分数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，它 只 包含数字<code>0-9</code>，加法运算符 <code>&#39;+&#39;</code>和乘法运算符 ‘<em>‘ ，这个字符串表示一个 合法 的只含有 个位数数字 的数学表达式（比方说 3+5</em>2）。有 n 位小学生将计算这个数学表达式，并遵循如下 运算顺序 ：</p><ul><li>按照 从左到右 的顺序计算 乘法 ，然后</li><li>按照 从左到右 的顺序计算 加法 。</li><li><p>给你一个长度为 <code>n</code> 的整数数组 <code>answers</code> ，表示每位学生提交的答案。你的任务是给 <code>answer</code> 数组按照如下 规则 打分：</p></li><li><p>如果一位学生的答案 等于 表达式的正确结果，这位学生将得到 5 分。</p></li><li>否则，如果答案由 一处或多处错误的运算顺序 计算得到，那么这位学生能得到 2 分。</li><li>否则，这位学生将得到 0 分。<br>请你返回所有学生的分数和。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"7+3*1*2"</span>, answers = [<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：如上图所示，正确答案为 <span class="number">13</span> ，因此有一位学生得分为 <span class="number">5</span> 分：[<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>] 。</span><br><span class="line">一位学生可能通过错误的运算顺序得到结果 <span class="number">20</span> ：<span class="number">7</span>+<span class="number">3</span>=<span class="number">10</span>，<span class="number">10</span>*<span class="number">1</span>=<span class="number">10</span>，<span class="number">10</span>*<span class="number">2</span>=<span class="number">20</span> 。所以这位学生得分为 <span class="number">2</span> 分：[<span class="number">20</span>,<span class="number">13</span>,<span class="number">42</span>] 。</span><br><span class="line">所有学生得分分别为：[<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>] 。所有得分之和为 <span class="number">2</span>+<span class="number">5</span>+<span class="number">0</span>=<span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3+5*2"</span>, answers = [<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>]</span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：表达式的正确结果为 <span class="number">13</span> ，所以有 <span class="number">3</span> 位学生得到 <span class="number">5</span> 分：[<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>] 。</span><br><span class="line">学生可能通过错误的运算顺序得到结果 <span class="number">16</span> ：<span class="number">3</span>+<span class="number">5</span>=<span class="number">8</span>，<span class="number">8</span>*<span class="number">2</span>=<span class="number">16</span> 。所以两位学生得到 <span class="number">2</span> 分：[<span class="number">13</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">16</span>] 。</span><br><span class="line">所有学生得分分别为：[<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>] 。所有得分之和为 <span class="number">5</span>+<span class="number">0</span>+<span class="number">0</span>+<span class="number">5</span>+<span class="number">5</span>+<span class="number">2</span>+<span class="number">2</span>=<span class="number">19</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"6+0*1"</span>, answers = [<span class="number">12</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：表达式的正确结果为 <span class="number">6</span> 。</span><br><span class="line">如果一位学生通过错误的运算顺序计算该表达式，结果仍为 <span class="number">6</span> 。</span><br><span class="line">根据打分规则，运算顺序错误的学生也将得到 <span class="number">5</span> 分（因为他们仍然得到了正确的结果），而不是 <span class="number">2</span> 分。</span><br><span class="line">所有学生得分分别为：[<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>] 。所有得分之和为 <span class="number">10</span> 分。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">3</span> &lt;= s.length &lt;= <span class="number">31</span>`</span><br><span class="line">+ `s` 表示一个只包含 `<span class="number">0</span><span class="number">-9</span>` ，`<span class="string">'+'</span>` 和 `<span class="string">'*'</span>` 的合法表达式。</span><br><span class="line">+ 表达式中所有整数运算数字都在闭区间 `[<span class="number">0</span>, <span class="number">9</span>]` 以内。</span><br><span class="line">+ <span class="number">1</span> &lt;= 数学表达式中所有运算符数目`（<span class="string">'+'</span>` 和 `<span class="string">'*'</span>） &lt;= <span class="number">15</span>`</span><br><span class="line">+ 测试数据保证正确表达式结果在范围` [<span class="number">0</span>, <span class="number">1000</span>] `以内。</span><br><span class="line">+ `n == answers.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= answers[i] &lt;= <span class="number">1000</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/weekly-contest-260/problems/the-score-of-students-solving-math-expression/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   dp</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 其实题目本身的解法就是比较暴力,计算出所有可能的得分,然后将 $answer$ 中的每个元素在所有可能的得分里面进行查找, 如果不能找到则得分为  $<span class="number">0</span>$,如果可以找到则得分为 $<span class="number">2</span>$,如果得分刚好等于正确的结果,则得分为 $<span class="number">5</span>$,题目的难点在于如果得到所有的得分,题目另外一个关键的提示为$<span class="number">0</span> \le answers[i] \le <span class="number">1000</span>$, 则我们知道可以尽可能的缩小范围.</span><br><span class="line"><span class="number">2.</span> 我们设 $dp[i][j]$ 表示为表达式从$i$ 到 $j$ 范围内的所有可能的计算组合的得分,则我们在计算 $dp[i][j+k]$ 时,我们会枚举所的可能，即从表达式的 $i$ 到 $j+k$ 枚举每一个计算符为最后的计算组合. 题目本身还算非常不错的题目, 非常适合面试.但是说到底本身还算暴力求解的过程. 还是喜欢那种带有计算性质且有技巧的题目.</span><br><span class="line"><span class="number">3.</span> 时间复杂度为$O(N^&#123;<span class="number">3</span>&#125;*MAX(answer))$,空间复杂度为 $O(N^&#123;<span class="number">2</span>&#125;*MAX(answer))$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> calc(<span class="keyword">const</span> vector&lt;<span class="built_in">int</span>&gt; &amp; nums,<span class="keyword">const</span> vector&lt;char&gt; &amp; ops) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        arr.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">/*calc mult*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; ops.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                arr.push_back(nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ops[i] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                arr[arr.size()<span class="number">-1</span>] = arr.back()*nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*calc add*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            ans += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> scoreOfStudents(<span class="built_in">string</span> s, vector&lt;<span class="built_in">int</span>&gt;&amp; answers) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">int</span> m = n/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> correct = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; nums;</span><br><span class="line">        vector&lt;char&gt; ops;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="built_in">int</span>&gt;&gt; dp(<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*parse expression*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'+'</span>||c == <span class="string">'*'</span>)&#123;</span><br><span class="line">                ops.push_back(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums.push_back(c-<span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        correct = calc(nums,ops);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ops[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                dp[<span class="number">1</span>&lt;&lt;i].insert(nums[i] + nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[<span class="number">1</span>&lt;&lt;i].insert(nums[i] * nums[i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j+i &lt;= m; ++j)&#123;</span><br><span class="line">                <span class="built_in">int</span> mask = ((<span class="number">1</span>&lt;&lt;(j+i))<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : dp[mask^(<span class="number">1</span>&lt;&lt;j)])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j] == <span class="string">'+'</span> &amp;&amp; nums[j] + v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j] + v);</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">if</span>(ops[j] == <span class="string">'*'</span> &amp;&amp; nums[j] * v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j] * v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">auto</span> v : dp[mask^(<span class="number">1</span>&lt;&lt;(j+i<span class="number">-1</span>))])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j+i<span class="number">-1</span>] == <span class="string">'+'</span> &amp;&amp; nums[j+i] + v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j+i] + v);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ops[j+i<span class="number">-1</span>] == <span class="string">'*'</span> &amp;&amp; nums[j+i] * v &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                        dp[mask].insert(nums[j+i] * v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> k = j+<span class="number">1</span>; k &lt; j+i<span class="number">-1</span>; ++k)&#123;</span><br><span class="line">                    <span class="built_in">int</span> left = ((<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">int</span> right = ((<span class="number">1</span>&lt;&lt;(j+i))<span class="number">-1</span>)^((<span class="number">1</span>&lt;&lt;k+<span class="number">1</span>)<span class="number">-1</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">auto</span> v1 : dp[left])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="built_in">auto</span> v2 : dp[right])&#123;</span><br><span class="line">                            <span class="keyword">if</span>(ops[k] == <span class="string">'+'</span> &amp;&amp; v1 + v2 &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                                dp[mask].insert(v1 + v2);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span>(ops[k] == <span class="string">'*'</span> &amp;&amp; v1 * v2 &lt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                                dp[mask].insert(v1 * v2);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>].erase(correct);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : answers)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == correct)&#123;</span><br><span class="line">                ans += <span class="number">5</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>].count(v))&#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-260&quot;&gt;&lt;a href=&quot;#leetcode-contest-260&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 260&quot;&gt;&lt;/a&gt;leetcode  contest 260&lt;/h1&gt;&lt;p&gt;还是三道题目的节奏,无奈太菜了. 感觉中间两道题目出的很水,第四题其实出的还算比较有水平的题目,不过感觉不算太难.&lt;/p&gt;&lt;h2 id=&quot;5881-增量元素之间的最大差值&quot;&gt;&lt;a href=&quot;#5881-增量元素之间的最大差值&quot; class=&quot;headerlink&quot; title=&quot;5881. 增量元素之间的最大差值&quot;&gt;&lt;/a&gt;5881. 增量元素之间的最大差值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 &lt;code&gt;0&lt;/code&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; ，该数组的大小为 &lt;code&gt;n&lt;/code&gt; ，请你计算 &lt;code&gt;nums[j] - nums[i]&lt;/code&gt; 能求得的 最大差值 ，其中 &lt;code&gt;0 &amp;lt;= i &amp;lt; j &amp;lt; n&lt;/code&gt;且 &lt;code&gt;nums[i] &amp;lt; nums[j]&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 259</title>
    <link href="http://yoursite.com/2021/09/19/328/"/>
    <id>http://yoursite.com/2021/09/19/328/</id>
    <published>2021-09-19T05:28:32.938Z</published>
    <updated>2021-09-20T08:14:08.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-259"><a href="#leetcode-contest-259" class="headerlink" title="leetcode  contest 259"></a>leetcode  contest 259</h1><p>还是三道题目的节奏,无奈太菜了.</p><h2 id="5875-执行操作后的变量值"><a href="#5875-执行操作后的变量值" class="headerlink" title="5875. 执行操作后的变量值"></a>5875. 执行操作后的变量值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：</p><ul><li><code>++X</code> 和 <code>X++</code> 使变量 <code>X</code> 的值 加 1</li><li><code>--X</code> 和 <code>X--</code> 使变量 <code>X</code> 的值 减 1<br>最初，X 的值是 0</li></ul><p>给你一个字符串数组 <code>operations</code> ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"--X"</span>,<span class="string">"X++"</span>,<span class="string">"X++"</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：操作按下述步骤执行：</span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">--X：X 减 <span class="number">1</span> ，X =  <span class="number">0</span> - <span class="number">1</span> = <span class="number">-1</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">-1</span> + <span class="number">1</span> =  <span class="number">0</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X =  <span class="number">0</span> + <span class="number">1</span> =  <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"++X"</span>,<span class="string">"++X"</span>,<span class="string">"X++"</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：操作按下述步骤执行： </span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：operations = [<span class="string">"X++"</span>,<span class="string">"++X"</span>,<span class="string">"--X"</span>,<span class="string">"X--"</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：操作按下述步骤执行：</span><br><span class="line">最初，X = <span class="number">0</span></span><br><span class="line">X++：X 加 <span class="number">1</span> ，X = <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">++X：X 加 <span class="number">1</span> ，X = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span></span><br><span class="line">--X：X 减 <span class="number">1</span> ，X = <span class="number">2</span> - <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">X--：X 减 <span class="number">1</span> ，X = <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= operations.length &lt;= 100</code></li><li><code>operations[i] 将会是 &quot;++X&quot;、&quot;X++&quot;、&quot;--X&quot; 或 &quot;X--&quot;</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/final-value-of-variable-after-performing-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/final-value-of-variable-after-performing-operations</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力检测当前字符串是加还是减即可.</li><li>算法时间复杂度为$O(N)$,空间复杂度$O(1)$.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">finalValueAfterOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; operations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> w : operations)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w == <span class="string">"++X"</span> || w == <span class="string">"X++"</span>) ans++;</span><br><span class="line">            <span class="keyword">else</span> ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5876-数组美丽值求和"><a href="#5876-数组美丽值求和" class="headerlink" title="5876. 数组美丽值求和"></a>5876. 数组美丽值求和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的整数数组 nums 。对于每个下标 <code>i（1 &lt;= i &lt;= nums.length - 2）</code>，<code>nums[i]</code>的 美丽值 等于：</p><ul><li><code>2</code>，对于所有 <code>0 &lt;= j &lt; i</code> 且 <code>i &lt; k &lt;= nums.length - 1</code>，满足 <code>nums[j] &lt; nums[i] &lt; nums[k]</code></li><li><code>1</code>，如果满足 <code>nums[i - 1] &lt; nums[i] &lt; nums[i + 1]</code>，且不满足前面的条件</li><li><code>0</code>，如果上述条件全部不满足<br>返回符合 <code>1 &lt;= i &lt;= nums.length - 2</code> 的所有 <code>nums[i]</code> 的 美丽值的总和 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">1</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">2</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">1</span></span><br><span class="line">- nums[<span class="number">2</span>] 的美丽值等于 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：对于每个符合范围 <span class="number">1</span> &lt;= i &lt;= <span class="number">1</span> 的下标 i :</span><br><span class="line">- nums[<span class="number">1</span>] 的美丽值等于 <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-beauty-in-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-beauty-in-the-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简单，我们利用滑动窗口即可，我们设$left[i]$表示当前索引小于等于$i$的元素的最大值,$right[i]$表示当前索引大于等于$i$的元素的最小值,我们每次检测当前的$i$是否满足:<script type="math/tex; mode=display">left[i-1] < nums[i] < right[i]</script>如果满足则美丽值为$2$,否则则检测是否满足$nums[i - 1] &lt; nums[i] &lt; nums[i + 1]$,如果满足则美丽值为$1$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$, 其中$N$为数组的长度.</li><li>空间复杂度为$O(N)$,其中$N$为数组的长度.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfBeauties</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n);</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[i] = max(nums[i],left[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = min(right[i+<span class="number">1</span>],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; left[i<span class="number">-1</span>] &amp;&amp; nums[i] &lt; right[i+<span class="number">1</span>])&#123;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>] &amp;&amp; nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5877-检测正方形"><a href="#5877-检测正方形" class="headerlink" title="5877. 检测正方形"></a>5877. 检测正方形</h2><p>给你一个在 <code>X-Y</code> 平面上的点构成的数据流。设计一个满足下述要求的算法：</p><ul><li><strong>添加</strong> 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。</li><li>给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。<br>轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。</li></ul><p>实现 <code>DetectSquares</code> 类：</p><ul><li><code>DetectSquares()</code> 使用空数据结构初始化对象</li><li><code>void add(int[] point)</code> 向数据结构添加一个新的点 <code>point = [x, y]int count(int[] point)</code> 统计按上述方式与点 <code>point = [x, y]</code> 共同构造 轴对齐正方形 的方案数。</li></ul><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"DetectSquares"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>, <span class="string">"count"</span>, <span class="string">"add"</span>, <span class="string">"count"</span>]</span><br><span class="line">[[], [[<span class="number">3</span>, <span class="number">10</span>]], [[<span class="number">11</span>, <span class="number">2</span>]], [[<span class="number">3</span>, <span class="number">2</span>]], [[<span class="number">11</span>, <span class="number">10</span>]], [[<span class="number">14</span>, <span class="number">8</span>]], [[<span class="number">11</span>, <span class="number">2</span>]], [[<span class="number">11</span>, <span class="number">10</span>]]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, <span class="number">1</span>, <span class="number">0</span>, null, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">DetectSquares detectSquares = new DetectSquares();</span><br><span class="line">detectSquares.add([<span class="number">3</span>, <span class="number">10</span>]);</span><br><span class="line">detectSquares.add([<span class="number">11</span>, <span class="number">2</span>]);</span><br><span class="line">detectSquares.add([<span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line">detectSquares.count([<span class="number">11</span>, <span class="number">10</span>]); <span class="comment">// 返回 1 。你可以选择：</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第二个，和第三个点</span></span><br><span class="line">detectSquares.count([<span class="number">14</span>, <span class="number">8</span>]);  <span class="comment">// 返回 0 。查询点无法与数据结构中的这些点构成正方形。</span></span><br><span class="line">detectSquares.add([<span class="number">11</span>, <span class="number">2</span>]);    <span class="comment">// 允许添加重复的点。</span></span><br><span class="line">detectSquares.count([<span class="number">11</span>, <span class="number">10</span>]); <span class="comment">// 返回 2 。你可以选择：</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第二个，和第三个点</span></span><br><span class="line">                               <span class="comment">//   - 第一个，第三个，和第四个点</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>point.length == 2</code></li><li><code>0 &lt;= x, y &lt;= 1000</code></li><li>调用 add 和 count 的 总次数 最多为 <code>5000</code><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/detect-squares" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-squares</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> hash统计</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>感觉这个题目出的非常不好,也不清楚想考什么,反正很怪异的题目.</li><li>首先我们将所有的坐标进行统计,然后统计每个坐标$x$上都包含哪些总坐标$y$．</li></ol><ul><li>当执行$add$时,我们直接添加即可;</li><li>当执行查询$(x,y)$时,我们遍历所有横坐标同样也为$x$的点的统计.枚举每一个点$(x,z)$,此时我们即可知道需要查询的正方形的边长以及其余两个可能的点,直接查询点的统计数目,然后利用组合公式计算返回即可.</li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N)$,其中 $N$ 表示点的个数.</li><li>空间复杂度分析:　时间复杂度为$O(N*MAXP)$,其中 $N$ 表示点的个数. $MAXP$ 表示当前点的横坐标或者纵坐标的最大值．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectSquares</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DetectSquares() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        cnt[make_pair(point[<span class="number">0</span>],point[<span class="number">1</span>])]++;</span><br><span class="line">        cntx[point[<span class="number">0</span>]].insert(point[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = point[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cntx.count(x))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : cntx[x])&#123;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="built_in">abs</span>(v-y);</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> a = cnt[make_pair(x,v)];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//up</span></span><br><span class="line">                <span class="keyword">if</span>(cntx.count(x-l))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt.count(make_pair(x-l,y)) &amp;&amp; cnt.count(make_pair(x-l,v)))&#123;</span><br><span class="line">                        <span class="keyword">int</span> b = cnt[make_pair((x-l),y)];</span><br><span class="line">                        <span class="keyword">int</span> c = cnt[make_pair((x-l),v)];</span><br><span class="line">                        ans += a*b*c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//down</span></span><br><span class="line">                <span class="keyword">if</span>(cntx.count(x+l))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt.count(make_pair(x+l,y)) &amp;&amp; cnt.count(make_pair(x+l,v)))&#123;</span><br><span class="line">                        <span class="keyword">int</span> b = cnt[make_pair((x+l),y)];</span><br><span class="line">                        <span class="keyword">int</span> c = cnt[make_pair((x+l),v)];</span><br><span class="line">                        ans += a*b*c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; cntx;</span><br><span class="line">    <span class="built_in">map</span>&lt;pii,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DetectSquares object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DetectSquares* obj = new DetectSquares();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(point);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;count(point);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="5878-重复-K-次的最长子序列"><a href="#5878-重复-K-次的最长子序列" class="headerlink" title="5878. 重复 K 次的最长子序列"></a>5878. 重复 K 次的最长子序列</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 n 的字符串 s ，和一个整数 k 。请你找出字符串 s 中 重复 k 次的 最长子序列 。</p><p>子序列 是由其他字符串删除某些（或不删除）字符派生而来的一个字符串。</p><p>如果 seq <em> k 是 s 的一个子序列，其中 seq </em> k 表示一个由 seq 串联 k 次构造的字符串，那么就称 seq 是字符串 s 中一个 重复 k 次 的子序列。</p><p>举个例子，”bba” 是字符串 “bababcba” 中的一个重复 2 次的子序列，因为字符串 “bbabba” 是由 “bba” 串联 2 次构造的，而 “bbabba” 是字符串 “bababcba” 的一个子序列。<br>返回字符串 s 中 重复 k 次的最长子序列  。如果存在多个满足的子序列，则返回 字典序最大 的那个。如果不存在这样的子序列，返回一个 空 字符串。</p><p>示例 1：</p><p>输入：s = “letsleetcode”, k = 2<br>输出：”let”<br>解释：存在两个最长子序列重复 2 次：let” 和 “ete” 。<br>“let” 是其中字典序最大的一个。<br>示例 2：</p><p>输入：s = “bb”, k = 2<br>输出：”b”<br>解释：重复 2 次的最长子序列是 “b” 。<br>示例 3：</p><p>输入：s = “ab”, k = 2<br>输出：””<br>解释：不存在重复 2 次的最长子序列。返回空字符串。<br>示例 4：</p><p>输入：s = “bbabbabbbbabaababab”, k = 3<br>输出：”bbbb”<br>解释：在 “bbabbabbbbabaababab” 中重复 3 次的最长子序列是 “bbbb” 。</p><p>提示：</p><ul><li><code>n == s.length</code></li><li><code>2 &lt;= k &lt;= 2000</code></li><li><code>2 &lt;= n &lt; k * 8</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-subsequence-repeated-k-times</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>比赛时看了5分钟就退出了,后来下来之后仔细看了下解答,感觉比想象中神奇的题目,竟然不需要用到太复杂的理论,就是暴力枚举加减枝即可,真心是比较奇怪的题目,感觉按照这种解题思路不需要太多特殊的技巧.</li><li>题目的关键提示在于$2 &lt;= n &lt; k * 8$,根据这个提示我们可以知道,目标结果的字符串最长长度只能为$7$,所以目标字符串最多可能只含有$7$个字符,我们统计出字符中所有出现次数大于$k$的字符数目最多也只有$7$个,我们试想一下排列组合,$7$种字符的排列组合最多只有 $7! = 5000$种组合,我们可以把所有可能的组合计算出来，然后再进行在原字符串种检测是否重复出现$k$次,当然中间还可以通过各种减枝的手段进行优化和提升效率.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N*(\frac{N}{K})!)$,其中 $N$ 表示字符串的长度.</li><li>空间复杂度分析:　时间复杂度为$O(N)$,其中 $N$ 表示字符串的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; cnt,<span class="built_in">string</span> &amp; curr,<span class="built_in">string</span> &amp; res,<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [c,freq] : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[c] &lt; k) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            curr.push_back(c + <span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr.size() &gt; res.size() || (curr.size() == res.size() &amp;&amp; curr &gt; res))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(c == curr[pos])&#123;</span><br><span class="line">                        pos++;</span><br><span class="line">                        <span class="keyword">if</span>(pos == curr.size())&#123;</span><br><span class="line">                            pos = <span class="number">0</span>;</span><br><span class="line">                            times++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(times &gt;= k)&#123;</span><br><span class="line">                    res = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[c] -= k;</span><br><span class="line">            dfs(cnt,curr,res,s);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">            cnt[c] = freq;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestSubsequenceRepeatedK</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">if</span>(n &lt; k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="built_in">string</span> t;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) arr[c-<span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt;= k)&#123;</span><br><span class="line">                cnt[i] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(c-<span class="string">'a'</span>))&#123;</span><br><span class="line">                t.push_back(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(cnt,curr,ans,t);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-259&quot;&gt;&lt;a href=&quot;#leetcode-contest-259&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 259&quot;&gt;&lt;/a&gt;leetcode  contest 259&lt;/h1&gt;&lt;p&gt;还是三道题目的节奏,无奈太菜了.&lt;/p&gt;&lt;h2 id=&quot;5875-执行操作后的变量值&quot;&gt;&lt;a href=&quot;#5875-执行操作后的变量值&quot; class=&quot;headerlink&quot; title=&quot;5875. 执行操作后的变量值&quot;&gt;&lt;/a&gt;5875. 执行操作后的变量值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;存在一种仅支持 4 种操作和 1 个变量 X 的编程语言：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;++X&lt;/code&gt; 和 &lt;code&gt;X++&lt;/code&gt; 使变量 &lt;code&gt;X&lt;/code&gt; 的值 加 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--X&lt;/code&gt; 和 &lt;code&gt;X--&lt;/code&gt; 使变量 &lt;code&gt;X&lt;/code&gt; 的值 减 1&lt;br&gt;最初，X 的值是 0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;operations&lt;/code&gt; ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 61</title>
    <link href="http://yoursite.com/2021/09/19/327/"/>
    <id>http://yoursite.com/2021/09/19/327/</id>
    <published>2021-09-19T01:11:28.094Z</published>
    <updated>2021-09-19T05:23:12.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-61"><a href="#leetcode-biweekly-contest-61" class="headerlink" title="leetcode  biweekly contest 61"></a>leetcode  biweekly contest 61</h1><p>今天的题目都非常简单，基本上看一眼都有思路,感觉最后一题就是送分题，晚上坐火车没时间打卡，今天早上补上。<br><img src="https://i.loli.net/2021/09/19/wL2Zatf4UQB1TE3.png" alt></p><h2 id="5859-差的绝对值为-K-的数对数目"><a href="#5859-差的绝对值为-K-的数对数目" class="headerlink" title="5859. 差的绝对值为 K 的数对数目"></a>5859. 差的绝对值为 K 的数对数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回数对<code>(i, j)</code> 的数目，满足 <code>i &lt; j</code>且 <code>|nums[i] - nums[j]| == k</code>。</p><a id="more"></a><p><code>|x|</code> 的值定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：差的绝对值为 <span class="number">1</span> 的数对为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">- [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有任何数对差的绝对值为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：差的绝对值为 <span class="number">2</span> 的数对为：</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 99</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-61/problems/count-number-of-pairs-with-absolute-difference-k/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力双层循环,找到所有$|nums[i] - nums[j]| == k$ 的数对即可,时间复杂度为$O(N^{2})$.</li><li>采用<code>hash</code>查找,时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countKDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[i]-nums[j]) == k) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countKDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) cnt[v]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(v + k))&#123;</span><br><span class="line">                ans += cnt[v+k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5860-从双倍数组中还原原数组"><a href="#5860-从双倍数组中还原原数组" class="headerlink" title="5860. 从双倍数组中还原原数组"></a>5860. 从双倍数组中还原原数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>一个整数数组 <code>original</code> 可以转变成一个 双倍 数组 <code>changed</code>，转变方式为将 <code>original</code> 中每个元素 值乘以 2 加入数组中，然后将所有元素 随机打乱 。</p><p>给你一个数组 <code>changed</code>，如果 <code>change</code>是 双倍 数组，那么请你返回 <code>original</code>数组，否则请返回空数组。<code>original</code> 的元素可以以 任意 顺序返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：一个可能的 original 数组为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>] :</span><br><span class="line">- 将 <span class="number">1</span> 乘以 <span class="number">2</span> ，得到 <span class="number">1</span> * <span class="number">2</span> = <span class="number">2</span> 。</span><br><span class="line">- 将 <span class="number">3</span> 乘以 <span class="number">2</span> ，得到 <span class="number">3</span> * <span class="number">2</span> = <span class="number">6</span> 。</span><br><span class="line">- 将 <span class="number">4</span> 乘以 <span class="number">2</span> ，得到 <span class="number">4</span> * <span class="number">2</span> = <span class="number">8</span> 。</span><br><span class="line">其他可能的原数组方案为 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>] 或者 [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="section">changed</span> = [<span class="number">6</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：<span class="section">changed</span> 不是一个双倍数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">输入：changed = [<span class="number">1</span>]</span><br><span class="line">输出：[]</span><br><span class="line">解释：changed 不是一个双倍数组。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= changed.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= changed[i] &lt;= <span class="number">105</span>`</span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-61/problems/find-original-array-from-doubled-array/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  排序</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 题目本身不是很难，细节处理稍微复杂点，处理过程如下：</span><br><span class="line">+ 首先我们需要判断数组的长度是否为偶数,如果数组的长度不是偶数,显然不可能是双倍数组.</span><br><span class="line">+ 其次我们需要处理特殊的元素$<span class="number">0</span>$,因为$<span class="number">0</span>$的两倍还是$<span class="number">0</span>$本身,因此我们知道双倍数组中$<span class="number">0</span>$的个数一定是偶数,如果不是偶数,则为肯定为非法的双倍数组．</span><br><span class="line"><span class="number">2.</span> 我们统计每个数字的个数,其中$cnt[i]$表示当前为$i$的元素有多少个,我们从小到大遍历每一个元素.</span><br><span class="line">+ 如果该元素 $i$ 的统计个数大于 $<span class="number">0</span>$,则我们将$<span class="number">2</span>*i$ 的个数减去$cnt[i]$,即$cnt[<span class="number">2</span>*i] = cnt[<span class="number">2</span>*i] - cnt[i]$;</span><br><span class="line">+ 如果该元素 $i$ 的统计个数大于$<span class="number">0</span>$,如果$<span class="number">2</span>*i$大于数组中元素的最大值，则我们可以认为该数组非法，直接返回空数组即可；</span><br><span class="line">+ 如果该元素 $i$ 的统计个数小于$<span class="number">0</span>$,则我们认为该元素非法,直接返回空数组即可.</span><br><span class="line"><span class="number">3.</span> 复杂度分析:</span><br><span class="line">+ 时间复杂度为$O(N\lg(N))$, 其中$N$为数组的长度.</span><br><span class="line">+ 空间复杂度为$O(N)$,其中$N$为数组的长度.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; findOriginalArray(vector&lt;<span class="built_in">int</span>&gt;&amp; changed) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = changed.size();</span><br><span class="line">        map&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; cnt;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : changed) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]%<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; cnt[<span class="number">0</span>]/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">            ans.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt.erase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second &lt; <span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">            <span class="keyword">if</span>(v.second &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(v.first*<span class="number">2</span>)) <span class="keyword">return</span> vector&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">                cnt[v.first*<span class="number">2</span>] -= v.second;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; v.second; ++i)&#123;</span><br><span class="line">                    ans.push_back(v.first);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5861-出租车的最大盈利"><a href="#5861-出租车的最大盈利" class="headerlink" title="5861. 出租车的最大盈利"></a>5861. 出租车的最大盈利</h2><p>你驾驶出租车行驶在一条有 <code>n</code>个地点的路上。这 <code>n</code>个地点从近到远编号为 <code>1</code>到 <code>n</code> ，你想要从 <code>1</code> 开到 <code>n</code>，通过接乘客订单盈利。你只能沿着编号递增的方向前进`，不能改变方向。</p><p>乘客信息用一个下标从<code>0</code> 开始的二维数组 rides 表示，其中<code>rides[i] = [starti, endi, tipi]</code> 表示第 <code>i</code> 位乘客需要从地点 <code>starti</code>前往 <code>endi</code>，愿意支付 <code>tipi</code> 元的小费。</p><p>每一位 你选择接单的乘客 <code>i</code>，你可以 盈利 <code>endi - starti + tipi</code>元。你同时 最多 只能接一个订单。</p><p>给你 <code>n</code> 和 <code>rides</code> ，请你返回在最优接单方案下，你能盈利 最多 多少元。</p><p>注意：你可以在一个地点放下一位乘客，并在同一个地点接上另一位乘客。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, rides = [[<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：我们可以接乘客 <span class="number">0</span> 的订单，获得 <span class="number">5</span> - <span class="number">2</span> + <span class="number">4</span> = <span class="number">7</span> 元。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">20</span>, rides = [[<span class="number">1</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">10</span>,<span class="number">2</span>],[<span class="number">10</span>,<span class="number">12</span>,<span class="number">3</span>],[<span class="number">11</span>,<span class="number">12</span>,<span class="number">2</span>],[<span class="number">12</span>,<span class="number">15</span>,<span class="number">2</span>],[<span class="number">13</span>,<span class="number">18</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：我们可以接以下乘客的订单：</span><br><span class="line">- 将乘客 <span class="number">1</span> 从地点 <span class="number">3</span> 送往地点 <span class="number">10</span> ，获得 <span class="number">10</span> - <span class="number">3</span> + <span class="number">2</span> = <span class="number">9</span> 元。</span><br><span class="line">- 将乘客 <span class="number">2</span> 从地点 <span class="number">10</span> 送往地点 <span class="number">12</span> ，获得 <span class="number">12</span> - <span class="number">10</span> + <span class="number">3</span> = <span class="number">5</span> 元。</span><br><span class="line">- 将乘客 <span class="number">5</span> 从地点 <span class="number">13</span> 送往地点 <span class="number">18</span> ，获得 <span class="number">18</span> - <span class="number">13</span> + <span class="number">1</span> = <span class="number">6</span> 元。</span><br><span class="line">我们总共获得 <span class="number">9</span> + <span class="number">5</span> + <span class="number">6</span> = <span class="number">20</span> 元。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= rides.length &lt;= 3 * 104</code></li><li><code>rides[i].length == 3</code></li><li><code>1 &lt;= starti &lt; endi &lt;= n</code></li><li><code>1 &lt;= tipi &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常典型，也非常简单的<code>dp</code>,题目中明确说明了每段行程最多只能带一个人,所以就非常简单的<code>dp</code>就搞定了．我们设$dp[i]$为到达第$i$个站点的最大收益,则我们可以知道递推如下:</li></ol><ul><li>如果从地点$i$到地点$i+1$载客为空时,则此时我们可以知道$dp[i+1] = dp[i]$;</li><li>如果我们知道到$i+1$载客时，则我们可以将所有载客到第$i+1$个地点时的乘客全部遍历一遍即可,我们假设第$k$个乘客的目的地为$i+1$,则此时我们可以知道:<script type="math/tex; mode=display">dp[i] = \max(dp[i],dp[rides[k][0]] + rides[k][1] - rides[k][0] + rides[k][2])</script></li></ul><ol><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(M+N)$,其中 $N$ 表示地点的个数. $M$ 表示乘客的个数．</li><li>空间复杂度分析:　时间复杂度为$O(M+N)$,其中 $N$ 表示地点的个数. $M$ 表示乘客的个数．<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxTaxiEarnings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rides)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = rides.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            arr[rides[i][<span class="number">1</span>]].push_back(i);   </span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> idx = arr[i][j];</span><br><span class="line">                dp[i] = max(dp[i],dp[rides[idx][<span class="number">0</span>]] + rides[idx][<span class="number">1</span>] - rides[idx][<span class="number">0</span>] + rides[idx][<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5862-使数组连续的最少操作数"><a href="#5862-使数组连续的最少操作数" class="headerlink" title="5862. 使数组连续的最少操作数"></a>5862. 使数组连续的最少操作数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。每一次操作中，你可以将 <code>nums</code> 中 任意 一个元素替换成 任意 整数。</p><p>如果 <code>nums</code> 满足以下条件，那么它是 连续的 ：</p><ul><li><code>nums</code> 中所有元素都是 互不相同 的。</li><li><code>nums</code> 中 最大 元素与 最小 元素的差等于 <code>nums.length - 1</code> 。<br>比方说，<code>nums = [4, 2, 5, 3]</code> 是 连续的 ，但是 <code>nums = [1, 2, 3, 5, 6]</code> 不是连续的 。</li></ul><p>请你返回使 <code>nums</code> 连续 的 最少 操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：nums 已经是连续的了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：一个可能的解是将最后一个元素变为 <span class="number">4</span> 。</span><br><span class="line">结果数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>] ，是连续数组。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：一个可能的解是：</span><br><span class="line">- 将第二个元素变为 <span class="number">2</span> 。</span><br><span class="line">- 将第三个元素变为 <span class="number">3</span> 。</span><br><span class="line">- 将第四个元素变为 <span class="number">4</span> 。</span><br><span class="line">结果数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ，是连续数组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-61/problems/minimum-number-of-operations-to-make-array-continuous/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口　＋　二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>1.　题目较为简单，首先我们需要将数组去重，我们试想一下，如果保证数组连续，则我们可以试想一下贪心算法，必定这个连续的空间一定会包含数组元素中的值，如果该连续空间不包含任何元素，则肯定不是最优解．</p><ol><li>我们假设区间左起点必定以数组中的某个元素为起点,则我们依次希望区间$[nums[i],nums[i] + n-1]$尽可能的包含最多的不相等的元素,因此我们只需要区间数组中的每个元素$nums[i]$构成的区间$[nums[i],nums[i] + n-1]$包含的不相等的数组元素最多即可最终的目的区间.</li><li>首先我们可以将数组元素去重,并且按照元素从小到大进行排序,排序后我们每次遍历区间$[nums[i],nums[i] + n-1]$,求出该区间包含的最多元素的个数$maxdiff$,剩余的元素则需要按照题目要求进行变换即可,最终返回结果为$n-maxdiff$.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度分析: 时间复杂度为$O(N\lg(N) + N)$,其中 $N$ 表示数组的长度, 我们需要排序话费的时间为$O(N\lg(N))$, 然后我们需要遍历每个元素,花费的时间为$O(N)$.</li><li>空间复杂度分析:　时间复杂度为$O(N)$,其中 $N$ 表示数组的长度.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        arr.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                arr.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = upper_bound(arr.begin(),arr.end(),arr[i] + n<span class="number">-1</span>) - arr.begin() - i;</span><br><span class="line">            ans = min(ans,n-x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-61&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-61&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 61&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 61&lt;/h1&gt;&lt;p&gt;今天的题目都非常简单，基本上看一眼都有思路,感觉最后一题就是送分题，晚上坐火车没时间打卡，今天早上补上。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/09/19/wL2Zatf4UQB1TE3.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5859-差的绝对值为-K-的数对数目&quot;&gt;&lt;a href=&quot;#5859-差的绝对值为-K-的数对数目&quot; class=&quot;headerlink&quot; title=&quot;5859. 差的绝对值为 K 的数对数目&quot;&gt;&lt;/a&gt;5859. 差的绝对值为 K 的数对数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回数对&lt;code&gt;(i, j)&lt;/code&gt; 的数目，满足 &lt;code&gt;i &amp;lt; j&lt;/code&gt;且 &lt;code&gt;|nums[i] - nums[j]| == k&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 258</title>
    <link href="http://yoursite.com/2021/09/12/326/"/>
    <id>http://yoursite.com/2021/09/12/326/</id>
    <published>2021-09-12T05:35:47.973Z</published>
    <updated>2021-09-12T07:23:00.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-258"><a href="#leetcode-contest-258" class="headerlink" title="leetcode  contest 258"></a>leetcode  contest 258</h1><p>第四题还是不会,智商不够,刚开始准备用线段树来实现的.</p><h2 id="5867-反转单词前缀"><a href="#5867-反转单词前缀" class="headerlink" title="5867. 反转单词前缀"></a>5867. 反转单词前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的字符串 <code>word</code> 和一个字符<code>ch</code> 。找出 ch 第一次出现的下标 i ，反转 <code>word</code> 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 <code>word</code> 中不存在字符 <code>ch</code> ，则无需进行任何操作。</p><a id="more"></a><p>例如，如果 <code>word = &quot;abcdefd&quot;</code> 且 <code>ch = &quot;d&quot;</code> ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 <code>3</code> ）。结果字符串将会是 <code>&quot;dcbaefd&quot;</code> 。<br>返回 结果字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"abcdefd"</span>, ch = <span class="string">"d"</span></span><br><span class="line">输出：<span class="string">"dcbaefd"</span></span><br><span class="line">解释：<span class="string">"d"</span> 第一次出现在下标 <span class="number">3</span> 。 </span><br><span class="line">反转从下标 <span class="number">0</span> 到下标 <span class="number">3</span>（含下标 <span class="number">3</span>）的这段字符，结果字符串是 <span class="string">"dcbaefd"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：word = <span class="string">"xyxzxe"</span>, ch = <span class="string">"z"</span></span><br><span class="line">输出：<span class="string">"zxyxxe"</span></span><br><span class="line">解释：<span class="string">"z"</span> 第一次也是唯一一次出现是在下标 <span class="number">3</span> 。</span><br><span class="line">反转从下标 <span class="number">0</span> 到下标 <span class="number">3</span>（含下标 <span class="number">3</span>）的这段字符，结果字符串是 <span class="string">"zxyxxe"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"abcd"</span>, <span class="number">ch</span> = <span class="string">"z"</span></span><br><span class="line">输出：<span class="string">"abcd"</span></span><br><span class="line">解释：<span class="string">"z"</span> 不存在于 <span class="built_in">word</span> 中。</span><br><span class="line">无需执行反转操作，结果字符串是 <span class="string">"abcd"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 250</code></li><li><code>word</code> 由小写英文字母组成</li><li><code>ch</code> 是一个小写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reverse-prefix-of-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-prefix-of-word</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>查找第一个符合要求的字符的位置,然后反转字符串,然后返回即可.</li><li>时间复杂度为$O(N)$,空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reversePrefix</span><span class="params">(<span class="built_in">string</span> word, <span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word[i] == ch)&#123;</span><br><span class="line">                x = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            reverse(word.begin(),word.begin()+x+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5868-可互换矩形的组数"><a href="#5868-可互换矩形的组数" class="headerlink" title="5868. 可互换矩形的组数"></a>5868. 可互换矩形的组数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>用一个下标从<code>0</code>开始的二维整数数组 <code>rectangles</code> 来表示 <code>n</code> 个矩形，其中 <code>rectangles[i] = [widthi, heighti]</code> 表示第 <code>i</code>个矩形的宽度和高度。</p><p>如果两个矩形 <code>i</code> 和 <code>j（i &lt; j）</code>的宽高比相同，则认为这两个矩形 可互换 。更规范的说法是，两个矩形满足 <code>widthi/heighti == widthj/heightj</code>（使用实数除法而非整数除法），则认为这两个矩形 可互换 。</p><p>计算并返回 <code>rectangles</code> 中有多少对 可互换 矩形。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">4</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">6</span>],[<span class="number">10</span>,<span class="number">20</span>],[<span class="number">15</span>,<span class="number">30</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：下面按下标（从 <span class="number">0</span> 开始）列出可互换矩形的配对情况：</span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">1</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">3</span>/<span class="number">6</span></span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">2</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">10</span>/<span class="number">20</span></span><br><span class="line">- 矩形 <span class="number">0</span> 和矩形 <span class="number">3</span> ：<span class="number">4</span>/<span class="number">8</span> == <span class="number">15</span>/<span class="number">30</span></span><br><span class="line">- 矩形 <span class="number">1</span> 和矩形 <span class="number">2</span> ：<span class="number">3</span>/<span class="number">6</span> == <span class="number">10</span>/<span class="number">20</span></span><br><span class="line">- 矩形 <span class="number">1</span> 和矩形 <span class="number">3</span> ：<span class="number">3</span>/<span class="number">6</span> == <span class="number">15</span>/<span class="number">30</span></span><br><span class="line">- 矩形 <span class="number">2</span> 和矩形 <span class="number">3</span> ：<span class="number">10</span>/<span class="number">20</span> == <span class="number">15</span>/<span class="number">30</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在成对的可互换矩形。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == rectangles.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>rectangles[i].length == 2</code></li><li><code>1 &lt;= widthi, heighti &lt;= 105</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/number-of-pairs-of-interchangeable-rectangles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-pairs-of-interchangeable-rectangles</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序 + 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>我们利用公约数将其进行化简，然后统计即可．我们如果有　$x$个形式相同的矩形,则我们就用$\frac{n*(n-1)}{2}$种组合.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(n*\lg(n))$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">interchangeableRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rectangles.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = __gcd(rectangles[i][<span class="number">0</span>],rectangles[i][<span class="number">1</span>]);</span><br><span class="line">            cnt[make_pair(rectangles[i][<span class="number">0</span>]/c,rectangles[i][<span class="number">1</span>]/c)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += (v.second<span class="number">-1</span>)*v.second/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5869-两个回文子序列长度的最大乘积"><a href="#5869-两个回文子序列长度的最大乘积" class="headerlink" title="5869. 两个回文子序列长度的最大乘积"></a>5869. 两个回文子序列长度的最大乘积</h2><p>给你一个字符串 <code>s</code> ，请你找到 <code>s</code> 中两个 不相交回文子序列 ，使得它们长度的 乘积最大 。两个子序列在原字符串中如果没有任何相同下标的字符，则它们是 不相交 的。</p><p>请你返回两个回文子序列长度可以达到的 最大乘积 。</p><p>子序列 指的是从原字符串中删除若干个字符（可以一个也不删除）后，剩余字符不改变顺序而得到的结果。如果一个字符串从前往后读和从后往前读一模一样，那么这个字符串是一个 回文字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcodecom"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：最优方案是选择 <span class="string">"ete"</span> 作为第一个子序列，<span class="string">"cdc"</span> 作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bb"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最优方案为选择 <span class="string">"b"</span> （第一个字符）作为第一个子序列，<span class="string">"b"</span> （第二个字符）作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">1</span> * <span class="number">1</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"accbcaxxcxx"</span></span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：最优方案为选择 <span class="string">"accca"</span> 作为第一个子序列，<span class="string">"xxcxx"</span> 作为第二个子序列。</span><br><span class="line">它们的乘积为 <span class="number">5</span> * <span class="number">5</span> = <span class="number">25</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= s.length &lt;= 12</code></li><li><code>s</code> 只含有小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩,子集遍历</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目其实非常简单,因为数据集很小,我们直接把数据集分成两个不相交的子集,然后在每个子集中找到最长的回文串子序列,然后将两个值进行相乘即可.需要预处理，哪些子集为回文字符串．</li><li>时间复杂度为 $O(ｎ*2^{n} + 3^{n})$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">            x = (x<span class="number">-1</span>)&amp;x;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; dp(<span class="number">1</span>&lt;&lt;n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr.push_back(s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = curr.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">if</span>(curr[l] == curr[r])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) dp[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = __builtin_popcount(i);</span><br><span class="line">            <span class="keyword">int</span> res = ((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)^i;</span><br><span class="line">            <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = res; k != <span class="number">0</span>; k = (k<span class="number">-1</span>)&amp;res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[k]) <span class="keyword">continue</span>;</span><br><span class="line">                y = max(y,__builtin_popcount(k));</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,x*y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5870-每棵子树内缺失的最小基因值"><a href="#5870-每棵子树内缺失的最小基因值" class="headerlink" title="5870. 每棵子树内缺失的最小基因值"></a>5870. 每棵子树内缺失的最小基因值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一棵根节点为 <code>0</code>的 家族树 ，总共包含 <code>n</code>个节点，节点编号为<code>0</code> 到 <code>n - 1</code>。给你一个下标从 <code>0</code>开始的整数数组 <code>parents</code> ，其中 <code>parents[i]</code> 是节点 <code>i</code>的父节点。由于节点<code>0</code>是 根 ，所以 <code>parents[0] == -1</code> 。</p><p>总共有 <code>105</code> 个基因值，每个基因值都用 闭区间 <code>[1, 105]</code>中的一个整数表示。给你一个下标从<code>0</code> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code>是节点 <code>i</code> 的基因值，且基因值 互不相同 。</p><p>请你返回一个数组 <code>ans</code> ，长度为 <code>n</code> ，其中 <code>ans[i]</code>是以节点<code>i</code>为根的子树内 缺失 的 最小 基因值。</p><p>节点 <code>x</code>为根的 子树 包含节点 <code>x</code> 和它所有的 后代 节点。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>], nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个子树答案计算结果如下：</span><br><span class="line">- <span class="number">0</span>：子树包含节点 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，基因值分别为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] 。<span class="number">5</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">1</span>：子树只包含节点 <span class="number">1</span> ，基因值为 <span class="number">2</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">2</span>：子树包含节点 [<span class="number">2</span>,<span class="number">3</span>] ，基因值分别为 [<span class="number">3</span>,<span class="number">4</span>] 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">3</span>：子树只包含节点 <span class="number">3</span> ，基因值为 <span class="number">4</span> 。<span class="number">1</span>是缺失的最小基因值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>], nums = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个子树答案计算结果如下：</span><br><span class="line">- <span class="number">0</span>：子树内包含节点 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，基因值分别为 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。<span class="number">7</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">1</span>：子树内包含节点 [<span class="number">1</span>,<span class="number">2</span>] ，基因值分别为 [<span class="number">4</span>,<span class="number">6</span>] 。 <span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">2</span>：子树内只包含节点 <span class="number">2</span> ，基因值为 <span class="number">6</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">3</span>：子树内包含节点 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，基因值分别为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>] 。<span class="number">4</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">4</span>：子树内只包含节点 <span class="number">4</span> ，基因值为 <span class="number">1</span> 。<span class="number">2</span> 是缺失的最小基因值。</span><br><span class="line">- <span class="number">5</span>：子树内只包含节点 <span class="number">5</span> ，基因值为 <span class="number">3</span> 。<span class="number">1</span> 是缺失的最小基因值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>], nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：所有子树都缺失基因值 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == parents.length == nums.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li>对于 <code>i != 0</code>，满足 <code>0 &lt;= parents[i] &lt;= n - 1</code></li><li><code>parents[0] == -1</code></li><li><code>parents</code>表示一棵合法的树。</li><li><code>1 &lt;= nums[i] &lt;= 105</code></li><li><code>nums[i]</code> 互不相同。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/smallest-missing-genetic-value-in-each-subtree</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目给的解法很好,但是非常抽象,且不容易理解,大致意思如下:</li></ol><ul><li>如果子树中不含有元素$1$,则该子树的缺失的最小基因值一定为$1$.</li><li>假设子树中含有元素$1$,则我们需要特殊处理.</li><li><ul><li>实际上我们可以看出首先我们可以把当前节点$X$为根的子树中含有$1$部分单独剔除来,则这时我们只需要求出子树中含有$1$的节点的最小缺失基因值即可.我们可以仔细分析哪些子树中含有元素$1$?<script type="math/tex; mode=display">root \rightarrow p_{1} \rightarrow p_{2} \rightarrow ... \rightarrow p_{m} \rightarrow 1</script></li></ul></li><li><ul><li>我们只需要依次求出上述节点的缺失最小基因值即可，我们可以采用递归的形式，先求出　$p_{m}$ 的所有子节点和最小确实基因,同时对该子树的所有节点进行标记,接着我们会返回上一层到达 $p_{m-1}$,我们求出该节点的最小缺失基因,同时再将其所有的子节点进行标记.</li></ul></li><li><ul><li>我们逐层的自底向上一直递归,机会把节点的所有基因值进行标记.从而可以求得该链上的所有最小缺失基因.</li></ul></li></ul><ol><li>复杂度分析:</li></ol><ul><li>空间复杂度分析: 时间复杂度分析$O(2*N)$,空间复杂度为$O(n)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; hasone;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit;</span><br><span class="line">    <span class="keyword">int</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[root] == <span class="number">1</span>)&#123;</span><br><span class="line">            ret = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            ret |= dfs1(v,tree,nums,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            res[root] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasone[root] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">        visit[nums[root]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            dfs(v,tree,nums);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hasone[root]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasone[v])&#123;</span><br><span class="line">                dfs2(v,tree,nums,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[root])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasone[v])&#123;</span><br><span class="line">                dfs(v,tree,nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visit[nums[root]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(visit[now]) now++;</span><br><span class="line">        res[root] = now;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestMissingValueSubtree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;hasone = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;visit = <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(N,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;now = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                tree[parents[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(<span class="number">0</span>,tree,nums,ans);</span><br><span class="line">        dfs2(<span class="number">0</span>,tree,nums,ans);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, mex;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != p) &#123;</span><br><span class="line">                dfs(v, u);</span><br><span class="line">                mex[u] = max(mex[u], mex[v]);</span><br><span class="line">                <span class="keyword">if</span> (mp[v].size() &gt; mp[u].size())</span><br><span class="line">                    swap(mp[u], mp[v]); </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i : mp[v])</span><br><span class="line">                    mp[u].emplace(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[u].emplace(nums[u]);</span><br><span class="line">        <span class="keyword">while</span> (mp[u].count(mex[u]))</span><br><span class="line">            mex[u]++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallestMissingValueSubtree(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        n = parents.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        mex = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">            adj[parents[i]].emplace_back(i);</span><br><span class="line">        mp = <span class="built_in">vector</span>&lt;<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;(n);</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> mex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-258&quot;&gt;&lt;a href=&quot;#leetcode-contest-258&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 258&quot;&gt;&lt;/a&gt;leetcode  contest 258&lt;/h1&gt;&lt;p&gt;第四题还是不会,智商不够,刚开始准备用线段树来实现的.&lt;/p&gt;&lt;h2 id=&quot;5867-反转单词前缀&quot;&gt;&lt;a href=&quot;#5867-反转单词前缀&quot; class=&quot;headerlink&quot; title=&quot;5867. 反转单词前缀&quot;&gt;&lt;/a&gt;5867. 反转单词前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个下标从 0 开始的字符串 &lt;code&gt;word&lt;/code&gt; 和一个字符&lt;code&gt;ch&lt;/code&gt; 。找出 ch 第一次出现的下标 i ，反转 &lt;code&gt;word&lt;/code&gt; 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 &lt;code&gt;word&lt;/code&gt; 中不存在字符 &lt;code&gt;ch&lt;/code&gt; ，则无需进行任何操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  LCCUP 2021</title>
    <link href="http://yoursite.com/2021/09/12/325/"/>
    <id>http://yoursite.com/2021/09/12/325/</id>
    <published>2021-09-12T05:07:57.283Z</published>
    <updated>2021-09-12T07:42:44.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-LCCUP-2021"><a href="#leetcode-LCCUP-2021" class="headerlink" title="leetcode  LCCUP 2021"></a>leetcode  LCCUP 2021</h1><p>本身前<code>4</code>题确实不是很难，第五题确实判断合法状态时要复杂一些。</p><h2 id="1-无人机方阵"><a href="#1-无人机方阵" class="headerlink" title="1. 无人机方阵"></a>1. 无人机方阵</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：</p><p>调整无人机的位置布局<br>切换无人机展示的灯光颜色<br>给定两个大小均为 <code>N*M</code> 的二维数组 <code>source</code> 和 <code>target</code> 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 <code>source</code> 到 <code>target</code> 最少需要多少架无人机切换灯光颜色。</p><a id="more"></a><p>注意： 调整无人机的位置布局时无人机的位置可以随意变动。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：source = [[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">5</span>,<span class="number">4</span>]], target = [[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最佳方案为</span><br><span class="line">将 [<span class="number">0</span>,<span class="number">1</span>] 处的无人机移动至 [<span class="number">0</span>,<span class="number">0</span>] 处；</span><br><span class="line">将 [<span class="number">0</span>,<span class="number">0</span>] 处的无人机移动至 [<span class="number">0</span>,<span class="number">1</span>] 处；</span><br><span class="line">将 [<span class="number">1</span>,<span class="number">0</span>] 处的无人机移动至 [<span class="number">1</span>,<span class="number">1</span>] 处；</span><br><span class="line">将 [<span class="number">1</span>,<span class="number">1</span>] 处的无人机移动至 [<span class="number">1</span>,<span class="number">0</span>] 处，其灯光颜色切换为颜色编号为 <span class="number">6</span> 的灯光；</span><br><span class="line">因此从source 到 target 所需要的最少灯光切换次数为 <span class="number">1</span>。</span><br><span class="line"><span class="number">8819</span>ccdd664e91c78cde3bba3c701986.gif</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：source = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]], target = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">仅需调整无人机的位置布局，便可完成图案切换。因此不需要无人机切换颜色</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == source.length == target.length</code></li><li><code>m == source[i].length == target[i].length</code></li><li><code>1 &lt;= n, m &lt;=100</code></li><li><code>1 &lt;= source[i][j], target[i][j] &lt;=10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/0jQkd0/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/0jQkd0/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计每一种颜色,然后统计颜色原有的颜色与目标的颜色种类的差距即可.</li><li>时间复杂度$O(N)$, 空间复杂度为$O(M)$,其中$N$为无人机的数目,$M$为颜色的数目.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumSwitchingTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = source.size();</span><br><span class="line">        <span class="keyword">int</span> col = target[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnts(N);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cntt(N);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                cnts[source[i][j]]++;</span><br><span class="line">                cntt[target[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(cnts[i]-cntt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="2-心算挑战"><a href="#2-心算挑战" class="headerlink" title="2. 心算挑战"></a>2. 心算挑战</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>「力扣挑战赛」心算项目的挑战比赛中，要求选手从 <code>N</code> 张卡牌中选出 <code>cnt</code>张卡牌，若这 <code>cnt</code> 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 <code>cnt</code> 张卡牌数字总和。<br>给定数组 <code>cards</code> 和 <code>cnt</code>，其中 <code>cards[i]</code> 表示第<code>i</code>张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>], cnt = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line"></span><br><span class="line">解释：选择数字为 <span class="number">1</span>、<span class="number">8</span>、<span class="number">9</span> 的这三张卡牌，此时可获得最大的有效得分 <span class="number">1</span>+<span class="number">8</span>+<span class="number">9</span>=<span class="number">18</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cards = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>], cnt = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：不存在获取有效得分的卡牌方案。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= cnt &lt;= cards.length &lt;= 10^5</code></li><li><code>1 &lt;= cards[i] &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/uOAnQW/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/uOAnQW/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目的关键在于总数为偶数，我们知道偶数可以分解为任意个偶数与偶数个奇数的和相加，因此我们尝试所有的偶数和奇数的组合即可．每次取最大的$2<em>k$个奇数,然后取最大的$cnt - 2</em>k$个偶数即可.</li><li>复杂度分析:</li></ol><ul><li>时间复杂度为$O(N)$,空间复杂度为$O(N)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxmiumScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cards, <span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cards.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr1;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr2;</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        sort(cards.begin(),cards.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cards[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                arr1.push_back(cards[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr2.push_back(cards[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum1(arr1.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; sum2(arr2.size() + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> l1 = arr1.size();</span><br><span class="line">        <span class="keyword">int</span> l2 = arr2.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); ++i)&#123;</span><br><span class="line">            sum1[i+<span class="number">1</span>] = sum1[i] + arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.size(); ++i)&#123;</span><br><span class="line">            sum2[i+<span class="number">1</span>] = sum2[i] + arr2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> even = cnt - i;</span><br><span class="line">            <span class="keyword">int</span> odd = i;</span><br><span class="line">            <span class="keyword">if</span>(even &gt; arr1.size() || odd &gt; arr2.size()) <span class="keyword">continue</span>;</span><br><span class="line">            ans = max(ans,sum1[l1] - sum1[l1-even] + sum2[l2] - sum2[l2-odd]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="3-黑白翻转棋"><a href="#3-黑白翻转棋" class="headerlink" title="3. 黑白翻转棋"></a>3. 黑白翻转棋</h2><p>在 <code>n*m</code> 大小的棋盘中，有黑白两种棋子，黑棋记作字母<code>&quot;X&quot;</code>, 白棋记作字母 <code>&quot;O&quot;</code>，空余位置记作<code>&quot;.&quot;</code>。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。</p><p>「力扣挑战赛」黑白翻转棋项目中，将提供给选手一个未形成可翻转棋子的棋盘残局，其状态记作 <code>chessboard</code>。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。</p><p>注意：</p><p>若翻转白棋成黑棋后，棋盘上仍存在可以翻转的白棋，将可以 继续 翻转白棋<br>输入数据保证初始棋盘状态无可以翻转的棋子且存在空余位置<br>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">"....X."</span>,<span class="string">"....X."</span>,<span class="string">"XOOO.."</span>,<span class="string">"......"</span>,<span class="string">"......"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">2</span>,<span class="number">4</span>] 处，能够翻转白方三枚棋子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">".X."</span>,<span class="string">".O."</span>,<span class="string">"XO."</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">2</span>,<span class="number">2</span>] 处，能够翻转白方两枚棋子。</span><br><span class="line"><span class="number">2126</span>c1d21b1b9a9924c639d449cc6e65.gif</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：chessboard = [<span class="string">"......."</span>,<span class="string">"......."</span>,<span class="string">"......."</span>,<span class="string">"X......"</span>,<span class="string">".O....."</span>,<span class="string">"..O...."</span>,<span class="string">"....OOX"</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">可以选择下在 [<span class="number">6</span>,<span class="number">3</span>] 处，能够翻转白方四枚棋子。</span><br><span class="line"><span class="number">803</span>f2f04098b6174397d6c696f54d709.gif</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= chessboard.length, chessboard[i].length &lt;= 8</code></li><li><code>chessboard[i] 仅包含 &quot;.&quot;、&quot;O&quot; 和 &quot;X&quot;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/fHi6rV/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/fHi6rV/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>暴力检测</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目因为数据量很小,感觉没有任何技巧, 我们只需要遍历所有可以放置黑棋的位置,放置黑棋后,然后我们对棋盘上的棋子进行合并和翻转,直到没有可以翻转的可能性位置.代码写的比较水,完全用暴力取检测行,列,对角线中是否存在可以合并的棋子.感觉完全不用技巧的题目,不是很喜欢这个题目.</li><li>时间复杂度为 $O(64<em>64</em>64*8)$,空间复杂度为 $O(n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; board;</span><br><span class="line">    <span class="keyword">int</span> flip;</span><br><span class="line">    Node(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; board,<span class="keyword">int</span> flip)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;flip = flip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">flipChess</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; chessboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = chessboard.size();</span><br><span class="line">        <span class="keyword">int</span> col = chessboard[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(chessboard[i][j] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    chessboard[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                    qu.push(Node(chessboard,<span class="number">0</span>));</span><br><span class="line">                    chessboard[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            ans = max(ans,curr.flip);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> flip = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//check row flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;          </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(last);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[i][j] != curr.board[i][last])&#123;</span><br><span class="line">                        arr.push_back(j);</span><br><span class="line">                        last = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[i][arr[j<span class="number">-1</span>]] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[i][arr[j]] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[i][arr[j+<span class="number">1</span>]] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]; k &lt; arr[j+<span class="number">1</span>]; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[i][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check col flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;          </span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(last);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[j][i] != curr.board[last][i])&#123;</span><br><span class="line">                        arr.push_back(j);</span><br><span class="line">                        last = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j<span class="number">-1</span>]][i] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j]][i] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]][i] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]; k &lt; arr[j+<span class="number">1</span>]; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[k][i] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//check diag flip</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = i;</span><br><span class="line">                <span class="keyword">int</span> lasty = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y + j) &lt; col; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y+j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y + j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y + j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]%col; k &lt; arr[j+<span class="number">1</span>]%col; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col + k - arr[j]%col][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> lasty = i;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = i;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y + j) &lt; col; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y+j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y + j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y + j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = arr[j]%col; k &lt; arr[j+<span class="number">1</span>]%col; ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col + k - arr[j]%col][k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = i;</span><br><span class="line">                <span class="keyword">int</span> lasty = col<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = col<span class="number">-1</span>;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y - j) &gt;= <span class="number">0</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y-j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y - j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y - j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (arr[j+<span class="number">1</span>]/col - arr[j]/col); ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col+k][arr[j]%col-k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">                <span class="keyword">int</span> lastx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> lasty = i;</span><br><span class="line">                <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> y = i;</span><br><span class="line">                arr.push_back(x*col+y);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; (x + j) &lt; row &amp;&amp; (y - j) &gt;= <span class="number">0</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[x+j][y-j] != curr.board[lastx][lasty])&#123;</span><br><span class="line">                        arr.push_back((x+j)*col + y - j);</span><br><span class="line">                        lastx = x + j;</span><br><span class="line">                        lasty = y - j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; arr.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr.board[arr[j]/col][arr[j]%col] == <span class="string">'O'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j<span class="number">-1</span>]/col][arr[j<span class="number">-1</span>]%col] == <span class="string">'X'</span> &amp;&amp; \</span><br><span class="line">                       curr.board[arr[j+<span class="number">1</span>]/col][arr[j+<span class="number">1</span>]%col] == <span class="string">'X'</span> )&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (arr[j+<span class="number">1</span>]/col - arr[j]/col); ++k)&#123;</span><br><span class="line">                            flip++;</span><br><span class="line">                            curr.board[arr[j]/col+k][arr[j]%col-k] = <span class="string">'X'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flip &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                curr.flip += flip;</span><br><span class="line">                qu.push(curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="4-玩具套圈"><a href="#4-玩具套圈" class="headerlink" title="4. 玩具套圈"></a>4. 玩具套圈</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>「力扣挑战赛」场地外，小力组织了一个套玩具的游戏。所有的玩具摆在平地上，<code>toys[i]</code> 以 <code>[xi,yi,ri]</code> 的形式记录了第 <code>i</code> 个玩具的坐标 <code>(xi,yi)</code> 和半径 <code>ri</code>。小扣试玩了一下，他扔了若干个半径均为 <code>r</code> 的圈，<code>circles[j]</code>记录了第<code>j</code> 个圈的坐标 <code>(xj,yj)</code>。套圈的规则如下：</p><p>若一个玩具被某个圈完整覆盖了（即玩具的任意部分均在圈内或者圈上），则该玩具被套中。<br>若一个玩具被多个圈同时套中，最终仅计算为套中一个玩具<br>请帮助小扣计算，他成功套中了多少玩具。</p><p>注意：</p><ul><li><p>输入数据保证任意两个玩具的圆心不会重合，但玩具之间可能存在重叠。<br>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：toys = [[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]], circles = [[<span class="number">4</span>,<span class="number">3</span>]], r = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释： 如图所示，仅套中一个玩具</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：toys = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>]], circles = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">3</span>]], r = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释： 如图所示，套中两个玩具</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><p>提示：</p></li><li><p><code>1 &lt;= toys.length &lt;= 10^4</code></p></li><li><code>0 &lt;= toys[i][0], toys[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= circles.length &lt;= 10^4</code></li><li><code>0 &lt;= circles[i][0], circles[i][1] &lt;= 10^9</code></li><li><code>1 &lt;= toys[i][2], r &lt;= 10</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/season/2021-fall/problems/vFjcfV/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/season/2021-fall/problems/vFjcfV/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>数学问题，咋一看题目挺吓人，关键是在于圈套的半径值只有　$[1,20]$ 之间,此时我们就可以利用数学的方法,来快速的检测出，每个玩具的周围是否存在可以将其完全套住的圈即可．</li><li>我们假设玩具的坐标为$[x_{1},y_{1}]$,玩具的的半径为$r_{1}$,圈的坐标为$[x_{2},y_{2}]$,圈的半径为 $r_{2}$,则此时我们根据数学的判定公式需要满足如下条件,才能使得圈可以完全覆盖住玩具:<script type="math/tex; mode=display">\sqrt{(x_{1}-x_{2})^{2} + (y_{1}-y_{2})^{2}} \le r_{2} - r_{1}</script>即两个圆心的距离小于等于二者的半径之差.</li><li>我们只需要检测在玩具的圆心位置$(x_{1}-10,y_{1}-10),(x_{1}+10,y_{1}+10)$的范围内是否存在满足两个圆覆盖的圆心,该圆心是否在圈中存在.</li><li>时间复杂度为 $O(20<em>20</em>N*\lg(M))$, 空间复杂度为 $O(M)$,其中 $N$ 为玩具的数目, $N$ 为圈的数目.</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">circleGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; toys, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; circles, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;pii&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : circles)&#123;</span><br><span class="line">            cnt.insert(make_pair(v[<span class="number">0</span>],v[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; toys.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(toys[i][<span class="number">2</span>] &gt; r) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> dx = <span class="number">-10</span>; dx &lt;= <span class="number">10</span>; ++dx)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> dy = <span class="number">-10</span>; dy &lt;= <span class="number">10</span>; ++dy)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((dx*dx + dy*dy) &lt;= (r - toys[i][<span class="number">2</span>])*(r - toys[i][<span class="number">2</span>]))&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = toys[i][<span class="number">0</span>] + dx;</span><br><span class="line">                        <span class="keyword">int</span> y = toys[i][<span class="number">1</span>] + dy;</span><br><span class="line">                        <span class="keyword">if</span>(cnt.count(make_pair(x,y)))&#123;</span><br><span class="line">                            valid = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(valid) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-十字路口的交通"><a href="#5-十字路口的交通" class="headerlink" title="5. 十字路口的交通"></a>5. 十字路口的交通</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>前往「力扣挑战赛」场馆的道路上，有一个拥堵的十字路口，该十字路口由两条双向两车道的路交叉构成。由于信号灯故障，交警需要手动指挥拥堵车辆。假定路口没有新的来车且一辆车从一个车道驶入另一个车道所需的时间恰好为一秒钟，长度为 <code>4</code> 的一维字符串数组<code>directions</code> 中按照 东、南、西、北 顺序记录了四个方向从最靠近路口到最远离路口的车辆计划开往的方向。其中：</p><ul><li>“E” 表示向东行驶；</li><li>“S” 表示向南行驶；</li><li>“W” 表示向西行驶；</li><li>“N” 表示向北行驶。<br>交警每秒钟只能指挥各个车道距离路口最近的一辆车，且每次指挥需要满足如下规则：</li></ul><p>同一秒钟内，一个方向的车道只允许驶出一辆车；<br>同一秒钟内，一个方向的车道只允许驶入一辆车；<br>同一秒钟内，车辆的行驶路线不可相交。<br>请返回最少需要几秒钟，该十字路口等候的车辆才能全部走完。</p><p>各个车道驶出的车辆可能的行驶路线如图所示：</p><p>注意：</p><ul><li>测试数据保证不会出现掉头行驶指令，即某一方向的行驶车辆计划开往的方向不会是当前车辆所在的车道的方向;</li><li>表示堵塞车辆行驶方向的字符串仅用大写字母 “E”，”N”，”W”，”S” 表示。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：directions = [<span class="string">"W"</span>,<span class="string">"N"</span>,<span class="string">"ES"</span>,<span class="string">"W"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 秒：东西方向排在最前的车先行，剩余车辆状态 [<span class="string">""</span>,<span class="string">"N"</span>,<span class="string">"S"</span>,<span class="string">"W"</span>]；</span><br><span class="line">第 <span class="number">2</span> 秒：南、西、北方向的车行驶，路口无等待车辆；</span><br><span class="line">因此最少需要 <span class="number">2</span> 秒，返回 <span class="number">2</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：directions = [<span class="string">"NS"</span>,<span class="string">"WE"</span>,<span class="string">"SE"</span>,<span class="string">"EW"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">1</span> 秒：四个方向排在最前的车均可驶出；</span><br><span class="line">第 <span class="number">2</span> 秒：东南方向的车驶出，剩余车辆状态 [<span class="string">""</span>,<span class="string">""</span>,<span class="string">"E"</span>,<span class="string">"W"</span>]；</span><br><span class="line">第 <span class="number">3</span> 秒：西北方向的车驶出。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>directions.length = 4</code></li><li><code>0 &lt;= directions[i].length &lt;= 20</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/Y1VbOX" target="_blank" rel="noopener">https://leetcode-cn.com/problems/Y1VbOX</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP　或者　DFS记忆化搜索</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>感觉这个<code>dp</code>最大的难度在于如何判断四个方向出行的车是否合法,检测了半天感觉都有点问题．感觉判断方向是否合法的时候非常容易出错．</li><li>算法时间复杂度为 $O(64*N^{4})$.题目虽然不是很难,但是感觉判断条件非常容易出错.</li></ol></blockquote><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dir;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">100</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp.count(curr)) <span class="keyword">return</span> dp[curr];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            tot += dir[i].size() - curr[i];           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tot == <span class="number">0</span>)&#123;</span><br><span class="line">            dp[curr] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check valid</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(curr[j] == dir[j].size())&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!valid) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check if the direction is valid</span></span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>))&#123;</span><br><span class="line">                <span class="comment">// E -&gt; S</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//E -&gt; W</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//E -&gt; N</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// S -&gt; W</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// S -&gt; N</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>))&#123;</span><br><span class="line">                <span class="comment">// W -&gt; E</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// W -&gt; N</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>)) &amp;&amp; dir[<span class="number">3</span>][curr[<span class="number">3</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">3</span>))&#123;</span><br><span class="line">                <span class="comment">// N -&gt; E</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] != <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] == <span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// N -&gt; S</span></span><br><span class="line">                <span class="keyword">if</span>(dir[<span class="number">3</span>][curr[<span class="number">3</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">0</span>)) &amp;&amp; dir[<span class="number">0</span>][curr[<span class="number">0</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">1</span>)) &amp;&amp; dir[<span class="number">1</span>][curr[<span class="number">1</span>]] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;<span class="number">2</span>)) &amp;&amp; dir[<span class="number">2</span>][curr[<span class="number">2</span>]] != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr[j] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = min(ret,<span class="number">1</span> + dfs(curr));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&amp;(<span class="number">1</span>&lt;&lt;j)) curr[j] -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for(int i = 0; i &lt; 4; ++i)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;curr[i]&lt;&lt;":";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;ret&lt;&lt;endl;*/</span></span><br><span class="line">        dp[curr] = ret;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trafficCommand</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; directions)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; arr(<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directions.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : directions[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">'E'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">0</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'S'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'W'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'N'</span>)&#123;</span><br><span class="line">                    arr[i].push_back(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dir = arr;</span><br><span class="line">        <span class="keyword">return</span> dfs(curr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-LCCUP-2021&quot;&gt;&lt;a href=&quot;#leetcode-LCCUP-2021&quot; class=&quot;headerlink&quot; title=&quot;leetcode  LCCUP 2021&quot;&gt;&lt;/a&gt;leetcode  LCCUP 2021&lt;/h1&gt;&lt;p&gt;本身前&lt;code&gt;4&lt;/code&gt;题确实不是很难，第五题确实判断合法状态时要复杂一些。&lt;/p&gt;&lt;h2 id=&quot;1-无人机方阵&quot;&gt;&lt;a href=&quot;#1-无人机方阵&quot; class=&quot;headerlink&quot; title=&quot;1. 无人机方阵&quot;&gt;&lt;/a&gt;1. 无人机方阵&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在 「力扣挑战赛」 开幕式的压轴节目 「无人机方阵」中，每一架无人机展示一种灯光颜色。 无人机方阵通过两种操作进行颜色图案变换：&lt;/p&gt;&lt;p&gt;调整无人机的位置布局&lt;br&gt;切换无人机展示的灯光颜色&lt;br&gt;给定两个大小均为 &lt;code&gt;N*M&lt;/code&gt; 的二维数组 &lt;code&gt;source&lt;/code&gt; 和 &lt;code&gt;target&lt;/code&gt; 表示无人机方阵表演的两种颜色图案，由于无人机切换灯光颜色的耗能很大，请返回从 &lt;code&gt;source&lt;/code&gt; 到 &lt;code&gt;target&lt;/code&gt; 最少需要多少架无人机切换灯光颜色。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
