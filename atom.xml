<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-14T08:04:46.508Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 28周双比赛</title>
    <link href="http://yoursite.com/2020/06/14/171/"/>
    <id>http://yoursite.com/2020/06/14/171/</id>
    <published>2020-06-14T08:04:41.518Z</published>
    <updated>2020-06-14T08:04:46.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="28周双周赛"><a href="#28周双周赛" class="headerlink" title="28周双周赛"></a>28周双周赛</h1><p>前3题半个小时搞定，最后一题又是经典的DP，在最后20分钟想出来了解决办法，但是没有时间提交了，最终排名竟然还挺高152名。赛后又加班搞了半个小时搞定了。其中涉及到一个中位数的数学理论。感慨下还是智商不够高。<br><img src="https://mike-box.github.io/images/173-1.png" alt="1"><br>本周双周赛的第四题出的非常好，又有数学理论和dp相结合，题目非常经典，虽然当时没有做出来，但是赛后靠自己的理解没有看答案做出来了，我觉得每次做题锻炼自己独立思考问题的能力非常重要，而不是上来就看答案。</p><a id="more"></a><h2 id="5420-商品折扣后的最终价格"><a href="#5420-商品折扣后的最终价格" class="headerlink" title="5420. 商品折扣后的最终价格"></a>5420. 商品折扣后的最终价格</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>prices</code>，其中<code>prices[i]</code>是商店里第<code>i</code>件商品的价格。</p><p>商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 <code>prices[j]</code>相等的折扣，其中 j 是满足 <code>j &gt; i</code> 且 <code>prices[j] &lt;= prices[i]</code>的 最小下标 ，如果没有满足条件的 <code>j</code> ，你将没有任何折扣。</p><p>请你返回一个数组，数组中第 <code>i</code>个元素是折扣后你购买商品 i 最终需要支付的价格。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">商品 <span class="number">0</span> 的价格为 price[<span class="number">0</span>]=<span class="number">8</span> ，你将得到 prices[<span class="number">1</span>]=<span class="number">4</span> 的折扣，所以最终价格为 <span class="number">8</span> - <span class="number">4</span> = <span class="number">4</span> 。</span><br><span class="line">商品 <span class="number">1</span> 的价格为 price[<span class="number">1</span>]=<span class="number">4</span> ，你将得到 prices[<span class="number">3</span>]=<span class="number">2</span> 的折扣，所以最终价格为 <span class="number">4</span> - <span class="number">2</span> = <span class="number">2</span> 。</span><br><span class="line">商品 <span class="number">2</span> 的价格为 price[<span class="number">2</span>]=<span class="number">6</span> ，你将得到 prices[<span class="number">3</span>]=<span class="number">2</span> 的折扣，所以最终价格为 <span class="number">6</span> - <span class="number">2</span> = <span class="number">4</span> 。</span><br><span class="line">商品 <span class="number">3</span> 和 <span class="number">4</span> 都没有折扣。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">解释：在这个例子中，所有商品都没有折扣。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices.length &lt;= <span class="number">500</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= prices[i] &lt;= <span class="number">10</span>^<span class="number">3</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/final-prices-with-a-special-discount-in-a-shop</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 这个题目没啥好说的，找到从`i+<span class="number">1</span>`处开始第一个比`arr[i]`小的数即可，两层循环，O(n^<span class="number">2</span>)复杂度。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; finalPrices(vector&lt;<span class="built_in">int</span>&gt;&amp; prices) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = prices.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; cut(n,<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cut[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[j] &lt;= prices[i])&#123;</span><br><span class="line">                    cut[i] = prices[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(prices[i] - cut[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5422-子矩形查询"><a href="#5422-子矩形查询" class="headerlink" title="5422. 子矩形查询"></a>5422. 子矩形查询</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你实现一个类 <code>SubrectangleQueries</code> ，它的构造函数的参数是一个 <code>rows x cols</code> 的矩形（这里用整数矩阵表示），并支持以下两种操作：</p><ul><li><ol><li>updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)</li></ol></li></ul><p>用 <code>newValue</code> 更新以 <code>(row1,col1)</code> 为左上角且以 <code>(row2,col2)</code>为右下角的子矩形。</p><ul><li><ol><li><code>getValue(int row, int col)</code></li></ol></li></ul><p>返回矩形中坐标 <code>(row,col)</code>的当前值。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SubrectangleQueries"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>]</span><br><span class="line">[[[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,null,<span class="number">5</span>,<span class="number">5</span>,null,<span class="number">10</span>,<span class="number">5</span>]</span><br><span class="line">解释：</span><br><span class="line">SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]);  </span><br><span class="line"><span class="comment">// 初始的 (4x3) 矩形如下：</span></span><br><span class="line"><span class="comment">// 1 2 1</span></span><br><span class="line"><span class="comment">// 4 3 4</span></span><br><span class="line"><span class="comment">// 3 2 1</span></span><br><span class="line"><span class="comment">// 1 1 1</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 1</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 此次更新后矩形变为：</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5</span></span><br><span class="line"><span class="comment">// 5 5 5 </span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 5</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 返回 5</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 此次更新后矩形变为：</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 5   5   5</span></span><br><span class="line"><span class="comment">// 10  10  10 </span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">3</span>, <span class="number">1</span>); <span class="comment">// 返回 10</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">2</span>); <span class="comment">// 返回 5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"SubrectangleQueries"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>,<span class="string">"getValue"</span>,<span class="string">"updateSubrectangle"</span>,<span class="string">"getValue"</span>]</span><br><span class="line">[[[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">20</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,<span class="number">1</span>,null,<span class="number">100</span>,<span class="number">100</span>,null,<span class="number">20</span>]</span><br><span class="line">解释：</span><br><span class="line">SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]]);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 返回 1</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">100</span>);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 返回 100</span></span><br><span class="line">subrectangleQueries.getValue(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 返回 100</span></span><br><span class="line">subrectangleQueries.updateSubrectangle(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">subrectangleQueries.getValue(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 返回 20</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>最多有 500 次<code>updateSubrectangle</code>和 <code>getValue</code>操作。</li><li><code>1 &lt;= rows, cols &lt;= 100</code></li><li><code>rows == rectangle.length</code></li><li><code>cols == rectangle[i].length</code></li><li><code>0 &lt;= row1 &lt;= row2 &lt; rows</code></li><li><code>0 &lt;= col1 &lt;= col2 &lt; cols</code></li><li><code>1 &lt;= newValue, rectangle[i][j] &lt;= 10^9</code></li><li><code>0 &lt;= row &lt; rows</code></li><li><code>0 &lt;= col &lt; cols</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/subrectangle-queries" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subrectangle-queries</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目咋一看非常复杂，实际我们不用每次都去真正的实际改变矩阵的值，只需要去查询即可。</li><li>我们保存更新的列表，找到最近一次更新<code>(row,col)</code>的值即可，时间杂度读O<code>(n^2)</code>。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubrectangleQueries</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SubrectangleQueries(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rectangle) &#123;</span><br><span class="line">        matrix = rectangle;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateSubrectangle</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        start.push_back(make_pair(row1,col1));</span><br><span class="line">        end.push_back(make_pair(row2,col2));</span><br><span class="line">        val.push_back(newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row &gt;= start[i].first &amp;&amp; col &gt;= start[i].second &amp;&amp; </span><br><span class="line">               row &lt;= end[i].first &amp;&amp; col &lt;= end[i].second)&#123;</span><br><span class="line">                <span class="keyword">return</span> val[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> matrix[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; start;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; end;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SubrectangleQueries object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SubrectangleQueries* obj = new SubrectangleQueries(rectangle);</span></span><br><span class="line"><span class="comment"> * obj-&gt;updateSubrectangle(row1,col1,row2,col2,newValue);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;getValue(row,col);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5423-找两个和为目标值且不重叠的子数组"><a href="#5423-找两个和为目标值且不重叠的子数组" class="headerlink" title="5423. 找两个和为目标值且不重叠的子数组"></a>5423. 找两个和为目标值且不重叠的子数组</h2><p>给你一个整数数组 <code>arr</code> 和一个整数值 <code>target</code> 。</p><p>请你在<code>arr</code>中找 两个互不重叠的子数组 且它们的和都等于 <code>target</code>。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p><p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 <code>-1</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：只有两个子数组和为 <span class="number">3</span> （[<span class="number">3</span>] 和 [<span class="number">3</span>]）。它们的长度和为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], target = <span class="number">7</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：尽管我们有 <span class="number">3</span> 个互不重叠的子数组和为 <span class="number">7</span> （[<span class="number">7</span>], [<span class="number">3</span>,<span class="number">4</span>] 和 [<span class="number">7</span>]），但我们会选择第一个和第三个子数组，因为它们的长度和 <span class="number">2</span> 是最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：我们只有一个和为 <span class="number">6</span> 的子数组。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：我们无法找到和为 <span class="number">3</span> 的子数组。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：注意子数组 [<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">2</span>,<span class="number">1</span>] 不能成为一个方案因为它们重叠了。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= target &lt;= 10^8</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们设<code>dp[i]</code>表示前<code>i</code>个元素中存在的连续子数组和为<code>target</code>的最小长度。</li><li>由于数组中所有的数都为正数，所以我们可以利用hash值来快速查询以索引<code>i</code>为结尾且和为<code>target</code>的连续子数组是否存在，如果存在则它的长度肯定是唯一的,我们可以利用<code>hash[sum-target]]</code>快速的得该连续子数组的最左的起点位置索引<code>j</code>，即可快速求出连续子数组的长度.我们用<code>len(target,i)</code>代表和为<code>target</code>且最右边的终点为索引<code>i</code>的连续子数组的长度。则可以得到公式为：<script type="math/tex; mode=display">\begin{array}{l}minSum = min(minSum,len(target,i) + dp[i-len(target,i)]) \quad (if \quad len(target,i) > 0) \\\\dp[i] = min(dp[i-1],len(target,i)) \quad (if \quad len(target,i) > 0) \\\end{array}</script><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> res = n+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,n+<span class="number">1</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            cnt[sum] = i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>) dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(sum-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> prev = cnt[sum-target];</span><br><span class="line">                <span class="keyword">if</span>(prev &gt;= <span class="number">0</span> &amp;&amp; dp[prev] &lt;= n)&#123;</span><br><span class="line">                    res = min(i - prev + dp[prev],res);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = min(dp[i],i - prev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5421-安排邮筒"><a href="#5421-安排邮筒" class="headerlink" title="5421. 安排邮筒"></a>5421. 安排邮筒</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个房屋数组houses 和一个整数<code>k</code>，其中 <code>houses[i]</code>是第 <code>i</code>栋房子在一条街上的位置，现需要在这条街上安排<code>k</code>个邮筒。</p><p>请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。</p><p>答案保证在 32 位有符号整数范围以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">20</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：将邮筒分别安放在位置 <span class="number">3</span>， <span class="number">9</span> 和 <span class="number">20</span> 处。</span><br><span class="line">每个房子到最近邮筒的距离和为 |<span class="number">3</span><span class="number">-1</span>| + |<span class="number">4</span><span class="number">-3</span>| + |<span class="number">9</span><span class="number">-8</span>| + |<span class="number">10</span><span class="number">-9</span>| + |<span class="number">20</span><span class="number">-20</span>| = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>,<span class="number">18</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：将邮筒分别安放在位置 <span class="number">3</span> 和 <span class="number">14</span> 处。</span><br><span class="line">每个房子到最近邮筒距离和为 |<span class="number">2</span><span class="number">-3</span>| + |<span class="number">3</span><span class="number">-3</span>| + |<span class="number">5</span><span class="number">-3</span>| + |<span class="number">12</span><span class="number">-14</span>| + |<span class="number">18</span><span class="number">-14</span>| = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">7</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">示例 <span class="number">4</span>：</span><br><span class="line"></span><br><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">10</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == houses.length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= houses[i] &lt;= 10^4</code></li><li><code>1 &lt;= k &lt;= n</code></li><li>数组 <code>houses</code> 中的整数互不相同。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/allocate-mailboxes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/allocate-mailboxes</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>题目出的非常好，中位数 + DP。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先这个题目需要了解一下背景知识，在一个已经排序的数列中，数列中所有元素与中位数绝对值之差的和最小:<script type="math/tex; mode=display">\begin{array}{l}A = [a_{1},a_{2},a_{3},...,a_{n}] \\\\minimum\sum_{i=1}^{n} |a_{i} - X| = \sum_{i=1}^{n} |a_{i} - A_{median}| \\\end{array}</script><script type="math/tex; mode=display">A_{median} = \left\{\begin{array}{l}a_{\frac{n+1}{2}} \quad n\pmod 2 = 1\\\\\frac{a_{\frac{n}{2}} +  a_{\frac{n}{2} + 1}}{2} \quad n\pmod 2 = 0\\\end{array}\right.</script>数列中所有的元素与平均和的差的平方和最小。<script type="math/tex; mode=display">\begin{array}{l}A = [a_{1},a_{2},a_{3},...,a_{n}] \\\\minimum\sum_{i=1}^{n} (a_{i} - X)^{2} = \sum_{i=1}^{n} |a_{i} - \overline{A}| \\\\\overline{A} = \frac{\sum_{i=1}^{n}a_{i}}{n} \\\end{array}</script></li><li>根据1的提示，我们可以很容易算出，如果在第<code>i</code>到<code>j</code>个<code>house</code>之间放置一个邮箱，那么该邮箱肯定放置在<code>house[i]</code>与<code>house[j]</code>的序列之间的中位数，很容易算出最小距离。我们假设<code>cost[i][j]</code>代表在<code>i</code>到<code>j</code>之间放置1个邮箱的最小距离之和，则：<script type="math/tex; mode=display">cost[i][j] = \sum_{k=i}^{j}abs(house[k]-A(i,j)_{median})</script></li><li>我们设递推公式<code>dp[i][j]</code>代表前<code>i</code>个house中放置<code>j</code>个邮箱的最小距离之和。我们只需要关心，新加入的第<code>j</code>个邮箱，有哪些<code>house</code>是到它的距离最短，假如我们已知最优解<code>dp[i][j]</code>,我们就需要去分别讨论有哪些<code>house</code>是以第<code>j</code>个邮箱为最近距离。则递推公式应该为:<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[k][j-1] + cost[k+1][i]) \quad (k\in(j-1,i-1))</script></li><li>题目还是非常难的，需要仔细理解dp和部分数学定理。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = houses.size();</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        sort(houses.begin(),houses.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cost(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((j-i+<span class="number">1</span>)%<span class="number">2</span> == <span class="number">0</span>) mid = (houses[(i+j)/<span class="number">2</span><span class="number">-1</span>] + houses[(i+j)/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> mid = houses[(i+j)/<span class="number">2</span><span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; ++k)&#123;</span><br><span class="line">                    cost[i][j] += <span class="built_in">abs</span>(houses[k<span class="number">-1</span>]-mid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = cost[<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= m &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = max(<span class="number">1</span>,j<span class="number">-1</span>); k &lt;= i - <span class="number">1</span>; ++k)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[k][j<span class="number">-1</span>] + cost[k+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;28周双周赛&quot;&gt;&lt;a href=&quot;#28周双周赛&quot; class=&quot;headerlink&quot; title=&quot;28周双周赛&quot;&gt;&lt;/a&gt;28周双周赛&lt;/h1&gt;&lt;p&gt;前3题半个小时搞定，最后一题又是经典的DP，在最后20分钟想出来了解决办法，但是没有时间提交了，最终排名竟然还挺高152名。赛后又加班搞了半个小时搞定了。其中涉及到一个中位数的数学理论。感慨下还是智商不够高。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/173-1.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;本周双周赛的第四题出的非常好，又有数学理论和dp相结合，题目非常经典，虽然当时没有做出来，但是赛后靠自己的理解没有看答案做出来了，我觉得每次做题锻炼自己独立思考问题的能力非常重要，而不是上来就看答案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 192周比赛</title>
    <link href="http://yoursite.com/2020/06/07/170/"/>
    <id>http://yoursite.com/2020/06/07/170/</id>
    <published>2020-06-07T08:23:30.556Z</published>
    <updated>2020-06-08T13:25:34.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="192周双周赛"><a href="#192周双周赛" class="headerlink" title="192周双周赛"></a>192周双周赛</h1><p>最后一题又是经典的DP，中间某个小case过不去，一直卡了好长时间，最后在1：28提交正确，最终排名242名。感慨还是老了，脑袋转不动，其实这些题目本质就是考智商。<br><img src="https://mike-box.github.io/images/172-1.png" alt="1"></p><h2 id="5428-重新排列数组"><a href="#5428-重新排列数组" class="headerlink" title="5428. 重新排列数组"></a>5428. 重新排列数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code> ，数组中有<code>2n</code>个元素，按 <code>[x1,x2,...,xn,y1,y2,...,yn]</code> 的格式排列。</p><a id="more"></a><p>请你将数组按 <code>[x1,y1,x2,y2,...,xn,yn]</code> 格式重新排列，返回重排后的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>] </span><br><span class="line">解释：由于 x1=<span class="number">2</span>, x2=<span class="number">5</span>, x3=<span class="number">1</span>, y1=<span class="number">3</span>, y2=<span class="number">4</span>, y3=<span class="number">7</span> ，所以答案为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], n = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 500</code></li><li><code>nums.length == 2n</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/shuffle-the-array/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>按照(i,n+i)的顺序依次压入数组即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            res.push_back(nums[n+i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5429-数组中的-k-个最强值"><a href="#5429-数组中的-k-个最强值" class="headerlink" title="5429. 数组中的 k 个最强值"></a>5429. 数组中的 k 个最强值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> 和一个整数<code>k</code> 。</p><p>设 m 为数组的中位数，只要满足下述两个前提之一，就可以判定 <code>arr[i]</code> 的值比 <code>arr[j]</code>的值更强：</p><ul><li><code>|arr[i] - m| &gt; |arr[j] - m|</code></li><li><code>|arr[i] - m| == |arr[j] - m|，且 arr[i] &gt; arr[j]</code><br>请返回由数组中最强的 k 个值组成的列表。答案可以以 任意顺序 返回。</li></ul><p>中位数 是一个有序整数列表中处于中间位置的值。形式上，如果列表的长度为 n ，那么中位数就是该有序列表（下标从 0 开始）中位于 <code>((n - 1) / 2)</code>的元素。</p><p>例如 <code>arr = [6, -3, 7, 2, 11]</code>，n = 5：数组排序后得到 <code>arr = [-3, 2, 6, 7, 11]</code>，数组的中间位置为<code>m = ((5 - 1) / 2) = 2</code>，中位数 arr[m] 的值为 6 。<br>例如 <code>arr = [-7, 22, 17, 3]</code>，<code>n = 4</code>：数组排序后得到<code>arr = [-7, 3, 17, 22]</code>，数组的中间位置为 <code>m = ((4 - 1) / 2) = 1</code> ，中位数 <code>arr[m]</code> 的值为 3 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>，按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">1</span>]。[<span class="number">1</span>, <span class="number">5</span>] 也是正确答案。</span><br><span class="line">注意，尽管 |<span class="number">5</span> - <span class="number">3</span>| == |<span class="number">1</span> - <span class="number">3</span>| ，但是 <span class="number">5</span> 比 <span class="number">1</span> 更强，因为 <span class="number">5</span> &gt; <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">解释：中位数为 <span class="number">3</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">5</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]。最强的两个元素是 [<span class="number">5</span>, <span class="number">5</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>], k = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">解释：中位数为 <span class="number">7</span>, 按从强到弱顺序排序后，数组变为 [<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]。</span><br><span class="line">[<span class="number">11</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>] 的任何排列都是正确答案。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">6</span>,<span class="number">-3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">11</span>], k = <span class="number">3</span></span><br><span class="line">输出：[<span class="number">-3</span>,<span class="number">11</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">-7</span>,<span class="number">22</span>,<span class="number">17</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">22</span>,<span class="number">17</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-10^5 &lt;= arr[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= arr.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/the-k-strongest-values-in-an-array/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>讲数组从小到达排序，求出中位数</li><li>按照与中位数的差的绝对值大小进行排序即可，二重排序即可，非常简单，太无聊了，这个题目。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getStrongest(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy = arr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; A;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        </span><br><span class="line">        sort(copy.begin(),copy.end());</span><br><span class="line">        <span class="keyword">int</span> m = copy[(n<span class="number">-1</span>)/<span class="number">2</span>]; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            A.push_back(make_pair(<span class="built_in">abs</span>(arr[i]-m),arr[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(),A.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            res.push_back(A[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5430-设计浏览器历史记录"><a href="#5430-设计浏览器历史记录" class="headerlink" title="5430. 设计浏览器历史记录"></a>5430. 设计浏览器历史记录</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是<code>homepage</code>，你可以访问其他的网站 <code>url</code> ，也可以在浏览历史中后退 <code>steps</code>步或前进 <code>steps</code> 步。</p><p>请你实现 BrowserHistory 类：</p><ul><li><code>BrowserHistory(string homepage)</code>，用 <code>homepage</code>初始化浏览器类。</li><li><code>void visit(string url)</code>从当前页跳转访问<code>url</code>对应的页面  。执行此操作会把浏览历史前进的记录全部删除。</li><li><code>string back(int steps)</code>在浏览历史中后退 <code>steps</code> 步。如果你只能在浏览历史中后退至多 x 步且 <code>steps &gt; x</code> ，那么你只后退 x 步。请返回后退 至多 <code>steps</code> 步以后的 <code>url</code> 。</li><li><code>string forward(int steps)</code>在浏览历史中前进 <code>steps</code> 步。如果你只能在浏览历史中前进至多 x 步且 steps &gt; x ，那么你只前进 x 步。请返回前进 至多 <code>steps</code>步以后的<code>url</code> 。</li></ul><p>示例：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"BrowserHistory"</span>,<span class="string">"visit"</span>,<span class="string">"visit"</span>,<span class="string">"visit"</span>,<span class="string">"back"</span>,<span class="string">"back"</span>,<span class="string">"forward"</span>,<span class="string">"visit"</span>,<span class="string">"forward"</span>,<span class="string">"back"</span>,<span class="string">"back"</span>]</span><br><span class="line">[[<span class="string">"leetcode.com"</span>],[<span class="string">"google.com"</span>],[<span class="string">"facebook.com"</span>],[<span class="string">"youtube.com"</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="number">1</span>],[<span class="string">"linkedin.com"</span>],[<span class="number">2</span>],[<span class="number">2</span>],[<span class="number">7</span>]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,<span class="string">"facebook.com"</span>,<span class="string">"google.com"</span>,<span class="string">"facebook.com"</span>,null,<span class="string">"linkedin.com"</span>,<span class="string">"google.com"</span>,<span class="string">"leetcode.com"</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"><span class="symbol">BrowserHistory</span> browserHistory = new <span class="symbol">BrowserHistory</span>(<span class="string">"leetcode.com"</span>);</span><br><span class="line">browserHistory.visit(<span class="string">"google.com"</span>);       // 你原本在浏览 <span class="string">"leetcode.com"</span> 。访问 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"facebook.com"</span>);     // 你原本在浏览 <span class="string">"google.com"</span> 。访问 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"youtube.com"</span>);      // 你原本在浏览 <span class="string">"facebook.com"</span> 。访问 <span class="string">"youtube.com"</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   // 你原本在浏览 <span class="string">"youtube.com"</span> ，后退到 <span class="string">"facebook.com"</span> 并返回 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.back(<span class="number">1</span>);                   // 你原本在浏览 <span class="string">"facebook.com"</span> ，后退到 <span class="string">"google.com"</span> 并返回 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.forward(<span class="number">1</span>);                // 你原本在浏览 <span class="string">"google.com"</span> ，前进到 <span class="string">"facebook.com"</span> 并返回 <span class="string">"facebook.com"</span></span><br><span class="line">browserHistory.visit(<span class="string">"linkedin.com"</span>);     // 你原本在浏览 <span class="string">"facebook.com"</span> 。 访问 <span class="string">"linkedin.com"</span></span><br><span class="line">browserHistory.forward(<span class="number">2</span>);                // 你原本在浏览 <span class="string">"linkedin.com"</span> ，你无法前进任何步数。</span><br><span class="line">browserHistory.back(<span class="number">2</span>);                   // 你原本在浏览 <span class="string">"linkedin.com"</span> ，后退两步依次先到 <span class="string">"facebook.com"</span> ，然后到 <span class="string">"google.com"</span> ，并返回 <span class="string">"google.com"</span></span><br><span class="line">browserHistory.back(<span class="number">7</span>);                   // 你原本在浏览 <span class="string">"google.com"</span>， 你只能后退一步到 <span class="string">"leetcode.com"</span> ，并返回 <span class="string">"leetcode.com"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= homepage.length &lt;= 20</code></li><li><code>1 &lt;= url.length &lt;= 20</code></li><li><code>1 &lt;= steps &lt;= 100</code></li><li><code>homepage</code> 和 <code>url</code> 都只包含 ‘.’ 或者小写英文字母。</li><li>最多调用 <code>5000</code> 次 <code>visit</code>， <code>back</code>和 <code>forward</code>函数。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 栈</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目很无聊，不晓得要考什么非常没有技巧。</li><li>很简单的栈操作即可，所有的pages都保存在栈中，每次保存back操作和forward操作的游标，一旦进行visit操作后，将当前游标后的元素全部从栈中删除即可。</li><li>每次进行back操作时不能超过0，每次进行forward操作时不能超过数组的现有长度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserHistory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BrowserHistory(<span class="built_in">string</span> homepage) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pages.push_back(homepage);</span><br><span class="line">        <span class="keyword">this</span>-&gt;last = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="built_in">string</span> url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pages.size()<span class="number">-1</span>; i &gt; last; --i)&#123;</span><br><span class="line">            pages.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        pages.push_back(url);</span><br><span class="line">        <span class="keyword">this</span>-&gt;last = pages.size()<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">back</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        last  = max(last-steps,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pages[last];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        last = min(last + steps,<span class="keyword">int</span>(pages.size()<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> pages[last];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pages;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BrowserHistory object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BrowserHistory* obj = new BrowserHistory(homepage);</span></span><br><span class="line"><span class="comment"> * obj-&gt;visit(url);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;back(steps);</span></span><br><span class="line"><span class="comment"> * string param_3 = obj-&gt;forward(steps);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5431-给房子涂色-III"><a href="#5431-给房子涂色-III" class="headerlink" title="5431. 给房子涂色 III"></a>5431. 给房子涂色 III</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>在一个小城市里，有 m 个房子排成一排，你需要给每个房子涂上 n 种颜色之一（颜色编号为 1 到 n ）。有的房子去年夏天已经涂过颜色了，所以这些房子不需要被重新涂色。</p><p>我们将连续相同颜色尽可能多的房子称为一个街区。（比方说 <code>houses = [1,2,2,3,3,2,1,1]</code>，它包含 5 个街区 <code>[{1}, {2,2}, {3,3}, {2}, {1,1}]</code> 。）</p><p>给你一个数组 <code>houses</code> ，一个 <code>m * n</code>的矩阵 <code>cost</code> 和一个整数<code>target</code> ，其中：</p><ul><li><code>houses[i]</code>：是第 i 个房子的颜色，0 表示这个房子还没有被涂色。</li><li><code>cost[i][j]</code>：是将第 i 个房子涂成颜色 <code>j+1</code> 的花费。<br>请你返回房子涂色方案的最小总花费，使得每个房子都被涂色后，恰好组成 target 个街区。如果没有可用的涂色方案，请返回 <code>-1</code>。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">1</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：房子涂色方案为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">此方案包含 target = <span class="number">3</span> 个街区，分别是 [&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">1</span>&#125;]。</span><br><span class="line">涂色的总花费为 (<span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">1</span> + <span class="number">5</span>) = <span class="number">9</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">1</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：有的房子已经被涂色了，在此基础上涂色方案为 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">此方案包含 target = <span class="number">3</span> 个街区，分别是 [&#123;<span class="number">2</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>,<span class="number">2</span>&#125;]。</span><br><span class="line">给第一个和最后一个房子涂色的花费为 (<span class="number">10</span> + <span class="number">1</span>) = <span class="number">11</span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], cost = [[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>],[<span class="number">10</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">10</span>]], m = <span class="number">5</span>, n = <span class="number">2</span>, target = <span class="number">5</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], cost = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]], m = <span class="number">4</span>, n = <span class="number">3</span>, target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：房子已经被涂色并组成了 <span class="number">4</span> 个街区，分别是 [&#123;<span class="number">3</span>&#125;,&#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>&#125;,&#123;<span class="number">3</span>&#125;] ，无法形成 target = <span class="number">3</span> 个街区。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == houses.length == cost.length</code></li><li><code>n == cost[i].length</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= target &lt;= m</code></li><li><code>0 &lt;= houses[i] &lt;= n</code></li><li><code>1 &lt;= cost[i][j] &lt;= 10^4</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-192/problems/paint-house-iii/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>经典的DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如果经常做DP相关的题目的话，这个题实际上就非常简单。但是细节考虑还是蛮复杂的。</li><li>我们首先需要得到递推公式，我们设<code>dp[i][j][k]</code>代表前<code>i</code>个<code>house</code>被染色分成了<code>j</code>个街区，且第<code>i</code>个街区被染成了第<code>k</code>种颜色的最小代价。</li><li>根据2的递推公式，我们实际上有两种情况需要单独进行讨论。</li></ol><ul><li>第i个<code>house</code>初始颜色在去年夏天已经被染成了颜色<code>c</code>,则这时<code>dp[i][j][c]</code>是可能存在的，其余<code>dp[i][j][x]且 x != c</code>为-1,且这时第<code>i</code>个house不能被染成其他颜色。<script type="math/tex; mode=display">dp[i][j][x] = \left\{\begin{array}{l}min(dp[i][j][x],dp[i-1][j][x])  \quad (x = c) \\\\min(dp[i][j][x],dp[i-1][j-1][y]) \quad (x = c \quad and \quad y \neq x)\\\\-1 \quad \quad (x \neq c)\end{array}\right.</script></li><li>第i个<code>house</code>初始颜色为<code>0</code>,这时第<code>i</code>个<code>house</code>可以被染成其他任何颜色。<script type="math/tex; mode=display">dp[i][j][x] = \left\{\begin{array}{l}min(dp[i][j][x],dp[i-1][j][x] + cost[i][x])   \\\\min(dp[i][j][x],dp[i-1][j-1][y] + cost[i][y])   \quad (y \neq x)\\\end{array}\right.</script></li></ul><ol><li>实际根据以上的递推公式很容易算法最后刚好满足<code>targe</code>个分区的最小代价。<script type="math/tex; mode=display">minCost = min(dp[m][target][x]) \quad x\in(1,2,3,...,n)</script></li><li>以上是针对第这个题目的详细题解，关键点的初始化必须将<code>dp[0][1][x],dp[0][0][x]</code>设为<code>0</code>。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">101</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cost, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f3f3f3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;= n; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="number">0</span>;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= target; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(houses[i<span class="number">-1</span>] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(houses[i<span class="number">-1</span>] == k) </span><br><span class="line">                            dp[i][j][houses[i<span class="number">-1</span>]] = min(dp[i][j][houses[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j][houses[i<span class="number">-1</span>]]);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            dp[i][j][houses[i<span class="number">-1</span>]] = min(dp[i][j][houses[i<span class="number">-1</span>]],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++l)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(k == l)</span><br><span class="line">                                dp[i][j][k] = min(dp[i][j][k],dp[i<span class="number">-1</span>][j][k] + cost[i<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                            <span class="keyword">else</span> </span><br><span class="line">                                dp[i][j][k] = min(dp[i][j][k],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][l] + cost[i<span class="number">-1</span>][k<span class="number">-1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            res = min(res, dp[m][target][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">0x3f3f3f3f</span>?<span class="number">-1</span>:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;192周双周赛&quot;&gt;&lt;a href=&quot;#192周双周赛&quot; class=&quot;headerlink&quot; title=&quot;192周双周赛&quot;&gt;&lt;/a&gt;192周双周赛&lt;/h1&gt;&lt;p&gt;最后一题又是经典的DP，中间某个小case过不去，一直卡了好长时间，最后在1：28提交正确，最终排名242名。感慨还是老了，脑袋转不动，其实这些题目本质就是考智商。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/172-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5428-重新排列数组&quot;&gt;&lt;a href=&quot;#5428-重新排列数组&quot; class=&quot;headerlink&quot; title=&quot;5428. 重新排列数组&quot;&gt;&lt;/a&gt;5428. 重新排列数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; ，数组中有&lt;code&gt;2n&lt;/code&gt;个元素，按 &lt;code&gt;[x1,x2,...,xn,y1,y2,...,yn]&lt;/code&gt; 的格式排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程</title>
    <link href="http://yoursite.com/2020/06/03/169/"/>
    <id>http://yoursite.com/2020/06/03/169/</id>
    <published>2020-06-03T05:09:50.568Z</published>
    <updated>2020-06-03T05:10:18.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，这个课程是数据结构的课程，当然对于数据结构这门课程基本的东西已经非常的熟悉了，。<br>对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。<br>抽了大概一周的时间把课程《Data Structure》学习完了，这部分的课程有些还是非常难，最后的<code>splaytree</code>太复杂了，没有做完，总得来说质量还是非常高得，虽然里面得算法大部分都学过，还是继续温习了一遍，已经会得算法就没有仔细再重新学习掌握，主要把<code>hashtable</code>和<code>splaytree</code>又重新温习了一遍。最后得分是<code>85.90</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/WMMZ3YUHX4QA" target="_blank" rel="noopener">Data Structure</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Data%20Structrues" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1-Basic-Data-Structures"><a href="#week1-Basic-Data-Structures" class="headerlink" title="week1.Basic Data Structures"></a>week1.Basic Data Structures</h2><p>basic data strucures主要是关于基本得队列、栈、链表的基本应用，题目还是有一些难度，如果对算法和数据结构不是很熟悉的话，对付<code>homework</code> 还是非常花时间的。</p><h3 id="1-1-Check-brackets-in-the-code"><a href="#1-1-Check-brackets-in-the-code" class="headerlink" title="1 1 Check brackets in the code"></a>1 1 Check brackets in the code</h3><p><strong>Input Format</strong>. Input contains one string 𝑆 which consists of big and small latin letters, digits, punctuation marks and brackets from the set []{}().<br><strong>Constraints</strong>. The length of 𝑆 is at least 1 and at most 105.<br><strong>Output Format</strong>. If the code in 𝑆 uses brackets correctly, output “Success” (without the quotes). Otherwise,<br>output the 1-based index of the first unmatched closing bracket, and if there are no unmatched closing<br>brackets, output the 1-based index of the first unmatched opening bracket.</p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> 经典的左右括号匹配问题</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>这题非常简单，用栈即可解决。遇到左括号入栈，遇到右括号如果与栈顶匹配，则出栈。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bracket</span> &#123;</span></span><br><span class="line">    Bracket(<span class="keyword">char</span> type, <span class="keyword">int</span> position):</span><br><span class="line">        type(type),</span><br><span class="line">        position(position)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Matchc</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">int</span> position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">    getline(<span class="built_in">std</span>::<span class="built_in">cin</span>, text);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span> &lt;Bracket&gt; opening_brackets_stack;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; text.length(); ++position) &#123;</span><br><span class="line">        <span class="keyword">char</span> next = text[position];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">'('</span> || next == <span class="string">'['</span> || next == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">            <span class="comment">// Process opening bracket, write your code here</span></span><br><span class="line">            opening_brackets_stack.push(Bracket(next,position+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="string">')'</span> || next == <span class="string">']'</span> || next == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">            <span class="comment">// Process closing bracket, write your code here</span></span><br><span class="line">            <span class="keyword">if</span>(opening_brackets_stack.empty()||!opening_brackets_stack.top().Matchc(next))&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;position+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            opening_brackets_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Printing answer, write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(opening_brackets_stack.empty())&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Success"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;opening_brackets_stack.top().position;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Compute-tree-height"><a href="#2-Compute-tree-height" class="headerlink" title="2 Compute tree height"></a>2 Compute tree height</h3><p><strong>Task</strong>. You are given a description of a rooted tree. Your task is to compute and output its height. Recall<br>that the height of a (rooted) tree is the maximum depth of a node, or the maximum distance from a<br>leaf to the root. You are given an arbitrary tree, not necessarily a binary tree.<br><strong>Input Format</strong>. The first line contains the number of nodes 𝑛. The second line contains 𝑛 integer numbers<br>from −1 to 𝑛 − 1 — parents of nodes. If the 𝑖-th one of them (0 ≤ 𝑖 ≤ 𝑛 − 1) is −1, node 𝑖 is the root,<br>otherwise it’s 0-based index of the parent of 𝑖-th node. It is guaranteed that there is exactly one root.<br>It is guaranteed that the input represents a tree.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105.<br><strong>Output Format</strong>. Output the height of the tree.</p><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>DFS</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的利用递归的DFS求数的高度。</li><li>用BFS实现也可以，层次遍历即可。<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    Node *parent;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node *&gt; children;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(Node *theParent)</span> </span>&#123;</span><br><span class="line">      parent = theParent;</span><br><span class="line">      parent-&gt;children.push_back(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_with_large_stack_space</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> max_height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; nodes;</span><br><span class="line">  nodes.resize(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> child_index = <span class="number">0</span>; child_index &lt; n; child_index++) &#123;</span><br><span class="line">    <span class="keyword">int</span> parent_index;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; parent_index;</span><br><span class="line">    <span class="keyword">if</span>(parent_index == <span class="number">-1</span>) root = child_index;</span><br><span class="line">    <span class="keyword">if</span> (parent_index &gt;= <span class="number">0</span>)</span><br><span class="line">      nodes[child_index].setParent(&amp;nodes[parent_index]);</span><br><span class="line">    nodes[child_index].key = child_index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  qu.push(root);</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : nodes[curr].children)&#123;</span><br><span class="line">              qu.push(v-&gt;key);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      max_height++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;max_height&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line">  <span class="comment">// Allow larger stack space</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rlim_t</span> kStackSize = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>;   <span class="comment">// min stack size = 16 MB</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = getrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (rl.rlim_cur &lt; kStackSize)</span><br><span class="line">      &#123;</span><br><span class="line">          rl.rlim_cur = kStackSize;</span><br><span class="line">          result = setrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"setrlimit returned result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> main_with_large_stack_space();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Network-packet-processing-simulation"><a href="#3-Network-packet-processing-simulation" class="headerlink" title="3 Network packet processing simulation"></a>3 Network packet processing simulation</h3><p><strong>Task</strong>. You are given a series of incoming network packets, and your task is to simulate their processing.<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Packets arrive <span class="keyword">in</span> some order. For <span class="keyword">each</span> packet <span class="built_in">number</span> 𝑖, you know <span class="keyword">the</span> <span class="built_in">time</span> when <span class="keyword">it</span> arrived 𝐴𝑖 <span class="keyword">and</span> <span class="keyword">the</span></span><br><span class="line"><span class="built_in">time</span> <span class="keyword">it</span> takes <span class="keyword">the</span> processor <span class="built_in">to</span> <span class="built_in">process</span> <span class="keyword">it</span> 𝑃𝑖 (both <span class="keyword">in</span> <span class="built_in">milliseconds</span>). There is only <span class="literal">one</span> processor, <span class="keyword">and</span> <span class="keyword">it</span></span><br><span class="line">processes <span class="keyword">the</span> incoming packets <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span> their arrival. If <span class="keyword">the</span> processor started <span class="built_in">to</span> <span class="built_in">process</span> some</span><br><span class="line">packet, <span class="keyword">it</span> doesn’t interrupt <span class="keyword">or</span> <span class="built_in">stop</span> <span class="keyword">until</span> <span class="keyword">it</span> finishes <span class="keyword">the</span> processing <span class="keyword">of</span> this packet, <span class="keyword">and</span> <span class="keyword">the</span> processing <span class="keyword">of</span></span><br><span class="line">packet 𝑖 takes exactly 𝑃𝑖 <span class="built_in">milliseconds</span>.</span><br><span class="line">The computer processing <span class="keyword">the</span> packets has <span class="keyword">a</span> network buffer <span class="keyword">of</span> fixed size 𝑆. When packets arrive,</span><br><span class="line">they are stored <span class="keyword">in</span> <span class="keyword">the</span> buffer <span class="keyword">before</span> being processed. However, <span class="keyword">if</span> <span class="keyword">the</span> buffer is full when <span class="keyword">a</span> packet</span><br><span class="line">arrives (there are 𝑆 packets which have arrived <span class="keyword">before</span> this packet, <span class="keyword">and</span> <span class="keyword">the</span> computer hasn’t finished</span><br><span class="line">processing <span class="keyword">any</span> <span class="keyword">of</span> them), <span class="keyword">it</span> is dropped <span class="keyword">and</span> won’t be processed <span class="keyword">at</span> all. If several packets arrive <span class="keyword">at</span> <span class="keyword">the</span></span><br><span class="line">same <span class="built_in">time</span>, they are <span class="keyword">first</span> all stored <span class="keyword">in</span> <span class="keyword">the</span> buffer (some <span class="keyword">of</span> them may be dropped because <span class="keyword">of</span> that —</span><br><span class="line">those which are described later <span class="keyword">in</span> <span class="keyword">the</span> input). The computer processes <span class="keyword">the</span> packets <span class="keyword">in</span> <span class="keyword">the</span> order <span class="keyword">of</span></span><br><span class="line">their arrival, <span class="keyword">and</span> <span class="keyword">it</span> starts processing <span class="keyword">the</span> next available packet <span class="built_in">from</span> <span class="keyword">the</span> buffer <span class="keyword">as</span> soon <span class="keyword">as</span> <span class="keyword">it</span> finishes</span><br><span class="line">processing <span class="keyword">the</span> previous <span class="literal">one</span>. If <span class="keyword">at</span> some point <span class="keyword">the</span> computer is <span class="keyword">not</span> busy, <span class="keyword">and</span> there are no packets <span class="keyword">in</span></span><br><span class="line"><span class="keyword">the</span> buffer, <span class="keyword">the</span> computer just waits <span class="keyword">for</span> <span class="keyword">the</span> next packet <span class="built_in">to</span> arrive. Note that <span class="keyword">a</span> packet leaves <span class="keyword">the</span> buffer</span><br><span class="line"><span class="keyword">and</span> frees <span class="keyword">the</span> <span class="literal">space</span> <span class="keyword">in</span> <span class="keyword">the</span> buffer <span class="keyword">as</span> soon <span class="keyword">as</span> <span class="keyword">the</span> computer finishes processing <span class="keyword">it</span>.</span><br></pre></td></tr></table></figure><br><strong>Input Format</strong>. The first line of the input contains the size 𝑆 of the buffer and the number 𝑛 of incoming<br>network packets. Each of the next 𝑛 lines contains two numbers. 𝑖-th line contains the time of arrival<br>𝐴𝑖 and the processing time 𝑃𝑖 (both in milliseconds) of the 𝑖-th packet. It is guaranteed that the<br>sequence of arrival times is non-decreasing (however, it can contain the exact same times of arrival in<br>milliseconds — in this case the packet which is earlier in the input is considered to have arrived earlier).<br><strong>Constraints</strong>. All the numbers in the input are integers. 1 ≤ 𝑆 ≤ 105; 0 ≤ 𝑛 ≤ 105; 0 ≤ 𝐴𝑖 ≤ 106;<br>0 ≤ 𝑃𝑖 ≤ 103; 𝐴𝑖 ≤ 𝐴𝑖+1 for 1 ≤ 𝑖 ≤ 𝑛 − 1.<br><strong>Output Format</strong>. For each packet output either the moment of time (in milliseconds) when the processor<br>began processing it or −1 if the packet was dropped (output the answers for the packets in the same<br>order as the packets are given in the input).</p><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>队列</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>如果当前队列为空，则直接将当前的packet入队列，同时给出response。</li><li>如果当前队列不为空，则将所有处理时间小于当前达到时间的packet全部出队列。这时判断队列中缓存的packet数目是否达到最大长度，如果达到最大长度上线，则将当前到达的packet丢弃，否则直接入队列。</li><li>题目还是有点意思，稍微用点技巧，非常适合面试。</li></ol><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Request</span> &#123;</span></span><br><span class="line">    Request(<span class="keyword">int</span> arrival_time, <span class="keyword">int</span> process_time):</span><br><span class="line">        arrival_time(arrival_time),</span><br><span class="line">        process_time(process_time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arrival_time;</span><br><span class="line">    <span class="keyword">int</span> process_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Response</span> &#123;</span></span><br><span class="line">    Response(<span class="keyword">bool</span> dropped, <span class="keyword">int</span> start_time):</span><br><span class="line">        dropped(dropped),</span><br><span class="line">        start_time(start_time)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> dropped;</span><br><span class="line">    <span class="keyword">int</span> start_time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Buffer(<span class="keyword">int</span> size):</span><br><span class="line">        size_(size),</span><br><span class="line">        finish_time_()</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Response <span class="title">Process</span><span class="params">(<span class="keyword">const</span> Request &amp;request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span> arrive = request.arrival_time;</span><br><span class="line">        <span class="keyword">int</span> process = request.process_time;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!finish_time_.empty() &amp;&amp; arrive &gt;= finish_time_.front())&#123;</span><br><span class="line">            finish_time_.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(finish_time_.empty())&#123;</span><br><span class="line">            finish_time_.push_back(arrive + process);            </span><br><span class="line">            <span class="keyword">return</span> Response(<span class="literal">false</span>,arrive);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(finish_time_.size() == size_)&#123;</span><br><span class="line">                <span class="keyword">return</span> Response(<span class="literal">true</span>,arrive);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> last = finish_time_.back();</span><br><span class="line">                finish_time_.push_back(last + process);</span><br><span class="line">                <span class="keyword">return</span> Response(<span class="literal">false</span>,last);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; finish_time_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; ReadRequests() &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; requests;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> arrival_time, process_time;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; arrival_time &gt;&gt; process_time;</span><br><span class="line">        requests.push_back(Request(arrival_time, process_time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requests;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; ProcessRequests(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; &amp;requests, Buffer *buffer) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; responses;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; requests.size(); ++i)</span><br><span class="line">        responses.push_back(buffer-&gt;Process(requests[i]));</span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintResponses</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; &amp;responses)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responses.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (responses[i].dropped ? <span class="number">-1</span> : responses[i].start_time) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Request&gt; requests = ReadRequests();</span><br><span class="line"></span><br><span class="line">    <span class="function">Buffer <span class="title">buffer</span><span class="params">(size)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span> &lt;Response&gt; responses = ProcessRequests(requests, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    PrintResponses(responses);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Extending-stack-interface"><a href="#4-Extending-stack-interface" class="headerlink" title="4 Extending stack interface"></a>4 Extending stack interface</h3><p><strong>Task</strong>. Implement a stack supporting the operations Push(), Pop(), and Max().<br><strong>Input Format</strong>. The first line of the input contains the number 𝑞 of queries. Each of the following 𝑞 lines<br>specifies a query of one of the following formats: push v, pop, or max.<br><strong>Constraints</strong>. 1 ≤ 𝑞 ≤ 400 000, 0 ≤ 𝑣 ≤ 105.<br><strong>Output Format</strong>. For each max query, output (on a separate line) the maximum value of the stack.</p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>经典的最大栈，最小栈的问题</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的最大栈和最小栈问题，不用再详细描述了。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max_element;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMax</span> &#123;</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxElement;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>.push_back(value);</span><br><span class="line">        <span class="keyword">if</span>(maxElement.empty())&#123;</span><br><span class="line">            maxElement.push_back(value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(maxElement.back() &lt; value)&#123;</span><br><span class="line">                maxElement.push_back(value);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                maxElement.push_back(maxElement.back());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assert(<span class="built_in">stack</span>.size());</span><br><span class="line">        <span class="built_in">stack</span>.pop_back();</span><br><span class="line">        maxElement.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        assert(<span class="built_in">stack</span>.size());</span><br><span class="line">        <span class="keyword">return</span> maxElement.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_queries = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num_queries;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> query;</span><br><span class="line">    <span class="built_in">string</span> value;</span><br><span class="line"></span><br><span class="line">    StackWithMax <span class="built_in">stack</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_queries; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; query;</span><br><span class="line">        <span class="keyword">if</span> (query == <span class="string">"push"</span>) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">            <span class="built_in">stack</span>.Push(<span class="built_in">std</span>::stoi(value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (query == <span class="string">"pop"</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>.Pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (query == <span class="string">"max"</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">stack</span>.Max() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-Maximum-in-Sliding-Window"><a href="#5-Maximum-in-Sliding-Window" class="headerlink" title="5 Maximum in Sliding Window"></a>5 Maximum in Sliding Window</h3><p><strong>Input Format</strong>. The first line contains an integer 𝑛, the second line contains 𝑛 integers 𝑎1, . . . , 𝑎𝑛 separated by spaces, the third line contains an integer 𝑚.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 1 ≤ 𝑚 ≤ 𝑛, 0 ≤ 𝑎𝑖 ≤ 105 for all 1 ≤ 𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. Output max{𝑎𝑖, . . . , 𝑎𝑖+𝑚−1} for every 1 ≤ 𝑖 ≤ 𝑛 − 𝑚 + 1.</p><h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><p>滑动窗口</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>滑动窗口的最大值问题。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pii &amp; a,<span class="keyword">const</span> pii &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_sliding_window_naive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">const</span> &amp; A, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;pii&gt; qu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.empty())&#123;</span><br><span class="line">            qu.push_back(make_pair(i,A[i]));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!qu.empty() &amp;&amp; A[i] &gt;= qu.back().second)&#123;</span><br><span class="line">                qu.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            qu.push_back(make_pair(i,A[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= w - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;qu.front().second&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span>(qu.front().first &lt;= i - w + <span class="number">1</span>)&#123;</span><br><span class="line">                qu.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; A.at(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; w;</span><br><span class="line"></span><br><span class="line">    max_sliding_window_naive(A, w);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week2-Priority-Queues-and-Disjoint-Sets"><a href="#week2-Priority-Queues-and-Disjoint-Sets" class="headerlink" title="week2. Priority Queues and Disjoint Sets"></a>week2. Priority Queues and Disjoint Sets</h2><h3 id="1-Convert-array-into-heap"><a href="#1-Convert-array-into-heap" class="headerlink" title="1 Convert array into heap"></a>1 Convert array into heap</h3><p><strong>Task</strong>. The first step of the HeapSort algorithm is to create a heap from the array you want to sort. By the<br>way, did you know that algorithms based on Heaps are widely used for external sort, when you need<br>to sort huge files that don’t fit into memory of a computer?<br>Your task is to implement this first step and convert a given array of integers into a heap. You will<br>do that by applying a certain number of swaps to the array. Swap is an operation which exchanges<br>elements 𝑎𝑖 and 𝑎𝑗 of the array 𝑎 for some 𝑖 and 𝑗. You will need to convert the array into a heap using<br>only 𝑂(𝑛) swaps, as was described in the lectures. Note that you will need to use a min-heap instead<br>of a max-heap in this problem.<br><strong>Input Format</strong>. The first line of the input contains single integer 𝑛. The next line contains 𝑛 space-separated<br>integers 𝑎𝑖.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 100 000; 0 ≤ 𝑖, 𝑗 ≤ 𝑛 − 1; 0 ≤ 𝑎0, 𝑎1, . . . , 𝑎𝑛−1 ≤ 109. All 𝑎𝑖 are distinct.<br><strong>Output Format</strong>. The first line of the output should contain single integer 𝑚 — the total number of swaps.<br>𝑚 must satisfy conditions 0 ≤ 𝑚 ≤ 4𝑛. The next 𝑚 lines should contain the swap operations used<br>to convert the array 𝑎 into a heap. Each swap is described by a pair of integers 𝑖, 𝑗 — the 0-based<br>indices of the elements to be swapped. After applying all the swaps in the specified order the array<br>must become a heap, that is, for each 𝑖 where 0 ≤ 𝑖 ≤ 𝑛 − 1 the following conditions must be true:</p><ul><li><ol><li>If 2𝑖 + 1 ≤ 𝑛 − 1, then 𝑎𝑖 &lt; 𝑎2𝑖+1.</li></ol></li><li><ol><li>If 2𝑖 + 2 ≤ 𝑛 − 1, then 𝑎𝑖 &lt; 𝑎2𝑖+2.<br>Note that all the elements of the input array are distinct. Note that any sequence of swaps that has<br>length at most 4𝑛 and after which your initial array becomes a correct heap will be graded as correct.</li></ol></li></ul><h4 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h4><p>经典的堆栈建立过程</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>此题考察堆的调整过程。经典的堆的建立过程，时间复杂度为:<script type="math/tex; mode=display">T(n) = O(\lg{\frac{n}{2}}) + O(\lg{\frac{n}{4}}) + ... = lg{n}</script><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeapBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data_;</span><br><span class="line">  <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; swaps_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteResponse</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; swaps_.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; swaps_.size(); ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; swaps_[i].first &lt;&lt; <span class="string">" "</span> &lt;&lt; swaps_[i].second &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    data_.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; data_[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateSwaps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    swaps_.clear();</span><br><span class="line">    <span class="comment">// The following naive implementation just sorts </span></span><br><span class="line">    <span class="comment">// the given sequence using selection sort algorithm</span></span><br><span class="line">    <span class="comment">// and saves the resulting sequence of swaps.</span></span><br><span class="line">    <span class="comment">// This turns the given array into a heap, </span></span><br><span class="line">    <span class="comment">// but in the worst case gives a quadratic number of swaps.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace by a more efficient implementation</span></span><br><span class="line">    <span class="keyword">int</span> n = data_.size();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (n<span class="number">-2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j*<span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = j*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = j*<span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; n ) m = l;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; n &amp;&amp; data_[r] &lt; data_[m]) m = r;</span><br><span class="line">            <span class="keyword">if</span>(data_[j] &gt; data_[m])&#123;</span><br><span class="line">                swaps_.push_back(make_pair(j,m));</span><br><span class="line">                swap(data_[j],data_[m]);</span><br><span class="line">                j = m;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    GenerateSwaps();</span><br><span class="line">    WriteResponse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  HeapBuilder heap_builder;</span><br><span class="line">  heap_builder.Solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Parallel-processing"><a href="#2-Parallel-processing" class="headerlink" title="2 Parallel processing"></a>2 Parallel processing</h3><p><strong>Task</strong>. You have a program which is parallelized and uses 𝑛 independent threads to process the given list of 𝑚<br>jobs. Threads take jobs in the order they are given in the input. If there is a free thread, it immediately<br>takes the next job from the list. If a thread has started processing a job, it doesn’t interrupt or stop<br>until it finishes processing the job. If several threads try to take jobs from the list simultaneously, the<br>thread with smaller index takes the job. For each job you know exactly how long will it take any thread<br>to process this job, and this time is the same for all the threads. You need to determine for each job<br>which thread will process it and when will it start processing.<br><strong>Input Format</strong>. The first line of the input contains integers 𝑛 and 𝑚.<br>The second line contains 𝑚 integers 𝑡𝑖 — the times in seconds it takes any thread to process 𝑖-th job.<br>The times are given in the same order as they are in the list from which threads take jobs.<br>Threads are indexed starting from 0.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105; 1 ≤ 𝑚 ≤ 105; 0 ≤ 𝑡𝑖 ≤ 109.<br><strong>Output Format</strong>. Output exactly 𝑚 lines. 𝑖-th line (0-based index is used) should contain two spaceseparated<br>integers — the 0-based index of the thread which will process the 𝑖-th job and the time<br>in seconds when it will start processing that job.</p><h4 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h4><p>优先级队列</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>将所有worker的空闲时间压入优先级队列，按照空闲时间的起始先后进行排列。</li><li>我们每次分配任务时，从队列中取出最先出现空闲时间的<code>worker</code>，让其处理本次的<code>job</code>，处理完成后，同时将该<code>worker</code>的下次空闲时间入队列。</li><li>题目的难度适中，非常适合面试考试题目，我觉得能够讲出思路非常不错的题目。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.second == b.second)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JobQueue</span> &#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> num_workers_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; jobs_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assigned_workers_;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; start_times_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">WriteResponse</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs_.size(); ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; assigned_workers_[i] &lt;&lt; <span class="string">" "</span> &lt;&lt; start_times_[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num_workers_ &gt;&gt; m;</span><br><span class="line">    jobs_.resize(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; jobs_[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssignJobs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> replace this code with a faster algorithm.</span></span><br><span class="line">    assigned_workers_.resize(jobs_.size());</span><br><span class="line">    start_times_.resize(jobs_.size());</span><br><span class="line">    priority_queue&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_workers_; ++i)&#123;</span><br><span class="line">        pq.push(make_pair(i,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs_.size(); ++i) &#123;</span><br><span class="line">        pii curr = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        assigned_workers_[i] = curr.first;</span><br><span class="line">        start_times_[i] = curr.second;</span><br><span class="line">        curr.second += jobs_[i];</span><br><span class="line">        pq.push(curr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReadData();</span><br><span class="line">    AssignJobs();</span><br><span class="line">    WriteResponse();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  JobQueue job_queue;</span><br><span class="line">  job_queue.Solve();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Merging-tables"><a href="#3-Merging-tables" class="headerlink" title="3 Merging tables"></a>3 Merging tables</h3><p><strong>Task</strong>. There are 𝑛 tables stored in some database. The tables are numbered from 1 to 𝑛. All tables share<br>the same set of columns. Each table contains either several rows with real data or a symbolic link to<br>another table. Initially, all tables contain data, and 𝑖-th table has 𝑟𝑖 rows. You need to perform 𝑚 of<br>the following operations:</p><ul><li><ol><li>Consider table number 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖. Traverse the path of symbolic links to get to the data. That is,<br>while 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 contains a symbolic link instead of real data do<br>𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 ← symlink(𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖)</li></ol></li><li><ol><li>Consider the table number 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 and traverse the path of symbolic links from it in the same<br>manner as for 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖.</li></ol></li><li><ol><li>Now, 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 and 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 are the numbers of two tables with real data. If 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 ̸=<br>𝑠𝑜𝑢𝑟𝑐𝑒𝑖, copy all the rows from table 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 to table 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖, then clear the table 𝑠𝑜𝑢𝑟𝑐𝑒𝑖<br>and instead of real data put a symbolic link to 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 into it.</li></ol></li><li><ol><li>Print the maximum size among all 𝑛 tables (recall that size is the number of rows in the table).<br>If the table contains only a symbolic link, its size is considered to be 0.<br>See examples and explanations for further clarifications.</li></ol></li></ul><p><strong>Input Format</strong>. The first line of the input contains two integers 𝑛 and 𝑚 — the number of tables in the<br>database and the number of merge queries to perform, respectively.<br>The second line of the input contains 𝑛 integers 𝑟𝑖 — the number of rows in the 𝑖-th table.<br>Then follow 𝑚 lines describing merge queries. Each of them contains two integers 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖 and<br>𝑠𝑜𝑢𝑟𝑐𝑒𝑖 — the numbers of the tables to merge.<br><strong>Constraints</strong>. 1 ≤ 𝑛,𝑚 ≤ 100 000; 0 ≤ 𝑟𝑖 ≤ 10 000; 1 ≤ 𝑑𝑒𝑠𝑡𝑖𝑛𝑎𝑡𝑖𝑜𝑛𝑖, 𝑠𝑜𝑢𝑟𝑐𝑒𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. For each query print a line containing a single integer — the maximum of the sizes of all<br>tables (in terms of the number of rows) after the corresponding operation.</p><h4 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h4><p>带权重的并查集</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>经典的带权重的并查集，记住DSU合并的权重有几种计算方式，一种是按照<code>size</code>，另一种是按照<code>height</code>。</li><li>按照<code>size</code>为权重来进行集合合并时，惯例为才会将<code>size</code>小的集合合并到<code>size</code>集合中。</li><li>按照<code>height</code>为权重来进行集合合并时，惯例为才会将<code>height</code>小的集合合并到<code>height</code>大的集合中<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisjointSetsElement</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> size, parent, rank;</span><br><span class="line"></span><br><span class="line">DisjointSetsElement(<span class="keyword">int</span> size = <span class="number">0</span>, <span class="keyword">int</span> parent = <span class="number">-1</span>, <span class="keyword">int</span> rank = <span class="number">0</span>):</span><br><span class="line">    size(size), parent(parent), rank(rank) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisjointSets</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">int</span> max_table_size;</span><br><span class="line"><span class="built_in">vector</span> &lt;DisjointSetsElement&gt; sets;</span><br><span class="line"></span><br><span class="line">DisjointSets(<span class="keyword">int</span> size): size(size), max_table_size(<span class="number">0</span>), sets(size) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">sets[i].parent = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span> table)</span> </span>&#123;</span><br><span class="line"><span class="comment">// find parent and compress path</span></span><br><span class="line"><span class="keyword">while</span>(sets[table].parent != table)&#123;</span><br><span class="line">table = sets[table].parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> destination, <span class="keyword">int</span> source)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> realDestination = getParent(destination);</span><br><span class="line"><span class="keyword">int</span> realSource = getParent(source);</span><br><span class="line"><span class="keyword">if</span> (realDestination != realSource) &#123;</span><br><span class="line"><span class="comment">// merge two components</span></span><br><span class="line"><span class="comment">// use union by rank heuristic</span></span><br><span class="line">            <span class="comment">// update max_table_size</span></span><br><span class="line"><span class="keyword">if</span>(sets[realDestination].rank &gt; sets[realSource].rank)&#123;</span><br><span class="line">sets[realDestination].size += sets[realSource].size;</span><br><span class="line">sets[realSource].parent = realDestination;</span><br><span class="line">max_table_size = max(max_table_size,sets[realDestination].size);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">sets[realDestination].parent = realSource;</span><br><span class="line">sets[realSource].size += sets[realDestination].size;</span><br><span class="line">max_table_size = max(max_table_size,sets[realSource].size);</span><br><span class="line"><span class="keyword">if</span>(sets[realDestination].rank == sets[realSource].rank)&#123;</span><br><span class="line">sets[realSource].rank = sets[realDestination].rank  + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="function">DisjointSets <span class="title">tables</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;table : tables.sets) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; table.size;</span><br><span class="line">tables.max_table_size = max(tables.max_table_size, table.size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> destination, source;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; destination &gt;&gt; source;</span><br><span class="line">                --destination;</span><br><span class="line">                --source;</span><br><span class="line"></span><br><span class="line">tables.merge(destination, source);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; tables.max_table_size &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week3-Hash-Tables-and-Hash-Functions"><a href="#week3-Hash-Tables-and-Hash-Functions" class="headerlink" title="week3: Hash Tables and Hash Functions"></a>week3: Hash Tables and Hash Functions</h2><p>这一章主要是讲kmp算法和KR算法。有几道题目非常的经典和难，必须要掌握该算法的本质。前两道题目比较简单，就不在这里展开描述，后面三道题题目还是经典的面试题。</p><h3 id="3-Find-pattern-in-text"><a href="#3-Find-pattern-in-text" class="headerlink" title="3 Find pattern in text"></a>3 Find pattern in text</h3><ul><li><strong>Task</strong>. In this problem your goal is to implement the Rabin–Karp’s algorithm for searching the given pattern<br>in the given text.</li><li><strong>Input Format</strong>. There are two strings in the input: the pattern 𝑃 and the text 𝑇.<br>Constraints. 1 ≤ |𝑃| ≤ |𝑇| ≤ 5 · 105. The total length of all occurrences of 𝑃 in 𝑇 doesn’t exceed 108. The<br>pattern and the text contain only latin letters.</li><li><strong>Output Format</strong>. Print all the positions of the occurrences of 𝑃 in 𝑇 in the ascending order. Use 0-based<br>indexing of positions in the the text 𝑇.𝐺𝑒𝑛𝑜𝑚𝑒.<h4 id="题意-8"><a href="#题意-8" class="headerlink" title="题意"></a>题意</h4>KMP算法或者KR算法。<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>在这里还是使用KR算法，其实这个算法如果理解10进制数的本质，就知道这个算法的本质含义，与我们所经常用的数位算法一样。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> pattern, text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Data <span class="title">read_input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data data;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; data.pattern &gt;&gt; data.text;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_occurrences</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; output)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; output.size(); ++i)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; output[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; get_occurrences(<span class="keyword">const</span> Data&amp; input) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; s = input.pattern, t = input.text;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> n = t.size();</span><br><span class="line">    <span class="keyword">int</span> m = s.size();</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">263</span>;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> h1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        h = (h*base + s[i])%mod;</span><br><span class="line">        h1 = (h1*base + t[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        b = (b*base)%mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(h == h1) ans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - m; ++i)&#123;</span><br><span class="line">        h1 = (h1 - t[i<span class="number">-1</span>]*b%mod + mod)%mod;</span><br><span class="line">        h1 = (h1*base + t[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        <span class="keyword">if</span>(h1 == h)&#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios_base::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    print_occurrences(get_occurrences(read_input()));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Substring-equality"><a href="#4-Substring-equality" class="headerlink" title="4 Substring equality"></a>4 Substring equality</h3><ul><li><strong>Input Format</strong>. The first line contains a string 𝑠 consisting of small Latin letters. The second line contains<br>the number of queries 𝑞. Each of the next 𝑞 lines specifies a query by three integers 𝑎, 𝑏, and 𝑙.</li><li><strong>Constraints</strong>. 1 ≤ |𝑠| ≤ 500 000. 1 ≤ 𝑞 ≤ 100 000. 0 ≤ 𝑎, 𝑏 ≤ |𝑠| − 𝑙 (hence the indices 𝑎 and 𝑏 are 0-based).</li><li><strong>Output Format</strong>. For each query, output “Yes” if 𝑠𝑎𝑠𝑎+1. . .𝑠𝑎+𝑙−1 = 𝑠𝑏𝑠𝑏+1. . .𝑠𝑏+𝑙−1 are equal, and “No”<br>otherwise.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>典型的KR算法。</li><li>算出所有长度的hash值，比较hash值是否相等。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> base;</span><br><span class="line"><span class="keyword">int</span> mod;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hx;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Solver(<span class="built_in">string</span> s) : s(s) &#123;</span><br><span class="line"><span class="comment">// initialization, precalculation</span></span><br><span class="line"><span class="keyword">int</span> n = s.size();</span><br><span class="line"><span class="keyword">this</span>-&gt;base = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;hx = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;bx = <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">hx[i] = (hx[i<span class="number">-1</span>]*base + s[i<span class="number">-1</span>])%mod;</span><br><span class="line">bx[i] = (bx[i<span class="number">-1</span>]*base)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h1 = (hx[a+l] - hx[a]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h2 = (hx[b+l] - hx[b]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">if</span>(h1 == h2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="number">0</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s &gt;&gt; q;</span><br><span class="line"><span class="function">Solver <span class="title">solver</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b, l;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; l;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (solver.ask(a, b, l) ? <span class="string">"Yes\n"</span> : <span class="string">"No\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="5-Longest-common-substring"><a href="#5-Longest-common-substring" class="headerlink" title="5 Longest common substring"></a>5 Longest common substring</h3><p><strong>Input Format</strong>. Every line of the input contains two strings 𝑠 and 𝑡 consisting of lower case Latin letters.<br><strong>Constraints</strong>. The total length of all 𝑠’s as well as the total length of all 𝑡’s does not exceed 100 000.<br><strong>Output Format</strong>. For each pair of strings 𝑠 and 𝑡𝑖, find its longest common substring and specify it by<br>outputting three integers: its starting position in 𝑠, its starting position in 𝑡 (both 0-based), and its<br>length. More formally, output integers 0 ≤ 𝑖 &lt; |𝑠|, 0 ≤ 𝑗 &lt; |𝑡|, and 𝑙 ≥ 0 such that 𝑠𝑖𝑠𝑖+1 · · · 𝑠𝑖+𝑙−1 =<br>𝑡𝑗 𝑡𝑗+1 · · · 𝑡𝑗+𝑙−1 and 𝑙 is maximal. (As usual, if there are many such triples with maximal 𝑙, output any<br>of them.)</p><h4 id="题意-9"><a href="#题意-9" class="headerlink" title="题意"></a>题意</h4><p>KR算法</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>leetcode周赛的原题，如果知道这个算法的，就知道这个题目非常简单，不知道该算法的就觉得非常难。或者后缀数组也可以实现该算法。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Answer</span> &#123;</span></span><br><span class="line"><span class="keyword">size_t</span> i, j, len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Answer <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">string</span> &amp;t)</span> </span>&#123;</span><br><span class="line">Answer ans = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> m = s.size();</span><br><span class="line"><span class="keyword">int</span> n = t.size();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base1 = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod1 = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod2 = <span class="number">100001611</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hs1(m+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ht1(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx1(max(m,n)+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s.size() == <span class="number">0</span> || t.size() == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max(m,n); ++i)&#123;</span><br><span class="line">bx1[i] = (bx1[i<span class="number">-1</span>]*base1)%mod1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">hs1[i] = (hs1[i<span class="number">-1</span>]*base1 + s[i<span class="number">-1</span>])%mod1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">ht1[i] = (ht1[i<span class="number">-1</span>]*base1 + t[i<span class="number">-1</span>])%mod1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> len,<span class="keyword">long</span> <span class="keyword">long</span> mod,Answer &amp; res)&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*calc string s*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-len; ++i)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h = (hs1[i+len] - hs1[i]*bx1[len]%mod + mod)%mod;</span><br><span class="line">cnt[h] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*calc string t*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-len; ++i)&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> h = (ht1[i+len] - ht1[i]*bx1[len]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">if</span>(cnt.count(h))&#123;</span><br><span class="line">res.i = cnt[h];</span><br><span class="line">res.j = i;</span><br><span class="line">res.len = len;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> r = min(m,n);</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">Answer curr;</span><br><span class="line"><span class="keyword">if</span>(check(mid,mod1,curr))&#123;</span><br><span class="line">ans = curr;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">string</span> s, t;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t) &#123;</span><br><span class="line"><span class="keyword">auto</span> ans = solve(s, t);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.i &lt;&lt; <span class="string">" "</span> &lt;&lt; ans.j &lt;&lt; <span class="string">" "</span> &lt;&lt; ans.len &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Pattern-matching-with-mismatches"><a href="#6-Pattern-matching-with-mismatches" class="headerlink" title="6 Pattern matching with mismatches"></a>6 Pattern matching with mismatches</h3><p><strong>Task</strong>. For an integer parameter 𝑘 and two strings 𝑡 = 𝑡0𝑡1 · · · 𝑡𝑚−1 and 𝑝 = 𝑝0𝑝1 · · · 𝑝𝑛−1, we say that<br>𝑝 occurs in 𝑡 at position 𝑖 with at most 𝑘 mismatches if the strings 𝑝 and 𝑡[𝑖 : 𝑖 + 𝑝) = 𝑡𝑖𝑡𝑖+1 · · · 𝑡𝑖+𝑛−1<br>differ in at most 𝑘 positions.<br><strong>Input Format</strong>. Every line of the input contains an integer 𝑘 and two strings 𝑡 and 𝑝 consisting of lower<br>case Latin letters.<br><strong>Constraints</strong>. 0 ≤ 𝑘 ≤ 5, 1 ≤ |𝑡| ≤ 200 000, 1 ≤ |𝑝| ≤ min{|𝑡|, 100 000}. The total length of all 𝑡’s does not<br>exceed 200 000, the total length of all 𝑝’s does not exceed 100 000.<br><strong>Output Format</strong>. For each triple (𝑘, 𝑡, 𝑝), find all positions 0 ≤ 𝑖1 &lt; 𝑖2 &lt; · · · &lt; 𝑖𝑙 &lt; |𝑡| where 𝑝 occurs in 𝑡<br>with at most 𝑘 mismatches. Output 𝑙 and 𝑖1, 𝑖2, . . . , 𝑖𝑙.</p><h4 id="题意-10"><a href="#题意-10" class="headerlink" title="题意"></a>题意</h4><p>KR算法 + 二分查找</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目想了很长时间，我觉得最经典的莫过于二分查找算法的应用，关于两个字符串中查找K个字符的不同位置，竟然可以这么神奇的用二分查找算法可以在 $O(lgn)$时间复杂度内全部求出，这个真心太强大的工具了。</li><li>如果对这个题目感兴趣的同学，可以仔细思考下我提交的代码，非常的有意思。<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve(<span class="keyword">int</span> k, <span class="keyword">const</span> <span class="built_in">string</span> &amp;text, <span class="keyword">const</span> <span class="built_in">string</span> &amp;pattern) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="keyword">int</span> m = text.size();</span><br><span class="line"><span class="keyword">int</span> n = pattern.size();</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> base = <span class="number">263</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ht(m+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; hp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bx(m+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(text.size() == <span class="number">0</span> || text.size() == <span class="number">0</span> || m &lt; n)&#123;</span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">bx[i] = (bx[i<span class="number">-1</span>]*base)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">ht[i] = (ht[i<span class="number">-1</span>]*base + text[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">hp[i] = (hp[i<span class="number">-1</span>]*base + pattern[i<span class="number">-1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> hashPattern = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"><span class="keyword">int</span> l = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> curr = (hp[y+<span class="number">1</span>] - hp[x]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> hashText = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line"><span class="keyword">int</span> l = y - x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> curr = (ht[y+<span class="number">1</span>] - ht[x]*bx[l]%mod + mod)%mod;</span><br><span class="line"><span class="keyword">return</span> curr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-n; ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = n<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;"start from "&lt;&lt;i&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(start &gt; end) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">int</span> l = start;</span><br><span class="line"><span class="keyword">int</span> r = end;</span><br><span class="line"><span class="keyword">int</span> last = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(hashText(i+start,i+mid) != hashPattern(start,mid))&#123;</span><br><span class="line">last = mid;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">start = last + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;start&lt;&lt;":"&lt;&lt;end&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(start &gt; end || hashText(start+i,end+i) == hashPattern(start,end))&#123;</span><br><span class="line">pos.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">string</span> t, p;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; k &gt;&gt; t &gt;&gt; p) &#123;</span><br><span class="line"><span class="keyword">auto</span> a = solve(k, t, p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x : a)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; x;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Binary-Search-Trees"><a href="#week4-Binary-Search-Trees" class="headerlink" title="week4 . Binary Search Trees"></a>week4 . Binary Search Trees</h2><h3 id="1-Binary-tree-traversals"><a href="#1-Binary-tree-traversals" class="headerlink" title="1 Binary tree traversals"></a>1 Binary tree traversals</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. You are given a rooted binary tree. Build and output its in-order, pre-order and post-order traversals.<br><strong>Input Format</strong>. The first line contains the number of vertices 𝑛. The vertices of the tree are numbered<br>from 0 to 𝑛 − 1. Vertex 0 is the root.<br>The next 𝑛 lines contain information about vertices 0, 1, …, 𝑛−1 in order. Each of these lines contains<br>three integers 𝑘𝑒𝑦𝑖, 𝑙𝑒𝑓𝑡𝑖 and 𝑟𝑖𝑔ℎ𝑡𝑖 — 𝑘𝑒𝑦𝑖 is the key of the 𝑖-th vertex, 𝑙𝑒𝑓𝑡𝑖 is the index of the left<br>child of the 𝑖-th vertex, and 𝑟𝑖𝑔ℎ𝑡𝑖 is the index of the right child of the 𝑖-th vertex. If 𝑖 doesn’t have<br>left or right child (or both), the corresponding 𝑙𝑒𝑓𝑡𝑖 or 𝑟𝑖𝑔ℎ𝑡𝑖 (or both) will be equal to −1.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105; 0 ≤ 𝑘𝑒𝑦𝑖 ≤ 109; −1 ≤ 𝑙𝑒𝑓𝑡𝑖, 𝑟𝑖𝑔ℎ𝑡𝑖 ≤ 𝑛 − 1. It is guaranteed that the input<br>represents a valid binary tree. In particular, if 𝑙𝑒𝑓𝑡𝑖 ̸= −1 and 𝑟𝑖𝑔ℎ𝑡𝑖 ̸= −1, then 𝑙𝑒𝑓𝑡𝑖 ̸= 𝑟𝑖𝑔ℎ𝑡𝑖. Also,<br>a vertex cannot be a child of two different vertices. Also, each vertex is a descendant of the root vertex.<br><strong>Output Format</strong>. Print three lines. The first line should contain the keys of the vertices in the in-order<br>traversal of the tree. The second line should contain the keys of the vertices in the pre-order traversal<br>of the tree. The third line should contain the keys of the vertices in the post-order traversal of the tree.</p><h4 id="题意-11"><a href="#题意-11" class="headerlink" title="题意"></a>题意</h4><p>二叉树的遍历</p><h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><ol><li>DFS递归遍历二叉树。</li><li>三种遍历方式，先序遍历，中序遍历，后续遍历<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::ios_base;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeOrders</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="keyword">int</span> root;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; key;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    key.resize(n);</span><br><span class="line">    left.resize(n);</span><br><span class="line">    right.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; key[i] &gt;&gt; left[i] &gt;&gt; right[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      dfs1(left[root],res);</span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      dfs1(right[root],res);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; in_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs1(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      dfs2(left[root],res);</span><br><span class="line">      dfs2(right[root],res);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; pre_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;    </span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs2(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">dfs3</span><span class="params">(<span class="keyword">int</span> root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">      dfs3(left[root],res);</span><br><span class="line">      dfs3(right[root],res);</span><br><span class="line">      res.push_back(key[root]);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; post_order() &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="comment">// Finish the implementation</span></span><br><span class="line">    <span class="comment">// You may need to add a new recursive method to do that</span></span><br><span class="line">    dfs3(<span class="number">0</span>,result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main_with_large_stack_space</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios_base::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">  TreeOrders t;</span><br><span class="line">  t.read();</span><br><span class="line">  print(t.in_order());</span><br><span class="line">  print(t.pre_order());</span><br><span class="line">  print(t.post_order());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__unix__) || defined(__APPLE__)</span></span><br><span class="line">  <span class="comment">// Allow larger stack space</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">rlim_t</span> kStackSize = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>;   <span class="comment">// min stack size = 16 MB</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  result = getrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">  <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (rl.rlim_cur &lt; kStackSize)</span><br><span class="line">      &#123;</span><br><span class="line">          rl.rlim_cur = kStackSize;</span><br><span class="line">          result = setrlimit(RLIMIT_STACK, &amp;rl);</span><br><span class="line">          <span class="keyword">if</span> (result != <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"setrlimit returned result = "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> main_with_large_stack_space();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Is-it-a-binary-search-tree"><a href="#2-Is-it-a-binary-search-tree" class="headerlink" title="2 Is it a binary search tree?"></a>2 Is it a binary search tree?</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>.<br>    You are given a binary tree with integers as its keys. You need to test whether it is a correct binary<br>    search tree. The definition of the binary search tree is the following: for any node of the tree, if its<br>    key is 𝑥, then for any node in its left subtree its key must be strictly less than 𝑥, and for any node in<br>    its right subtree its key must be strictly greater than 𝑥. In other words, smaller elements are to the<br>    left, and bigger elements are to the right. You need to check whether the given binary tree structure<br>    satisfies this condition. You are guaranteed that the input contains a valid binary tree. That is, it is a<br>    tree, and each node has at most two children.</p><h4 id="题意-12"><a href="#题意-12" class="headerlink" title="题意"></a>题意</h4><p>判定二叉树是否为二叉查找树</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol><li>两个条件需要判定。</li><li>父节点的值一定大于左孩子，小于右孩子。</li><li>父节点的值一定大于左子树的最右边的节点，小于右子树的最左边的节点。<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">  Node() : key(<span class="number">0</span>), left(<span class="number">-1</span>), right(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">  Node(<span class="keyword">int</span> key_, <span class="keyword">int</span> left_, <span class="keyword">int</span> right_) : key(key_), left(left_), right(right_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = tree[root].left;</span><br><span class="line">    <span class="keyword">int</span> right = tree[root].right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> isLeaf = [&amp;](<span class="keyword">int</span> curr)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[curr].left == <span class="number">-1</span> &amp;&amp; tree[curr].right == <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*check left*/</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[root].key &lt;= tree[left].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="number">-1</span> &amp;&amp; !isLeaf(left))&#123;</span><br><span class="line">        left = tree[left].right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[left].key &gt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check right*/</span></span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[root].key &gt;= tree[right].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="number">-1</span> &amp;&amp; !isLeaf(right))&#123;</span><br><span class="line">        right = tree[right].left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[right].key &lt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(tree[root].left,tree)&amp;&amp;dfs(tree[root].right,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement correct algorithm here</span></span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">0</span>,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nodes;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; nodes;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> key, left, right;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    tree.push_back(Node(key, left, right));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsBinarySearchTree(tree)) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"INCORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Is-it-a-binary-search-tree-Hard-version"><a href="#3-Is-it-a-binary-search-tree-Hard-version" class="headerlink" title="3 Is it a binary search tree? Hard version."></a>3 Is it a binary search tree? Hard version.</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. You are given a binary tree with integers as its keys. You need to test whether it is a correct binary<br>search tree. Note that there can be duplicate integers in the tree, and this is allowed. The definition of<br>the binary search tree in such case is the following: for any node of the tree, if its key is 𝑥, then for any<br>node in its left subtree its key must be strictly less than 𝑥, and for any node in its right subtree its key<br>must be greater than or equal to 𝑥. In other words, smaller elements are to the left, bigger elements<br>are to the right, and duplicates are always to the right. You need to check whether the given binary<br>tree structure satisfies this condition. You are guaranteed that the input contains a valid binary tree.<br>That is, it is a tree, and each node has at most two children.</p><h4 id="题意-13"><a href="#题意-13" class="headerlink" title="题意"></a>题意</h4><p>判定二叉树是否为二叉查找树，这题跟第二题一样</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ol><li>两个条件需要判定。</li><li>父节点的值一定大于左孩子，小于右孩子。</li><li>父节点的值一定大于左子树的最右边的节点，小于右子树的最左边的节点。<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> key;</span><br><span class="line">  <span class="keyword">int</span> left;</span><br><span class="line">  <span class="keyword">int</span> right;</span><br><span class="line"></span><br><span class="line">  Node() : key(<span class="number">0</span>), left(<span class="number">-1</span>), right(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">  Node(<span class="keyword">int</span> key_, <span class="keyword">int</span> left_, <span class="keyword">int</span> right_) : key(key_), left(left_), right(right_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = tree[root].left;</span><br><span class="line">    <span class="keyword">int</span> right = tree[root].right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> isLeaf = [&amp;](<span class="keyword">int</span> curr)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[curr].left == <span class="number">-1</span> &amp;&amp; tree[curr].right == <span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isLeaf(root)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/*check left*/</span></span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[root].key &lt;= tree[left].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left != <span class="number">-1</span> &amp;&amp; !isLeaf(left))&#123;</span><br><span class="line">        left = tree[left].right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="number">-1</span> &amp;&amp; tree[left].key &gt;= tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check right*/</span></span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[root].key &gt; tree[right].key) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="number">-1</span> &amp;&amp; !isLeaf(right))&#123;</span><br><span class="line">        right = tree[right].left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="number">-1</span> &amp;&amp; tree[right].key &lt; tree[root].key)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(tree[root].left,tree)&amp;&amp;dfs(tree[root].right,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBinarySearchTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement correct algorithm here</span></span><br><span class="line">  <span class="keyword">return</span> dfs(<span class="number">0</span>,tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> nodes;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; nodes;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> key, left, right;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; key &gt;&gt; left &gt;&gt; right;</span><br><span class="line">    tree.push_back(Node(key, left, right));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IsBinarySearchTree(tree))&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"CORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"INCORRECT"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Set-with-range-sums"><a href="#4-Set-with-range-sums" class="headerlink" title="4 Set with range sums"></a>4 Set with range sums</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><strong>Task</strong>. Implement a data structure that stores a set 𝑆 of integers with the following allowed operations:</p><ul><li><strong>add(𝑖)</strong> — add integer 𝑖 into the set 𝑆 (if it was there already, the set doesn’t change).</li><li><strong>del(𝑖)</strong> — remove integer 𝑖 from the set 𝑆 (if there was no such element, nothing happens).</li><li><strong>find(𝑖)</strong> — check whether 𝑖 is in the set 𝑆 or not.</li><li><strong>sum(𝑙, 𝑟)</strong> — output the sum of all elements 𝑣 in 𝑆 such that 𝑙 ≤ 𝑣 ≤ 𝑟.<h4 id="题意-14"><a href="#题意-14" class="headerlink" title="题意"></a>题意</h4>这题本意是用splay tree，但是对于splaytree的扭转确实太复杂，太难记了。</li></ul><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ol><li>这题不用splaytree，完全可以用skiplist。</li><li>利用skiplist的插入时间复杂度为$O(lgn)$.</li><li>利用skiplist的删除时间复杂度为$O(lgn)$.</li><li>利用skiplist的find时间复杂度为$O(lgn)$.</li><li>利用skiplist的sum的时间复杂度为$O(lgn)$.</li><li>skiplist代码就没有实现，感兴趣可以找一下开源代码实现。<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据结构这个课程比前几个课程简单多了，前面几个算法课程的题目非常难，一度以为怀疑自己的智商，后来终于搞定了，基本上绝大部分都是100分，现在又要开始刷<code>standford</code>的算法课程，真心头大，真心痛苦。我想人总是会在痛苦和压力中成长起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Data-Structure&quot;&gt;&lt;a href=&quot;#Data-Structure&quot; class=&quot;headerlink&quot; title=&quot;Data Structure&quot;&gt;&lt;/a&gt;Data Structure&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，这个课程是数据结构的课程，当然对于数据结构这门课程基本的东西已经非常的熟悉了，。&lt;br&gt;对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。&lt;br&gt;抽了大概一周的时间把课程《Data Structure》学习完了，这部分的课程有些还是非常难，最后的&lt;code&gt;splaytree&lt;/code&gt;太复杂了，没有做完，总得来说质量还是非常高得，虽然里面得算法大部分都学过，还是继续温习了一遍，已经会得算法就没有仔细再重新学习掌握，主要把&lt;code&gt;hashtable&lt;/code&gt;和&lt;code&gt;splaytree&lt;/code&gt;又重新温习了一遍。最后得分是&lt;code&gt;85.90&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/WMMZ3YUHX4QA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Data Structure&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Data%20Structrues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Data Structure》" scheme="http://yoursite.com/tags/%E3%80%8AData-Structure%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>数位DP</title>
    <link href="http://yoursite.com/2020/06/02/168/"/>
    <id>http://yoursite.com/2020/06/02/168/</id>
    <published>2020-06-02T05:08:51.385Z</published>
    <updated>2020-06-03T02:01:10.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h1><h2 id="1012-至少有-1-位重复的数字"><a href="#1012-至少有-1-位重复的数字" class="headerlink" title="1012. 至少有 1 位重复的数字"></a>1012. 至少有 1 位重复的数字</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数的个数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">20</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：具有至少 <span class="number">1</span> 位重复数字的正数（&lt;= <span class="number">20</span>）只有 <span class="number">11</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">100</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：具有至少 <span class="number">1</span> 位重复数字的正数（&lt;= <span class="number">100</span>）有 <span class="number">11</span>，<span class="number">22</span>，<span class="number">33</span>，<span class="number">44</span>，<span class="number">55</span>，<span class="number">66</span>，<span class="number">77</span>，<span class="number">88</span>，<span class="number">99</span> 和 <span class="number">100</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="number">1000</span></span><br><span class="line">输出：<span class="number">262</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= N &lt;= 10^9</code><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/numbers-with-repeated-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/numbers-with-repeated-digits</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3>数位dp<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></li></ul><ol><li>经典的数位dp问题，为了这个dp问题，想了很久才想明白，今天终于靠自己的努力，把这两道数位的dp的问题彻底弄清楚了，还是非常的复杂。</li><li>具体的数位dp问题如下:<br>数位动态规划是一类特殊的动态规划，它的形式一般为：<blockquote><p>给定下界$ ll $和上界 $rr$，求 $[l, r][l,r] $之间满足某一要求的元素个数。</p></blockquote></li></ol><p>在力扣平台上，数位动态规划的题目很少，典型的例子为 1012. 至少有 1 位重复的数字，即给定下界 $11$和上界 $NN$，求上下界之间满足「至少有 11 位重复数字」的元素个数。</p><p>我们如何解决数位动态规划的题目呢？一般来说，数位动态规划有一个特定的状态表达：</p><script type="math/tex; mode=display">f[\textit{pos}][\textit{stats}][\textit{bound}]</script><p>它表示：</p><ul><li><p>我们现在处理到了数的第 $\textit{pos}$ 位。在数位动态规划中，我们是从高位到低位，一位一位地处理数字的。例如当下界 $l = 13$，上界 $r = 678$时，我们会先将上下界的高位补零使得它们拥有相同的位数，即 $(l, r) = (013, 678)$。随后我们从高位开始进行动态规划；</p></li><li><p>在 $\textit{pos}$ 位之前的那些数的状态被压缩成了 $\textit{stats}$。这是什么意思呢？我们举一个简单的例子，假设我们现在想要求出在 $[l, r][l,r]$之间各位数字之和是 $55$ 的倍数的所有数，那么此时 $\textit{stats}$ 就可以表示为「在 $ \textit{pos}$ 位之前的那些数的数字之和对 55 取模的值」，这样我们只用一个整数就能够表示 $\textit{pos}$  位之前的状态。如果在第 $ \textit{pos}$ 位我们选择了数 dd，那么动态规划中的下一个状态就为 $f[\textit{pos} + 1][(\textit{stats} + d) \bmod 5][\ldots]$；</p></li><li><p>在 $pospos$ 位之前的那些数和上下界 $l$, $rl$,$r$ 的关系为 $\textit{bound}$。这又是什么意思呢？我们还是使用上面的那个例子，求出 $[013, 678][013,678]$内各位数字之和是 $55$ 的倍数的所有数。</p></li></ul><ul><li><ul><li>如果最高位的数字我们选择了 22，它和上下界的最高位数字没有任何关系，因此对于次高位的数字，我们可以在 [0, 9][0,9] 之间任意选择；</li></ul></li><li><ul><li>如果最高位的数字我们选择了 66，此时这个数字是「贴着」上界的，也就是说，对于次高位的数字，我们只能在 [0, 7][0,7] 之间选择，其中 77 就是上界的次高位的数字。如果我们选择了数字 88 或 99，那么整个数为 68_68_，无论最后一位怎么选择，都不可能在上下界的区间内；</li></ul></li><li><ul><li>如果最高位的数字我们选择了 00，此时这个数字是「贴着」下界的，也就是说，对于次高位的数字，我们只能在 [1, 9][1,9] 之间选择，其中 11 就是下界的次高位数字。如果我们选择了数字 00，那么整个数为 00_00_，无论最后一位怎么选择，都不可能在上下界的区间内；</li></ul></li></ul><ul><li><ul><li>此外，还有一种最为特殊的情况。如果上下界为 (l, r) = (123, 156)(l,r)=(123,156)，并且最高位我们选择了 11，那么此时这个数字既「贴着」上界，也「贴着」下界，对于次高位的数字，我们只能在 [2, 5][2,5] 之间选择，其中 22 是下界的次高位数字，55 是上界的次高位数字。</li></ul></li></ul><p>综上所述，\textit{bound}bound 共有 44 种不同的情况，我们可以给它们分别设定取值 $0, 1, 2, 3$:</p><ul><li><ul><li>如果和上下界没有任何关系，那么取值为 00，并且以后也不可能和上下界有关系；</li></ul></li><li><ul><li>如果「贴着」下界，那么取值为 11，并且只有当第 \textit{pos}pos 位取了下界对应位置的数字时，才会延续 11 值，否则会变为 00；</li></ul></li><li><ul><li>如果「贴着」上界，那么取值为 22，并且只有当第 \textit{pos}pos 位取了上界对应位置的数字时，才会延续 22 值，否则会变为 00；</li></ul></li><li><ul><li>如果同时「贴着」上下界，那么取值为 3，并且：</li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位同时取了上下界对应位置的数字（此时上下界对应位置的数字一定相同），那么延续 33 值；</li></ul></li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位取了下界对应位置的数字，那么会变为 11；</li></ul></li></ul></li><li><ul><li><ul><li>如果 \textit{pos}pos 位取了上界对应位置的数字，那么会变为 22；</li></ul></li></ul></li><li><ul><li><ul><li>其余情况会变为 00。</li></ul></li></ul></li><li><p>另一种理解方式是，\textit{bound}bound 是一个 22 位的二进制数，低位为 11 当且仅当「贴着」下界，高位为 11 当且仅当「贴着」上界。</p></li></ul><p>而对于 $f[\textit{pos}][\textit{stats}][\textit{bound}]$的值本身，它表示「满足上述条件的数的个数」。这样以来，我们可以使用记忆化搜索$（DFS + memo）$的方法进行动态规划，即</p><script type="math/tex; mode=display">f[\textit{pos}][\textit{stats}][\textit{bound}] = \sum_d f[\textit{pos + 1}][g_s(\textit{stats}, d)][g_b(\textit{bound}, d)]</script><p>其中 $d$ 为第 $\textit{pos}$ 位选择的数字；$g_b(\textit{bound}, d)$ 是关于 $\textit{bound}$ 的转移函数，例如上文中四个取值 $0, 1, 2, 30,1,2,3$ 之间的转化；$g_s(\textit{stats}$ 是关于 $ \textit{stats}$  的转移函数，例如上文中的 $(\textit{stats} + d) \bmod 5$。最终的答案存放在</p><script type="math/tex; mode=display">f[0][\textit{stats}_{\textit{init}}][3]</script><p>中，即满足「枚举到最高位、初始状态、同时贴着上下界（可以想象成更高位还可以补零，那么在最高位之前的数字都是贴着上下界的）」的数的个数，也就是需要求出的答案。</p><ol><li>在此题目中我们知道上线为数<code>n</code>,下限为<code>0</code>,我们判断用掩码存储当前数目中出现的数位，当新递增第<code>i</code>位的数字位<code>m</code>时，我们通过<code>bitTst</code>方法探测是否已经出现过该数字，如果出现则认为该数字重估。</li><li>利用上述的数位dp方法还是非常的复杂。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">1024</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[N][P][M];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lower;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; upper;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">checkNum</span><span class="params">(<span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bitTst(mask,i)) res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> state,<span class="keyword">int</span> bound,<span class="keyword">int</span> zero)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == upper.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(checkNum(state) + zero == pos) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[pos][state][bound] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line"></span><br><span class="line">        dp[pos][state][bound] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = (bound&amp;<span class="number">2</span>)? upper[pos] : <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= r; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(bitTst(state,i)) <span class="keyword">continue</span>;            </span><br><span class="line">            <span class="keyword">if</span>(state == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,state,<span class="number">0</span>,zero + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> nx_bound = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>((bound&amp;<span class="number">1</span>) &amp;&amp; i == lower[pos]) nx_bound |= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((bound&amp;<span class="number">2</span>) &amp;&amp; i == upper[pos]) nx_bound |= <span class="number">2</span>;</span><br><span class="line">                dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,state|(<span class="number">1</span>&lt;&lt;i),nx_bound,zero);</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDupDigitsAtMostN</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = n; x &gt; <span class="number">0</span>; x /= <span class="number">10</span>)&#123;</span><br><span class="line">            upper.push_back(x%<span class="number">10</span>);</span><br><span class="line">            lower.push_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(upper.begin(),upper.end());</span><br><span class="line">        reverse(lower.begin(),lower.end());</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1397-找到所有好字符串"><a href="#1397-找到所有好字符串" class="headerlink" title="1397. 找到所有好字符串"></a>1397. 找到所有好字符串</h2><p>给你两个长度为<code>n</code> 的字符串 <code>s1</code> 和<code>s2</code> ，以及一个字符串 <code>evil</code> 。请你返回 好字符串 的数目。</p><p>好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 <code>s2</code> ，且不包含 <code>evil</code> `为子字符串。</p><p>由于答案可能很大，请你返回答案对<code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, s1 = <span class="string">"aa"</span>, s2 = <span class="string">"da"</span>, evil = <span class="string">"b"</span></span><br><span class="line">输出：<span class="number">51</span> </span><br><span class="line">解释：总共有 <span class="number">25</span> 个以 <span class="string">'a'</span> 开头的好字符串：<span class="string">"aa"</span>，<span class="string">"ac"</span>，<span class="string">"ad"</span>，<span class="params">...</span>，<span class="string">"az"</span>。还有 <span class="number">25</span> 个以 <span class="string">'c'</span> 开头的好字符串：<span class="string">"ca"</span>，<span class="string">"cc"</span>，<span class="string">"cd"</span>，<span class="params">...</span>，<span class="string">"cz"</span>。最后，还有一个以 <span class="string">'d'</span> 开头的好字符串：<span class="string">"da"</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">8</span>, <span class="built_in">s1</span> = <span class="string">"leetcode"</span>, <span class="built_in">s2</span> = <span class="string">"leetgoes"</span>, evil = <span class="string">"leet"</span></span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：所有字典序大于等于 <span class="built_in">s1</span> 且小于等于 <span class="built_in">s2</span> 的字符串都以 evil 字符串 <span class="string">"leet"</span> 开头。所以没有好字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span>, <span class="attr">s1</span> = <span class="string">"gx"</span>, <span class="attr">s2</span> = <span class="string">"gz"</span>, <span class="attr">evil</span> = <span class="string">"x"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s1.length == n</code></li><li><code>s2.length == n</code></li><li><code>s1 &lt;= s2</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= evil.length &lt;= 50</code></li><li><code>所有字符串都只包含小写英文字母</code></li></ul><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/find-all-good-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-good-strings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>KMP + 数位dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>思路还是非常的复杂，数位dp中的关键在于状态，此题目中状态存储的数据为当前已经匹配<code>evil</code>的最大长度。</li><li>我们可以利用kmp算法的匹配最长后缀，来线性时间的判断接受新字符后的下一个状态。</li><li>该题目非常的经典，需要经常翻看的题目。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> P = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> dp[N][M][P];</span><br><span class="line">    <span class="keyword">int</span> dfa[M][<span class="number">27</span>];</span><br><span class="line">    <span class="built_in">string</span> s1;</span><br><span class="line">    <span class="built_in">string</span> s2;</span><br><span class="line">    <span class="built_in">string</span> evil;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; str)</span></span>&#123;</span><br><span class="line">        dfa[<span class="number">0</span>][str[<span class="number">0</span>]-<span class="string">'a'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                dfa[i][k] = dfa[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            dfa[i][str[i]-<span class="string">'a'</span>] = i + <span class="number">1</span>;</span><br><span class="line">            j = dfa[j][str[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos,<span class="keyword">int</span> state,<span class="keyword">int</span> bound)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(state == evil.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == s1.size()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[pos][state][bound] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> lower = (bound&amp;<span class="number">1</span>)?s1[pos] : <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">char</span> upper = (bound&amp;<span class="number">2</span>)?s2[pos] : <span class="string">'z'</span>;</span><br><span class="line">        dp[pos][state][bound] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch = lower; ch &lt;= upper; ++ch)&#123;</span><br><span class="line">            <span class="keyword">int</span> nx_state = dfa[state][ch-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> nx_bound = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*lower bound*/</span></span><br><span class="line">            <span class="keyword">if</span>((bound&amp;<span class="number">1</span>) &amp;&amp; ch == s1[pos]) nx_bound |= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">/*upper bound*/</span></span><br><span class="line">            <span class="keyword">if</span>((bound&amp;<span class="number">2</span>) &amp;&amp; ch == s2[pos]) nx_bound |= <span class="number">2</span>;</span><br><span class="line">            dp[pos][state][bound] += dfs(pos+<span class="number">1</span>,nx_state,nx_bound);</span><br><span class="line">            dp[pos][state][bound] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[pos][state][bound];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> evil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = evil.size();</span><br><span class="line">        <span class="built_in">memset</span>(dfa,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfa));</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        kmp(evil);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;s1 = s1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s2 = s2;</span><br><span class="line">        <span class="keyword">this</span>-&gt;evil = evil;</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;s</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数位dp&quot;&gt;&lt;a href=&quot;#数位dp&quot; class=&quot;headerlink&quot; title=&quot;数位dp&quot;&gt;&lt;/a&gt;数位dp&lt;/h1&gt;&lt;h2 id=&quot;1012-至少有-1-位重复的数字&quot;&gt;&lt;a href=&quot;#1012-至少有-1-位重复的数字&quot; class=&quot;headerlink&quot; title=&quot;1012. 至少有 1 位重复的数字&quot;&gt;&lt;/a&gt;1012. 至少有 1 位重复的数字&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数的个数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：具有至少 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 位重复数字的正数（&amp;lt;= &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;）只有 &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：具有至少 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 位重复数字的正数（&amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;）有 &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;33&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;44&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;66&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;77&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;88&lt;/span&gt;，&lt;span class=&quot;number&quot;&gt;99&lt;/span&gt; 和 &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;262&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 191周比赛</title>
    <link href="http://yoursite.com/2020/05/31/167/"/>
    <id>http://yoursite.com/2020/05/31/167/</id>
    <published>2020-05-31T09:04:23.304Z</published>
    <updated>2020-05-31T15:10:33.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="191周双周赛"><a href="#191周双周赛" class="headerlink" title="191周双周赛"></a>191周双周赛</h1><p>最后一题DP很简单，结果在第三题上卡了好长时间，最后排名404名。</p><h2 id="5424-数组中两元素的最大乘积"><a href="#5424-数组中两元素的最大乘积" class="headerlink" title="5424. 数组中两元素的最大乘积"></a>5424. 数组中两元素的最大乘积</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你选择数组的两个不同下标 i 和 j，使 <code>(nums[i]-1)*(nums[j]-1)</code> 取得最大值。</p><p>请你计算并返回该式的最大值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">12</span> </span><br><span class="line">解释：如果选择下标 i=<span class="number">1</span> 和 j=<span class="number">2</span>（下标从 <span class="number">0</span> 开始），则可以获得最大值，(nums[<span class="number">1</span>]<span class="number">-1</span>)*(nums[<span class="number">2</span>]<span class="number">-1</span>) = (<span class="number">4</span><span class="number">-1</span>)*(<span class="number">5</span><span class="number">-1</span>) = <span class="number">3</span>*<span class="number">4</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：选择下标 i=<span class="number">1</span> 和 j=<span class="number">3</span>（下标从 <span class="number">0</span> 开始），则可以获得最大值 (<span class="number">5</span><span class="number">-1</span>)*(<span class="number">5</span><span class="number">-1</span>) = <span class="number">16</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 10^3</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序取最大的两个元素</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序取最大的两个元素相乘<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> (nums[n<span class="number">-1</span>]<span class="number">-1</span>)*(nums[n<span class="number">-2</span>]<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5425-切割后面积最大的蛋糕"><a href="#5425-切割后面积最大的蛋糕" class="headerlink" title="5425. 切割后面积最大的蛋糕"></a>5425. 切割后面积最大的蛋糕</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>矩形蛋糕的高度为 h 且宽度为 w，给你两个整数数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code>，其中<code>horizontalCuts[i]</code>是从矩形蛋糕顶部到第  i 个水平切口的距离，类似地， <code>verticalCuts[j]</code> 是从矩形蛋糕的左侧到第 j 个竖直切口的距离。</p><p>请你按数组 <code>horizontalCuts</code> 和 <code>verticalCuts</code> 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。由于答案可能是一个很大的数字，因此需要将结果对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], verticalCuts = [<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色的那份蛋糕面积最大。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">3</span>,<span class="number">1</span>], verticalCuts = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图所示的矩阵蛋糕中，红色线表示水平和竖直方向上的切口。切割蛋糕后，绿色和黄色的两份蛋糕面积最大。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：h = <span class="number">5</span>, w = <span class="number">4</span>, horizontalCuts = [<span class="number">3</span>], verticalCuts = [<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= h, w &lt;= 10^9</code></li><li><code>1 &lt;= horizontalCuts.length &lt; min(h, 10^5)</code></li><li><code>1 &lt;= verticalCuts.length &lt; min(w, 10^5)</code></li><li><code>1 &lt;= horizontalCuts[i] &lt; h</code></li><li><code>1 &lt;= verticalCuts[i] &lt; w</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将所有的切口按照坐标的位置从小达到排序，找到切分的最大的高度和宽度，取乘积即可。</li><li>题目必须要注意的时溢出的问题，因为这个细节处理不好，提交错误了两次。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size();</span><br><span class="line">        <span class="keyword">int</span> n = B.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxW = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxH = <span class="number">0</span>;</span><br><span class="line">        sort(A.begin(),A.end());</span><br><span class="line">        sort(B.begin(),B.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            maxH = max(maxH,A[i]-x);</span><br><span class="line">            x = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxH = max(maxH,h-x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            maxW = max(maxW,B[i]-y);</span><br><span class="line">            y = B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maxW = max(maxW,w-y);</span><br><span class="line">        res = ((<span class="keyword">long</span> <span class="keyword">long</span>)maxH*(<span class="keyword">long</span> <span class="keyword">long</span>)maxW)%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5426-重新规划路线"><a href="#5426-重新规划路线" class="headerlink" title="5426. 重新规划路线"></a>5426. 重新规划路线</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>n 座城市，从 0 到 <code>n-1</code> 编号，其间共有 <code>n-1</code> 条路线。因此，要想在两座不同城市之间旅行只有唯一一条路线可供选择（路线网形成一颗树）。去年，交通运输部决定重新规划路线，以改变交通拥堵的状况。</p><p>路线用<code>connections</code> 表示，其中 <code>connections[i] = [a, b]</code> 表示从城市 a 到 b 的一条有向路线。</p><p>今年，城市 0 将会举办一场大型比赛，很多游客都想前往城市 0 。</p><p>请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。</p><p>题目数据 保证 每个城市在重新规划路线方向后都能到达城市 0 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, connections = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, connections = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：更改以红色显示的路线的方向，使每个城市都可以到达城市 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, connections = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 5 * 10^4</code></li><li><code>connections.length == n-1</code></li><li><code>connections[i].length == 2</code></li><li><code>0 &lt;= connections[i][0], connections[i][1] &lt;= n-1</code></li><li><code>connections[i][0] != connections[i][1]</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>存储城市的连接图和它的逆向图，我们以0为起点，进行BFS，同时将每个点的正向图和逆向图的边全部都入队列，对于逆向图的边我们进行加1操作即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minReorder</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; connections)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseGraph;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : connections)&#123;</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">            reverseGraph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : reverseGraph[curr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[v])&#123;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                    res++;</span><br><span class="line">                    visit[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5427-两个盒子中球的颜色数相同的概率"><a href="#5427-两个盒子中球的颜色数相同的概率" class="headerlink" title="5427. 两个盒子中球的颜色数相同的概率"></a>5427. 两个盒子中球的颜色数相同的概率</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>桌面上有 2n 个颜色不完全相同的球，球上的颜色共有 k 种。给你一个大小为 k 的整数数组<code>balls</code>，其中 balls[i] 是颜色为 i 的球的数量。</p><p>所有的球都已经 随机打乱顺序 ，前 n 个球放入第一个盒子，后 n 个球放入另一个盒子（请认真阅读示例 2 的解释部分）。</p><p>注意：这两个盒子是不同的。例如，两个球颜色分别为 a 和 b，盒子分别为 [] 和 ()，那么<code>[a] (b)</code> 和 <code>[b] (a)</code>这两种分配方式是不同的（请认真阅读示例 1 的解释部分）。</p><p>请计算「两个盒子中球的颜色数相同」的情况的概率。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1.00000</span></span><br><span class="line">解释：球平均分配的方式只有两种：</span><br><span class="line">- 颜色为 <span class="number">1</span> 的球放入第一个盒子，颜色为 <span class="number">2</span> 的球放入第二个盒子</span><br><span class="line">- 颜色为 <span class="number">2</span> 的球放入第一个盒子，颜色为 <span class="number">1</span> 的球放入第二个盒子</span><br><span class="line">这两种分配，两个盒子中球的颜色数都相同。所以概率为 <span class="number">2</span>/<span class="number">2</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0.66667</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">随机打乱，得到 <span class="number">12</span> 种等概率的不同打乱方案，每种方案概率为 <span class="number">1</span>/<span class="number">12</span> ：</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span> / <span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span> / <span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span> / <span class="number">1</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span> / <span class="number">3</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">3</span> / <span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span> / <span class="number">2</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">1</span> / <span class="number">1</span>,<span class="number">3</span>], [<span class="number">2</span>,<span class="number">1</span> / <span class="number">3</span>,<span class="number">1</span>], [<span class="number">2</span>,<span class="number">3</span> / <span class="number">1</span>,<span class="number">1</span>], [<span class="number">3</span>,<span class="number">1</span> / <span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">1</span> / <span class="number">2</span>,<span class="number">1</span>], [<span class="number">3</span>,<span class="number">2</span> / <span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">然后，我们将前两个球放入第一个盒子，后两个球放入第二个盒子。</span><br><span class="line">这 <span class="number">12</span> 种可能的随机打乱方式中的 <span class="number">8</span> 种满足「两个盒子中球的颜色数相同」。</span><br><span class="line">概率 = <span class="number">8</span>/<span class="number">12</span> = <span class="number">0.66667</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0.60000</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]。要想显示所有 <span class="number">180</span> 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 <span class="number">108</span> 种情况是比较容易的。</span><br><span class="line">概率 = <span class="number">108</span> / <span class="number">180</span> = <span class="number">0.6</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0.30000</span></span><br><span class="line">解释：球的列表为 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]。要想显示所有 <span class="number">60</span> 种随机打乱方案是很难的，但只检查「两个盒子中球的颜色数相同」的 <span class="number">18</span> 种情况是比较容易的。</span><br><span class="line">概率 = <span class="number">18</span> / <span class="number">60</span> = <span class="number">0.3</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：balls = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">0.90327</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= balls.length &lt;= 8</code></li><li><code>1 &lt;= balls[i] &lt;= 6</code></li><li><code>sum(balls)</code>是偶数</li><li>答案与真实值误差在 <code>10^-5</code> 以内，则被视为正确答案</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls" target="_blank" rel="noopener">https://leetcode-cn.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们知道球的个数的数列为:<script type="math/tex; mode=display">A = [a_{0},a_{1},a_{2},a_{3},..,a_{n}]</script>则该数列所有可能的组合序列个数为：<script type="math/tex; mode=display">T_{a} = \frac{(\sum_{i=1}^{n}a_{i})!}{\prod_{i=1}^{n}(a_{i}!)}</script></li><li>我们可以直接用暴力法，因为该题的数目很小，我们直接可以用暴力，求出所有的球的颜色的组合数，python直接用笛卡儿积就可以搞定，比如我们假设目前该盒子中所有的球的颜色组合数目列表为:<script type="math/tex; mode=display">A = [a_{0},a_{1},a_{2},a_{3},..,a_{n}]</script>已知第一个盒子的球的颜色组合数列表为<script type="math/tex; mode=display">B = [b_{0},b_{1},b_{2},b_{3},..,b_{n}]</script>则另一个盒子中的球的颜色组合数目列表为<script type="math/tex; mode=display">C = [a_{0}-b_{0},a_{1}-b_{1},a_{2}-b_{2},a_{3}-b_{3},..,a_{n}-b_{n}]</script>如何才能满足题目中的条件呢，按照题目中要求第一个盒子和第二个盒子中的球的数目相等，且颜色种类相等。则需满足以下两个条件:<script type="math/tex; mode=display">\sum_{i=1}^{n}b_{i} = \sum_{i=1}^{n}a_{i}-b_{i} \\type(B) = type(C)</script>我们分别求出满足以上两个条件的组合的数列$B$，然后再求出数列$B$的组合数$T_{b}$,与数列$C$的组合数$T_{c}$.<script type="math/tex; mode=display">T_{b} = \frac{(\sum_{i=0}^{n}b_{i})!}{\prod_{i=0}^{n}(b_{i}!)} \\\qquad \\T_{c} = \frac{(\sum_{i=0}^{n}c_{i})!}{\prod_{i=0}^{n}(c_{i}!)} \\\qquad \\P_{b} = \frac{T_{b}*T_{c}}{T_{a}}</script></li><li>比如下面这个例子：<br>比如球得个数序列为：<br><code>B1, B2, B3 = 1, 2, 3</code><br>则第一个盒子中球的可能组合为：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>但实际只有两个序列符合要求,两个序列中球的个数相等，且颜色数目也相等：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="keyword">and</span> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) <span class="keyword">and</span> (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>因此：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P = [M(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>) * M(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) + M(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>) * M(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>)]/ M(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>所以我们只需要暴力遍历所有可能的组合即可。</li><li>我们找到所有符合条件的序列$B$:<script type="math/tex; mode=display">[B_{0},B_{1},B_{2},...,B_{m}]</script>则总的概率$P$为：<script type="math/tex; mode=display">P = \sum_{i=0}^{m}P_{b_{i}}</script></li><li>我只能说<code>python</code>太强大了，这个暴力要是用C++真心得累死，用<code>python</code>几行就搞定。<br><a href="https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/discuss/661757/Python-10-Lines-90-Multionomial-coefficients-explained" target="_blank" rel="noopener">详见国际版</a></li><li>还有一种解法参考@cuiaoxiang的解法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multinomial</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> factorial(sum(n))/prod([factorial(i) <span class="keyword">for</span> i <span class="keyword">in</span> n])</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getProbability</span><span class="params">(self, balls)</span>:</span></span><br><span class="line">        print(self.multinomial([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]))</span><br><span class="line">        k, n, Q = len(balls), sum(balls)// <span class="number">2</span>, <span class="number">0</span></span><br><span class="line">        arrays = [range(<span class="number">0</span>,i+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> balls]</span><br><span class="line">        t = list(product(*arrays))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)):</span><br><span class="line">            <span class="keyword">if</span> sum(t[i]) == n <span class="keyword">and</span> t[i].count(<span class="number">0</span>) == t[-i<span class="number">-1</span>].count(<span class="number">0</span>):</span><br><span class="line">                Q += self.multinomial(t[i]) * self.multinomial(t[-i<span class="number">-1</span>]) </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Q / self.multinomial(list(balls))</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> C[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> cnt, tot;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> sum, <span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">double</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum == m) &#123;</span><br><span class="line">                cnt += (A == B) * p;</span><br><span class="line">                tot += p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a[pos] &amp;&amp; i + sum &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nxtA = A + (i &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> nxtB = B + (a[pos] - i &gt; <span class="number">0</span>);</span><br><span class="line">            search(pos + <span class="number">1</span>, i + sum, nxtA, nxtB, p * C[a[pos]][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getProbability</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            C[i][i] = C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">        n = a.size();</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) m += x;</span><br><span class="line">        m /= <span class="number">2</span>;</span><br><span class="line">        cnt = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">        search(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt / tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;191周双周赛&quot;&gt;&lt;a href=&quot;#191周双周赛&quot; class=&quot;headerlink&quot; title=&quot;191周双周赛&quot;&gt;&lt;/a&gt;191周双周赛&lt;/h1&gt;&lt;p&gt;最后一题DP很简单，结果在第三题上卡了好长时间，最后排名404名。&lt;/p&gt;&lt;h2 id=&quot;5424-数组中两元素的最大乘积&quot;&gt;&lt;a href=&quot;#5424-数组中两元素的最大乘积&quot; class=&quot;headerlink&quot; title=&quot;5424. 数组中两元素的最大乘积&quot;&gt;&lt;/a&gt;5424. 数组中两元素的最大乘积&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt;，请你选择数组的两个不同下标 i 和 j，使 &lt;code&gt;(nums[i]-1)*(nums[j]-1)&lt;/code&gt; 取得最大值。&lt;/p&gt;&lt;p&gt;请你计算并返回该式的最大值。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如果选择下标 i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 和 j=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;（下标从 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 开始），则可以获得最大值，(nums[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(nums[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = (&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;*&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：选择下标 i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 和 j=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;（下标从 &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; 开始），则可以获得最大值 (&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;)*(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：nums = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 27周双周赛</title>
    <link href="http://yoursite.com/2020/05/31/166/"/>
    <id>http://yoursite.com/2020/05/31/166/</id>
    <published>2020-05-31T09:04:23.303Z</published>
    <updated>2020-05-31T09:04:28.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="27周双周赛"><a href="#27周双周赛" class="headerlink" title="27周双周赛"></a>27周双周赛</h1><p>最后一题DP很简单，结果在第三题上卡了好长时间，最后排名192名，还是水平很菜，我想只能靠自己一点点去提高。<br><img src="https://mike-box.github.io/images/167-1.png" alt="1"></p><h2 id="5408-通过翻转子数组使两个数组相等"><a href="#5408-通过翻转子数组使两个数组相等" class="headerlink" title="5408. 通过翻转子数组使两个数组相等"></a>5408. 通过翻转子数组使两个数组相等</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个长度相同的整数数组<code>target</code>和 <code>arr</code> 。</p><p>每一步中，你可以选择 <code>arr</code> 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。</p><a id="more"></a><p>如果你能让 <code>arr</code>变得与 <code>target</code> 相同，返回 <code>True</code>；否则，返回<code>False</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你可以按照如下步骤使 arr 变成 target：</span><br><span class="line"><span class="number">1</span>- 翻转子数组 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">2</span>- 翻转子数组 [<span class="number">4</span>,<span class="number">2</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span>- 翻转子数组 [<span class="number">4</span>,<span class="number">3</span>] ，arr 变成 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">7</span>], arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：arr 不需要做任何翻转已经与 target 相等。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">12</span>], arr = [<span class="number">12</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>], arr = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">11</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：arr 没有数字 <span class="number">9</span> ，所以无论如何也无法变成 target 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>target.length == arr.length</code></li><li><code>1 &lt;= target.length &lt;= 1000</code></li><li><code>1 &lt;= target[i] &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-two-arrays-equal-by-reversing-sub-arrays</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>最简单的就是排序后，看两个数组是否相等即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canBeEqual</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(target.begin(),target.end());</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target[i] != arr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5409-检查一个字符串是否包含所有长度为-K-的二进制子串"><a href="#5409-检查一个字符串是否包含所有长度为-K-的二进制子串" class="headerlink" title="5409. 检查一个字符串是否包含所有长度为 K 的二进制子串"></a>5409. 检查一个字符串是否包含所有长度为 K 的二进制子串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 s 和一个整数 k 。</p><p>如果所有长度为 k 的二进制字符串都是 s 的子串，请返回 True ，否则请返回 False 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00110110"</span>, k = <span class="number">2</span></span><br><span class="line">输出：true</span><br><span class="line">解释：长度为 <span class="number">2</span> 的二进制串包括 <span class="string">"00"</span>，<span class="string">"01"</span>，<span class="string">"10"</span> 和 <span class="string">"11"</span>。它们分别是 s 中下标为 <span class="number">0</span>，<span class="number">1</span>，<span class="number">3</span>，<span class="number">2</span> 开始的长度为 <span class="number">2</span> 的子串。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"00110"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0110"</span>, <span class="attr">k</span> = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的二进制串包括 <span class="string">"0"</span> 和 <span class="string">"1"</span>，显然它们都是 s 的子串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0110"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：长度为 <span class="number">2</span> 的二进制串 <span class="string">"00"</span> 没有出现在 s 中。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"0000000001011100"</span>, <span class="attr">k</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 5 * 10^5</li><li>s 中只含 0 和 1 。</li><li>1 &lt;= k &lt;= 20</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>该字符串中所有长度为k的子串用set存储起来即可，最后查看set中元素的数量是否等于<code>2^k</code>。</li><li>如果希望能够更快一点，可以KR算法，直接将字符串转换为hash数字。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasAllCodes</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-k; ++i)&#123;</span><br><span class="line">            cnt.insert(s.substr(i,k));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size() == (<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5410-课程安排-IV"><a href="#5410-课程安排-IV" class="headerlink" title="5410. 课程安排 IV"></a>5410. 课程安排 IV</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你总共需要上 n 门课，课程编号依次为 0 到 n-1 。</p><p>有的课会有直接的先修课程，比如如果想上课程 0 ，你必须先上课程 1 ，那么会以 [1,0] 数对的形式给出先修课程数对。</p><p>给你课程总数 n 和一个直接先修课程数对列表 <code>prerequisite</code>和一个查询对列表 queries 。</p><p>对于每个查询对 <code>queries[i]</code>，请判断<code>queries[i][0]</code> 是否是<code>queries[i][1]</code> 的先修课程。</p><p>请返回一个布尔值列表，列表中每个元素依次分别对应 <code>queries</code> 每个查询对的判断结果。</p><p>注意：如果课程 a 是课程 b 的先修课程且课程 b 是课程 c 的先修课程，那么课程 a 也是课程 c 的先修课程。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>]], queries = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">解释：课程 <span class="number">0</span> 不是课程 <span class="number">1</span> 的先修课程，但课程 <span class="number">1</span> 是课程 <span class="number">0</span> 的先修课程。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, prerequisites = [], queries = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">解释：没有先修课程对，所以每门课程之间是独立的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, prerequisites = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]], queries = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, prerequisites = <span class="string">[[1,0],[2,0]]</span>, queries = <span class="string">[[0,1],[2,0]]</span></span><br><span class="line">输出：[<span class="literal">false</span>,<span class="literal">true</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, prerequisites = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>]], queries = [[<span class="number">0</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">0</span>]]</span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>0 &lt;= prerequisite.length &lt;= (n * (n - 1) / 2)</code></li><li><code>0 &lt;= prerequisite[i][0], prerequisite[i][1] &lt; n</code></li><li><code>prerequisite[i][0] != prerequisite[i][1]</code></li><li>先修课程图中没有环。</li><li>先修课程图中没有重复的边。</li><li><code>1 &lt;= queries.length &lt;= 10^4</code></li><li><code>queries[i][0] != queries[i][1]</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/course-schedule-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule-iv</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> TOP排序或者Floyd</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始这个题目以为很简单，上来就直接BFS，然后毫无意外的超时。。</li><li>仔细分析了一下超时的原因。后来用了top排序，求所有课程的依赖关系，当每个课程的依赖关系是递进的，比如：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B B-&gt;C 则 A-&gt;C</span><br></pre></td></tr></table></figure>我们根据top排序，求出所有B的依赖集合，同时C继承B的所有依赖即可即可。</li><li>类似于floy算法，算法复杂度稍微高一些，O(n^3),即可求解。我们已经知道依赖关系如下：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A-&gt;B B-&gt;C</span><br></pre></td></tr></table></figure>则我们将所有B依赖的课程都查询一遍，加给C的依赖关系即可。详情可见Floyd-Warshall算法</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Graph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseGraph;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; require;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ret;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : prerequisites)&#123;</span><br><span class="line">            Graph[v[<span class="number">0</span>]].push_back(v[<span class="number">1</span>]);</span><br><span class="line">            reverseGraph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                qu.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : Graph[curr])&#123;</span><br><span class="line">                indegree[v]--;</span><br><span class="line">                require[v].insert(curr);</span><br><span class="line">                <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> e : reverseGraph[v])&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> x : require[e])&#123;</span><br><span class="line">                            require[v].insert(x);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    qu.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : queries)&#123;</span><br><span class="line">            <span class="keyword">if</span>(require[v[<span class="number">1</span>]].count(v[<span class="number">0</span>]))&#123;</span><br><span class="line">                ret.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v :  prerequisites)&#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][v[<span class="number">0</span>]])&#123;</span><br><span class="line">                    dp[i][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : queries)&#123;</span><br><span class="line">            res.push_back(dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; checkIfPrerequisite(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v :  prerequisites)&#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j] &amp;&amp; dp[j][k])&#123;</span><br><span class="line">                        dp[i][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : queries)&#123;</span><br><span class="line">            res.push_back(dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5411-摘樱桃-II"><a href="#5411-摘樱桃-II" class="headerlink" title="5411. 摘樱桃 II"></a>5411. 摘樱桃 II</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>rows x cols</code>的矩阵<code>grid</code>来表示一块樱桃地。 <code>grid</code> 中每个格子的数字表示你能获得的樱桃数目。</p><p>你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。</p><p>请你按照如下规则，返回两个机器人能收集的最多樱桃数目：</p><p>从格子 (i,j) 出发，机器人可以移动到格子 <code>(i+1, j-1)，(i+1, j) 或者 (i+1, j+1)</code> 。<br>当一个机器人经过某个格子时，它会把该格子内所有的樱桃都摘走，然后这个位置会变成空格子，即没有樱桃的格子。<br>当两个机器人同时到达同一个格子时，它们中只有一个可以摘到樱桃。<br>两个机器人在任意时刻都不能移动到 grid 外面。<br>两个机器人最后都要到达 grid 最底下一行。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">3</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">12</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">1</span>) = <span class="number">12</span> 。</span><br><span class="line">樱桃总数为： <span class="number">12</span> + <span class="number">12</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">28</span></span><br><span class="line">解释：机器人 <span class="number">1</span> 和机器人 <span class="number">2</span> 的路径在上图中分别用绿色和蓝色表示。</span><br><span class="line">机器人 <span class="number">1</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">9</span> + <span class="number">5</span> + <span class="number">2</span>) = <span class="number">17</span> 。</span><br><span class="line">机器人 <span class="number">2</span> 摘的樱桃数目为 (<span class="number">1</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">3</span>) = <span class="number">11</span> 。</span><br><span class="line">樱桃总数为： <span class="number">17</span> + <span class="number">11</span> = <span class="number">28</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">22</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>rows == grid.length</code></li><li><code>cols == grid[i].length</code></li><li><code>2 &lt;= rows, cols &lt;= 70</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cherry-pickup-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cherry-pickup-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>经典的DP，稍微转换下思路即可实现</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题目是经典的DP，如果熟悉DP的同学这个题目还是非常简单。</li><li>设<code>dp[i][x][y]</code>表示到达第<code>i</code>行时，机器人1在第<code>x</code>列，机器人2在第<code>y</code>列的时取得最大值。因为我们知道机器人从<code>(i,j)</code>出发，机器人可以移动到格子 <code>(i+1, j-1)，(i+1, j)</code> 或者 <code>(i+1, j+1)</code>。则我们可以知道机器人在<code>(i,j)</code>坐标时，则只可能从前一行得<code>(i-1, j-1)，(i-1, j)，(i-1,j+1)</code>这三个坐标到达。因为两个机器人时同时前进一步得，则当机器人1在坐标<code>(i,x)</code>,则上一行机器人1的位置可能在<code>(i-1, x-1)，(i-1, x)，(i-1,x+1)</code>；则当机器人1在坐标<code>(i,y)</code>,则上一行机器人2的位置可能在<code>(i-1, y-1)，(i-1, y)，(i-1,y+1)</code>这三个位置。</li><li>则dp得递推公式为<script type="math/tex; mode=display">dp[i][x][y] = grid[i][x] + grid[i][y] + max\left\{\begin{aligned}dp[i-1][x-1][y-1]\\dp[i-1][x-1][y]\\dp[i-1][x-1][y+1]\\dp[i-1][x][y-1]\\dp[i-1][x][y]\\dp[i-1][x][y+1]\\dp[i-1][x+1][y-1]\\dp[i-1][x+1][y]\\dp[i-1][x+1][y+1]\\\end{aligned}\right.</script></li><li>实际上根据贪心元素，机器人1和机器人2不要在同一个格子进行摘樱桃。即<script type="math/tex">x \neq y</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">71</span>][<span class="number">71</span>][<span class="number">71</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cherryPickup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][col<span class="number">-1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] + grid[<span class="number">0</span>][col<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l1 = <span class="number">-1</span>; l1 &lt;= <span class="number">1</span>; ++l1)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> l2 = <span class="number">-1</span>; l2 &lt;= <span class="number">1</span>; ++l2)&#123;</span><br><span class="line">                            <span class="keyword">int</span> x = j + l1;</span><br><span class="line">                            <span class="keyword">int</span> y = k + l2;</span><br><span class="line">                            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; col &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; dp[i<span class="number">-1</span>][x][y] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                                dp[i][j][k] = max(dp[i][j][k],dp[i<span class="number">-1</span>][x][y]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j == k)&#123;</span><br><span class="line">                            dp[i][j][k] += grid[i][j];</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            dp[i][j][k] += grid[i][j] + grid[i][k];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                res = max(res,dp[row<span class="number">-1</span>][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;27周双周赛&quot;&gt;&lt;a href=&quot;#27周双周赛&quot; class=&quot;headerlink&quot; title=&quot;27周双周赛&quot;&gt;&lt;/a&gt;27周双周赛&lt;/h1&gt;&lt;p&gt;最后一题DP很简单，结果在第三题上卡了好长时间，最后排名192名，还是水平很菜，我想只能靠自己一点点去提高。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/167-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5408-通过翻转子数组使两个数组相等&quot;&gt;&lt;a href=&quot;#5408-通过翻转子数组使两个数组相等&quot; class=&quot;headerlink&quot; title=&quot;5408. 通过翻转子数组使两个数组相等&quot;&gt;&lt;/a&gt;5408. 通过翻转子数组使两个数组相等&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个长度相同的整数数组&lt;code&gt;target&lt;/code&gt;和 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;每一步中，你可以选择 &lt;code&gt;arr&lt;/code&gt; 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCP2020 (组队赛)</title>
    <link href="http://yoursite.com/2020/05/29/165/"/>
    <id>http://yoursite.com/2020/05/29/165/</id>
    <published>2020-05-29T05:03:24.516Z</published>
    <updated>2020-05-29T05:03:32.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCP比赛"><a href="#LCP比赛" class="headerlink" title="LCP比赛"></a>LCP比赛</h1><p>LCP组队赛的题目真心难，接近ACM的比赛的水平了，比单人赛难多了，最终两个人的组合做出来了第一题和第二题，第三题和第四题全部超时。感觉自己的水平还是不够，平时还是应该有时间刷刷CF、GCJ、ATCODER才能提高水平。平时需要抓紧这几方面的练习。lc的题目还是难度太低了。</p><h2 id="LCP11"><a href="#LCP11" class="headerlink" title="LCP11"></a>LCP11</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。</p><a id="more"></a><p>小 <code>A</code> 和小 <code>B</code> 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 <code>scores</code>，设 X 代表小<code>A</code>和小<code>B</code>的浏览顺序中出现在同一位置的简历数，求 <code>X</code> 的期望。</p><p>提示：离散的非负随机变量的期望计算公式为 。在本题中，由于 X 的取值为 <code>0</code>到 <code>n</code> 之间，期望计算公式可以是 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：设两位面试者的编号为 <span class="number">0</span>, <span class="number">1</span>。由于他们的能力值都是 <span class="number">1</span>，小 A 和小 B 的浏览顺序都为从全排列 [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [<span class="number">0</span>,<span class="number">1</span>] 或者 [<span class="number">1</span>,<span class="number">0</span>] ，那么出现在同一位置的简历数为 <span class="number">2</span> ，否则是 <span class="number">0</span> 。所以 X 的期望是 (<span class="number">2</span>+<span class="number">0</span>+<span class="number">2</span>+<span class="number">0</span>) * <span class="number">1</span>/<span class="number">4</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：scores = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= scores.length &lt;= 10^5</code></li><li><code>0 &lt;= scores[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>经过分析，我们发现不同能力值的简历是不会互相影响的，所以问题可以简化为有一个长度为$n$的的数组，将里面的元素按照全排列随机排序后，问有多少个元素还在原位。设这个随机变量为 $x$ ，并且设$X_{i}$是第$i$个元素还在原位的 0-1 变量，即如果第$i$个元素还在原位,$X_{i} = 1$,否则 $X_{i} = 0$,每一个元素随机排序后还在原位的概率是$\frac{1}{n}$。<br>由期望的可加性，我们可以得到:<script type="math/tex; mode=display">E(X) = E(X_{0} + X_{1} + ... + X_{n-1}) = \sum_{0\le x \le n}EX_{i} = \frac{1}{n}*n = 1</script>我们发现$E(X)$跟数组元素的长度无关，所以我们只需要求这个数组中的不同数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expectNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; scores)</span> </span>&#123;</span><br><span class="line">        sort(scores.begin(), scores.end());</span><br><span class="line">        <span class="keyword">return</span> unique(scores.begin(), scores.end()) - scores.begin();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-12-小张刷题计划"><a href="#LCP-12-小张刷题计划" class="headerlink" title="LCP 12. 小张刷题计划"></a>LCP 12. 小张刷题计划</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>为了提高自己的代码能力，小张制定了<code>LeetCode</code>刷题计划，他选中了 <code>LeetCode</code>题库中的<code>n</code>道题，编号从 <code>0</code> 到 <code>n-1</code>，并计划在 <code>m</code>天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。</p><p>在小张刷题计划中，小张需要用<code>time[i]</code>的时间完成编号<code>i</code>的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。</p><p>我们定义<code>m</code> 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 <span class="number">3</span> 的时间，并且这个值是最小的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：time = [<span class="number">999</span>,<span class="number">999</span>,<span class="number">999</span>], m = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。</span><br></pre></td></tr></table></figure></p><p>限制：</p><ul><li><code>1 &lt;= time.length &lt;= 10^5</code></li><li><code>1 &lt;= time[i] &lt;= 10000</code></li><li><code>1 &lt;= m &lt;= 1000</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xiao-zhang-shua-ti-ji-hua</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的数组的长度的级数为10的5次方。</li><li>我们用二分查找的办法找到最小时间。每次去检测当前的最小时间能否满足要求，关键点在与检测函数，检测函数实际也时一个简单的贪心算法。</li><li>我们在有限的时间约束下，每次剔除最大的花费时间。花费的天数能否小于等于<code>m</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; time,<span class="keyword">int</span> m,<span class="keyword">int</span> maxT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = time.size();</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cost &lt;= m &amp;&amp; i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxCurr = <span class="number">0</span>;            </span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; curr &lt;= maxT)&#123;</span><br><span class="line">                curr += time[i];</span><br><span class="line">                maxCurr = max(maxCurr,time[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n &amp;&amp; curr &gt; maxT) curr -= maxCurr;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; curr + time[i] &lt;= maxT)&#123;</span><br><span class="line">                curr += time[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            cost++;</span><br><span class="line">        &#125;  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cost &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = time.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(time,m,mid))&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-13-寻宝"><a href="#LCP-13-寻宝" class="headerlink" title="LCP 13. 寻宝"></a>LCP 13. 寻宝</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>我们得到了一副藏宝图，藏宝图显示，在一个迷宫中存在着未被世人发现的宝藏。迷宫是一个二维矩阵，用一个字符串数组表示。它标识了唯一的入口（用 ‘S’ 表示），和唯一的宝藏地点（用 ‘T’ 表示）。但是，宝藏被一些隐蔽的机关保护了起来。在地图上有若干个机关点（用 ‘M’ 表示），只有所有机关均被触发，才可以拿到宝藏。</p><p>要保持机关的触发，需要把一个重石放在上面。迷宫中有若干个石堆（用 ‘O’ 表示），每个石堆都有无限个足够触发机关的重石。但是由于石头太重，我们一次只能搬一个石头到指定地点。</p><p>迷宫中同样有一些墙壁（用 ‘#’ 表示），我们不能走入墙壁。剩余的都是可随意通行的点（用 ‘.’ 表示）。石堆、机关、起点和终点（无论是否能拿到宝藏）也是可以通行的。</p><p>我们每步可以选择向上/向下/向左/向右移动一格，并且不能移出迷宫。搬起石头和放下石头不算步数。那么，从起点开始，我们最少需要多少步才能最后拿到宝藏呢？如果无法拿到宝藏，返回 -1 。</p><p>示例 1：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S#O"</span>, <span class="string">"M.."</span>, <span class="string">"M.T"</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line"></span><br><span class="line">解释：最优路线为： S-&gt;O, <span class="function"><span class="title">cost</span> = 4, 去搬石头 O-&gt;</span>第二行的M, <span class="function"><span class="title">cost</span> = 3, M机关触发 第二行的M-&gt;</span>O, <span class="function"><span class="title">cost</span> = 3, 我们需要继续回去 O 搬石头。 O-&gt;</span>第三行的M, <span class="function"><span class="title">cost</span> = 4, 此时所有机关均触发 第三行的M-&gt;</span>T, cost = <span class="number">2</span>，去T点拿宝藏。 总步数为<span class="number">16</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S<span class="subst">#O</span>"</span>, <span class="string">"M.#"</span>, <span class="string">"M.T"</span>]</span><br><span class="line"></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释：我们无法搬到石头触发机关</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： [<span class="string">"S<span class="subst">#O</span>"</span>, <span class="string">"M.T"</span>, <span class="string">"M.."</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">17</span></span><br><span class="line"></span><br><span class="line">解释：注意终点也是可以通行的。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= maze.length &lt;= 100</code></li><li><code>1 &lt;= maze[i].length &lt;= 100</code></li><li><code>maze[i].length == maze[j].length</code></li><li><code>S</code> 和 <code>T</code>有且只有一个</li><li><code>0 &lt;= M</code>的数量 <code>&lt;= 16</code></li><li><code>0 &lt;= O</code>的数量 <code>&lt;= 40</code>，题目保证当迷宫中存在 <code>M</code>时，一定存在至少一个 <code>O</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/xun-bao" target="_blank" rel="noopener">https://leetcode-cn.com/problems/xun-bao</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS + DP</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是非常复杂，中间需要处理的细节非常多。当时比赛的时候各种细节处理。</li><li>题目中要求从起点开始，拿到石头，然后打开所有开关后，然后再走到终点，我们可以看到所有的最短路径都是如下：<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; O -&gt; M -&gt; O -&gt; M -&gt; O -&gt; M ...-&gt; T</span><br></pre></td></tr></table></figure>最短路径肯定是从起点开始拿到石头打开开关<code>M1</code>,拿起石头打开开关<code>M2</code>，直到所有的开关都打开，然后再走到终点<code>T</code>.</li><li>首先由于所有的石头都是无限的，可以重复多次拿取，我们应该实际有限取距离机关最近的石头，但是实际上应该是我们从一个开关，拿到石头，然后走向另一个开关，这个非常类似于<code>leetcode</code>上1293题：<a href="https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/" target="_blank" rel="noopener">网格中的最短路径</a>,如果做了这个题目的话，肯定对这个题有所了解。我们可以快速的通过BFS求出以下三种最短距离：</li></ol><ul><li>从起点<code>T</code>处开始拿到石头走到某个开关<code>M</code>的最短距离。</li><li>从任意的机关<code>Mx</code>处出发拿到石头走到任意其他机关<code>My</code>处的最短距离。</li><li>从任意的机关<code>M</code>处出发走到终点<code>T</code>的最短距离。<br>总的来说，最短路径实际分为以上三部分，求出以上三部分的和即为最短路径。</li></ul><ol><li>这道题目稍微复杂点，如果直接计算的话，所有的路径组合大概大概有<code>n!</code>数量级，这是肯定不可接受的，所以我们需要用<code>dp</code>，我们用位图掩码<code>mask</code>来表示当前哪些机关已经被打开。</li><li>我们设<code>dp[x][state]</code>表示最后一个经过的开关为<code>x</code>所有已经打开<code>state</code>开关的位图。则递推公式为：<script type="math/tex; mode=display">dp[y][state|(1<<y)] = min(dp[y][state|(1<<y)],dp[x][state] + distance(x,y))</script></li><li>我们按照上述的 动态规划，可以很快的求出从起点开始打开所有的机关的最短距离，时间复杂度为$O(m^2*2^m)$最后还需要再加上从最后一个机关到达终点<code>T</code>的距离。这道题得代码真心是又臭又长得。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> visit[<span class="number">101</span>][<span class="number">101</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSet</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask|(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitClr</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask&amp;(~(<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze,<span class="keyword">int</span> start,<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; qu;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        </span><br><span class="line">        qu.push(make_pair(start,<span class="number">0</span>));</span><br><span class="line">        visit[start/col][start%col][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dist[make_pair(start,start)] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> x = curr.first/col;</span><br><span class="line">                <span class="keyword">int</span> y = curr.first%col;</span><br><span class="line">                <span class="keyword">int</span> take = curr.second;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;x&lt;&lt;":"&lt;&lt;y&lt;&lt;":"&lt;&lt;take&lt;&lt;endl;</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny][take] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'O'</span>)&#123;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,<span class="number">1</span>));</span><br><span class="line">                        visit[nx][ny][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'M'</span> &amp;&amp; take == <span class="number">1</span>)&#123;</span><br><span class="line">                        dist[make_pair(start,nx*col+ny)] = step + <span class="number">1</span>;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,take));</span><br><span class="line">                        visit[nx][ny][take] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        qu.push(make_pair(nx*col+ny,take));</span><br><span class="line">                        visit[nx][ny][take] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze,<span class="keyword">int</span> start,<span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; &amp; dist)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        qu.push(start);</span><br><span class="line">        visit[start/col][start%col][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dist[make_pair(start,start)] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">int</span> x = curr/col;</span><br><span class="line">                <span class="keyword">int</span> y = curr%col;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'#'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'M'</span> || maze[nx][ny] == <span class="string">'S'</span>)&#123;</span><br><span class="line">                        dist[make_pair(start,nx*col+ny)] = step + <span class="number">1</span>;</span><br><span class="line">                        visit[nx][ny][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                        qu.push(nx*col+ny);  </span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        qu.push(nx*col+ny);</span><br><span class="line">                        visit[nx][ny][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            num = num&amp;(num<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimalSteps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; maze)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size(); </span><br><span class="line">        <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; dist;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; locks;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'S'</span>) start = i*col + j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'T'</span>) end = i*col + j;</span><br><span class="line">                <span class="keyword">if</span>(maze[i][j] == <span class="string">'M'</span>) locks.push_back(i*col+j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">/*bfs*/</span></span><br><span class="line">        bfs1(maze,start,dist);</span><br><span class="line">        bfs2(maze,end,dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locks.size(); ++i)&#123;</span><br><span class="line">            bfs1(maze,locks[i],dist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = locks.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(end,start))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> dist[make_pair(end,start)];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">/*check if there has the way make two point connected*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(start,locks[i]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!dist.count(make_pair(end,locks[i]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!dist.count(make_pair(locks[i],locks[j]))) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*dp*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>&lt;&lt;m,INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>&lt;&lt;i] = dist[make_pair(start,locks[i])];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(bitTst(i,j))&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(!bitTst(i,k))&#123;</span><br><span class="line">                            <span class="keyword">int</span> nx = bitSet(i,k);</span><br><span class="line">                            <span class="keyword">if</span>(dp[j][i] != INT_MAX)&#123;</span><br><span class="line">                                dp[k][nx] = min(dp[k][nx],dp[j][i] + dist[make_pair(locks[j],locks[k])]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist.count(make_pair(end,locks[i])) &amp;&amp; dp[i][mask] != INT_MAX)&#123;</span><br><span class="line">                res = min(res,dp[i][mask] + dist[make_pair(end,locks[i])]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-14-切分数组"><a href="#LCP-14-切分数组" class="headerlink" title="LCP 14. 切分数组"></a>LCP 14. 切分数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> ，小李想将<code>nums</code> 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最优切割为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 和 [<span class="number">3</span>,<span class="number">3</span>] 。第一个子数组头尾数字的最大公约数为 <span class="number">2</span> ，第二个子数组头尾数字的最大公约数为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：只有一种可行的切割：[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>2 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qie-fen-shu-zu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qie-fen-shu-zu</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  dp + 素数筛选</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目初始一看，感觉就我们就可以用 dp来做出来,我们用<code>dp[i]</code>来表示到达索引<code>i</code>处的最少切分量。dp的递推公式如下：<script type="math/tex; mode=display">dp[i] = min(dp[k-1] + 1,dp[i]) \qquad 0 \le k \le (i-1)  \qquad and  \qquad if(GCD(dp[k],dp[i]) \neq 1)</script></li><li>按照上面的思路可以很容易写出代码，代码的时间复杂度为O(n^2).</li><li>后来仔细看了官方的题解答案，感觉自己还是太水了，知道相关的解法。我们设dp[x]代表以切割的数组中最后一个切割第一个元素的包含质因数x为的最小分割数目,prev 代表加入当前元素之前的最小分割比如当我们加入元素num[i]时，我们已知<code>nums[i]</code>包含的质因子为<code>prime1,prime2,prime3,prime4,prime5</code>等一系列质因子.比如我们当前的数组分组如下：<script type="math/tex; mode=display">[a_{1},a_{2},...,a_{i}],[a_{i+1},a_{i+2},...,a_{j}] ,...,\\[a_{j+1},a_{j+2},...,a_{k}],[a_{k+1},a_{k+2},...,a_{m}]</script>我们假设最后一个分组的第一个元素为<script type="math/tex">a_{k+1}</script>,则假设<script type="math/tex">a_{k+1}</script>包含质因数<code>x</code>，则次时我们新加入一个元素<script type="math/tex">a_{n}</script>,它也包含有质因子x,则它可以直接并入到最后一个分组，此时我们的最小值可能为<code>n+1</code>,当然它也可能含有其他质数因子，比如<code>y,q,z</code>等，我们如果找到前面的分组中的首元素包含该质因子的，则我们就可以进行合并。<script type="math/tex; mode=display">dp[x] = min(dp[x],prev + 1) \\dp[prime1] = min(dp[prime1],prev + 1) \\dp[prime2] = min(dp[prime2],prev + 1) \\dp[prime3] = min(dp[prime3],prev + 1) \\dp[prime4] = min(dp[prime4],prev + 1) \\</script></li><li>首先我们需要求出每个数包含的最小质因子，然后我们就可以通过循环来找到该数目包含的所有质因子。求每个数的最小质因数需要一点技巧，当时也是看解答想明了很长时间。这个筛选的还是非常需要一点小技巧，可以再O(m + m)的时间复杂度内求出所有数目的最小质因子。从质数2开始搜索，如k为探测的最小的质数，则<code>1*k,2*k,3*k,4*k,5*k,...,n*k</code>的最小质因数均为<code>k</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*get prime*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxV; ++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(min_prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxV; j += i)&#123;</span><br><span class="line">            min_prime[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>动态规划时。我们需要求出一个数key的所有质因数，可以采用以下办法,这也是一个小技巧。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x = key; x &gt; <span class="number">1</span>; x = x/min_prime[x])&#123;</span><br><span class="line">    <span class="comment">/* the mini dive prime*/</span></span><br><span class="line">    <span class="keyword">int</span> p = min_prime[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>整体的代码还是非常有技巧性的，这才是真是比赛需要的难度，leetcode平常的难度还是太低了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> min_prime[<span class="number">1000010</span>], prime[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">int</span> g[<span class="number">1000010</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> maxV = *max_element(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_prime(maxV+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp_prime(maxV+<span class="number">1</span>,maxV);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get prime*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxV; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min_prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= maxV; j += i)&#123;</span><br><span class="line">                    min_prime[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> x = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = min_prime[x];</span><br><span class="line">                dp[i] = min(dp[i],dp_prime[p]);</span><br><span class="line">                dp_prime[p] = min(dp_prime[p],dp[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">do</span>&#123;x = x/p;&#125;<span class="keyword">while</span>(x%p == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-15-游乐园的迷宫"><a href="#LCP-15-游乐园的迷宫" class="headerlink" title="LCP 15. 游乐园的迷宫"></a>LCP 15. 游乐园的迷宫</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定一个整数数组 <code>nums</code> ，小李想将<code>nums</code> 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释：最优切割为 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] 和 [<span class="number">3</span>,<span class="number">3</span>] 。第一个子数组头尾数字的最大公约数为 <span class="number">2</span> ，第二个子数组头尾数字的最大公约数为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：只有一种可行的切割：[<span class="number">2</span>], [<span class="number">3</span>], [<span class="number">5</span>], [<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>2 &lt;= nums[i] &lt;= 10^6</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/qie-fen-shu-zu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qie-fen-shu-zu</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li></li><li><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="LCP-16-游乐园的游览计划"><a href="#LCP-16-游乐园的游览计划" class="headerlink" title="LCP 16. 游乐园的游览计划"></a>LCP 16. 游乐园的游览计划</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3>又到了一年一度的春游时间，小吴计划去游乐场游玩 1 天，游乐场总共有 N 个游乐项目，编号从 0 到 N-1。小吴给每个游乐项目定义了一个非负整数值 value[i] 表示自己的喜爱值。两个游乐项目之间会有双向路径相连，整个游乐场总共有 M 条双向路径，保存在二维数组 edges中。 小吴计划选择一个游乐项目 A 作为这一天游玩的重点项目。上午小吴准备游玩重点项目 A 以及与项目 A 相邻的两个项目 B、C （项目A、B与C要求是不同的项目，且项目B与项目C要求相邻），并返回 A ，即存在一条 A-B-C-A 的路径。 下午，小吴决定再游玩重点项目 A以及与A相邻的两个项目 B’、C’，（项目A、B’与C’要求是不同的项目，且项目B’与项目C’要求相邻），并返回 A ，即存在一条 A-B’-C’-A 的路径。下午游玩项目 B’、C’ 可与上午游玩项目B、C存在重复项目。 小吴希望提前安排好游玩路径，使得喜爱值之和最大。请你返回满足游玩路径选取条件的最大喜爱值之和，如果没有这样的路径，返回 0。 注意：一天中重复游玩同一个项目并不能重复增加喜爱值了。例如：上下午游玩路径分别是 A-B-C-A与A-C-D-A 那么只能获得 value[A] + value[B] + value[C] + value[D] 的总和。</li></ol></blockquote><p>示例 1：</p><pre><code>输入：edges = [[0,1],[1,2],[0,2]], value = [1,2,3]输出：6解释：喜爱值之和最高的方案之一是 0-&gt;1-&gt;2-&gt;0 与 0-&gt;2-&gt;1-&gt;0 。重复游玩同一点不重复计入喜爱值，返回1+2+3=6</code></pre><p>示例 2：</p><pre><code>输入：edges = [[0,2],[2,1]], value = [1,2,5]输出：0解释：无满足要求的游玩路径，返回 0</code></pre><p>示例 3：</p><pre><code>输入：edges = [[0,1],[0,2],[0,3],[0,4],[0,5],[1,3],[2,4],[2,5],[3,4],[3,5],[4,5]], value = [7,8,6,8,9,7]输出：39解释：喜爱值之和最高的方案之一是 3-&gt;0-&gt;1-&gt;3 与 3-&gt;4-&gt;5-&gt;3 。喜爱值最高为 7+8+8+9+7=39</code></pre><p>限制：</p><pre><code>3 &lt;= value.length &lt;= 100001 &lt;= edges.length &lt;= 100000 &lt;= edges[i][0],edges[i][1] &lt; value.length0 &lt;= value[i] &lt;= 10000edges中没有重复的边edges[i][0] != edges[i][1]</code></pre><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/you-le-yuan-de-you-lan-ji-hua/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/you-le-yuan-de-you-lan-ji-hua/</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li></li><li><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCP比赛&quot;&gt;&lt;a href=&quot;#LCP比赛&quot; class=&quot;headerlink&quot; title=&quot;LCP比赛&quot;&gt;&lt;/a&gt;LCP比赛&lt;/h1&gt;&lt;p&gt;LCP组队赛的题目真心难，接近ACM的比赛的水平了，比单人赛难多了，最终两个人的组合做出来了第一题和第二题，第三题和第四题全部超时。感觉自己的水平还是不够，平时还是应该有时间刷刷CF、GCJ、ATCODER才能提高水平。平时需要抓紧这几方面的练习。lc的题目还是难度太低了。&lt;/p&gt;&lt;h2 id=&quot;LCP11&quot;&gt;&lt;a href=&quot;#LCP11&quot; class=&quot;headerlink&quot; title=&quot;LCP11&quot;&gt;&lt;/a&gt;LCP11&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程 《Algorithmic on Strings》</title>
    <link href="http://yoursite.com/2020/05/27/164/"/>
    <id>http://yoursite.com/2020/05/27/164/</id>
    <published>2020-05-27T09:22:51.199Z</published>
    <updated>2020-05-28T00:46:46.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-On-Strings"><a href="#Algorithmic-On-Strings" class="headerlink" title="Algorithmic On Strings"></a>Algorithmic On Strings</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，这个课程是关于字符串相关算法，这个课程算法的部分题目非常的<code>tricky</code>,对于我这种智商普通人的来说，真心好多题目想了好几天才能够想出来，特别是关于后缀树的部分，还有后缀数组的部分，想了很长时间才把问题独立的想明白，我想独立思考的问题才是自己最大的收获。对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。<br>课程《Algorithmic On Strings》学习完了，这部分的课程难度特别是后缀式和后缀数组相关的知识真心非常的难，好多题目非常的<code>trikly</code>，最后得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/ESEG2K7DRVHP" target="_blank" rel="noopener">Algorithms on Strings</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20Strings" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1-Suffix-Trees"><a href="#week1-Suffix-Trees" class="headerlink" title="week1 Suffix Trees"></a>week1 Suffix Trees</h2><h3 id="1-Problem-Construct-a-Trie-from-a-Collection-of-Patterns"><a href="#1-Problem-Construct-a-Trie-from-a-Collection-of-Patterns" class="headerlink" title="1 Problem: Construct a Trie from a Collection of Patterns"></a>1 Problem: Construct a Trie from a Collection of Patterns</h3><ul><li><strong>Construct</strong> a trie from a collection of patterns.</li><li><strong>Input Format</strong>. An integer 𝑛 and a collection of strings Patterns = {𝑝1, . . . , 𝑝𝑛} (each string is given on a<br>separate line).</li></ul><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> trie的构建</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>这题非常简单，直接构建即可。<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; edges;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;edges&gt; trie;</span><br><span class="line"></span><br><span class="line"><span class="function">trie <span class="title">build_trie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; patterns)</span> </span>&#123;</span><br><span class="line">  trie t;</span><br><span class="line">  edges e;</span><br><span class="line"></span><br><span class="line">  t.push_back(e);</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">string</span> w : patterns)&#123;</span><br><span class="line">      <span class="keyword">int</span> node = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> c : w)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!t[node].count(c))&#123;</span><br><span class="line">              t.push_back(e);</span><br><span class="line">              t[node][c] = t.size()<span class="number">-1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          node = t[node][c];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; patterns;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    patterns.push_back(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  trie t = build_trie(patterns);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; j : t[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; j.second &lt;&lt; <span class="string">":"</span> &lt;&lt; j.first &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Problem-Implement-TrieMatching"><a href="#2-Problem-Implement-TrieMatching" class="headerlink" title="2 Problem: Implement TrieMatching"></a>2 Problem: Implement TrieMatching</h3><p><strong>Task</strong>. Implement TrieMatching algorithm.<br><strong>Input Format</strong>. The first line of the input contains a string Text, the second line contains an integer 𝑛,<br>each of the following 𝑛 lines contains a pattern from Patterns = {𝑝1, . . . , 𝑝𝑛}.</p><h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><p>trie的match即可</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol><li>直接利用trie的match即可。<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> next [Letters];</span><br><span class="line"></span><br><span class="line">Node ()</span><br><span class="line">&#123;</span><br><span class="line">fill (next, next + Letters, NA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span> <span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (next[<span class="number">0</span>] == NA &amp;&amp; next[<span class="number">1</span>] == NA &amp;&amp; next[<span class="number">2</span>] == NA &amp;&amp; next[<span class="number">3</span>] == NA);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;  buildTrie(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; patterns)&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">Node node;</span><br><span class="line">trie.push_back(node);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>  p : patterns)&#123;</span><br><span class="line"><span class="keyword">int</span> curr  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : p)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(c);</span><br><span class="line"><span class="keyword">if</span>(trie[curr].next[idx] == NA)&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> trie;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">searchTrie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;Node&gt; &amp; trie,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; text.size(); ++i)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(text[i]);</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line"><span class="keyword">if</span>(curr == NA) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(trie[curr].isLeaf()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; solve (<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt;&amp; patterns)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; trie = buildTrie(patterns);</span><br><span class="line"><span class="comment">// write your code here</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); ++i)&#123;</span><br><span class="line"><span class="keyword">if</span>(searchTrie(trie,text,i))&#123;</span><br><span class="line">result.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> t;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; patterns (n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; patterns[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">ans = solve (t, n, patterns);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) ans.size (); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; (<span class="keyword">int</span>) ans.size ())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Problem-Construct-the-Suffix-Tree-of-a-String"><a href="#4-Problem-Construct-the-Suffix-Tree-of-a-String" class="headerlink" title="4 Problem: Construct the Suffix Tree of a String"></a>4 Problem: Construct the Suffix Tree of a String</h3><p><strong>Task</strong>. Construct the suffix tree of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><p>直接建立压缩的suffix tree</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目当时卡壳的很久，好好的花时间把suffix Tree的建立过程要讲清楚一下。</li><li>因为题目中要求的为压缩的suffix trie,如果用未压缩的suffix trie则会出现超时。</li><li>我们首先看一个重要的操作的，求两个后缀的最长公共前缀，longest common prefix。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>比如字符<strong>ababac</strong>,后缀<strong>suffix[0] = ababac</strong>, 后缀 <strong>suffix[2] = abac</strong>，则上述的两个后缀的最长公共前缀长度为2.<br>我们从后往前对字符串<strong>ababac</strong>，进行建立它的后缀树。如下图所示<br><img src="https://mike-box.github.io/images/164-1.png" alt="1"></li><li>我们从根节点开始，每次计算当前后缀与当前节点的孩子节点的最长前缀，直到LCP计算结果为0，则这时直接将当前后缀作为叶子节点加入到树中。</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next [Letters];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    Node ()&#123;</span><br><span class="line">        fill (next, next + Letters, NA);</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = NA;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Letters; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;next[i] == NA) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'$'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pii&gt; suffixTrie;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build a suffix tree of the string text and return a vector</span></span><br><span class="line"><span class="comment">// with all of the labels of its edges (the corresponding </span></span><br><span class="line"><span class="comment">// substrings of the text) in any order.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComputeSuffixTreeEdges</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;pii&gt; result;</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">  Node node;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  trie.push_back(node);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n;)&#123;</span><br><span class="line">          <span class="keyword">int</span> idx = letterToIndex(text[j]);</span><br><span class="line">          <span class="keyword">int</span> next =  trie[curr].next[idx];      </span><br><span class="line">          <span class="keyword">if</span>(next == NA)&#123;</span><br><span class="line">              trie.push_back(node);</span><br><span class="line">              trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">              curr = trie[curr].next[idx];</span><br><span class="line">              trie[curr].start = j;</span><br><span class="line">              trie[curr].length = n-j;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">int</span> length = lcs(text,trie[next].start,j,trie[next].length);</span><br><span class="line">              <span class="keyword">if</span>(length == trie[next].length)&#123;</span><br><span class="line">                  curr = next;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  trie.push_back(node);</span><br><span class="line">                  trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">                  curr = trie[curr].next[idx];</span><br><span class="line">                  trie[curr].start = j;</span><br><span class="line">                  trie[curr].length = length;</span><br><span class="line">                  trie[next].start  += length;</span><br><span class="line">                  trie[next].length -= length;</span><br><span class="line">                  <span class="keyword">int</span> x = letterToIndex(text[trie[next].start]);</span><br><span class="line">                  trie[curr].next[x] = next;</span><br><span class="line">              &#125;</span><br><span class="line">              j = j + length;</span><br><span class="line">          &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; trie.size(); ++i)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;text.substr(trie[i].start,trie[i].length)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  ComputeSuffixTreeEdges(text);  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Advanced-Problem-Find-the-Shortest-Non-Shared-Substring-of"><a href="#5-Advanced-Problem-Find-the-Shortest-Non-Shared-Substring-of" class="headerlink" title="5 Advanced Problem: Find the Shortest Non-Shared Substring of"></a>5 Advanced Problem: Find the Shortest Non-Shared Substring of</h3><p>Two Strings<br><strong>Task</strong>. Find the shortest substring of one string that does not appear in another string.<br><strong>Input Format</strong>. Strings Text1 and Text2.</p><h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><p>这个题目也很有意思。</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>后缀树的应用有很多，我们可以利用后缀树的特性。</li><li>如果发现某个后缀树的节点的所有孩子节点不存在两个字符串的公共部分，则认为该节点符合要求。</li><li>实际判别的时候比较复杂。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =    <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next [Letters];</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    Node ()&#123;</span><br><span class="line">        fill (next, next + Letters, NA);</span><br><span class="line">        <span class="keyword">this</span>-&gt;start = NA;</span><br><span class="line">        <span class="keyword">this</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'#'</span>: <span class="keyword">return</span> <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'$'</span>: <span class="keyword">return</span> <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// Build a suffix tree of the string text and return a vector</span></span><br><span class="line"><span class="comment">// with all of the labels of its edges (the corresponding </span></span><br><span class="line"><span class="comment">// substrings of the text) in any order.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> l1,<span class="keyword">int</span> l2,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 &lt; <span class="number">0</span> || l2 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[l1+i] != text[l2+i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;Node&gt; &amp; trie,<span class="keyword">int</span> curr,<span class="keyword">int</span> length,<span class="built_in">string</span> &amp; text)</span></span>&#123;</span><br><span class="line"><span class="built_in">string</span> res;</span><br><span class="line"><span class="built_in">string</span> diff = text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curr == NA) <span class="keyword">return</span> text;</span><br><span class="line"><span class="keyword">if</span>(trie[curr].start != NA &amp;&amp; trie[curr].start &lt; length)&#123;</span><br><span class="line">res.push_back(text[trie[curr].start]);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(trie[curr].start != NA)&#123;</span><br><span class="line">res = text.substr(trie[curr].start,trie[curr].length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line"><span class="built_in">string</span> next = dfs(trie,trie[curr].next[i],length,text);</span><br><span class="line"><span class="keyword">if</span>(next.size() &lt; diff.size())&#123;</span><br><span class="line">diff = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res + diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">solve</span> <span class="params">(<span class="built_in">string</span> p, <span class="built_in">string</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> result = p;</span><br><span class="line"><span class="built_in">string</span> text = p + <span class="string">"#"</span> +  q  + <span class="string">"$"</span>;</span><br><span class="line"><span class="keyword">int</span> n = text.size();</span><br><span class="line"><span class="keyword">int</span> m = p.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;Node&gt; trie;</span><br><span class="line">  Node node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement this function yourself</span></span><br><span class="line">trie.push_back(node);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n;)&#123;</span><br><span class="line"><span class="keyword">int</span> idx = letterToIndex(text[j]);</span><br><span class="line"><span class="keyword">int</span> next =  trie[curr].next[idx];      </span><br><span class="line"><span class="keyword">if</span>(next == NA)&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">trie[curr].start = j;</span><br><span class="line">trie[curr].length = n-j;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = lcs(text,trie[next].start,j,trie[next].length);</span><br><span class="line"><span class="keyword">if</span>(length == trie[next].length)&#123;</span><br><span class="line">curr = next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">trie.push_back(node);</span><br><span class="line">trie[curr].next[idx] = trie.size()<span class="number">-1</span>;</span><br><span class="line">curr = trie[curr].next[idx];</span><br><span class="line">trie[curr].start = trie[next].start;</span><br><span class="line">trie[curr].length = length;</span><br><span class="line">trie[next].start  += length;</span><br><span class="line">trie[next].length -= length;</span><br><span class="line"><span class="keyword">int</span> x = letterToIndex(text[trie[next].start]);</span><br><span class="line">trie[curr].next[x] = next;</span><br><span class="line">&#125;</span><br><span class="line">j = j + length;</span><br><span class="line">&#125;          </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dfs(trie,<span class="number">0</span>,m,text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line"><span class="built_in">string</span> q;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> ans = solve (p, q);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="1-Problem-Construct-the-Burrows–Wheeler-Transform-of-a-String"><a href="#1-Problem-Construct-the-Burrows–Wheeler-Transform-of-a-String" class="headerlink" title="1 Problem: Construct the Burrows–Wheeler Transform of a String"></a>1 Problem: Construct the Burrows–Wheeler Transform of a String</h3><p><strong>Task</strong>. Construct the Burrows–Wheeler transform of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>先利用count array算法对字符进行排序。</li><li>然后按照notebook中的参考算法编写代码即可。</li><li>count array作为一个非常重要的算法需要牢记，可以在<strong>O(n+R)</strong>的线性时间复杂度内完成数组的排序。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">istringstream</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> keys = <span class="string">"ACGT$"</span>;</span><br><span class="line"><span class="comment">// Preprocess the Burrows-Wheeler Transform bwt of some text</span></span><br><span class="line"><span class="comment">// and compute as a result:</span></span><br><span class="line"><span class="comment">//   * starts - for each character C in bwt, starts[C] is the first position </span></span><br><span class="line"><span class="comment">//       of this character in the sorted array of </span></span><br><span class="line"><span class="comment">//       all characters of the text.</span></span><br><span class="line"><span class="comment">//   * occ_count_before - for each character C in bwt and each position P in bwt,</span></span><br><span class="line"><span class="comment">//       occ_count_before[C][P] is the number of occurrences of character C in bwt</span></span><br><span class="line"><span class="comment">//       from position 0 to position P inclusive.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreprocessBWT</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; starts, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; occ_count_before)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implement this function yourself</span></span><br><span class="line">    <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">257</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occ(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">string</span> text = <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.size(); ++i)&#123;</span><br><span class="line">        occ_count_before[keys[i]] = occ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[bwt[i]+<span class="number">1</span>]++;</span><br><span class="line">        occ_count_before[bwt[i]][i+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : keys)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            occ_count_before[c][j+<span class="number">1</span>] += occ_count_before[c][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!starts.count(bwt[i]))  starts[bwt[i]] = count[bwt[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto c : keys)&#123;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;c&lt;&lt;":"&lt;&lt;starts[c]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt;= n; ++i)&#123;</span></span><br><span class="line"><span class="comment">            cout&lt;&lt;occ_count_before[c][i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the number of occurrences of string pattern in the text</span></span><br><span class="line"><span class="comment">// given only Burrows-Wheeler Transform bwt of the text and additional</span></span><br><span class="line"><span class="comment">// information we get from the preprocessing stage - starts and occ_counts_before.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CountOccurrences</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&amp; starts, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; occ_count_before)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">  <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">  <span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> bottom = n<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> curr = m<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(top &lt;= bottom)&#123;</span><br><span class="line">      <span class="keyword">if</span>(curr &lt; <span class="number">0</span>) <span class="keyword">return</span> bottom - top + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span> c = pattern[curr--];</span><br><span class="line">      top = starts[c] + occ_count_before[c][top];</span><br><span class="line">      bottom = starts[c] + occ_count_before[c][bottom+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bwt;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; bwt;</span><br><span class="line">  <span class="keyword">int</span> pattern_count;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pattern_count;</span><br><span class="line">  <span class="comment">// Start of each character in the sorted list of characters of bwt,</span></span><br><span class="line">  <span class="comment">// see the description in the comment about function PreprocessBWT</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; starts;</span><br><span class="line">  <span class="comment">// Occurrence counts for each character and each position in bwt,</span></span><br><span class="line">  <span class="comment">// see the description in the comment about function PreprocessBWT</span></span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; occ_count_before;</span><br><span class="line">  <span class="comment">// Preprocess the BWT once to get starts and occ_count_before.</span></span><br><span class="line">  <span class="comment">// For each pattern, we will then use these precomputed values and</span></span><br><span class="line">  <span class="comment">// spend only O(|pattern|) to find all occurrences of the pattern</span></span><br><span class="line">  <span class="comment">// in the text instead of O(|pattern| + |text|).</span></span><br><span class="line">  PreprocessBWT(bwt, starts, occ_count_before);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pi = <span class="number">0</span>; pi &lt; pattern_count; ++pi) &#123;</span><br><span class="line">    <span class="built_in">string</span> pattern;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; pattern;</span><br><span class="line">    <span class="keyword">int</span> occ_count = CountOccurrences(pattern, bwt, starts, occ_count_before);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, occ_count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Problem-Construct-the-Suffix-Array-of-a-String"><a href="#4-Problem-Construct-the-Suffix-Array-of-a-String" class="headerlink" title="4 Problem: Construct the Suffix Array of a String"></a>4 Problem: Construct the Suffix Array of a String</h3><p><strong>Task</strong>. Construct the suffix array of a string.<br><strong>Input Format</strong>. A string Text ending with a “$” symbol.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>先建立后缀树，采用压缩的suffix trie即可。</li><li>然后我们通过中序遍历所有的叶子节点，即可得到suffix array。</li><li>这道题目需要对前面讲述的重点suffix tree的建立要非常熟悉，实际题目还是非常难做的。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">InverseBWT</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; bwt)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = bwt.size();</span><br><span class="line">  <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">257</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n,<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">string</span> text = <span class="string">""</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      count[bwt[i]+<span class="number">1</span>]++;</span><br><span class="line">      <span class="keyword">if</span>(bwt[i] == <span class="string">'$'</span>) row = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">      count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      next[count[bwt[i]]++] = i; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      text.push_back(bwt[next[row]]);</span><br><span class="line">      row = next[row];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// write your code here</span></span><br><span class="line">  <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> bwt;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; bwt;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; InverseBWT(bwt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Algorithmic-Challenges"><a href="#week4-Algorithmic-Challenges" class="headerlink" title="week4: Algorithmic Challenges"></a>week4: Algorithmic Challenges</h2><p>总的来说这一章是字符串算法最难的，当时卡壳了几个星期才把所有的题目全部通过，其实有时候真的很难理解讲义中的算法，还是要落到实地，自己去写实际的代码才直到哪里存在坑，对算法实际的原理才能深入的理解。suffix array真心不容易。</p><h3 id="1-Problem-Find-All-Occurrences-of-a-Pattern-in-a-String"><a href="#1-Problem-Find-All-Occurrences-of-a-Pattern-in-a-String" class="headerlink" title="1 Problem: Find All Occurrences of a Pattern in a String"></a>1 Problem: Find All Occurrences of a Pattern in a String</h3><p>In this problem, we ask a simple question: how many times one string occurs as a substring of another?<br>Recall that different occurrences of a substring can overlap with each other. For example, ATA occurs three<br>times in CGATATATCCATAG.</p><ul><li><strong>Task</strong>. Find all occurrences of a pattern in a string.</li><li><strong>Input Format</strong>. Strings 𝑃𝑎𝑡𝑡𝑒𝑟𝑛 and 𝐺𝑒𝑛𝑜𝑚𝑒.<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>KMP算法，熟悉kmp算法模式匹配的话，这个题目非常简单。</li><li>只是讲义中的kmp算法跟我们平常用的方法有一些不同。不用计算next数组，直接计算最长后缀。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> Letters =   <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> NA      =   <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">letterToIndex</span> <span class="params">(<span class="keyword">char</span> letter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (letter)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'A'</span>: <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'G'</span>: <span class="keyword">return</span> <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>: <span class="keyword">return</span> <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: assert (<span class="literal">false</span>); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find all occurrences of the pattern in the text and return a</span></span><br><span class="line"><span class="comment">// vector with all positions in the text (starting from 0) where </span></span><br><span class="line"><span class="comment">// the pattern starts in the text.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; find_pattern(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, <span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = pattern.size();</span><br><span class="line">  <span class="keyword">int</span> m = text.size();</span><br><span class="line">  <span class="built_in">string</span> t = pattern + <span class="string">"$"</span> + text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(m + n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; t[j] != t[i]) j = prefix[j<span class="number">-1</span>];</span><br><span class="line">      <span class="keyword">if</span>(t[i] == t[j])&#123;</span><br><span class="line">          j++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          j = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      prefix[i] = j;</span><br><span class="line">      <span class="keyword">if</span>(i &gt; n &amp;&amp; prefix[i] == n) </span><br><span class="line">        result.push_back(i<span class="number">-2</span>*n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> pattern, text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; pattern;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = find_pattern(pattern, text);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, result[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Construct-the-Suffix-Array-of-a-Long-String"><a href="#2-Problem-Construct-the-Suffix-Array-of-a-Long-String" class="headerlink" title="2 Problem: Construct the Suffix Array of a Long String"></a>2 Problem: Construct the Suffix Array of a Long String</h3><p>The goal in this problem is to construct the suffix array of a given string again, but this time for a longer<br>string. This will require you to implement an efficient algorithm.</p><ul><li><strong>Task</strong>. Construct the suffix array of a string.</li><li><strong>Input Format</strong>. A string Text ending with a “$” symbol.<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>对后缀数组的建立，我们之前讲过一种方法即为建立后缀树，然后再进行DFS遍历即可，时间复杂度为O(n^2),显然不能满足题目要求。</li><li>利用讲义中给出的算法来实现即可。其中有两个非常重要的概念要将讲一下，count sort和 classfiy操作。<br><img src="https://mike-box.github.io/images/164-2.png" alt="2"></li><li>排序的时候利用倍增原理来确定顺序，非常牛的一种思路来解决该问题，发明这个算法的人一定很聪明。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Build suffix array of the string text and</span></span><br><span class="line"><span class="comment">// return a vector result of the same length as the text</span></span><br><span class="line"><span class="comment">// such that the value result[i] is the index (0-based)</span></span><br><span class="line"><span class="comment">// in text where the i-th lexicographically smallest</span></span><br><span class="line"><span class="comment">// suffix of text starts.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortCharacters(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : text)&#123;</span><br><span class="line">        count[c]++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        count[text[i]]--;</span><br><span class="line">        order[count[text[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ComputeCharClasses(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">0</span>);</span><br><span class="line">    res[order[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[order[i]] != text[order[i<span class="number">-1</span>]])&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortDoubled(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newOrder(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[classfiy[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> start = (order[i]-len+n)%n;</span><br><span class="line">        <span class="keyword">int</span> cl = classfiy[start];</span><br><span class="line">        count[cl]--;</span><br><span class="line">        newOrder[count[cl]] = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; UpdateClasses(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; newOrder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = newOrder.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newClassfiy(n,<span class="number">0</span>);</span><br><span class="line">    newClassfiy[newOrder[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = newOrder[i];</span><br><span class="line">        <span class="keyword">int</span> prev = newOrder[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid = curr + len;</span><br><span class="line">        <span class="keyword">int</span> midPrev = (prev + len)%n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classfiy[curr] != classfiy[prev] || </span><br><span class="line">           classfiy[mid] != classfiy[midPrev])&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newClassfiy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; BuildSuffixArray(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = SortCharacters(text);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; classfiy = ComputeCharClasses(text,order);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l &lt; n)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;order[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;classfiy[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      order = SortDoubled(text,l,order,classfiy);</span><br><span class="line">      classfiy = UpdateClasses(order,classfiy,l);</span><br><span class="line">      l = l&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> text;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array = BuildSuffixArray(text);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; suffix_array.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; suffix_array[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Problem-Pattern-Matching-with-the-Suffix-Array"><a href="#3-Problem-Pattern-Matching-with-the-Suffix-Array" class="headerlink" title="3 Problem: Pattern Matching with the Suffix Array"></a>3 Problem: Pattern Matching with the Suffix Array</h3>In this problem, we will let you use the suffix array to solve the Multiple Pattern Matching Problem.</li></ol><ul><li><strong>Task</strong>. Find all occurrences of a given collection of patterns in a string.</li><li><strong>Input Format</strong>. The first line contains a string Text). The second line specifies an integer 𝑛. The last line gives a collection of 𝑛 strings Patterns = {𝑝1, . . . , 𝑝𝑛} separated by spaces.<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>思路对应先通过倍增算法，求出后缀数组。</li><li>利用二分查找算法，查找对大于等于字符串的左边界，查找小于等于字符串的右边界，最终即为左右边界之间的数组。</li><li>算法还是非常经典的算法，需要认真思考和揣摩。<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortCharacters(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(<span class="number">256</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : text)&#123;</span><br><span class="line">        count[c]++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        count[text[i]]--;</span><br><span class="line">        order[count[text[i]]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ComputeCharClasses(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">0</span>);</span><br><span class="line">    res[order[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(text[order[i]] != text[order[i<span class="number">-1</span>]])&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]]+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[order[i]] = res[order[i<span class="number">-1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; SortDoubled(<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> len,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; order,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = text.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newOrder(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[classfiy[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> start = (order[i]-len+n)%n;</span><br><span class="line">        <span class="keyword">int</span> cl = classfiy[start];</span><br><span class="line">        count[cl]--;</span><br><span class="line">        newOrder[count[cl]] = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newOrder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; UpdateClasses(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; newOrder,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; classfiy,<span class="keyword">int</span> len)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = newOrder.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; newClassfiy(n,<span class="number">0</span>);</span><br><span class="line">    newClassfiy[newOrder[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = newOrder[i];</span><br><span class="line">        <span class="keyword">int</span> prev = newOrder[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">int</span> mid = curr + len;</span><br><span class="line">        <span class="keyword">int</span> midPrev = (prev + len)%n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(classfiy[curr] != classfiy[prev] || </span><br><span class="line">           classfiy[mid] != classfiy[midPrev])&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             newClassfiy[curr] = newClassfiy[prev];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newClassfiy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; BuildSuffixArray(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text) &#123;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = SortCharacters(text);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; classfiy = ComputeCharClasses(text,order);</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(l &lt; n)&#123;</span><br><span class="line">      order = SortDoubled(text,l,order,classfiy);</span><br><span class="line">      classfiy = UpdateClasses(order,classfiy,l);</span><br><span class="line">      l = l&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; FindOccurrences(<span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern, <span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suffix_array) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  <span class="keyword">int</span> m = pattern.size();</span><br><span class="line">  <span class="built_in">string</span> key = text + text;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> r = n;</span><br><span class="line">  <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// write your code here</span></span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(pattern &gt; key.substr(suffix_array[mid],m))&#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          r = mid;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start = l;</span><br><span class="line">  r = n;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(pattern &lt;  key.substr(suffix_array[mid],m))&#123;</span><br><span class="line">          r = mid;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          l = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  end = r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(start &gt; end) <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; ++i)&#123;</span><br><span class="line">      result.push_back(suffix_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">100001</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">  <span class="built_in">string</span> text = buffer;</span><br><span class="line">  text += <span class="string">'$'</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array = BuildSuffixArray(text);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> pattern_count;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pattern_count);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; occurs(text.length(), <span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> pattern_index = <span class="number">0</span>; pattern_index &lt; pattern_count; ++pattern_index) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">    <span class="built_in">string</span> pattern = buffer;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; occurrences = FindOccurrences(pattern, text, suffix_array);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; occurrences.size(); ++j) &#123;</span><br><span class="line">      occurs[occurrences[j]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; occurs.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (occurs[i]) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Advanced-Problem-Construct-the-Suffix-Tree-from-the-Suffix-Array"><a href="#4-Advanced-Problem-Construct-the-Suffix-Tree-from-the-Suffix-Array" class="headerlink" title="4 Advanced Problem: Construct the Suffix Tree from the Suffix Array"></a>4 Advanced Problem: Construct the Suffix Tree from the Suffix Array</h3><p>SuffixTree(Text) can be constructed in linear time from SuffixArray(Text) by using the longest common<br>prefix (LCP) array of Text, LCP(Text), which stores the length of the longest common prefix shared by<br>consecutive lexicographically ordered suffixes of Text. For example,<br>LCP(“panamabananas$”) = (0, 1, 1, 3, 3, 1, 0, 0, 0, 2, 2, 0, 0).</p><ul><li><strong>Task</strong>. Construct a suffix tree from the suffix array and LCP array of a string.</li><li><strong>Input Format</strong>. The first line contains a string Text ending with a “$” symbol, the second line contains<br>SuffixArray(Text) as a list of |Text| integers separated by spaces, the last line contains LCP(Text) as<br>a list of |Text| − 1 integers separated by spaces.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li></ul><ol><li>这个题目真心难，当时恨不得看了一个星期才看懂该算法，题目的本意即为从叶子节点往上建造树。</li><li>每次保存上次建树的叶子节点，比较当前叶子节点与后缀之间的最长前缀。如果长度为0则直接创建新的叶子节点。</li><li>这个题目解释起来太复杂了，需要仔细的画图示意才能对这个算法有深入的了解，最坑的是刚开始递归太深，导致一直报<code>sig 12</code>的错误，找不到原因，后来在论坛上问，才知道原来是利用dfs求边时导致递归太深，堆栈溢出的问题，后来终于解决了这个题目，感觉时我做的时间最长的题目了。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::make_pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data structure to store edges of a suffix tree.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="comment">// The ending node of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> node;</span><br><span class="line">  <span class="comment">// Starting position of the substring of the text </span></span><br><span class="line">  <span class="comment">// corresponding to the label of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> start;</span><br><span class="line">  <span class="comment">// Position right after the end of the substring of the text </span></span><br><span class="line">  <span class="comment">// corresponding to the label of this edge.</span></span><br><span class="line">  <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">  Edge(<span class="keyword">int</span> node_, <span class="keyword">int</span> start_, <span class="keyword">int</span> end_) : node(node_), start(start_), end(end_) &#123;&#125;</span><br><span class="line">  Edge(<span class="keyword">const</span> Edge&amp; e) : node(e.node), start(e.start), end(e.end) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuffixTreeNode</span>&#123;</span></span><br><span class="line">   SuffixTreeNode * parent;</span><br><span class="line">   <span class="built_in">map</span>&lt;<span class="keyword">char</span>,SuffixTreeNode*&gt; child;</span><br><span class="line">   <span class="keyword">int</span> depth;</span><br><span class="line">   <span class="keyword">int</span> start;</span><br><span class="line">   <span class="keyword">int</span> end;</span><br><span class="line">   SuffixTreeNode()&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;depth = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;start = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;end = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Build suffix tree of the string text given its suffix array suffix_array</span></span><br><span class="line"><span class="comment">// and LCP array lcp_array. Return the tree as a mapping from a node ID</span></span><br><span class="line"><span class="comment">// to the vector of all outgoing edges of the corresponding node. The edges in the</span></span><br><span class="line"><span class="comment">// vector must be sorted in the ascending order by the first character of the edge label.</span></span><br><span class="line"><span class="comment">// Root must have node ID = 0, and all other node IDs must be different</span></span><br><span class="line"><span class="comment">// nonnegative integers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For example, if text = "ACACAA$", an edge with label "$" from root to a node with ID 1</span></span><br><span class="line"><span class="comment">// must be represented by Edge(1, 6, 7). This edge must be present in the vector tree[0]</span></span><br><span class="line"><span class="comment">// (corresponding to the root node), and it should be the first edge in the vector </span></span><br><span class="line"><span class="comment">// (because it has the smallest first character of all edges outgoing from the root).</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(SuffixTreeNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SuffixTreeNode *&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;SuffixTreeNode *&gt; child;</span><br><span class="line"></span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">        SuffixTreeNode * curr = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;parent) <span class="built_in">cout</span>&lt;&lt;curr-&gt;start&lt;&lt;<span class="string">" "</span>&lt;&lt;curr-&gt;end+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr-&gt;child)&#123;</span><br><span class="line">            child.push(v.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!child.empty())&#123;</span><br><span class="line">            s.push(child.top());</span><br><span class="line">            child.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SuffixTreeNode * <span class="title">CreateNewLeaf</span><span class="params">(SuffixTreeNode * node,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> suffix)</span></span>&#123;</span><br><span class="line">    SuffixTreeNode * leaf = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">    leaf-&gt;parent = node;</span><br><span class="line">    leaf-&gt;depth = text.size()-suffix;</span><br><span class="line">    leaf-&gt;start = suffix + node-&gt;depth;</span><br><span class="line">    leaf-&gt;end = text.size()<span class="number">-1</span>;</span><br><span class="line">    node-&gt;child[text[leaf-&gt;start]] = leaf;</span><br><span class="line">    <span class="keyword">return</span> leaf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SuffixTreeNode * <span class="title">BreakEdge</span><span class="params">(SuffixTreeNode * node,<span class="keyword">const</span> <span class="built_in">string</span> &amp; text,<span class="keyword">int</span> start,<span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> startChar = text[start];</span><br><span class="line">    <span class="keyword">char</span> midChar = text[start + offset];</span><br><span class="line">    SuffixTreeNode * midNode = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">    midNode-&gt;parent = node;</span><br><span class="line">    midNode-&gt;depth = node-&gt;depth + offset;</span><br><span class="line">    midNode-&gt;start = start;</span><br><span class="line">    midNode-&gt;end = start + offset - <span class="number">1</span>;</span><br><span class="line">    midNode-&gt;child[midChar] = node-&gt;child[startChar];</span><br><span class="line">    node-&gt;child[startChar]-&gt;parent = midNode;</span><br><span class="line">    node-&gt;child[startChar]-&gt;start += offset;</span><br><span class="line">    node-&gt;child[startChar] = midNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> midNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">realseSuffixTree</span><span class="params">(SuffixTreeNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">        realseSuffixTree(v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SuffixTreeFromSuffixArray</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; suffix_array,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lcp_array,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; text)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = text.size();</span><br><span class="line">  SuffixTreeNode * root = <span class="keyword">new</span> SuffixTreeNode();</span><br><span class="line">  root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">  root-&gt;depth = <span class="number">0</span>;</span><br><span class="line">  root-&gt;start = <span class="number">0</span>;</span><br><span class="line">  root-&gt;end = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// Implement this function yourself</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> lcpPrev = <span class="number">0</span>;</span><br><span class="line">  SuffixTreeNode * currNode = root;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> suffix = suffix_array[i];</span><br><span class="line">      <span class="keyword">while</span>(currNode-&gt;depth &gt; lcpPrev)&#123;</span><br><span class="line">          currNode = currNode-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(currNode-&gt;depth == lcpPrev)&#123;</span><br><span class="line">          currNode = CreateNewLeaf(currNode,text,suffix);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">int</span> start = suffix_array[i<span class="number">-1</span>] + currNode-&gt;depth;</span><br><span class="line">          <span class="keyword">int</span> offset = lcpPrev - currNode-&gt;depth;</span><br><span class="line">          <span class="comment">/*break from the edge*/</span></span><br><span class="line">          SuffixTreeNode * midNode =  BreakEdge(currNode,text,start,offset);</span><br><span class="line">          <span class="comment">/*add new leaf node*/</span></span><br><span class="line">          currNode = CreateNewLeaf(midNode,text,suffix);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">          lcpPrev = lcp_array[i];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dfs(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">200001</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buffer);</span><br><span class="line">  <span class="built_in">string</span> text = buffer;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; suffix_array(text.length());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length(); ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;suffix_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lcp_array(text.length() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + <span class="number">1</span> &lt; text.length(); ++i) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;lcp_array[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Build the suffix tree and get a mapping from </span></span><br><span class="line">  <span class="comment">// suffix tree node ID to the list of outgoing Edges.</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  SuffixTreeFromSuffixArray(suffix_array, lcp_array, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>仔细回想一下自己本科时候学的算法水平真的很差了，那么基础和简单的东西都没有好好学，那个时候有大把的时间去好好学习，好好思考，却被自己荒废了。确实值得自己去反思一下原因。</p><ul><li>个人主观原因： 对自己要求放松，再加上外界环境的放松，很难对自己有所提高。而自己年轻时的不珍惜时间，不珍惜机会导致中年危机，我想也是自己咎由自取。</li><li>外界客观原因： 想想读书时，本科老师很多水平真的不行，绝大部分科研不行，也没有工业界的经验，绝大部分老师都是照本宣科来讲课本，对于计算这门实践性这么强的科目，没有实践基本上相当于白学。想想本来老师讲的算法和数据结构根本就没有完整的实现过，对数据的理解和 算法的深入远远不够。我想当年专业课老师们也对我们这群差生也很无语了。</li><li>观念的原因： 想想当年总觉得自己辛辛苦苦的读完大学就该享受了，却并没有对这个世界和这个社会有真正的认识，只是着眼于眼前。当然那个时候互联网也没有现在这么发达，不像现在网上随处可以学习的公开课和开源代码供自己参考，当年可是找本最新的教科书都很难。<br>絮絮叨叨了这么多，不管怎么样，努力学习，努力提升自己，不要随周围环境随波逐流，不要迷失自己，不要忘了自己初心，不要忘了自己的责任。虽然爬坡的过程很艰难，但是前方的光明依然在等着你。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-On-Strings&quot;&gt;&lt;a href=&quot;#Algorithmic-On-Strings&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic On Strings&quot;&gt;&lt;/a&gt;Algorithmic On Strings&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，这个课程是关于字符串相关算法，这个课程算法的部分题目非常的&lt;code&gt;tricky&lt;/code&gt;,对于我这种智商普通人的来说，真心好多题目想了好几天才能够想出来，特别是关于后缀树的部分，还有后缀数组的部分，想了很长时间才把问题独立的想明白，我想独立思考的问题才是自己最大的收获。对于特别需要独立思考的问题，适当建议对于卡到壳的时候，一定要先放一放，去外面散步或者多运动，只有这样利用自己的发散思维就能把问题解决出来，仔细思考一下这种思考模式，在《learning how to learn》课程中学到的知识应用到这些科学知识，真的是非常有用。&lt;br&gt;课程《Algorithmic On Strings》学习完了，这部分的课程难度特别是后缀式和后缀数组相关的知识真心非常的难，好多题目非常的&lt;code&gt;trikly&lt;/code&gt;，最后得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/ESEG2K7DRVHP&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms on Strings&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20Strings&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithmic On Strings》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithmic-On-Strings%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 190周周赛</title>
    <link href="http://yoursite.com/2020/05/24/163/"/>
    <id>http://yoursite.com/2020/05/24/163/</id>
    <published>2020-05-24T04:46:56.440Z</published>
    <updated>2020-05-24T04:58:01.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="190周周赛"><a href="#190周周赛" class="headerlink" title="190周周赛"></a>190周周赛</h1><p>本周周赛的题目出奇的简单，我这种渣渣水平都能在半个小时全部搞定。</p><h2 id="5416-检查单词是否为句中其他单词的前缀"><a href="#5416-检查单词是否为句中其他单词的前缀" class="headerlink" title="5416. 检查单词是否为句中其他单词的前缀"></a>5416. 检查单词是否为句中其他单词的前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>sentence</code>作为句子并指定检索词为 <code>searchWord</code>，其中句子由若干用 单个空格 分隔的单词组成。</p><p>请你检查检索词 <code>searchWord</code>是否为句子<code>sentence</code>中任意单词的前缀。</p><a id="more"></a><ul><li>如果<code>searchWord</code>是某一个单词的前缀，则返回句子<code>sentence</code> 中该单词所对应的下标（下标从 1 开始）。</li><li>如果 <code>searchWord</code>是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。</li><li>如果<code>searchWord</code> 不是任何单词的前缀，则返回 -1 。</li><li>字符串 S 的 「前缀」是 S 的任何前导连续子字符串。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">"i love eating burger"</span>, searchWord = <span class="string">"burg"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="string">"burg"</span> 是 <span class="string">"burger"</span> 的前缀，而 <span class="string">"burger"</span> 是句子中第 <span class="number">4</span> 个单词。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：sentence = <span class="string">"this problem is an easy problem"</span>, searchWord = <span class="string">"pro"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">"pro"</span> 是 <span class="string">"problem"</span> 的前缀，而 <span class="string">"problem"</span> 是句子中第 <span class="number">2</span> 个也是第 <span class="number">6</span> 个单词，但是应该返回最小下标 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"i am tired"</span>, <span class="attr">searchWord</span> = <span class="string">"you"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br><span class="line">解释：<span class="string">"you"</span> 不是句子中任何单词的前缀。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"i use triple pillow"</span>, <span class="attr">searchWord</span> = <span class="string">"pill"</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">sentence</span> = <span class="string">"hello from the other side"</span>, <span class="attr">searchWord</span> = <span class="string">"they"</span></span><br><span class="line">输出：-<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= sentence.length &lt;= 100</code></li><li><code>1 &lt;= searchWord.length &lt;= 10</code></li><li><code>sentence</code>由小写英文字母和空格组成。</li><li><code>searchWord</code>由小写英文字母组成。</li><li>前缀就是紧密附着于词根的语素，中间不能插入其它成分，并且它的位置是固定的——-位于词根之前。（引用自 前缀_百度百科 ）</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接判断</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>送分题，当然想用技巧的话可以搞KMP之类的。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrefixOfWord</span><span class="params">(self, sentence: str, searchWord: str)</span> -&gt; int:</span></span><br><span class="line">        words = sentence.split()</span><br><span class="line">        m = len(searchWord)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(words)):</span><br><span class="line">            <span class="keyword">if</span> len(words[i]) &gt;= m <span class="keyword">and</span> words[i][:m] == searchWord:</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5417-定长子串中元音的最大数目"><a href="#5417-定长子串中元音的最大数目" class="headerlink" title="5417. 定长子串中元音的最大数目"></a>5417. 定长子串中元音的最大数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你字符串<code>s</code>和整数 <code>k</code> 。<br>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。<br>英文中的 元音字母 为<code>（a, e, i, o, u）</code>。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abciiidef"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：子字符串 <span class="string">"iii"</span> 包含 <span class="number">3</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aeiou"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：任意长度为 <span class="number">2</span> 的子字符串都包含 <span class="number">2</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="string">"lee"</span>、<span class="string">"eet"</span> 和 <span class="string">"ode"</span> 都包含 <span class="number">2</span> 个元音字母。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"rhythms"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串 s 中不含任何元音字母。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"tryhard"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li>s 由小写英文字母组成</li><li><code>1 &lt;= k &lt;= s.length</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/maximum-number-of-vowels-in-a-substring-of-given-length/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>送分题，滑动窗口，窗口大小为K.判定窗口内的元音字母。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'a'</span>||c == <span class="string">'o'</span>||c == <span class="string">'e'</span>||c == <span class="string">'i'</span>||c == <span class="string">'u'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxVowels</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;  </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isVowel(s[i]))&#123;</span><br><span class="line">                cnt[s[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">                    curr += x.second;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(curr,res);</span><br><span class="line">                <span class="keyword">if</span>(isVowel(s[i-k+<span class="number">1</span>]))&#123;</span><br><span class="line">                    cnt[s[i-k+<span class="number">1</span>]]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5418-二叉树中的伪回文路径"><a href="#5418-二叉树中的伪回文路径" class="headerlink" title="5418. 二叉树中的伪回文路径"></a>5418. 二叉树中的伪回文路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。</p><p>请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：上图为给定的二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 。</span><br><span class="line">     在这些路径中，只有红色和绿色的路径是伪回文路径，因为红色路径 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>] 存在回文排列 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>] ，绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：上图为给定二叉树。总共有 <span class="number">3</span> 条从根到叶子的路径：绿色路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] ，路径 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>] 和路径 [<span class="number">2</span>,<span class="number">1</span>] 。</span><br><span class="line">     这些路径中只有绿色路径是伪回文路径，因为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>] 存在回文排列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>给定二叉树的节点数目在 1 到 10^5 之间。</li><li>节点值在 1 到 9 之间。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/pseudo-palindromic-paths-in-a-binary-tree/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们通过DFS，统计每条从根节点到叶子节点的路径上的数字个数。</li><li>如果路径上的数字有1个以上的数字的数量为奇数，则该路径不能组成回文数。</li><li>题目实际上可以稍微加大点难度，去掉数字大小的限制，这样的话这个题目难度就稍微大了点。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        cnt[root-&gt;val]++;</span><br><span class="line">        <span class="keyword">if</span>(cnt[root-&gt;val]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            cnt.erase(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.size() &lt;= <span class="number">1</span>) res++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(root-&gt;left,cnt,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;right,cnt,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pseudoPalindromicPaths</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        dfs(root,cnt,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5419-两个子序列的最大点积"><a href="#5419-两个子序列的最大点积" class="headerlink" title="5419. 两个子序列的最大点积"></a>5419. 两个子序列的最大点积</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你两个数组 <code>nums1</code>和 <code>nums2</code> 。</p><p>请你返回 <code>nums1</code>和 <code>nums2</code>中两个长度相同的 非空 子序列的最大点积。</p><p>数组的非空子序列是通过删除原数组中某些元素（可能一个也不删除）后剩余数字组成的序列，但不能改变数字间相对顺序。比方说，<code>[2,3,5]</code> 是 <code>[1,2,3,4,5]</code>的一个子序列而 <code>[1,5,3]</code> 不是。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">5</span>], nums2 = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">-6</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">2</span>,<span class="number">-2</span>] ，从 nums2 中得到子序列 [<span class="number">3</span>,<span class="number">-6</span>] 。</span><br><span class="line">它们的点积为 (<span class="number">2</span>*<span class="number">3</span> + (<span class="number">-2</span>)*(<span class="number">-6</span>)) = <span class="number">18</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">3</span>,<span class="number">-2</span>], nums2 = [<span class="number">2</span>,<span class="number">-6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">3</span>] ，从 nums2 中得到子序列 [<span class="number">7</span>] 。</span><br><span class="line">它们的点积为 (<span class="number">3</span>*<span class="number">7</span>) = <span class="number">21</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">-1</span>,<span class="number">-1</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：从 nums1 中得到子序列 [<span class="number">-1</span>] ，从 nums2 中得到子序列 [<span class="number">1</span>] 。</span><br><span class="line">它们的点积为 <span class="number">-1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 500</code></li><li><code>-1000 &lt;= nums1[i], nums2[i] &lt;= 100</code></li></ul><p>定义两个数列 $a = [a_{1},a_{2},a_{3},a_{4}…a_{n}]$ 与 $b = [b_{1},b_{2},b_{3},b_{4}…b_{n}]$的点积为：</p><script type="math/tex; mode=display">a.b = \sum_{i=1}^{n}a_{i}b_{i} = a_{1}b_{1} + a_{2}b_{2} + a_{3}b_{3} + ...+ a_{n}b_{n}</script><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-190/problems/max-dot-product-of-two-subsequences/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的DP，根LCS问题几乎是一样的，稍微复杂点的要注意处理负数的边界问题。</li><li>dp[i][j]表示数列1到索引<code>i</code>处，数列2到索引<code>j</code>处的点积最大值，dp的递推公式如下：<script type="math/tex; mode=display">dp[i][j] = max\left\{\begin{aligned}a_{i}b_{i} + dp[i-1][j-1] \\dp[i-1][j] \\dp[i][j-1] \\a_{i}b_{i} \\\end{aligned}\right.</script></li><li>基本上代码10行就可以搞定。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDotProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                dp[i][j] = nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j] = max(dp[i][j],nums1[i<span class="number">-1</span>]*nums2[j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">1</span>) dp[i][j] = max(dp[i][j],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>(j &gt; <span class="number">1</span>) dp[i][j] = max(dp[i][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;190周周赛&quot;&gt;&lt;a href=&quot;#190周周赛&quot; class=&quot;headerlink&quot; title=&quot;190周周赛&quot;&gt;&lt;/a&gt;190周周赛&lt;/h1&gt;&lt;p&gt;本周周赛的题目出奇的简单，我这种渣渣水平都能在半个小时全部搞定。&lt;/p&gt;&lt;h2 id=&quot;5416-检查单词是否为句中其他单词的前缀&quot;&gt;&lt;a href=&quot;#5416-检查单词是否为句中其他单词的前缀&quot; class=&quot;headerlink&quot; title=&quot;5416. 检查单词是否为句中其他单词的前缀&quot;&gt;&lt;/a&gt;5416. 检查单词是否为句中其他单词的前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;sentence&lt;/code&gt;作为句子并指定检索词为 &lt;code&gt;searchWord&lt;/code&gt;，其中句子由若干用 单个空格 分隔的单词组成。&lt;/p&gt;&lt;p&gt;请你检查检索词 &lt;code&gt;searchWord&lt;/code&gt;是否为句子&lt;code&gt;sentence&lt;/code&gt;中任意单词的前缀。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 189周周赛</title>
    <link href="http://yoursite.com/2020/05/18/162/"/>
    <id>http://yoursite.com/2020/05/18/162/</id>
    <published>2020-05-18T09:02:46.654Z</published>
    <updated>2020-05-18T09:05:53.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="189周周赛"><a href="#189周周赛" class="headerlink" title="189周周赛"></a>189周周赛</h1><p>还是周赛质量稍微高一些。</p><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two integer arrays startTime and endTime and given an integer queryTime.</p><a id="more"></a><p>The ith student started doing their homework at the time startTime[i] and finished it at time <code>endTime[i]</code>.</p><p>Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p><p>Example 1:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], endTime = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: We have <span class="number">3</span> students <span class="keyword">where</span>:</span><br><span class="line">The <span class="keyword">first</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">1</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">second</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> also wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">third</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">7</span> <span class="keyword">and</span> was <span class="keyword">the</span> only student doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The only student was doing their homework at the queryTime.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], endTime = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], queryTime = <span class="number">7</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], endTime = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>startTime.length == endTime.length</code></li><li><code>1 &lt;= startTime.length &lt;= 100</code></li><li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li><li><code>1 &lt;= queryTime &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接判断或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的数据量非常小，我们直接判断每个区间是否包含<code>querytime</code>即可，O(n)时间复杂度内即可完成，比较简单。</li><li>另有一种比较方便的算法，可以用来计算多个<code>query</code>，可以在O(1)或者O(lgn)时间复杂度内获取多个<code>query</code>的次数。类似于左右括号匹配的办法。我们将所有的<code>startTime</code>在坐标上以<code>(</code>表示，将所有的<code>endTime</code>以<code>)</code>表示，我们遇到左括号则进行加1操作，遇到右括号则进行减1操作。</li><li>根据2的解法其实很简单，我们将所有的<code>startTime</code>和<code>endTime</code>进行排序，我们查找小于等于<code>querytime</code>的<code>startTime</code>有l个，我们查找小于<code>querytime</code>的<code>endTime</code>有r个，在此区间的则总共有<code>l - r</code>。<br><img src="https://mike-box.github.io/images/163-1.png" alt="1"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Declare Array of maximum given constraint size to</span></span><br><span class="line">        <span class="comment">// store all the overlapping intervals at any time.</span></span><br><span class="line">        <span class="comment">// Initially no intervals overlap so initialised by 0.</span></span><br><span class="line">        <span class="keyword">int</span> overlap_intervals[<span class="number">1002</span>];</span><br><span class="line">        <span class="built_in">memset</span>(overlap_intervals, <span class="number">0</span>, <span class="keyword">sizeof</span>(overlap_intervals));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For every index in start time </span></span><br><span class="line">        <span class="comment">// increment the index in array by 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : startTime) </span><br><span class="line">            overlap_intervals[i] += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Since the intervals also contains the ending points so</span></span><br><span class="line">        <span class="comment">// decrement will work at index i+1.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : endTime) </span><br><span class="line">            overlap_intervals[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find the overlaps by using prefix sum technique</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) </span><br><span class="line">            overlap_intervals[i+<span class="number">1</span>] += overlap_intervals[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return the overlaps at the given query time.</span></span><br><span class="line">        <span class="keyword">return</span> overlap_intervals[queryTime];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        sort(startTime.begin(),startTime.end());</span><br><span class="line">        sort(endTime.begin(),endTime.end());</span><br><span class="line">        <span class="keyword">int</span> l = upper_bound(startTime.begin(),startTime.end(),queryTime) - startTime.begin();</span><br><span class="line">        <span class="keyword">int</span> r = lower_bound(endTime.begin(),endTime.end(),queryTime) - endTime.begin();</span><br><span class="line">        <span class="keyword">return</span> l - r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1451-Rearrange-Words-in-a-Sentence"><a href="#1451-Rearrange-Words-in-a-Sentence" class="headerlink" title="1451. Rearrange Words in a Sentence"></a>1451. Rearrange Words in a Sentence</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a sentence <code>text</code> (A sentence is a string of space-separated words) in the following format:</p><ul><li>First letter is in upper case.</li><li>Each word in <code>text</code> are separated by a single space.</li></ul><p>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p><p>Return the new text following the format shown above.</p><p>Example 1:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="keyword">text</span> = <span class="string">"Leetcode is cool"</span></span><br><span class="line">Output: <span class="string">"Is cool leetcode"</span></span><br><span class="line">Explanation: There are <span class="number">3</span> <span class="keyword">words</span>, <span class="string">"Leetcode"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">8</span>, <span class="string">"is"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">2</span> <span class="keyword">and</span> <span class="string">"cool"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">4.</span></span><br><span class="line">Output is ordered <span class="keyword">by</span> <span class="built_in">length</span> <span class="keyword">and</span> <span class="keyword">the</span> <span class="built_in">new</span> <span class="keyword">first</span> <span class="built_in">word</span> starts <span class="keyword">with</span> capital letter.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="type">text</span> = <span class="string">"Keep calm and code on"</span></span><br><span class="line">Output: <span class="string">"On and keep calm code"</span></span><br><span class="line">Explanation: Output <span class="literal">is</span> ordered <span class="keyword">as</span> follows:</span><br><span class="line"><span class="string">"On"</span> <span class="number">2</span> letters.</span><br><span class="line"><span class="string">"and"</span> <span class="number">3</span> letters.</span><br><span class="line"><span class="string">"keep"</span> <span class="number">4</span> letters <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> tie <span class="keyword">order</span> <span class="keyword">by</span><span class="built_in"> position</span> <span class="keyword">in</span> original <span class="type">text</span>.</span><br><span class="line"><span class="string">"calm"</span> <span class="number">4</span> letters.</span><br><span class="line"><span class="string">"code"</span> <span class="number">4</span> letters.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = "To <span class="keyword">be</span> <span class="keyword">or</span> <span class="keyword">not</span> to <span class="keyword">be</span>"</span><br><span class="line">Output: "To <span class="keyword">be</span> <span class="keyword">or</span> to <span class="keyword">be</span> <span class="keyword">not</span>"</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li>text begins with a capital letter and then contains lowercase letters and single space between words.</li><li><code>1 &lt;= text.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">https://leetcode.com/problems/rearrange-words-in-a-sentence/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这种题目特别无聊，就是直接暴力即可，没有一点技巧可言。</li><li>先分词，然后对所有的单词按照长度进行<code>稳定</code>排序，保证单词的顺序与原来保持一致。</li><li>再重写句子，然后将首字母改成大写。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sv,<span class="keyword">const</span> <span class="keyword">char</span> flag = <span class="string">' '</span>)</span> </span>&#123;</span><br><span class="line">        sv.clear();</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(iss, temp, flag)) &#123;</span><br><span class="line">            sv.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.size() == b.first.size()) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first.size() &lt; b.first.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lower</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">upper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span>&amp;&amp; c &lt;= <span class="string">'z'</span>)||(c &gt;= <span class="string">'A'</span>&amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">arrangeWords</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        </span><br><span class="line">        text[<span class="number">0</span>] = lower(text[<span class="number">0</span>]);</span><br><span class="line">        split(text,words,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i)&#123;</span><br><span class="line">            arr.push_back(make_pair(words[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),cmp);</span><br><span class="line">        res += arr[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">           res += <span class="string">' '</span> + arr[i].first;</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isAlpha(res[<span class="number">0</span>]))&#123;</span><br><span class="line">            res[<span class="number">0</span>] = upper(res[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List"></a>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given the array favoriteCompanies where <code>favoriteCompanies[i]</code> is the list of favorites companies for the ith person (indexed from 0).</p><p>Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.</p><p>Example 1:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>,<span class="string">"microsoft"</span>],[<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">2</span> has favoriteCompanies[<span class="number">2</span>]=[<span class="string">"google"</span>,<span class="string">"facebook"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] corresponding to the person with index <span class="number">0.</span> </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">3</span> has favoriteCompanies[<span class="number">3</span>]=[<span class="string">"google"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] and favoriteCompanies[<span class="number">1</span>]=[<span class="string">"google"</span>,<span class="string">"microsoft"</span>]. </span><br><span class="line"><span class="symbol">Other</span> lists of favorite companies are not a subset of another list, therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"leetcode"</span>,<span class="string">"amazon"</span>],[<span class="string">"facebook"</span>,<span class="string">"google"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">In</span> this case favoriteCompanies[<span class="number">2</span>]=[<span class="string">"facebook"</span>,<span class="string">"google"</span>] is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>], therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>].</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>],[<span class="string">"google"</span>],[<span class="string">"facebook"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= favoriteCompanies.length &lt;= 100</code></li><li><code>1 &lt;= favoriteCompanies[i].length &lt;= 500</code></li><li><code>1 &lt;= favoriteCompanies[i][j].length &lt;= 20</code></li><li>All strings in <code>favoriteCompanies[i]</code> are distinct.</li><li>All lists of favorite companies are distinct, that is, If we sort alphabetically each list then <code>favoriteCompanies[i] != favoriteCompanies[j]</code>.</li><li>All strings consist of lowercase English letters only.</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目也是直接暴力即可，稍微用点技巧的是可以将字符串改用hash来存储，直接暴力两层循环即可。</li><li>难点在于如何判断两个<code>list</code>存在包含关系，稍微用点技巧，用hash或者双指针均可，即可在O(m)得时间复杂度完成判别。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">int</span> n = b.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peopleIndexes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            sort(A[i].begin(),A[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isContain = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(contain(A[i],A[j]))&#123;</span><br><span class="line">                    isContain = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isContain) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard"></a>1453. Maximum Number of Darts Inside of a Circular Dartboard</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane.<br>Return the maximum number of points that are within or lie on <code>any</code> circular dartboard of radius r.</p><p>Example 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="keyword">and</span> radius = <span class="number">2</span> contain all points.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">7</span>,<span class="number">8</span>]], r = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">4</span>) <span class="keyword">and</span> radius = <span class="number">5</span> contain all points except the point (<span class="number">7</span>,<span class="number">8</span>).</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">1</span></span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= points.length &lt;= 100</code></li><li><code>points[i].length == 2</code></li><li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li><li><code>1 &lt;= r &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到这种图论或者数学问题果真不会解答，直接参考答案。<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Enumerate all combinations <span class="keyword">of</span> <span class="number">2</span> points,</span><br><span class="line">find <span class="keyword">the</span> circle going <span class="keyword">through</span> them <span class="keyword">with</span> radius = r.</span><br><span class="line"></span><br><span class="line">Use this circumcenter <span class="keyword">as</span> <span class="keyword">the</span> center <span class="keyword">of</span> circle,</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">count</span> how many points inside.</span><br><span class="line"></span><br><span class="line">Also explained <span class="keyword">by</span> Alexandre C:</span><br><span class="line">Basic observations :</span><br><span class="line"></span><br><span class="line">    I assume <span class="keyword">the</span> radius <span class="keyword">is</span> one,</span><br><span class="line">    <span class="keyword">since</span> <span class="keyword">it</span> doesn't change anything.</span><br><span class="line">    <span class="keyword">given</span> any two points,</span><br><span class="line">    there exists <span class="keyword">at</span> most two unit circles <span class="keyword">on</span> which they lie.</span><br><span class="line">    <span class="keyword">given</span> a solution circle <span class="keyword">to</span> your problem,</span><br><span class="line">    you can move <span class="keyword">it</span> <span class="keyword">until</span> <span class="keyword">it</span> <span class="keyword">contains</span> two points <span class="keyword">of</span> your <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">while</span> keeping <span class="keyword">the</span> same <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside <span class="keyword">it</span>.</span><br><span class="line"></span><br><span class="line">The algorithm <span class="keyword">is</span> <span class="keyword">then</span>:</span><br><span class="line"></span><br><span class="line">    For each pair <span class="keyword">of</span> points,</span><br><span class="line">    <span class="keyword">if</span> their distance <span class="keyword">is</span> &lt; <span class="number">2</span>,</span><br><span class="line">    compute <span class="keyword">the</span> two unit circles C1 <span class="keyword">and</span> C2 <span class="keyword">that</span> pass <span class="keyword">through</span> them.</span><br><span class="line">    Compute <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside C1 <span class="keyword">and</span> C2</span><br><span class="line">    Take <span class="keyword">the</span> max.</span><br></pre></td></tr></table></figure></li><li>涉及到图论中的相关数学知识，还是没有学过。如果一个圆 C 能覆盖点集 S，当S包含两个及以上数量的点时，我们可以将园进行平移移动 C 找到一个 C’，使得 C’ 也能覆盖 S，且至少有两个点在 C’ 上。这个证明就很复杂了，感兴趣的还是看看数学定理吧。<br><img src="https://mike-box.github.io/images/163-2.png" alt="2"></li><li>现在我们已经知道园上两点的坐标和园的半径，求圆心。根据学过的解析几何，很容易将圆心的坐标求出来。实际圆心可能由两种情况，如图所示的A,B两点为可能的圆心。<br><img src="https://mike-box.github.io/images/163-4.png" alt="3"></li><li>又把解析几何稍微复习了一下，上面使一些递推公式，稍微复杂点，大意就是起点坐标加上单位向量乘以长度。推公式还是非常有意思的。<script type="math/tex; mode=display">(x^{'},y^{'}) = (x,y) + (x_{d},y_{d})*h</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y1 = points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x2 = points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">double</span> d = <span class="built_in">sqrt</span>((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class="line">                <span class="keyword">if</span>(d &gt; r*<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> x0 = (x1+x2)/<span class="number">2.0</span> + (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">double</span> y0 = (y1+y2)/<span class="number">2.0</span> - (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                x0 = (x1+x2)/<span class="number">2.0</span> - (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                y0 = (y1+y2)/<span class="number">2.0</span> + (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;189周周赛&quot;&gt;&lt;a href=&quot;#189周周赛&quot; class=&quot;headerlink&quot; title=&quot;189周周赛&quot;&gt;&lt;/a&gt;189周周赛&lt;/h1&gt;&lt;p&gt;还是周赛质量稍微高一些。&lt;/p&gt;&lt;h2 id=&quot;1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot;&gt;&lt;a href=&quot;#1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot; class=&quot;headerlink&quot; title=&quot;1450. Number of Students Doing Homework at a Given Time&quot;&gt;&lt;/a&gt;1450. Number of Students Doing Homework at a Given Time&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two integer arrays startTime and endTime and given an integer queryTime.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 26周双周赛</title>
    <link href="http://yoursite.com/2020/05/17/161/"/>
    <id>http://yoursite.com/2020/05/17/161/</id>
    <published>2020-05-16T16:09:54.635Z</published>
    <updated>2020-05-16T16:10:00.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26周双周赛"><a href="#26周双周赛" class="headerlink" title="26周双周赛"></a>26周双周赛</h1><p>前三题非常简单，最后一题稍微复杂点。</p><h2 id="5396-连续字符"><a href="#5396-连续字符" class="headerlink" title="5396. 连续字符"></a>5396. 连续字符</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。</p><p>请你返回字符串的能量。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子字符串 <span class="string">"ee"</span> 长度为 <span class="number">2</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbcccddddeeeeedcba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：子字符串 <span class="string">"eeeee"</span> 长度为 <span class="number">5</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"triplepillooooow"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hooraaaaaaaaaaay"</span></span><br><span class="line">输出：<span class="number">11</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"tourist"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力滑动窗口统计相同的字符数目即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">char</span> curr = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == curr)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                curr = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5397-最简分数"><a href="#5397-最简分数" class="headerlink" title="5397. 最简分数"></a>5397. 最简分数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你返回所有 <code>0</code>到 <code>1</code> 之间（不包括 0 和 1）满足分母小于等于  <code>n</code>的 最简 分数 。分数可以以 任意 顺序返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>]</span><br><span class="line">解释：<span class="string">"1/2"</span> 是唯一一个分母小于等于 <span class="number">2</span> 的最简分数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"2/3"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"1/4"</span>,<span class="string">"2/3"</span>,<span class="string">"3/4"</span>]</span><br><span class="line">解释：<span class="string">"2/4"</span> 不是最简分数，因为它可以化简为 <span class="string">"1/2"</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的<code>n</code>最大只有100，所以根本就不用技巧了，直接暴力求出所有可能的分数，然后化简分数，去掉重复的数即可。</li><li>去重的方法有很多种，我这里用的hash。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; simplifiedFractions(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; count;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> g = __gcd(i,j);</span><br><span class="line">                <span class="keyword">int</span> x = i/g;</span><br><span class="line">                <span class="keyword">int</span> y = j/g;</span><br><span class="line">                <span class="built_in">string</span> s = to_string(x) + <span class="string">"/"</span> + to_string(y);</span><br><span class="line">                count.insert(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : count)&#123;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5398-统计二叉树中好节点的数目"><a href="#5398-统计二叉树中好节点的数目" class="headerlink" title="5398. 统计二叉树中好节点的数目"></a>5398. 统计二叉树中好节点的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。</p><p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：图中蓝色节点为好节点。</span><br><span class="line">根节点 (<span class="number">3</span>) 永远是个好节点。</span><br><span class="line">节点 <span class="number">4</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">5</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">3</span> -&gt; (<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>) 是路径中的最大值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：节点 <span class="number">2</span> -&gt; (<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>) 不是好节点，因为 <span class="string">"3"</span> 比它大。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：根节点是好节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>二叉树中节点数目范围是<code>[1, 10^5]</code>。</li><li>每个节点权值的范围是 <code>[-10^4, 10^4]</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目咋一看貌似很复杂，实际一分析非常简单，直接DFS搞定。</li><li>DFS时每次传输从根节点到该节点路劲上的最大值，判断当前的节点的值是否大于等于路径的最大值即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> maxCurr,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;= maxCurr)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCurr = max(root-&gt;val,maxCurr);</span><br><span class="line">        dfs(root-&gt;left,maxCurr,res);</span><br><span class="line">        dfs(root-&gt;right,maxCurr,res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root,INT_MIN,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5399-数位成本和为目标值的最大数字"><a href="#5399-数位成本和为目标值的最大数字" class="headerlink" title="5399. 数位成本和为目标值的最大数字"></a>5399. 数位成本和为目标值的最大数字</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code>。请你返回满足如下规则可以得到的 最大 整数：</p><ul><li>给当前结果添加一个数位<code>（i + 1）</code>的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li><li>总成本必须恰好等于 <code>target</code>。</li><li>添加的数位中没有数字 0 。</li></ul><p>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"7772"</span></span><br><span class="line">解释：添加数位 '<span class="number">7</span>' 的成本为 <span class="number">2</span> ，添加数位 '<span class="number">2</span>' 的成本为 <span class="number">3</span> 。所以 <span class="string">"7772"</span> 的代价为 <span class="number">2</span>*<span class="number">3</span>+ <span class="number">3</span>*<span class="number">1</span> = <span class="number">9</span> 。 <span class="string">"997"</span> 也是满足要求的数字，但 <span class="string">"7772"</span> 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  <span class="number">1</span>  -&gt;   <span class="number">4</span></span><br><span class="line">  <span class="number">2</span>  -&gt;   <span class="number">3</span></span><br><span class="line">  <span class="number">3</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">4</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">5</span>  -&gt;   <span class="number">6</span></span><br><span class="line">  <span class="number">6</span>  -&gt;   <span class="number">7</span></span><br><span class="line">  <span class="number">7</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">8</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">9</span>  -&gt;   <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>], target = <span class="number">12</span></span><br><span class="line">输出：<span class="string">"85"</span></span><br><span class="line">解释：添加数位 '<span class="number">8</span>' 的成本是 <span class="number">7</span> ，添加数位 '<span class="number">5</span>' 的成本是 <span class="number">5</span> 。<span class="string">"85"</span> 的成本为 <span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], target = <span class="number">5</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>], target = <span class="number">47</span></span><br><span class="line">输出：<span class="string">"32211"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>cost.length == 9</code></li><li><code>1 &lt;= cost[i] &lt;= 5000</code></li><li><code>1 &lt;= target &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  0-1背包问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的0-1背包问题，给定的重量下，有无数的货物，如何取货物使得背包的价值最大。</li><li>在这里背包的重量即为<code>target</code>,每个货物的重量即为<code>cost</code>,价值即为组成的数。</li><li>稍微复杂点的数如何表示，假设我们直接用字符串来表示已经取得货物的价值时，肯定会出现内存超出或者超时的问题，仔细分析一下，我们用一个数据统计已经取得所有数目<code>1~9</code>的个数。每次进行价值比较时，我们首先比较数字的个数，如果数字的个数相同，则比较数目的大小即可，具体可以参考代码。</li><li>直接dp即可。<script type="math/tex; mode=display">dp[i] = max(dp[i],dp[i-cost[j]] + j)</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            cnta += a[i];</span><br><span class="line">            cntb += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnta &gt; cntb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnta &lt; cntb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[i] &gt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; ++j)&#123;</span><br><span class="line">                res += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(target+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= cost[j<span class="number">-1</span>] &amp;&amp; valid(dp[i-cost[j<span class="number">-1</span>]]))&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev = dp[i-cost[j<span class="number">-1</span>]];</span><br><span class="line">                    prev[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(!valid(dp[i])||compare(prev,dp[i]))&#123;</span><br><span class="line">                        dp[i] = prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!valid(dp[target])) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> generNum(dp[target]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;26周双周赛&quot;&gt;&lt;a href=&quot;#26周双周赛&quot; class=&quot;headerlink&quot; title=&quot;26周双周赛&quot;&gt;&lt;/a&gt;26周双周赛&lt;/h1&gt;&lt;p&gt;前三题非常简单，最后一题稍微复杂点。&lt;/p&gt;&lt;h2 id=&quot;5396-连续字符&quot;&gt;&lt;a href=&quot;#5396-连续字符&quot; class=&quot;headerlink&quot; title=&quot;5396. 连续字符&quot;&gt;&lt;/a&gt;5396. 连续字符&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。&lt;/p&gt;&lt;p&gt;请你返回字符串的能量。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;ee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abbcccddddeeeeedcba&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;eeeee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;triplepillooooow&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;hooraaaaaaaaaaay&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;tourist&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程《Algorithms on Graphs》</title>
    <link href="http://yoursite.com/2020/05/10/160/"/>
    <id>http://yoursite.com/2020/05/10/160/</id>
    <published>2020-05-10T12:09:15.322Z</published>
    <updated>2020-05-10T12:09:20.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Graphs"><a href="#Algorithmic-Graphs" class="headerlink" title="Algorithmic Graphs"></a>Algorithmic Graphs</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是比较容易的题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6" target="_blank" rel="noopener">Algorithms on Graphs</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs" target="_blank" rel="noopener">source code</a><br>总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。</p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Problem-Finding-an-Exit-from-a-Maze"><a href="#1-Problem-Finding-an-Exit-from-a-Maze" class="headerlink" title="1. Problem: Finding an Exit from a Maze"></a>1. Problem: Finding an Exit from a Maze</h3><p>A maze is a rectangular grid of cells with walls between some of adjacent cells.<br>You would like to check whether there is a path from a given cell to a given<br>exit from a maze where an exit is also a cell that lies on the border of the maze<br>(in the example shown to the right there are two exits: one on the left border<br>and one on the right border). For this, you represent the maze as an undirected<br>graph: vertices of the graph are cells of the maze, two vertices are connected by<br>an undirected edge if they are adjacent and there is no wall between them. Then,<br>to check whether there is a path between two given cells in the maze, it suffices to<br>check that there is a path between the corresponding two vertices in the graph.<br><strong>Task</strong>. Given an undirected graph and two distinct vertices 𝑢 and 𝑣, check if there is a path between 𝑢 and 𝑣.<br><strong>Input Format</strong>. An undirected graph with 𝑛 vertices and 𝑚 edges. The next line contains two vertices 𝑢<br>and 𝑣 of the graph.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 103; 1 ≤ 𝑚 ≤ 103; 1 ≤ 𝑢, 𝑣 ≤ 𝑛; 𝑢 ̸= 𝑣.<br><strong>Output Format</strong>. Output 1 if there is a path between 𝑢 and 𝑣 and 0 otherwise.</p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> BFS</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>最基本的BFS路径搜索<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">  visit.insert(x);</span><br><span class="line">  qu.push(x);</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line">      <span class="keyword">if</span>(curr == y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">          qu.push(v);</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reach(adj, x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Problem-Adding-Exits-to-a-Maze"><a href="#2-Problem-Adding-Exits-to-a-Maze" class="headerlink" title="2 Problem: Adding Exits to a Maze"></a>2 Problem: Adding Exits to a Maze</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, compute the number of connected components in it.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 103.<br><strong>Output Format</strong>. Output the number of connected components.</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.最基本的查找图的连通单元，用BFS或者并查集实现均可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(visit.count(i)) <span class="keyword">continue</span>;</span><br><span class="line">      qu.push(i);</span><br><span class="line">      visit.insert(i);</span><br><span class="line">      res++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit.insert(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><p>第一题比较简单</p><h3 id="2-Determining-an-Order-of-Courses"><a href="#2-Determining-an-Order-of-Courses" class="headerlink" title="2. Determining an Order of Courses"></a>2. Determining an Order of Courses</h3><p><strong>Task</strong>. Compute a topological ordering of a given directed acyclic graph (DAG) with 𝑛 vertices and 𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105. The given graph is guaranteed to be acyclic.<br><strong>Output Format</strong>. Output any topological ordering of its vertices. (Many DAGs have more than just one topological ordering. You may output any of them.)</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>很直接的拓扑排序<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;used, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;order, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; toposort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; used(adj.size(), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(adj.size(),<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">          indegree[adj[i][j]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">          qu.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      order.push_back(curr);</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          indegree[v]--;</span><br><span class="line">          <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">              qu.push(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = toposort(adj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; order.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; order[i] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City"><a href="#3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City" class="headerlink" title="3. Advanced Problem: Checking Whether Any Intersection in a City"></a>3. Advanced Problem: Checking Whether Any Intersection in a City</h3><p><strong>Task</strong>. Compute the number of strongly connected components of a given directed graph with 𝑛 vertices and<br>𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 104, 0 ≤ 𝑚 ≤ 104.<br><strong>Output Format</strong>. Output the number of strongly connected components.</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>求有向图的连通分量，SCC算法。先用DFS遍历图，并且将图的节点保存到栈中，然后每次从栈中弹出一个元素，DFS遍历遍历逆向图即可，得到SCC分量。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,v,s,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(curr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs2(adj,v,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_strongly_connected_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseAdj(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit1(n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit2(n,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            reverseAdj[adj[i][j]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit1[i]) <span class="keyword">continue</span>;</span><br><span class="line">        visit1[i] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,i,post,visit1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!post.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = post.top();</span><br><span class="line">        post.pop();</span><br><span class="line">        <span class="keyword">if</span>(visit2[curr]) <span class="keyword">continue</span>;</span><br><span class="line">        visit2[curr] = <span class="literal">true</span>;</span><br><span class="line">        result++;</span><br><span class="line">        dfs2(reverseAdj,curr,visit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_strongly_connected_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week-3-Paths-in-Graphs"><a href="#week-3-Paths-in-Graphs" class="headerlink" title="week 3 Paths in Graphs"></a>week 3 Paths in Graphs</h2><p>dijistra求最短距离</p><h3 id="1-Problem-Computing-the-Minimum-Number-of-Flight-Segments"><a href="#1-Problem-Computing-the-Minimum-Number-of-Flight-Segments" class="headerlink" title="1. Problem: Computing the Minimum Number of Flight Segments"></a>1. Problem: Computing the Minimum Number of Flight Segments</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges and two vertices 𝑢 and 𝑣, compute the length of a shortest path between 𝑢 and 𝑣 (that is, the minimum number of edges in a path from 𝑢 to 𝑣).<br><strong>Input Format</strong>. A graph is given in the standard format. The next line contains two vertices 𝑢 and 𝑣.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105, 𝑢 ̸= 𝑣, 1 ≤ 𝑢, 𝑣 ≤ 𝑛.<br><strong>Output Format</strong>. Output the minimum number of edges in a path from 𝑢 to 𝑣, or −1 if there is no path.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历图，求最短路径。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  qu.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line">          <span class="keyword">if</span>(curr == t) <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit[v] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Checking-whether-a-Graph-is-Bipartite"><a href="#2-Problem-Checking-whether-a-Graph-is-Bipartite" class="headerlink" title="2. Problem: Checking whether a Graph is Bipartite"></a>2. Problem: Checking whether a Graph is Bipartite</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, check whether it is bipartite.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105.<br><strong>Output Format</strong>. Output 1 if the graph is bipartite and 0 otherwise.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历即可，非常简单，leetcode也有原题。<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WHITE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BLACK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  qu.push(make_pair(<span class="number">0</span>,WHITE));</span><br><span class="line">  visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  color[<span class="number">0</span>] = WHITE;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr.first])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit[v])&#123;</span><br><span class="line">              <span class="keyword">if</span>(color[curr.first] == color[v]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          qu.push(make_pair(v,!curr.second));</span><br><span class="line">          visit[v] = <span class="literal">true</span>;</span><br><span class="line">          color[v] = !curr.second;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bipartite(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Paths-in-Graphs"><a href="#week4-Paths-in-Graphs" class="headerlink" title="week4: Paths in Graphs"></a>week4: Paths in Graphs</h2><p>这章主要是dijistra算法和bellman ford算法</p><h3 id="Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="Problem: Detecting Anomalies in Currency Exchange Rates"></a>Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>直接用dijistra算法求最短距离即可<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code her</span></span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  qu.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[curr.first].size(); ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> v = adj[curr.first][i];</span><br><span class="line">          <span class="keyword">int</span> w = cost[curr.first][i];</span><br><span class="line">          <span class="keyword">if</span>((curr.second + w) &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = curr.second + w;</span><br><span class="line">              qu.push(make_pair(v,dist[v]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, cost, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="2. Problem: Detecting Anomalies in Currency Exchange Rates"></a>2. Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>求图中是否有和为负的有向环，直接BF算法。先进行<code>v-1</code>次循环对边进行叠加，再进行一次循环进行迭代，经过V次循环后，如果发现仍有边可以迭代，则认为此时该图中存在负的有向环。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">relax</span><span class="params">(Edge &amp; e,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negative_cycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;":"&lt;&lt;v&lt;&lt;" ="&lt;&lt;w&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; negative_cycle(adj, cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Advanced-Problem-Exchanging-Money-Optimally"><a href="#3-Advanced-Problem-Exchanging-Money-Optimally" class="headerlink" title="3. Advanced Problem: Exchanging Money Optimally"></a>3. Advanced Problem: Exchanging Money Optimally</h3><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges as well as its vertex 𝑠, compute the length of shortest paths from 𝑠 to all other vertices of the graph.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, 1 ≤ 𝑠 ≤ 𝑛, edge weights are integers of absolute value at most 109.<br><strong>Output Format</strong>. For all vertices 𝑖 from 1 to 𝑛 output the following on a separate line:<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目也比较简单，<code>bellman-ford</code>算法，先进行V次迭代后，将所有还可继续迭代的节点入队列，然后用BFS算法，将所有这些可迭代的点遍历，所有可以达到的点，都认为不存在最小值。<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortest_paths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;distance, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;reachable, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;shortest)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dist(n,INT_MAX);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">      <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">      <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">      <span class="comment">// get all relaxed node</span></span><br><span class="line">      <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : visit)&#123;</span><br><span class="line">        qu.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">            qu.push(v);</span><br><span class="line">            visit.insert(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check answer*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] == INT_MAX)&#123;</span><br><span class="line">            reachable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reachable[i] = <span class="number">1</span>;</span><br><span class="line">            distance[i] = dist[i];</span><br><span class="line">            <span class="keyword">if</span>(visit.count(i)) shortest[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  s--;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; distance(n, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;::max());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reachable(n, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortest(n, <span class="number">1</span>);</span><br><span class="line">  shortest_paths(adj, cost, s, distance, reachable, shortest);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reachable[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shortest[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="Problem-Building-Roads-to-Connect-Cities"><a href="#Problem-Building-Roads-to-Connect-Cities" class="headerlink" title="Problem: Building Roads to Connect Cities"></a>Problem: Building Roads to Connect Cities</h3><p><strong>Task</strong>. Given 𝑛 points on a plane, connect them with segments of minimum total length such that there is a<br>path between any two points. Recall that the length of a segment with endpoints (𝑥1, 𝑦1) and (𝑥2, 𝑦2)<br>is equal to<br>√︀<br>(𝑥1 − 𝑥2)2 + (𝑦1 − 𝑦2)2.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖).<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different, no three<br>points lie on the same line.<br><strong>Output Format</strong>. Output the minimum total length of segments. The absolute value of the difference<br>between the answer of your program and the optimal value should be at most 10−6. To ensure this,<br>output your answer with at least seven digits after the decimal point (otherwise your answer, while<br>being computed correctly, can turn out to be wrong because of rounding issues).</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>最小生成树，求最短距离。</li><li>重点考察对并查集的应用，<code>kruskal</code> 算法中常用的求最短距离。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> d)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">      <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">      <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">        x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimum_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> distance = [&amp;](<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[p1]-x[p2],<span class="number">2</span>) + <span class="built_in">pow</span>(y[p1]-y[p2],<span class="number">2</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          pq.push(Node(i,j,distance(i,j)));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(find(f,x) == find(f,y)) <span class="keyword">continue</span>;</span><br><span class="line">      uni(f,x,y);</span><br><span class="line">      result += curr.d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; minimum_distance(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p><strong>Task</strong>. Given 𝑛 points on a plane and an integer 𝑘, compute the largest possible value of 𝑑 such that the<br>given points can be partitioned into 𝑘 non-empty subsets in such a way that the distance between any<br>two points from different subsets is at least 𝑑.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖). The last line contains the number 𝑘 of clusters.<br><strong>Constraints</strong>. 2 ≤ 𝑘 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different.<br><strong>Output Format</strong>. Output the largest value of 𝑑. The absolute value of the difference between the answer of<br>your program and the optimal value should be at most 10−6. To ensure this, output your answer with<br>at least seven digits after the decimal point (otherwise your answer, while being computed correctly,<br>can turn out to be wrong because of rounding issues).</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>算法的变种，求最短距离时进行集合合并。</li><li>当合并的单元到达<code>k</code>时，求出最长满足要求的边即可。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Node(<span class="keyword">double</span> d,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;distance = d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=f[x]) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distance &gt; b.distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCluster</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.size(); ++i)&#123;</span><br><span class="line">        visit.insert(find(f,i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)visit.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">clustering</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="keyword">int</span> count = n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[i]-x[j],<span class="number">2</span>) + <span class="built_in">pow</span>(y[i]-y[j],<span class="number">2</span>));</span><br><span class="line">          pq.push(Node(d,i,j));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!pq.empty() &amp;&amp; count &gt;= k)&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line">      <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">          uni(f,x,y);</span><br><span class="line">          count--;   </span><br><span class="line">      &#125;</span><br><span class="line">      d = max(d,curr.distance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; clustering(x, y, k) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Graphs&quot;&gt;&lt;a href=&quot;#Algorithmic-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Graphs&quot;&gt;&lt;/a&gt;Algorithmic Graphs&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是比较容易的题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms on Graphs&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;br&gt;总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithms on Graphs》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithms-on-Graphs%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 181周比赛</title>
    <link href="http://yoursite.com/2020/05/10/159/"/>
    <id>http://yoursite.com/2020/05/10/159/</id>
    <published>2020-05-10T09:31:20.124Z</published>
    <updated>2020-05-10T09:31:26.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="181周比赛"><a href="#181周比赛" class="headerlink" title="181周比赛"></a>181周比赛</h1><p>周赛的题目质量果真非常高。</p><h2 id="5404-用栈操作构建数组"><a href="#5404-用栈操作构建数组" class="headerlink" title="5404. 用栈操作构建数组"></a>5404. 用栈操作构建数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个目标数组 <code>target</code>和一个整数 <code>n</code>。每次迭代，需要从  <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p><p>请使用下述操作来构建目标数组 <code>target</code> ：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Push：从 </span>list 中读取一个新元素， 并将其推入数组中。</span><br><span class="line"><span class="keyword">Pop：删除数组中的最后一个元素。</span></span><br><span class="line"><span class="keyword">如果目标数组构建完成，就停止读取更多元素。</span></span><br></pre></td></tr></table></figure><br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</p><a id="more"></a><p>请返回构建目标数组所用的操作序列。</p><p>题目数据保证答案是唯一的。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释： </span><br><span class="line">读取 <span class="number">1</span> 并自动推入数组 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">2</span> 并自动推入数组，然后删除它 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">3</span> 并自动推入数组 -&gt; [<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释：只需要读取前 <span class="number">2</span> 个数字就可以停止。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= target.length &lt;= 1001 &lt;= target[i] &lt;= 1001 &lt;= n &lt;= 100target 是严格递增的</code></pre><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-an-array-with-stack-operations</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前的最大值，如果发现当前的值小于序列的值，则进行”push”和“pop”双操作。</li><li>如果当前的值等于序列的值，则只进行<code>push</code>操作即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start == target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5405-形成两个异或相等数组的三元组数目"><a href="#5405-形成两个异或相等数组的三元组数目" class="headerlink" title="5405. 形成两个异或相等数组的三元组数目"></a>5405. 形成两个异或相等数组的三元组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>arr</code> 。</p><p>现需要从数组中取三个下标 <code>i、j</code>和 k ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p><p><code>a</code>和 <code>b</code>定义如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = arr[i]<span class="regexp"> ^</span> arr[i + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[j - <span class="number">1</span>]</span><br><span class="line">b = arr[j]<span class="regexp"> ^</span> arr[j + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[k]</span><br></pre></td></tr></table></figure><br>注意：^ 表示 按位异或 操作。</p><p>请返回能够令 <code>a == b</code> 成立的三元组<code>(i, j , k)</code> 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：满足题意的三元组分别是 (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) 以及 (<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">22</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>&lt;= arr.length &lt;= <span class="number">300</span></span><br><span class="line"><span class="symbol">1 </span>&lt;= arr[i] &lt;= <span class="number">10</span>^<span class="number">8</span></span><br></pre></td></tr></table></figure><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学运算</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们可以数学运算公式如下：<script type="math/tex; mode=display">xor(i,j) = arr[i]\bigoplus arr[i+1]\bigoplus arr[i+2]\bigoplus arr[i+3]\bigoplus arr[i+4]\bigoplus arr[i+5]\bigoplus... arr[j]\bigoplus</script>我们知道假如<script type="math/tex; mode=display">a \bigoplus b = 0</script>则一定是可以得到<strong>a == b</strong>.</li><li>实际过程中，我们可以按照如下将<code>xor(i,j) = 0</code>按照如下来分解：<script type="math/tex; mode=display">xor(i,j) = \left\{\begin{aligned}xor(i,i)\bigoplus xor(i+1,j) = 0 \\xor(i,i+1)\bigoplus xor(i+2,j)  = 0\\xor(i,i+2)\bigoplus xor(i+3,j)  = 0\\...                           \\xor(i,j-2)\bigoplus xor(j-1,j) = 0 \\xor(i,j-1)\bigoplus xor(j,j) = 0 \\\end{aligned}\right.</script>按照我们的推算则应该有如下等式成立：<script type="math/tex; mode=display">\left\{\begin{aligned}xor(i,i) ==  xor(i+1,j) \\xor(i,i+1) ==  xor(i+2,j) \\xor(i,i+2) ==  xor(i+3,j) \\...                           \\xor(i,j-2) == xor(j-1,j)  \\xor(i,j-1) == xor(j,j)  \\\end{aligned}\right.</script>因此总共有<code>j-i</code>种组合满足题目要求。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mask(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask[i+<span class="number">1</span>] = mask[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr = curr^arr[j];</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                    res += j - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5406-收集树上所有苹果的最少时间"><a href="#5406-收集树上所有苹果的最少时间" class="headerlink" title="5406. 收集树上所有苹果的最少时间"></a>5406. 收集树上所有苹果的最少时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p><p>无向树的边由<code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code>，表示有一条边连接 <code>from</code>和<code>toi</code>。除此以外，还有一个布尔数组 <code>hasApple</code>，其中 <code>hasApple[i] = true</code>代表节点<code>i</code>有一个苹果，否则，节点<code>i</code>没有苹果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">8</span> </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n-1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt;= n-1</code></li><li><code>fromi &lt; toi</code></li><li><code>hasApple.length == n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们知道每次从根节点下去取孩子节点的苹果时，都会有两步上下操作，因此我们每次判断发现本次的当前节点的孩子节点的子树有苹果存在时，则将路径+2.</li><li>采用DFS即可，我们每次返回子树是否有苹果，如果有苹果存在，则加2.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; apples,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hasapple = <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">if</span>(apples[curr]) hasapple = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(v,tree,apples,res))&#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                hasapple = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasapple;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            tree[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>,tree,hasApple,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5407-切披萨的方案数"><a href="#5407-切披萨的方案数" class="headerlink" title="5407. 切披萨的方案数"></a>5407. 切披萨的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>rows x cols</code>大小的矩形披萨和一个整数 k ，矩形包含两种字符：<code>&#39;A&#39;</code>（表示苹果）和 ‘.’ （表示空白格子）。你需要切披萨 <code>k-1</code>次，得到 <code>k</code> 块披萨并送给别人。</p><p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p><p>请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 <code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AAA"</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AA."</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"A.."</span>,<span class="string">"..."</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= rows, cols &lt;= <span class="number">50</span></span><br><span class="line">rows == pizza.length</span><br><span class="line">cols == pizza[i].length</span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= <span class="number">10</span></span><br><span class="line">pizza 只包含字符 <span class="string">'A'</span> 和 <span class="string">'.'</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设递推公式<code>dp[i][j][k]</code>代表从左上定点<code>(i,j)</code>与右下顶点<code>(m,n)</code>组成的矩形，切分<code>k</code>次的方案数，很容易想到递推公式:<script type="math/tex; mode=display">dp[x][y][k] = \left\{\begin{aligned}\sum_{i=x+1}^{m-1}dp[i][y][k-1] \qquad if(sum[x][y] - sum[i][y] > 0) \\\sum_{j=y+1}^{n-1}dp[x][j][k-1] \qquad if(sum[x][y] - sum[x][j] > 0) \\\end{aligned}\right.</script></li><li><code>sum</code>代表后缀和，<code>sum[i][j]</code>代表从<code>(i,j)</code>到<code>(m,n)</code>组成的矩形中苹果的总数目。<script type="math/tex; mode=display">sum[x][y] = \sum_{i=x}^{m}\sum_{j=y}^{n}matrix[i][j]</script><script type="math/tex; mode=display">sum[x][y] = sum[x][y+1] + sum[x+1][y] - sum[x+1][y+1] + matrix[x][y]</script>题目其实仔细分析下来挺简单的，就是写的时候稍微复杂点。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.size();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[M][M][k];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*prefix sum*/</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="keyword">sizeof</span>(dp),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum[i][j] = sum[i+<span class="number">1</span>][j] + sum[i][j+<span class="number">1</span>] - sum[i+<span class="number">1</span>][j+<span class="number">1</span>] + (pizza[i][j] == <span class="string">'A'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sum[i][j] &gt; <span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; k; ++s)&#123;</span><br><span class="line">                    <span class="comment">/*cut row*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = i+<span class="number">1</span>; t &lt; m; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[t][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[t][j][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*cut col*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = j+<span class="number">1</span>; t &lt; n; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[i][t] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[i][t][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;181周比赛&quot;&gt;&lt;a href=&quot;#181周比赛&quot; class=&quot;headerlink&quot; title=&quot;181周比赛&quot;&gt;&lt;/a&gt;181周比赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真非常高。&lt;/p&gt;&lt;h2 id=&quot;5404-用栈操作构建数组&quot;&gt;&lt;a href=&quot;#5404-用栈操作构建数组&quot; class=&quot;headerlink&quot; title=&quot;5404. 用栈操作构建数组&quot;&gt;&lt;/a&gt;5404. 用栈操作构建数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个目标数组 &lt;code&gt;target&lt;/code&gt;和一个整数 &lt;code&gt;n&lt;/code&gt;。每次迭代，需要从  &lt;code&gt;list = {1,2,3..., n}&lt;/code&gt; 中依序读取一个数字。&lt;/p&gt;&lt;p&gt;请使用下述操作来构建目标数组 &lt;code&gt;target&lt;/code&gt; ：&lt;br&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Push：从 &lt;/span&gt;list 中读取一个新元素， 并将其推入数组中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Pop：删除数组中的最后一个元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;如果目标数组构建完成，就停止读取更多元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 180周比赛</title>
    <link href="http://yoursite.com/2020/05/03/158/"/>
    <id>http://yoursite.com/2020/05/03/158/</id>
    <published>2020-05-03T06:16:42.499Z</published>
    <updated>2020-05-03T06:16:49.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="180周比赛"><a href="#180周比赛" class="headerlink" title="180周比赛"></a>180周比赛</h1><p>周赛的题目质量果真非常高。</p><h2 id="5384-拥有最多糖果的孩子"><a href="#5384-拥有最多糖果的孩子" class="headerlink" title="5384. 拥有最多糖果的孩子"></a>5384. 拥有最多糖果的孩子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code>表示，其中 <code>paths[i] = [cityAi, cityBi]</code>表示该线路将会从 <code>cityAi</code>直接前往 <code>cityBi</code>。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p><a id="more"></a><p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"London"</span>,<span class="string">"New York"</span>],[<span class="string">"New York"</span>,<span class="string">"Lima"</span>],[<span class="string">"Lima"</span>,<span class="string">"Sao Paulo"</span>]]</span><br><span class="line">输出：<span class="string">"Sao Paulo"</span> </span><br><span class="line">解释：从 <span class="string">"London"</span> 出发，最后抵达终点站 <span class="string">"Sao Paulo"</span> 。本次旅行的路线是 <span class="string">"London"</span> -&gt; <span class="string">"New York"</span> -&gt; <span class="string">"Lima"</span> -&gt; <span class="string">"Sao Paulo"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"B"</span>,<span class="string">"C"</span>],[<span class="string">"D"</span>,<span class="string">"B"</span>],[<span class="string">"C"</span>,<span class="string">"A"</span>]]</span><br><span class="line">输出：<span class="string">"A"</span></span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line"><span class="string">"D"</span> -&gt; <span class="string">"B"</span> -&gt; <span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"B"</span> -&gt; <span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"A"</span>. </span><br><span class="line">显然，旅行终点站是 <span class="string">"A"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"A"</span>,<span class="string">"Z"</span>]]</span><br><span class="line">输出：<span class="string">"Z"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= paths.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `paths[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= cityAi.length, cityBi.length &lt;= <span class="number">10</span>`</span><br><span class="line">+ `cityAi != cityBi`</span><br><span class="line">+ 所有字符串均由大小写英文字母和空格字符组成。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/destination-city</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  求入度</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 这个题目可以用BFS来解决，但是作为简单题目真心没必要。</span><br><span class="line"><span class="number">2.</span> 我们求出每个节点的入度和出度，求出入度大于<span class="number">0</span>且出度为<span class="number">0</span>的节点即为目标节点。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> destCity(vector&lt;vector&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="keyword">out</span>;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="keyword">in</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> s : paths)&#123;</span><br><span class="line">            <span class="keyword">out</span>[s[<span class="number">0</span>]]++;</span><br><span class="line">            <span class="keyword">in</span>[s[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> x : <span class="keyword">in</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">out</span>.count(x.first)) <span class="keyword">return</span> x.first;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5401-是否所有-1-都至少相隔-k-个元素"><a href="#5401-是否所有-1-都至少相隔-k-个元素" class="headerlink" title="5401. 是否所有 1 都至少相隔 k 个元素"></a>5401. 是否所有 1 都至少相隔 k 个元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；否则，返回 False 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：每个 <span class="number">1</span> 都至少相隔 <span class="number">2</span> 个元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：第二个 <span class="number">1</span> 和第三个 <span class="number">1</span> 之间只隔了 <span class="number">1</span> 个元素。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= k &lt;= nums.length`</span><br><span class="line">+ ` nums[i] `的值为 <span class="number">0</span> 或 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  水题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 把所有元素值为<span class="number">1</span>的索引求出来，然后查看相邻的元素是否间隔满足条件.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> kLengthApart(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                arr.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5402-绝对差不超过限制的最长连续子数组"><a href="#5402-绝对差不超过限制的最长连续子数组" class="headerlink" title="5402. 绝对差不超过限制的最长连续子数组"></a>5402. 绝对差不超过限制的最长连续子数组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p>如果不存在满足条件的子数组，则返回 0 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>], limit = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[<span class="number">8</span>] 最大绝对差 |<span class="number">8</span><span class="number">-8</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span> </span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>] 最大绝对差 |<span class="number">2</span><span class="number">-2</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">2</span><span class="number">-4</span>| = <span class="number">2</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">2</span><span class="number">-7</span>| = <span class="number">5</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>] 最大绝对差 |<span class="number">4</span><span class="number">-4</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">4</span><span class="number">-7</span>| = <span class="number">3</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">7</span>] 最大绝对差 |<span class="number">7</span><span class="number">-7</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span> </span><br><span class="line">因此，满足题意的最长子数组的长度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>], limit = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：满足题意的最长子数组是 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>]，其最大绝对差 |<span class="number">2</span><span class="number">-7</span>| = <span class="number">5</span> &lt;= <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>], limit = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= limit &lt;= 10^9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>保证当前窗口的最大值和最小值之差小于等于<code>limit</code>即可。</li><li>用multiset保存当前位置为终点的最长连续子序列，如果最大值与最小值之差小于等于<code>limit</code>，则该连续子序列肯定可以满足要求。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">        prev.insert(nums[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            prev.insert(nums[i]);</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; i &amp;&amp; <span class="built_in">abs</span>(*prev.rbegin()-*prev.begin()) &gt; limit)&#123;</span><br><span class="line">                prev.erase(nums[curr]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,(<span class="keyword">int</span>)prev.size());</span><br><span class="line">        &#125;</span><br><span class="line">                  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5403-有序矩阵中的第-k-个最小数组和"><a href="#5403-有序矩阵中的第-k-个最小数组和" class="headerlink" title="5403. 有序矩阵中的第 k 个最小数组和"></a>5403. 有序矩阵中的第 k 个最小数组和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p><p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第<code>k</code>个 最小 数组和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">3</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">6</span>]。其中第 <span class="number">5</span> 个的和是 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]], k = <span class="number">9</span></span><br><span class="line">输出：<span class="number">17</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]。其中第 <span class="number">7</span> 个的和是 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>]], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == mat.length</code></li><li><code>n == mat.length[i]</code></li><li><code>1 &lt;= m, n &lt;= 40</code></li><li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li><li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li><li><code>mat[i]</code> 是一个非递减数组</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  BFS + 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>想到这到题目需要用优先级队列，但是比赛时没有做出来。</li><li>就是BFS + 优先级队列，由于<code>k</code>的值不超过200，我们直接暴力搜索即可。每次将当前节点的所有后续节点入优先级队列中即可，优先级节点比较所有的列的和。</li><li>我们用每一行的列索引作为节点的状态，定义节点如下：<script type="math/tex; mode=display">curr = (cols[0],cols[1],...,cols[n-1])</script>比如有<code>4*m</code>的矩阵，最开始的节点为<script type="math/tex; mode=display">[0,0,0,0]</script>那么它的后续节点即下一个最小值的可能由列的索引构成,我们将后续的四个可能的节点全部入队列。<script type="math/tex; mode=display">[1,0,0,0] \quad [0,1,0,0] \quad [0,0,1,0] \quad [0,0,0,1]</script>每次从优先级队列中取出最小的值。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx(row,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; v)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i)&#123;</span><br><span class="line">                res += mat[i][v[i]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        pq.insert(&#123;get(idx),idx&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [val,v] = *pq.begin();</span><br><span class="line">            pq.erase(pq.begin());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                v[j]++;</span><br><span class="line">                <span class="keyword">if</span>(v[j] &lt; col)&#123;</span><br><span class="line">                    pq.insert(&#123;get(v),v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                v[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.begin()-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;180周比赛&quot;&gt;&lt;a href=&quot;#180周比赛&quot; class=&quot;headerlink&quot; title=&quot;180周比赛&quot;&gt;&lt;/a&gt;180周比赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真非常高。&lt;/p&gt;&lt;h2 id=&quot;5384-拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#5384-拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;5384. 拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;5384. 拥有最多糖果的孩子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一份旅游线路图，该线路图中的旅行线路用数组 &lt;code&gt;paths&lt;/code&gt;表示，其中 &lt;code&gt;paths[i] = [cityAi, cityBi]&lt;/code&gt;表示该线路将会从 &lt;code&gt;cityAi&lt;/code&gt;直接前往 &lt;code&gt;cityBi&lt;/code&gt;。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 25周双周比赛</title>
    <link href="http://yoursite.com/2020/05/03/157/"/>
    <id>http://yoursite.com/2020/05/03/157/</id>
    <published>2020-05-03T02:15:25.433Z</published>
    <updated>2020-05-03T02:15:30.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="25周比赛"><a href="#25周比赛" class="headerlink" title="25周比赛"></a>25周比赛</h1><p>双周赛的题目难度比周赛稍微差点</p><h2 id="5384-拥有最多糖果的孩子"><a href="#5384-拥有最多糖果的孩子" class="headerlink" title="5384. 拥有最多糖果的孩子"></a>5384. 拥有最多糖果的孩子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>candies</code>和一个整数 <code>extraCandies</code>，其中 <code>candies[i]</code> 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code>个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>], extraCandies = <span class="number">3</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>] </span><br><span class="line">解释：</span><br><span class="line">孩子 <span class="number">1</span> 有 <span class="number">2</span> 个糖果，如果他得到所有额外的糖果（<span class="number">3</span>个），那么他总共有 <span class="number">5</span> 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">2</span> 有 <span class="number">3</span> 个糖果，如果他得到至少 <span class="number">2</span> 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">3</span> 有 <span class="number">5</span> 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">4</span> 有 <span class="number">1</span> 个糖果，即使他得到所有额外的糖果，他也只有 <span class="number">4</span> 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 <span class="number">5</span> 有 <span class="number">3</span> 个糖果，如果他得到至少 <span class="number">2</span> 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], extraCandies = <span class="number">1</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>] </span><br><span class="line">解释：只有 <span class="number">1</span> 个额外糖果，所以不管额外糖果给谁，只有孩子 <span class="number">1</span> 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">12</span>,<span class="number">1</span>,<span class="number">12</span>], extraCandies = <span class="number">10</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= candies.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= candies[i] &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= extraCandies &lt;= <span class="number">50</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/kids-with-the-greatest-number-of-candies/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  暴力</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 首先找到数组中最大的数`maxval`，遍历数组每个元素，将该元素与`extra`相加比较与`maxval`的大小，如果比`maxval`小则返回`<span class="literal">false</span>`，否则为`<span class="literal">true</span>`.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">bool</span>&gt; kidsWithCandies(vector&lt;<span class="built_in">int</span>&gt;&amp; candies, <span class="built_in">int</span> extraCandies) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = candies.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; res(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">int</span> maxv = *max_element(candies.begin(),candies.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candies[i] + extraCandies &gt;= maxv)&#123;</span><br><span class="line">                res[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5385-改变一个整数能得到的最大差值"><a href="#5385-改变一个整数能得到的最大差值" class="headerlink" title="5385. 改变一个整数能得到的最大差值"></a>5385. 改变一个整数能得到的最大差值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 num 。你可以对它进行如下步骤恰好 两次 ：</p><p>选择一个数字 <code>x (0 &lt;= x &lt;= 9)</code>.<br>选择另一个数字<code>y (0 &lt;= y &lt;= 9)</code>。数字 <code>y</code>可以等于<code>x</code> 。<br>将 num 中所有出现 x 的数位都用 y 替换。<br>得到的新的整数 不能 有前导 0 ，得到的新整数也 不能 是 0 。<br>令两次对<code>num</code>的操作得到的结果分别为 <code>a</code>和 <code>b</code>。</p><p>请你返回 <code>a</code> 和<code>b</code>的 最大差值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">555</span></span><br><span class="line">输出：<span class="number">888</span></span><br><span class="line">解释：第一次选择 x = <span class="number">5</span> 且 y = <span class="number">9</span> ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x = <span class="number">5</span> 且 y = <span class="number">1</span> ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a = <span class="number">999</span> 和 b = <span class="number">111</span> ，最大差值为 <span class="number">888</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">9</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：第一次选择 x = <span class="number">9</span> 且 y = <span class="number">9</span> ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x = <span class="number">9</span> 且 y = <span class="number">1</span> ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a = <span class="number">9</span> 和 b = <span class="number">1</span> ，最大差值为 <span class="number">8</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">123456</span></span><br><span class="line">输出：<span class="number">820000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">10000</span></span><br><span class="line">输出：<span class="number">80000</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">9288</span></span><br><span class="line">输出：<span class="number">8700</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= num &lt;= <span class="number">10</span>^<span class="number">8</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/max-difference-you-can-get-from-changing-an-integer/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 所谓最大的数即将从左往右第一个小于**<span class="number">9</span>**的数字改为**<span class="number">9</span>**.</span><br><span class="line"><span class="number">2.</span> 所谓最小的数分为两种情况，如果最高位不为`<span class="number">1</span>`,将所有最高位相同的数字改为**<span class="number">1</span>**;如果最高位为`<span class="number">1</span>`,将从左往右第<span class="number">2</span>位开始第一个大于**<span class="number">1</span>**的数字改为**<span class="number">0</span>**.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minChange(<span class="built_in">int</span> num)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        char c;</span><br><span class="line">        <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt; <span class="string">'1'</span>)&#123;</span><br><span class="line">                last = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        c = s[last];</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'1'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxChange(<span class="built_in">int</span> num)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        char c;</span><br><span class="line">        <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                last = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        c = s[last];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'9'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDiff(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        cout&lt;&lt;maxChange(num)&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;minChange(num)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> maxChange(num) - minChange(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5386-检查一个字符串是否可以打破另一个字符串"><a href="#5386-检查一个字符串是否可以打破另一个字符串" class="headerlink" title="5386. 检查一个字符串是否可以打破另一个字符串"></a>5386. 检查一个字符串是否可以打破另一个字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串<code>s1</code> 和 <code>s2</code>，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，或者是否存在一个 s2 的排列可以打破 s1 的一个排列。</p><p>字符串 x 可以打破字符串 <code>y</code>（两者长度都为 <code>n</code> ）需满足对于所有 i（在 <code>0</code> 到 <code>n - 1</code> 之间）都有<code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"abc"</span>, <span class="built_in">s2</span> = <span class="string">"xya"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">"ayx"</span> 是 <span class="built_in">s2</span>=<span class="string">"xya"</span> 的一个排列，<span class="string">"abc"</span> 是字符串 <span class="built_in">s1</span>=<span class="string">"abc"</span> 的一个排列，且 <span class="string">"ayx"</span> 可以打破 <span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"abe"</span>, <span class="built_in">s2</span> = <span class="string">"acd"</span></span><br><span class="line">输出：false </span><br><span class="line">解释：<span class="built_in">s1</span>=<span class="string">"abe"</span> 的所有排列包括：<span class="string">"abe"</span>，<span class="string">"aeb"</span>，<span class="string">"bae"</span>，<span class="string">"bea"</span>，<span class="string">"eab"</span> 和 <span class="string">"eba"</span> ，<span class="built_in">s2</span>=<span class="string">"acd"</span> 的所有排列包括：<span class="string">"acd"</span>，<span class="string">"adc"</span>，<span class="string">"cad"</span>，<span class="string">"cda"</span>，<span class="string">"dac"</span> 和 <span class="string">"dca"</span>。然而没有任何 <span class="built_in">s1</span> 的排列可以打破 <span class="built_in">s2</span> 的排列。也没有 <span class="built_in">s2</span> 的排列能打破 <span class="built_in">s1</span> 的排列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"leetcodee"</span>, s2 = <span class="string">"interview"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `s1.length == n`</span><br><span class="line">+ `s2.length == n`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ 所有字符串都只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/check-if-a-string-can-break-another-string/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;  数学问题</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 我们将两个字符串按照字符大小排序。实际也为贪心法，如果字符串`s`存在严格意义上每一位字符都比字符串`t`的每一位都大，或者字符串`t`存在严格意义上每一位字符都比字符串`s`的每一位都大，则一定存在严格意义上的打破排序。</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> checkIfCanBreak(<span class="keyword">string</span> s1, <span class="keyword">string</span> s2) &#123;</span><br><span class="line">        sort(s1.begin(),s1.end());</span><br><span class="line">        sort(s2.begin(),s2.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> ret1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> ret2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &lt; s2[i]) ret1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &gt; s2[i]) ret2 = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret1||ret2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5387-每个人戴不同帽子的方案数"><a href="#5387-每个人戴不同帽子的方案数" class="headerlink" title="5387. 每个人戴不同帽子的方案数"></a>5387. 每个人戴不同帽子的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>总共有 <code>n</code> 个人和 <code>40</code>种不同的帽子，帽子编号从 1 到 40 。</p><p>给你一个整数列表的列表 <code>hats</code> ，其中 <code>hats[i]</code> 是第 i 个人所有喜欢帽子的列表。</p><p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p><p>由于答案可能很大，请返回它对 <code>10^9 + 7</code>取余后的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：给定条件下只有一种方法选择帽子。</span><br><span class="line">第一个人选择帽子 <span class="number">3</span>，第二个人选择帽子 <span class="number">4</span>，最后一个人选择帽子 <span class="number">5</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 种安排帽子的方法：</span><br><span class="line">(<span class="number">3</span>,<span class="number">5</span>)，(<span class="number">5</span>,<span class="number">3</span>)，(<span class="number">1</span>,<span class="number">3</span>) 和 (<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：每个人都可以从编号为 <span class="number">1</span> 到 <span class="number">4</span> 的帽子中选。</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="number">4</span> 个帽子的排列方案数为 <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>]]</span><br><span class="line">输出：<span class="number">111</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == hats.length</code></li><li><code>1 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= hats[i].length &lt;= 40</code></li><li><code>1 &lt;= hats[i][j] &lt;= 40</code></li><li><code>hats[i]</code> 包含一个数字互不相同的整数列表。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  状态压缩 + 动态规划</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>对于<code>leetcode</code>上的题目做多了的话，本题一看就知道要用状态压缩dp.本来我以为本题会出一个类似于最大二分图的题目，可以用最大流来解决。这种题目基本上已经非常常见了，这个题目在lc平台上已经出现了很多次。lc平台特别喜欢出这种状态压缩的dp。比如典型的：</li></ol><ul><li><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">1349. 参加考试的最大学生数</a></li><li><a href="https://leetcode-cn.com/problems/find-the-shortest-superstring/" target="_blank" rel="noopener">943. 最短超级串</a></li><li><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/" target="_blank" rel="noopener">1411. 给 N x 3 网格图涂色的方案数</a></li><li><a href="https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/" target="_blank" rel="noopener">864. 获取所有钥匙的最短路径</a></li></ul><ol><li>稍微复杂点，这次稍微迷惑的是状态定义。常规思路肯定是<code>n</code>个人选<code>m</code>种颜色,<code>m</code>种颜色的选择作为一个状态，但是这个题目给的数据是颜色的种类远大于人的数目，所以按照这种常规思路肯定会出现超时。反过来来看，我们也可以这样看待，<code>m</code>种颜色需要选择<code>n</code>个人进行分配，计算每个人都能分配到一种颜色的方案数目，这样实际等效过程是一样的。</li><li>我们设递推公式位<code>dp[i][state]</code>,代表前<code>i</code>个元素分为给<code>state</code>代表的位图的人数的方案数,我们可以知道当加入第<code>i+1</code>种颜色时，要么该颜色不分配给任何人，要么将该颜色分配给允许该颜色的人<code>p</code>,且前<code>i-1</code>种颜色未分配给<code>p</code>。<script type="math/tex; mode=display">dp[i][state] = dp[i-1][state] + \sum_{j = 1}^{n}dp[i-1][state-(1<<j)] \qquad if \quad valid[i][j] = true</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSet</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask|(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitClr</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask&amp;(~(<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hats.size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">41</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; valid(<span class="number">41</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hats[i].size(); ++j)&#123;</span><br><span class="line">                valid[hats[i][j]][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(bitTst(j,k)&amp;&amp;valid[i][k])&#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i<span class="number">-1</span>][bitClr(j,k)])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">40</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;25周比赛&quot;&gt;&lt;a href=&quot;#25周比赛&quot; class=&quot;headerlink&quot; title=&quot;25周比赛&quot;&gt;&lt;/a&gt;25周比赛&lt;/h1&gt;&lt;p&gt;双周赛的题目难度比周赛稍微差点&lt;/p&gt;&lt;h2 id=&quot;5384-拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#5384-拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;5384. 拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;5384. 拥有最多糖果的孩子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;candies&lt;/code&gt;和一个整数 &lt;code&gt;extraCandies&lt;/code&gt;，其中 &lt;code&gt;candies[i]&lt;/code&gt; 代表第 i 个孩子拥有的糖果数目。&lt;/p&gt;&lt;p&gt;对每一个孩子，检查是否存在一种方案，将额外的 &lt;code&gt;extraCandies&lt;/code&gt;个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程《Algorithmic Toolbox》</title>
    <link href="http://yoursite.com/2020/05/02/156/"/>
    <id>http://yoursite.com/2020/05/02/156/</id>
    <published>2020-05-02T10:23:04.359Z</published>
    <updated>2020-05-02T10:51:58.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Toolbox"><a href="#Algorithmic-Toolbox" class="headerlink" title="Algorithmic Toolbox"></a>Algorithmic Toolbox</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是基本题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST" target="_blank" rel="noopener">Algorithmic Toolbox</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Sum-of-Two-Digits"><a href="#1-Sum-of-Two-Digits" class="headerlink" title="1. Sum of Two Digits"></a>1. Sum of Two Digits</h3><p>We start from this ridiculously simple problem to show you the<br>pipeline of reading the problem statement, designing an algorithm, implementing<br>it, testing and debugging your program, and submitting it to<br>the grading system.<br>Input format. Integers a and b on the same line (separated by a space).<br>Output format. The sum of a and b.<br>Constraints. 0  a;b  9.<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample.</span><br><span class="line">Input:</span><br><span class="line"><span class="number">9</span> <span class="number">7</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> 直接相加</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>相加即可<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_of_two_digits</span><span class="params">(<span class="keyword">int</span> first_digit, <span class="keyword">int</span> second_digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first_digit + second_digit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum_of_two_digits(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Maximum-Pairwise-Product"><a href="#2-Maximum-Pairwise-Product" class="headerlink" title="2 Maximum Pairwise Product"></a>2 Maximum Pairwise Product</h3><p>Given a sequence of non-negative integers a1; : : : ;an, compute<br>max<br>1i,jn<br>ai  aj :<br>Note that i and j should be different, though it may be the case that ai = aj .<br>Input format. The first line contains an integer n. The next line contains<br>n non-negative integers a1; : : : ;an (separated by spaces).<br>Output format. The maximum pairwise product.<br>Constraints. 2  n  2  105; 0  a1; : : : ;an  2  105.</p><p>Sample 1.<br>Input:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><br>Output:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.找到二维数组中的最大的两个元素即可，返回他们的乘积，时间复杂度$O(n)$。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MaxPairwiseProduct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &gt; first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = numbers[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] &gt; second)&#123;</span><br><span class="line">            second = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first*second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; MaxPairwiseProduct(numbers) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="Fibonacci-Number"><a href="#Fibonacci-Number" class="headerlink" title="Fibonacci Number"></a>Fibonacci Number</h3><p>Given an integer 𝑛, find the 𝑛th Fibonacci number 𝐹𝑛.</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>非常简单了，找到第<code>n</code>个斐波那契数。<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following code calls a naive algorithm for computing a Fibonacci number.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// What to do:</span></span><br><span class="line"><span class="comment">// 1. Compile the following code and run it on an input "40" to check that it is slow.</span></span><br><span class="line"><span class="comment">//    You may also want to submit it to the grader to ensure that it gets the "time limit exceeded" message.</span></span><br><span class="line"><span class="comment">// 2. Implement the fibonacci_fast procedure.</span></span><br><span class="line"><span class="comment">// 3. Remove the line that prints the result of the naive algorithm, comment the lines reading the input,</span></span><br><span class="line"><span class="comment">//    uncomment the line with a call to test_solution, compile the program, and run it.</span></span><br><span class="line"><span class="comment">//    This will ensure that your efficient algorithm returns the same as the naive one for small values of n.</span></span><br><span class="line"><span class="comment">// 4. If test_solution() reveals a bug in your implementation, debug it, fix it, and repeat step 3.</span></span><br><span class="line"><span class="comment">// 5. Remove the call to test_solution, uncomment the line with a call to fibonacci_fast (and the lines reading the input),</span></span><br><span class="line"><span class="comment">//    and submit it to the grader.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fibonacci_naive(n - <span class="number">1</span>) + fibonacci_naive(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci_fast</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        f3 = f2 + f1;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(fibonacci_fast(<span class="number">3</span>) == <span class="number">2</span>);</span><br><span class="line">    assert(fibonacci_fast(<span class="number">10</span>) == <span class="number">55</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">20</span>; ++n)</span><br><span class="line">        assert(fibonacci_fast(n) == fibonacci_naive(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; fibonacci_naive(n) &lt;&lt; '\n';</span></span><br><span class="line">    <span class="comment">//test_solution();</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci_fast(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Last-Digit-of-a-Large-Fibonacci-Number"><a href="#2-Last-Digit-of-a-Large-Fibonacci-Number" class="headerlink" title="2 Last Digit of a Large Fibonacci Number"></a>2 Last Digit of a Large Fibonacci Number</h3><p>Your goal in this problem is to find the last digit of 𝑛-th Fibonacci number. Recall that Fibonacci numbers<br>grow exponentially fast. For example,<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝐹<span class="number">200</span> = <span class="number">280</span> <span class="number">571</span> <span class="number">172</span> <span class="number">992</span> <span class="number">510</span> <span class="number">140</span> <span class="number">037</span> <span class="number">611</span> <span class="number">932</span> <span class="number">413</span> <span class="number">038</span> <span class="number">677</span> <span class="number">189</span> <span class="number">525</span> .</span><br></pre></td></tr></table></figure></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>找到斐波那契数的个位数。</li><li>我们直接对每一位取模即可。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fibonacci_last_digit_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_previous = previous%<span class="number">10</span>;</span><br><span class="line">        previous = current%<span class="number">10</span>;</span><br><span class="line">        current = (tmp_previous + current)%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> c = get_fibonacci_last_digit_naive(n);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Greatest-Common-Divisor"><a href="#3-Greatest-Common-Divisor" class="headerlink" title="3 Greatest Common Divisor"></a>3 Greatest Common Divisor</h3>The greatest common divisor GCD(𝑎, 𝑏) of two non-negative integers 𝑎 and 𝑏<br>(which are not both equal to 0) is the greatest integer 𝑑 that divides both 𝑎 and 𝑏.<br>Your goal in this problem is to implement the Euclidean algorithm for computing<br>the greatest common divisor.<br>Efficient algorithm for computing the greatest common divisor is an important<br>basic primitive of commonly used cryptographic algorithms like RSA.</li></ol><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>牛顿法找到两个数的最大公约数即可。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_naive(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_naive(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd_naive(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Least-Common-Multiple"><a href="#4-Least-Common-Multiple" class="headerlink" title="4 Least Common Multiple"></a>4 Least Common Multiple</h3><p>Given two integers 𝑎 and 𝑏, find their least common multiple.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>找到两个数的最小公倍数。</li><li>先找两个数的最大公约数，然后乘以他们各自除以最大公约数的结果。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_fast</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_fast(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_fast(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">1</span>; l &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>) a * b; ++l)</span><br><span class="line">    <span class="keyword">if</span> (l % a == <span class="number">0</span> &amp;&amp; l % b == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_fast</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) (a * b)/gcd_fast(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(lcm_fast(<span class="number">6</span>,<span class="number">8</span>) == <span class="number">24</span>);</span><br><span class="line">    assert(lcm_fast(<span class="number">761457</span>,<span class="number">614573</span>) == <span class="number">467970912861</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  test_solution();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcm_fast(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Fibonacci-Number-Again"><a href="#5-Fibonacci-Number-Again" class="headerlink" title="5 Fibonacci Number Again"></a>5 Fibonacci Number Again</h3>In this problem, your goal is to compute 𝐹𝑛 modulo 𝑚, where 𝑛 may be really huge: up to 1014. For such<br>values of 𝑛, an algorithm looping for 𝑛 iterations will not fit into one second for sure. Therefore we need to<br>avoid such a loop.<br>To get an idea how to solve this problem without going through all 𝐹𝑖 for 𝑖 from 0 to 𝑛, let’s see what<br>happens when 𝑚 is small — say, 𝑚 = 2 or 𝑚 = 3.</li></ol><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>用数学方法可以证明斐波那契数列对某个自然数取模后的结果一定存在循环，数学证明方法比较复杂就不展开讲了，知道它肯定会循环，我们需要找到它的循环周期<code>T</code>,则后续处理就非常简单。</li><li>我们只需要找到连续的两个数取模后的结果分别为<code>0,1</code>这即为循环序列的开始，题目稍微有点复杂。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_pisano_period</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; (m*m); ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">        <span class="keyword">if</span>(previous == <span class="number">0</span> &amp;&amp; current == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_fibonacci_huge_naive</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> period = get_pisano_period(m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = n%period;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; mod<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_fibonacci_huge_naive(n, m) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers"><a href="#6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers" class="headerlink" title="6-8 Last Digit of the Sum of Fibonacci Numbers"></a>6-8 Last Digit of the Sum of Fibonacci Numbers</h3><p>The goal in this problem is to find the last digit of a sum of the first 𝑛 Fibonacci numbers.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>如果会解决第5题，后面的三道题目都非常简单，在这里就不贴详细的代码。</li><li>主要是利用斐波那契数列取模后的循环数列的技巧，分别求即可。</li></ol><h2 id="week-3-Greedy-Algorithms"><a href="#week-3-Greedy-Algorithms" class="headerlink" title="week 3 Greedy Algorithms"></a>week 3 Greedy Algorithms</h2><p>贪心算法也是非常常见和应用的算法，前1-5题非常简单。重点需要展开讲述一下6-7题。</p><h3 id="6-Maximum-Number-of-Prizes"><a href="#6-Maximum-Number-of-Prizes" class="headerlink" title="6 Maximum Number of Prizes"></a>6 Maximum Number of Prizes</h3><p>You are organizing a funny competition for children. As a prize fund you have 𝑛<br>candies. You would like to use these candies for top 𝑘 places in a competition<br>with a natural restriction that a higher place gets a larger number of candies.<br>To make as many children happy as possible, you are going to find the largest<br>value of 𝑘 for which it is possible.</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ol><li>我们从<code>1</code>开始顺序的加入自然数即可，直到加入第<code>i-1</code>个数后，剩余的元素应该大于等于<code>i</code>.<script type="math/tex; mode=display">i \le n - (i-1)*i/2</script></li><li>本质也是贪心算法<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; optimal_summands(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> rest = n - (i*(i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(rest &lt;= i)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)&#123;</span><br><span class="line">              summands.push_back(j);</span><br><span class="line">          &#125;</span><br><span class="line">          summands.push_back(n-(i<span class="number">-1</span>)*i/<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> summands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands = optimal_summands(n);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; summands.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Maximum-Salary"><a href="#7-Maximum-Salary" class="headerlink" title="7 Maximum Salary"></a>7 Maximum Salary</h3><strong>Task</strong>. Compose the largest number out of a set of integers.<br><strong>Input Format</strong>. The first line of the input contains an integer 𝑛. The second line contains integers<br>𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 100; 1 ≤ 𝑎𝑖 ≤ 103 for all 1 ≤ 𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. Output the largest number that can be composed out of 𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Sample 1</strong>.<br>Input:<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">21 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>Output:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">221</span></span><br></pre></td></tr></table></figure>Note that in this case the above algorithm also returns an incorrect answer <code>212</code>.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li><li>仔细看下似乎比较麻烦，但是实际上很简单，我们采取贪心的算法，将字典序组合最大的排在前面即可。我们将字符串按照<code>s1,s2</code>如下顺序进行排列：<script type="math/tex; mode=display">(s1 + s2) > (s2 + s1)</script></li><li>我们直接排序然后输出字符串即可，当然了这是<code>leetcode</code>上的原题。<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp; a,<span class="built_in">string</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = a + b;</span><br><span class="line">    <span class="built_in">string</span> s2 = b + a;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largest_number</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ret;</span><br><span class="line">  sort(a.begin(),a.end(),cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    ret &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  ret &gt;&gt; result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; largest_number(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Divide-and-Conquer"><a href="#week4-Divide-and-Conquer" class="headerlink" title="week4: Divide-and-Conquer"></a>week4: Divide-and-Conquer</h2><p>这一章主要是将分治法，主要涉及的内容有二分查找和归并排序的应用。非常非常重要的基础算法应用。题目稍微比较难。前2题比较简单，重点把后4题稍微思考一下。<br>分治法的核心思路也是递归。将一个大的<strong>task</strong>划分成为n个小的<strong>task</strong>即可。然后再对<code>n</code>个<strong>task</strong>进行归并调度即可。</p><h3 id="3-Improving-Quick-Sort"><a href="#3-Improving-Quick-Sort" class="headerlink" title="3 Improving Quick Sort"></a>3 Improving Quick Sort</h3><p>To force the given implementation of the quick sort algorithm to efficiently process sequences with<br>few unique elements, your goal is replace a 2-way partition with a 3-way partition. That is, your new<br>partition procedure should partition the array into three parts: &lt; 𝑥 part, = 𝑥 part, and &gt; 𝑥 part.</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>对快速排序的改进，实际也是所谓的<strong>3-way-partion</strong>，每次将数组划分为3部分，即小于<code>pivot</code>,等于<code>pivot</code>,大于<code>pivot</code>三部分，然后小于<code>pivot</code>和大于<code>pivot</code>的部分进行下一轮划分，等于<code>piovt</code>的保持不变即可。</li><li>这样总的划分效果较好，特别是较少了递归的次数，每次相等的部分位置就固定下来。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = a[l];</span><br><span class="line">  <span class="keyword">int</span> j = l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= x) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a[l], a[j]);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partition3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">int</span> k = l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; x) &#123;</span><br><span class="line">            swap(a[k],a[i]);</span><br><span class="line">            swap(a[k++],a[j++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == x)&#123;</span><br><span class="line">            swap(a[k++],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret.push_back(j);</span><br><span class="line">    ret.push_back(k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threeway_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partion = partition3(a, l, r);</span><br><span class="line">  threeway_quick_sort(a, l, partion[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">  threeway_quick_sort(a, partion[<span class="number">1</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomized_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="keyword">int</span> m = partition2(a, l, r);</span><br><span class="line"></span><br><span class="line">  randomized_quick_sort(a, l, m - <span class="number">1</span>);</span><br><span class="line">  randomized_quick_sort(a, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  threeway_quick_sort(a, <span class="number">0</span>, a.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Number-of-Inversions"><a href="#4-Number-of-Inversions" class="headerlink" title="4 Number of Inversions"></a>4 Number of Inversions</h3><p>An inversion of a sequence 𝑎0, 𝑎1, . . . , 𝑎𝑛−1 is a pair of indices 0 ≤ 𝑖 &lt; 𝑗 &lt; 𝑛 such that 𝑎𝑖 &gt; 𝑎𝑗 . The number of inversions of a sequence in some sense measures how close the sequence is to being sorted. For example, a sorted (in non-descending order) sequence contains no inversions at all, while in a sequence sorted in descending order any two elements constitute an inversion (for a total of 𝑛(𝑛 − 1)/2 inversions).The goal in this problem is to count the number of inversions of a given sequence.</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol><li>这个是<code>leetcode</code>上的原题，本质是归并排序。</li><li>每次我们将数组划分为前半部分后后半部分，并分别对前半部分进行归并排序，并同时判断两个部分的逆序对。</li><li>每次进行归并时，计算前半部分的元素大于后半部分的数的有多少个，然其所有大于的数组之和相加即可。</li><li>我们刚好利用归并时即可，将两个有序的数组进行归并，所以这次归并时在<code>O(n)</code>时间复杂度内完成本次逆序对的计算和排序。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_number_of_inversions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="keyword">size_t</span> left, <span class="keyword">size_t</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> number_of_inversions = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (right &lt;= left + <span class="number">1</span>) <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">  <span class="keyword">size_t</span> ave = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, left, ave);</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, ave, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> l = left;</span><br><span class="line">  <span class="keyword">int</span> r = ave;</span><br><span class="line">  <span class="keyword">int</span> curr = left;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; ave || r &lt; right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave &amp;&amp; r &lt; right)&#123;</span><br><span class="line">          <span class="keyword">if</span>(a[r] &lt; a[l])&#123;</span><br><span class="line">              number_of_inversions += ave - l;</span><br><span class="line">              b[curr++] = a[r++];</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              b[curr++] = a[l++];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave) b[curr++] = a[l++];</span><br><span class="line">      <span class="keyword">if</span>(r &lt; right) b[curr++] = a[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.size());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_number_of_inversions(a, b, <span class="number">0</span>, a.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Organizing-a-Lottery"><a href="#5-Organizing-a-Lottery" class="headerlink" title="5 Organizing a Lottery"></a>5 Organizing a Lottery</h3>You are organizing an online lottery. To participate, a person bets on a single integer. You then draw several ranges of consecutive integers at random.A participant’s payoff then is proportional to the number of ranges that<br>contain the participant’s number minus the number of ranges that does not contain it. You need an efficient algorithm for computing the payoffs for all participants. A naive way to do this is to simply scan, for all participants, the<br>list of all ranges. However, you lottery is very popular: you have thousands of participants and thousands of ranges. For this reason, you cannot afford a slow naive algorithm.<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目非常好，质量很高。其实拿到这个题目我一开始想到的就是<code>segmentTree</code>，结果就是超时了。</li><li>后来思考了好长时间没有想到更简单的做法。然后去论坛找了提示，发现这个解法非常非常的巧妙。</li><li>我们对所有的元素进行标记，我们可以想像把线段的左端点标记为左括号<code>(</code>,线段的右端点标记为右括号<code>(</code>,需要查找的点标记为<code>p</code>,我们实际上就是判断点p能否被几个完成的左右括号同时覆盖<code>()</code>.</li><li>记住上面的关键点的思考。实际我们可能还有许多细节要思考，比如这种线段<code>s:(x,x)</code>,点p为<code>x</code>,则这时点<code>p</code>应该是被线段<code>s</code>包围的,这点所谓的包含思维需要仔细的思考。我们将线段的左端点标记为<code>l</code>，线段的右端点标记为<code>r</code>，将point标记为<code>p</code>，然后将左端点和右端点加在一起排序。我们判断时，每次遇到左括号则进行计数加<code>1</code>,遇到右括号，则将计数减<code>1</code>,到达当前点<code>p</code>时的计数大小即为所有包含点<code>p</code>的线段数。</li><li>另一种方法可能更快一点，我们直接利用二分查找。对于当前点<code>p:x</code>,我们查找有多少个大于<code>x</code>的左端点，个数即为<code>lx</code>,同时查找大于等于<code>x</code>的右端点的个数为<code>rx</code>.包含点<code>p</code>的线段数为<code>rx-lx</code>.<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; fast_count_segments(vector&lt;int&gt; starts, vector&lt;int&gt; ends, vector&lt;int&gt; points) &#123;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; cnt(points.size());</span></span><br><span class="line"><span class="comment">    int n = starts.size();</span></span><br><span class="line"><span class="comment">    int m = points.size();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sort(starts.begin(),starts.end());</span></span><br><span class="line"><span class="comment">    sort(ends.begin(),ends.end());</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; m; ++i)&#123;</span></span><br><span class="line"><span class="comment">        auto it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span></span><br><span class="line"><span class="comment">        auto it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span></span><br><span class="line"><span class="comment">        int x = it1 - starts.begin();</span></span><br><span class="line"><span class="comment">        int y = it2 - ends.begin();</span></span><br><span class="line"><span class="comment">        cnt[i] = x - y;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return cnt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fast_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">    <span class="keyword">int</span> n = starts.size();</span><br><span class="line">    <span class="keyword">int</span> m = points.size();</span><br><span class="line"></span><br><span class="line">    sort(starts.begin(),starts.end());</span><br><span class="line">    sort(ends.begin(),ends.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span><br><span class="line">        <span class="keyword">int</span> x = it1 - starts.begin();</span><br><span class="line">        <span class="keyword">int</span> y = it2 - ends.begin();</span><br><span class="line">        cnt[i] = x - y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; naive_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; starts.size(); j++) &#123;</span><br><span class="line">      cnt[i] += starts[j] &lt;= points[i] &amp;&amp; points[i] &lt;= ends[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts(n), ends(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; starts.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; starts[i] &gt;&gt; ends[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; points[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//use fast_count_segments</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt = fast_count_segments(starts, ends, points);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Closest-Points"><a href="#6-Closest-Points" class="headerlink" title="6 Closest Points"></a>6 Closest Points</h3><p>In this problem, your goal is to find the closest pair of points among the given 𝑛<br>points. This is a basic primitive in computational geometry having applications in,<br>for example, graphics, computer vision, traffic-control systems.</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol><li>题目中的要求求出一堆点的集合中距离最短的两个点的距离。这个题目我按照提示的要求做出来了，但是至今为止还没搞懂原理。</li><li>将点的集合按照横坐标<code>x</code>的大小进行排序，然后将集合按照横坐标的大小划分为左右两部分。递归求出左半部分的最小距离<code>dl</code>,右半部分的最小距离<code>dr</code>.</li><li>令<code>d = min(dl,dr)</code>,令<code>mid = p[(l+r)/2]</code>,求出所有距离线段<code>x = mid</code>的距离小于等于<code>d</code>的点。</li><li>将上述求得所有的点按照纵坐标<code>y</code>的大小进行排序，每次求出连续相邻<code>8</code>个点的最小距离为<code>d&#39;</code>，令<code>d = min(d,d&#39;)</code>,返回<code>d</code>即可。</li><li>代码本身比较简单，但是这个方法确实不容易想到。<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">  Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpX</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpY</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp; arr, <span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> DBL_MAX;</span><br><span class="line">    <span class="keyword">if</span>(r - l == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[l].x-arr[l+<span class="number">1</span>].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[l].y - arr[l+<span class="number">1</span>].y,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sort(arr.begin()+l,arr.begin()+r,cmpX);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> dl = helper(arr,l,mid);</span><br><span class="line">    <span class="keyword">double</span> dr = helper(arr,mid,r);</span><br><span class="line">    <span class="keyword">double</span> d = min(dl,dr);</span><br><span class="line">    <span class="keyword">int</span> ml = l;</span><br><span class="line">    <span class="keyword">int</span> mr = r<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ml &lt; r &amp;&amp; <span class="built_in">abs</span>(arr[ml].x - arr[mid].x) &gt; d) ml++;</span><br><span class="line">    <span class="keyword">while</span>(mr &gt;= l &amp;&amp; <span class="built_in">abs</span>(arr[mr].x - arr[mid].x) &gt; d) mr--;</span><br><span class="line">    sort(arr.begin() + ml,arr.begin() + mr + <span class="number">1</span>,cmpY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mr ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= mr &amp;&amp; j &lt;= i + <span class="number">7</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">double</span> dy = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[i].x-arr[j].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[i].y-arr[j].y,<span class="number">2</span>));</span><br><span class="line">            d = min(d,dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimal_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">    arr.push_back(Point(x[i],y[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> helper(arr,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; minimal_distance(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="5-Longest-Common-Subsequence-of-Three-Sequences"><a href="#5-Longest-Common-Subsequence-of-Three-Sequences" class="headerlink" title="5 Longest Common Subsequence of Three Sequences"></a>5 Longest Common Subsequence of Three Sequences</h3><p>Compute the length of a longest common subsequence of three sequences.</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ol><li>题目是求出三个字符串的最长公共子序列，稍微复杂点。</li><li>本题中有三个字符串<code>a,b,c</code>,我们设递推公式<code>dp[x][y][z]</code>为字符串<code>a</code>的到索引<code>x</code>处，字符串<code>b</code>的到索引<code>y</code>处，字符串<code>c</code>的到索引<code>z</code>处的最长公共子序列数目。</li><li>递推公式如下：<br>如果当<code>a[x] = b[y]</code>且<code>b[y] = c[z]</code>时：<script type="math/tex; mode=display">dp[x][y][z] = dp[x-1][y-1][z-1] \qquad if(a[x] = b[y] = c[z])</script>否则：<script type="math/tex; mode=display">dp[x][y][z] = min\left\{\begin{aligned}dp[x-1][y][z] \\dp[x][y-1][z] \\dp[x][y][z-1] \\\end{aligned}\right.</script></li><li>根据以上的递推公式即可。<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.size();</span><br><span class="line">    <span class="keyword">int</span> n = b.size();</span><br><span class="line">    <span class="keyword">int</span> l = c.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= l; ++k)&#123;</span><br><span class="line">              <span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>] &amp;&amp; b[j<span class="number">-1</span>] == c[k<span class="number">-1</span>])&#123;</span><br><span class="line">                  dp[i][j][k] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i<span class="number">-1</span>][j][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j<span class="number">-1</span>][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n][l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> an;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; an;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(an);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; an; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> bn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; bn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(bn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; bn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> cn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(cn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcs3(a, b, c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-Dynamic-Programming-2"><a href="#6-Dynamic-Programming-2" class="headerlink" title="6:Dynamic Programming 2"></a>6:Dynamic Programming 2</h2><p>最后两道题目稍微有点难度，别的都还好，也是<code>dp</code>的重要应用。<code>dp</code>的思想，最关键的是递推关系的确立。递推关系一般不好思考，这点需要经验。不过一般都是跟元素的大小有关系。</p><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p>You and two of your friends have just returned back home after visiting various countries. Now you would<br>like to evenly split all the souvenirs that all three of you bought.</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ol><li>这个也是动态规划，我们需要找到递推关系还是需要花费一定时间思考的。</li><li>首先思考一下数组本身，如果整个数组的和<code>sum</code>不能被3整除，那么该数组肯定不能划分成为相等的3个非重复的子序列。最终划分为3个子序列，每个子序列的和为$\frac{sum}{3}$.</li><li>我们思考一下，设动态规划递推公式<code>dp[i][x][y]</code>表示前<code>i</code>个元素能否被划分成为3个子序列，其中有两个字序列的和为<code>x,y</code>.实际这三个子序列的和应该分别为：<code>x,y,sum[i]-x-y</code>,则当我们加入第<code>i+1</code>个元素时，第<code>i+1</code>个元素可以分别加入到这三个不同的子序列，我们判断当其加入到这三个不同的子序列中时，等式是否成立.我们设立递推公式为如下：<script type="math/tex; mode=display">dp[i][x][y] = dp[i-1][x][y] \quad or \quad dp[i-1][x-arr[i]][y] \quad or \quad dp[i-1][x][y-arr[i]]</script></li><li>实际我们可以将题目本身的问题转化为n个元素划分为三个子序列，是否有其中两个子序列的和分别为$\frac{sum}{3}$.即<code>dp[n][sum/3][sum/3]</code>是否为成立。<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">        all += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(all%<span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    div = all/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*intiail*/</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= div; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= div; ++k)&#123;</span><br><span class="line">                dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]][k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k-A[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][div][div];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; partition3(A) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Maximum-Value-of-an-Arithmetic-Expression"><a href="#3-Maximum-Value-of-an-Arithmetic-Expression" class="headerlink" title="3 Maximum Value of an Arithmetic Expression"></a>3 Maximum Value of an Arithmetic Expression</h3><p>Find the maximum value of an arithmetic expression by specifying the order of applying its arithmetic<br>operations using additional parentheses.<br>In this problem, your goal is to add parentheses to a given arithmetic<br>expression to maximize its value. max(5−8+7×4−8+9) =?</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目非常类似于括号匹配的最大值，跟<code>leetcode</code>某个题目非常相似。</li><li>题目中由于加入了加法、减法、乘法，实际情况稍微复杂一些。我们首先设立<code>dpmax[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最大值,<code>dpmin[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最小值.我们仔细判断一下，分为以下三种情况,<code>l</code>代表符号左边的值，<code>r</code>代表符号右边的值：</li></ol><ul><li><code>+</code>：当符号为加号时我们肯定希望等式表示左右两边的加数最大。<script type="math/tex; mode=display">max(result) = max(l) + max(r) \qquad min(result) = min(l) + min(r)</script></li><li><code>-</code>：当符号为减号号时我们肯定希望等式表示左边的数最大，右边的数。<script type="math/tex; mode=display">max(result) = max(l) - min(r) \qquadmin(result) = min(l) - max(r)</script></li><li><code>*</code>：当符号为乘号时，情况比较复杂，因为涉及到乘积的符号的问题，但是<script type="math/tex; mode=display">max(result) = max\left\{\begin{aligned}max(l)*max(r)\\min(l)*max(r)\\    max(l)*min(r)\\min(l)*min(r)\\  \end{aligned}\right.</script><script type="math/tex; mode=display">min(result) = min\left\{\begin{aligned}max(l)*max(r)\\min(l)*max(r)\\    max(l)*min(r)\\min(l)*min(r)\\  \end{aligned}\right.</script></li></ul><ol><li>我们接下来我们需要仔细处理等式划分的问题，因为这涉及到括号的问题。<code>dp[i][j]</code>代表从<code>i</code>到<code>j</code>的表达式，我们可以从<code>i+1</code>,<code>i+2</code>,<code>i+3</code>,…,<code>j-1</code>处进行断开。</li><li>我们可以看到如下：</li></ol><script type="math/tex; mode=display">dpmax[i][j]  =  max\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned} \right. \qquad  (i \le k \le j)</script><script type="math/tex; mode=display">dpmin[i][j] = min\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\ eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned}\right. \qquad  (i \le k \le j)</script><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">eval</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="string">'*'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'+'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">'+'</span>|| c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_maximum_value</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n = (<span class="built_in">exp</span>.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp1(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MAX));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp2(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MIN));</span><br><span class="line">  <span class="comment">/*intial*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isDigit(<span class="built_in">exp</span>[i])) nums.push_back(<span class="built_in">exp</span>[i] - <span class="string">'0'</span>);</span><br><span class="line">      <span class="keyword">if</span>(isOp(<span class="built_in">exp</span>[i])) op.push_back(<span class="built_in">exp</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    dp1[i][i] = nums[i];</span><br><span class="line">    dp2[i][i] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt;= j+i; ++k)&#123;</span><br><span class="line">              <span class="comment">/*min expression*/</span></span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*max expression*/</span></span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp2[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_maximum_value(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Toolbox&quot;&gt;&lt;a href=&quot;#Algorithmic-Toolbox&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Toolbox&quot;&gt;&lt;/a&gt;Algorithmic Toolbox&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是基本题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithmic Toolbox
&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithmic Toolbox》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithmic-Toolbox%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第186周比赛</title>
    <link href="http://yoursite.com/2020/04/26/155/"/>
    <id>http://yoursite.com/2020/04/26/155/</id>
    <published>2020-04-26T09:15:42.260Z</published>
    <updated>2020-04-26T09:15:44.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="186周比赛"><a href="#186周比赛" class="headerlink" title="186周比赛"></a>186周比赛</h1><p>本周题目的质量不错。</p><h2 id="5392-分割字符串的最大得分"><a href="#5392-分割字符串的最大得分" class="headerlink" title="5392. 分割字符串的最大得分"></a>5392. 分割字符串的最大得分</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由若干 <code>0</code> 和<code>1</code> 组成的字符串 <code>s</code>，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"011101"</span></span><br><span class="line">输出：<span class="number">5</span> </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 = <span class="string">"0"</span> 且 右子字符串 = <span class="string">"11101"</span>，得分 = <span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span> </span><br><span class="line">左子字符串 = <span class="string">"01"</span> 且 右子字符串 = <span class="string">"1101"</span>，得分 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> </span><br><span class="line">左子字符串 = <span class="string">"011"</span> 且 右子字符串 = <span class="string">"101"</span>，得分 = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> </span><br><span class="line">左子字符串 = <span class="string">"0111"</span> 且 右子字符串 = <span class="string">"01"</span>，得分 = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> </span><br><span class="line">左子字符串 = <span class="string">"01110"</span> 且 右子字符串 = <span class="string">"1"</span>，得分 = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00111"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：当 左子字符串 = <span class="string">"00"</span> 且 右子字符串 = <span class="string">"111"</span> 时，我们得到最大得分 = <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身数据量非常小，我们实际只需暴力匹配即可。非常简单<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCurr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) one++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) zero++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) oneCurr++;</span><br><span class="line">            res = max(res,zero + one - oneCurr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5393-可获得的最大点数"><a href="#5393-可获得的最大点数" class="headerlink" title="5393. 可获得的最大点数"></a>5393. 可获得的最大点数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code>给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组<code>cardPoints</code> 和整数<code>k</code>，请你返回可以获得的最大点数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="number">1</span> + <span class="number">6</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">55</span></span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">1000</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="number">1</span> 。</span><br><span class="line">``` </span><br><span class="line">示例 <span class="number">5</span>：</span><br></pre></td></tr></table></figure><br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints.length &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints[i] &lt;= <span class="number">10</span>^<span class="number">4</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= k &lt;= cardPoints.length`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 数组的前缀和后缀组合，前`i`个前缀和后`k-i`个后缀之和的最大值。</span><br><span class="line">$$</span><br><span class="line">f = max(prefix[i] + suffix[k-i])  \: i \<span class="keyword">in</span>(<span class="number">0</span>,...,k)</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 另一种思路，求滑动窗口，求出剩余的连续`n-k`个元素的最小值，总数减去这个值即可。</span><br><span class="line">$$</span><br><span class="line">f = \sum_&#123;i=<span class="number">1</span>&#125;^&#123;n&#125; p[i] - min(sum(i,i+n-k<span class="number">-1</span>))  \: i \<span class="keyword">in</span>(<span class="number">1</span>,...,k)</span><br><span class="line">$$</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxScore(vector&lt;<span class="built_in">int</span>&gt;&amp; cardPoints, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = cardPoints.size();</span><br><span class="line">        <span class="built_in">int</span> m = n-k;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> remove = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += cardPoints[i];</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m<span class="number">-1</span> &amp;&amp; m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                remove = min(curr,remove);</span><br><span class="line">                curr -= cardPoints[i-m+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(remove == INT_MAX) remove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum - remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5394-对角线遍历-II"><a href="#5394-对角线遍历-II" class="headerlink" title="5394. 对角线遍历 II"></a>5394. 对角线遍历 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个列表 <code>nums</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i].length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i][j] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">nums 中最多有 <span class="number">10</span>^<span class="number">5</span> 个数字。</span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diagonal-traverse-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是蛮有意思。首先对角线打印其实很简单，但是时间复杂度的话 会超时。</li><li>我们应该找规律，想更快的办法，后来仔细分析一下，我们可以对每个元素的下标进行排序，按照<code>rowindex</code>和<code>colindex</code>的和的大小进行顺序排序，如果和相等，再按照<code>rowindex</code>从大到小排序。</li><li>根据索引的排序结果输入所有元素。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sa = a.first + a.second;</span><br><span class="line">        <span class="keyword">int</span> sb = b.first + b.second;</span><br><span class="line">        <span class="keyword">if</span>(sa == sb) <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        <span class="keyword">return</span> sa &lt; sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums[n<span class="number">-1</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); ++j)&#123;</span><br><span class="line">                idx.push_back(make_pair(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(idx.begin(),idx.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx.size(); ++i)&#123;</span><br><span class="line">            res.push_back(nums[idx[i].first][idx[i].second]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5180-带限制的子序列和"><a href="#5180-带限制的子序列和" class="headerlink" title="5180. 带限制的子序列和"></a>5180. 带限制的子序列和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 <code>nums[i]</code> 和 <code>nums[j]</code>，它们在原数组中的下标 i 和 j 满足<code>i &lt; j</code>且 <code>j - i &lt;= k</code>。</p><p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">37</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">-2</span>,<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">-2</span>, <span class="number">-5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/constrained-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/constrained-subset-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本题基本一眼看到就是动态规划。</li><li>仔细思考一下我们设<code>dp[i]</code>为前<code>i</code>个元素的最大子序列和且包含第<code>i</code>个元素。</li><li>按照常规思路<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[0],dp[1],dp[2],...,dp[i-1])+nums[i]);</script></li><li>但是本题中限制了两个元素之间的相隔不超过<code>k</code>则上述递推公式应该变为：<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[i-k],dp[i-k+1],dp[i-k+2],...,dp[i-1])+nums[i]);</script></li><li>我们用滑动窗口即可，我们利用优先级队列，保留前<code>k</code>元素的最大子序列，每次取前<code>k</code>个元素的最大子序列和的最大值。如果队列的元素个数大于<code>k</code>则去掉队首的元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        prev.insert(dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = max(nums[i],*prev.rbegin() + nums[i]);</span><br><span class="line">            prev.insert(dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) prev.erase(dp[i-k]);</span><br><span class="line">            res = max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;186周比赛&quot;&gt;&lt;a href=&quot;#186周比赛&quot; class=&quot;headerlink&quot; title=&quot;186周比赛&quot;&gt;&lt;/a&gt;186周比赛&lt;/h1&gt;&lt;p&gt;本周题目的质量不错。&lt;/p&gt;&lt;h2 id=&quot;5392-分割字符串的最大得分&quot;&gt;&lt;a href=&quot;#5392-分割字符串的最大得分&quot; class=&quot;headerlink&quot; title=&quot;5392. 分割字符串的最大得分&quot;&gt;&lt;/a&gt;5392. 分割字符串的最大得分&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由若干 &lt;code&gt;0&lt;/code&gt; 和&lt;code&gt;1&lt;/code&gt; 组成的字符串 &lt;code&gt;s&lt;/code&gt;，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCP2020</title>
    <link href="http://yoursite.com/2020/04/20/154/"/>
    <id>http://yoursite.com/2020/04/20/154/</id>
    <published>2020-04-20T15:00:58.392Z</published>
    <updated>2020-04-22T09:39:59.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCP2020"><a href="#LCP2020" class="headerlink" title="LCP2020"></a>LCP2020</h1><p>还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。</p><h2 id="LCP-06-拿硬币"><a href="#LCP-06-拿硬币" class="headerlink" title="LCP 06. 拿硬币"></a>LCP 06. 拿硬币</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>桌上有 <code>n</code>堆力扣币，每堆的数量保存在数组 <code>coins</code>中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 <span class="number">2</span> 次，第二堆最少需要拿 <span class="number">1</span> 次，第三堆最少需要拿 <span class="number">1</span> 次，总共 <span class="number">4</span> 次即可拿完。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><br>限制：</p><a id="more"></a><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/na-ying-bi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/na-ying-bi</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单题目直接计算即可。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            res += (c+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a>LCP 07. 传递信息</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小朋友 <code>A</code> 在和<code>ta</code>的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比3. A 可以向 B 传信息，但 B 不能向 A 传信息）。<br> 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 n，以及按 <code>[玩家编号,对应可传递玩家编号]</code>关系组成的二维数组 <code>relation</code>。返回信息从小<code>A</code>(编号 0 ) 经过 <code>k</code>轮传递到编号为<code>n-1</code> 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>]], k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：信息从小 A 编号 <span class="number">0</span> 处开始，经 <span class="number">3</span> 轮传递，到达编号 <span class="number">4</span>。共有 <span class="number">3</span> 种方案，分别是 <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：信息不能从小 A 处经过 <span class="number">2</span> 轮传递到编号 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chuan-di-xin-xi</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><code>dp[i][j]</code>代表从经过<code>i</code>轮传递到<code>j</code>的方案数。<script type="math/tex; mode=display">dp[i][j] = \sum_{v = 1}^{n}dp[i-1][v] \:\:  if(edge[v][j] == true)</script></li><li>非常简单的<code>dp</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : relation)&#123;</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][v] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] += dp[i<span class="number">-1</span>][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[k][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-08-剧情触发时间"><a href="#LCP-08-剧情触发时间" class="headerlink" title="LCP 08. 剧情触发时间"></a>LCP 08. 剧情触发时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 <code>increase</code>来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如<code>[[1,2,1],[3,4,2]]</code>表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。</p><p>所有剧情的触发条件也用一个二维数组<code>requirements</code>表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code>且 <code>H &gt;= h[i]</code>，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]] requirements = [[<span class="number">2</span>,<span class="number">11</span>,<span class="number">3</span>],[<span class="number">15</span>,<span class="number">10</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>],[<span class="number">8</span>,<span class="number">1</span>,<span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">初始时，C = <span class="number">0</span>，R = <span class="number">0</span>，H = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 天，C = <span class="number">2</span>，R = <span class="number">8</span>，H = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">2</span> 天，C = <span class="number">4</span>，R = <span class="number">13</span>，H = <span class="number">4</span>，此时触发剧情 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">3</span> 天，C = <span class="number">14</span>，R = <span class="number">22</span>，H = <span class="number">12</span>，此时触发剧情 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">剧情 <span class="number">1</span> 和 <span class="number">3</span> 无法触发。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>]] requirements = [[<span class="number">12</span>,<span class="number">11</span>,<span class="number">16</span>],[<span class="number">20</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">10</span>,<span class="number">18</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">14</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = <span class="string">[[1,1,1]]</span> requirements = <span class="string">[[0,0,0]]</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>限制：`</p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常典型的二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找，当时竟然很麻烦的用的线段树完成该题的解答。</li><li>我们把所有天数的属性值全部叠加起来组成数组，然后利用二分查找的特性查找满足剧情要求的最小的天数。</li><li>关于二分查找算法，自己掌握的还是不够好，经常对于边界条件处理的不好。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getTriggerTime(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; increase, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requirements) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = increase.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; days;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        days.push_back(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : increase)&#123;</span><br><span class="line">            curr[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">            curr[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">            curr[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">            days.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : requirements)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = days.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(days[mid][<span class="number">0</span>] &lt; v[<span class="number">0</span>] || days[mid][<span class="number">1</span>] &lt; v[<span class="number">1</span>] || days[mid][<span class="number">2</span>] &lt; v[<span class="number">2</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(days[l][<span class="number">0</span>] &gt;= v[<span class="number">0</span>] &amp;&amp; days[l][<span class="number">1</span>] &gt;= v[<span class="number">1</span>] &amp;&amp; days[l][<span class="number">2</span>] &gt;= v[<span class="number">2</span>])&#123;</span><br><span class="line">                res.push_back(l);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-09-最小跳跃次数"><a href="#LCP-09-最小跳跃次数" class="headerlink" title="LCP 09. 最小跳跃次数"></a>LCP 09. 最小跳跃次数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射<code>jump[i]</code>的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 <code>i+jump[i]</code> 的弹簧（若 <code>i+jump[i]&gt;=N</code> ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p><p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：jump = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：小 Z 最少需要按动 <span class="number">3</span> 次弹簧，小球依次到达的顺序为 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">6</span>，最终小球弹出了机器。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= jump.length &lt;= 10^6</code></li><li><code>1 &lt;= jump[i] &lt;= 10000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  BFS或者DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始准备用BFS，第一次写BFS时竟然超时了，后来仔细发现还是部分条件存在重复的问题。</li><li>每次往前跳的时候或者往后跳的时候如果发现部分元素已经访问过时，需要将其剔除掉。</li><li>记录当前步数下所能够跳的最远距离，这时下一布如果选择往回跳时，直接从上一次的最大值开始常识，而不必要从0开始跳起。算法的时间复杂度为<code>O(n)</code>.</li><li>其实这个题目刚开始准备利用<code>set</code>自动排序的特性，每次直接将已经访问的元素直接从<code>set</code>中自动去掉。算法的时间时间复杂度为<code>O(lgn)</code>,因为二叉平衡树每次进行查找时需要<code>lgn</code>的时间复杂度，结果意外的超时，最后一个测试用例无法通过。</li><li>时间仔细计算以下，题目中的数量级为<code>10e6</code>,如果利用二分查找，则时间复杂度的数量级在<code>1e7</code>次方的数量级，这种情况下其实很容易超时。</li><li>仔细想想其实绝大部分问题的最优解法其实都是非常简单的，并且基本上思路都很直接和简单，实际在做题的时候如果把题目想的太复杂的话，很可能时自己的解法应该时错误的，这点必须知道自己的错误点在哪里，思路在哪里。其实目前刷题来说对于应付一般的面试肯定没有什么问题，但是如果正对于竞赛的话，自己的水平其实差的太远太远。</li><li>对于竞赛的话，感觉自己这种老人肯定是远远达不到年轻人的水平。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = jump.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= n) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= mx) qu.push(curr + jump[curr]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = mx; j &lt; curr; ++j) qu.push(j);</span><br><span class="line">                mx = max(mx,curr + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-10-二叉树任务调度"><a href="#LCP-10-二叉树任务调度" class="headerlink" title="LCP 10. 二叉树任务调度"></a>LCP 10. 二叉树任务调度</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。</p><p>通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 <code>root</code> 为根任务，<code>root.left</code> 和 <code>root.right</code> 为他的两个前导任务（可能为空），<code>root.val</code> 为其自身的执行时间。</p><p>在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。</p><p>现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">47</span>, <span class="number">74</span>, <span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">121</span></span><br><span class="line"></span><br><span class="line">解释：根节点的左右节点可以并行执行<span class="number">31</span>分钟，剩下的<span class="number">43</span>+<span class="number">47</span>分钟只能串行执行，因此总体执行时间是<span class="number">121</span>分钟。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">15</span>, <span class="number">21</span>, <span class="literal">null</span>, <span class="number">24</span>, <span class="literal">null</span>, <span class="number">27</span>, <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">87</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">7.5</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= 节点数量 &lt;= 1000</code></li><li><code>1 &lt;= 单节点执行时间 &lt;= 1000</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>当时比赛的时候没有想明白，解题思路可以参考lee215的微信公众号<a href="https://mp.weixin.qq.com/s/rmwVuDpbQlhoK7DcD715bg" target="_blank" rel="noopener">2020力扣杯</a>。</li><li>后来仔细思考了一下，还是非常有意思的，当时比赛时想到了这点，但是如何进一步优化确实没有深入思考，遇到困难就放弃，确实是自己最大的问题。</li><li>根据题目种的思路，实际上对于节点<code>root</code>,它的左右子树的任务是可以进行并行运行的，我们整个的解题思路也是围绕着，如何能够更好的解决左右子树同时并行的任务的最大值的问题。我们<code>dfs</code>时，每次返回<code>root</code>节点下双核并行任务的运行时间和单核任务运行的时间，分别为<code>s</code>,<code>d</code>,如何围绕左右子树的任务进行合并。</li><li>我们假设当前<code>root</code>节点的左子树返回的双核并行时间和单核运行时间分别为<code>d1</code>,<code>s1</code>.右子树返回的双核并行时间和单核运行时间分别为<code>d2</code>,<code>s2</code>.常规思路是我们讲所有的并行时间加起来，再把单核运行的时间中的部分最小值部分进行并行即<code>min(s1,s2)</code>.<br>所以我们可以得到左右子树的总共的并行时间为：<script type="math/tex; mode=display">d = d1 + d2 + min(s1,s2)</script>左右子树的总共的单核运行时间为:<script type="math/tex; mode=display">s = abs(s1-s2)</script>所以完成左右子树的任务的总时间应该为：<script type="math/tex; mode=display">t = d + s = d1 + d2 + min(s1,s2) + abs(s1-s2)\\</script></li><li>上面这样的结果基本上大部分人都能想到，但是实际上这样真的是最小吗？我们能否再增加d的时间，减少s的时间？但是如何再增加并行的时间，可能讨论就非常的复杂。隐隐约约感觉可以进行优化，因为我们知道假设并行的时间d再增减$\Delta t1$,单核运行的时间就可以减少$2\Delta t1$,总的时间也就减少$\Delta t1$, 也即我们想办法如何减少<code>abs(s1-s2)</code>，减少单核运行的时间。<script type="math/tex; mode=display">t = d + \Delta t1 + s - 2\Delta t1 = d + s - \Delta t1\\0 \le \Delta t1 \le \frac{s}{2} \\</script>仔细思考一下，这点稍微有点绕弯。如何进行优化呢？比如<code>s1 &gt; s2</code>,我们能否减少<code>d2</code>的并行时间$\Delta t$,然后<code>s2</code>就增加了$2 \Delta t$的时间内然后<code>s1</code>就能增加$2 \Delta t$与<code>s2</code>进行并行，这样我们就能够增加并行时间，那么总的消耗时间也就减少了。<script type="math/tex; mode=display">d2 = d2 - \Delta t\\s2 = s2 + 2*\Delta t\\t = d + s  \\t = d1 + d2  - \Delta t + min(s1,s2 + 2*\Delta t) + abs(s1-s2-2*\Delta t)</script>也就是我们要从<code>d2</code>中剥离部分时间尽量延长<code>s2</code>的使得<code>abs(s1-s2)</code>最小。只有这样才能得到最小值，实际也是贪心算法。所以当<code>s1 &gt; s2</code>时我们就要想办法提高<code>s2</code>,当<code>s2 &gt; s1</code>时我们就需要想办法提高<code>s1</code>.只有这样才能保证绝对值之差最小。<br>已知如下条件:<script type="math/tex; mode=display">s1 \ge s2 \\s1 \ge s2 - 2*\Delta t\\d2 \ge \Delta t\\d = d1 + d2 + min(s1,s2) = d1 + d2 + s2\\s = abs(s1-s2) = s1 - s2 \\t = d1 + d2 + s1 \\</script>我们对上述表达式进行展开：<script type="math/tex; mode=display">d^{'} = d1 + d2 + s2 + \Delta t \\s^{'} = s1 - s2 - 2*\Delta t \\t^{'} = d1 + d2  - \Delta t + s2 + 2*\Delta t  + (s1-s2-2*\Delta t)  \\t^{'} = d1 + d2 - \Delta t + s1</script>当然最优解的话肯定为：<script type="math/tex; mode=display">\Delta t = \frac{s1-s2}{2}</script>但由于还有下面的限制。<script type="math/tex; mode=display">d2 \ge \Delta t\\</script>所以总结起来：<script type="math/tex; mode=display">\Delta T = min(\frac{s1-s2}{2},d2)</script><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; dfs(TreeNode * root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; l = dfs(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> delta = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(l.first &gt;= r.first)&#123;</span><br><span class="line">            delta = min((l.first-r.first)/<span class="number">2</span>,r.second);</span><br><span class="line">            d = l.second + r.second + r.first + delta;</span><br><span class="line">            s = l.first - r.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            delta = min((r.first-l.first)/<span class="number">2</span>,l.second);</span><br><span class="line">            d = l.second + r.second + l.first + delta;</span><br><span class="line">            s = r.first - l.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">minimalExecTime</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; t = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> t.first + t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCP2020&quot;&gt;&lt;a href=&quot;#LCP2020&quot; class=&quot;headerlink&quot; title=&quot;LCP2020&quot;&gt;&lt;/a&gt;LCP2020&lt;/h1&gt;&lt;p&gt;还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。&lt;/p&gt;&lt;h2 id=&quot;LCP-06-拿硬币&quot;&gt;&lt;a href=&quot;#LCP-06-拿硬币&quot; class=&quot;headerlink&quot; title=&quot;LCP 06. 拿硬币&quot;&gt;&lt;/a&gt;LCP 06. 拿硬币&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;桌上有 &lt;code&gt;n&lt;/code&gt;堆力扣币，每堆的数量保存在数组 &lt;code&gt;coins&lt;/code&gt;中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 次，第二堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，第三堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，总共 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;限制：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第185周比赛</title>
    <link href="http://yoursite.com/2020/04/19/153/"/>
    <id>http://yoursite.com/2020/04/19/153/</id>
    <published>2020-04-19T00:37:17.252Z</published>
    <updated>2020-04-20T15:00:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="185周比赛"><a href="#185周比赛" class="headerlink" title="185周比赛"></a>185周比赛</h1><p>今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。</p><h2 id="5388-重新格式化字符串"><a href="#5388-重新格式化字符串" class="headerlink" title="5388. 重新格式化字符串"></a>5388. 重新格式化字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"a0b1c2"</span></span><br><span class="line">输出：<span class="string">"0a1b2c"</span></span><br><span class="line">解释：<span class="string">"0a1b2c"</span> 中任意两个相邻字符的类型都不同。 <span class="string">"a0b1c2"</span>, <span class="string">"0a1b2c"</span>, <span class="string">"0c2a1b"</span> 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"leetcode"</span> 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1229857369"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"1229857369"</span> 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"covid2019"</span></span><br><span class="line">输出：<span class="string">"c2o0v1i9d"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ab123"</span></span><br><span class="line">输出：<span class="string">"1a2b3"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 仅由小写英文字母和/或数字组成。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reformat-the-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reformat-the-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>字母的数目和数字的数目差的绝对值大于2则不可能产生出相应的字符串。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformat</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(s.size(),<span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) digit++;</span><br><span class="line">            <span class="keyword">else</span> alpha++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(digit-alpha) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> la = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(digit &gt; alpha)&#123;</span><br><span class="line">            ld = <span class="number">0</span>;</span><br><span class="line">            la = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ld = <span class="number">1</span>;</span><br><span class="line">            la = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res[ld] = c;</span><br><span class="line">                ld += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[la] = c;</span><br><span class="line">                la += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5389-点菜展示表"><a href="#5389-点菜展示表" class="headerlink" title="5389. 点菜展示表"></a>5389. 点菜展示表</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code>是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code>是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 <code>“Table”</code> ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Corina"</span>,<span class="string">"10"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Water"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Rous"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Ceviche"</span>,<span class="string">"Fried Chicken"</span>,<span class="string">"Water"</span>],[<span class="string">"3"</span>,<span class="string">"0"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>],[<span class="string">"5"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>],[<span class="string">"10"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>]] </span><br><span class="line">解释：</span><br><span class="line">点菜展示表如下所示：</span><br><span class="line">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class="line"><span class="number">3</span>    ,<span class="number">0</span>           ,<span class="number">2</span>      ,<span class="number">1</span>            ,<span class="number">0</span></span><br><span class="line"><span class="number">5</span>    ,<span class="number">0</span>           ,<span class="number">1</span>      ,<span class="number">0</span>            ,<span class="number">1</span></span><br><span class="line"><span class="number">10</span>   ,<span class="number">1</span>           ,<span class="number">0</span>      ,<span class="number">0</span>            ,<span class="number">0</span></span><br><span class="line">对于餐桌 <span class="number">3</span>：David 点了 <span class="string">"Ceviche"</span> 和 <span class="string">"Fried Chicken"</span>，而 Rous 点了 <span class="string">"Ceviche"</span></span><br><span class="line">而餐桌 <span class="number">5</span>：Carla 点了 <span class="string">"Water"</span> 和 <span class="string">"Ceviche"</span></span><br><span class="line">餐桌 <span class="number">10</span>：Corina 点了 <span class="string">"Beef Burrito"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"James"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Ratesh"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Amadeus"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Adam"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>],[<span class="string">"Brianna"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Canadian Waffles"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"0"</span>],[<span class="string">"12"</span>,<span class="string">"0"</span>,<span class="string">"3"</span>]] </span><br><span class="line">解释：</span><br><span class="line">对于餐桌 <span class="number">1</span>：<span class="symbol">Adam</span> 和 <span class="symbol">Brianna</span> 都点了 <span class="string">"Canadian Waffles"</span></span><br><span class="line">而餐桌 <span class="number">12</span>：<span class="symbol">James</span>, <span class="symbol">Ratesh</span> 和 <span class="symbol">Amadeus</span> 都点了 <span class="string">"Fried Chicken"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"Laura"</span>,<span class="string">"2"</span>,<span class="string">"Bean Burrito"</span>],[<span class="string">"Jhon"</span>,<span class="string">"2"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"Melissa"</span>,<span class="string">"2"</span>,<span class="string">"Soda"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Bean Burrito"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Soda"</span>],[<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li><li><code>orders[i].length == 3</code></li><li><code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li><li><code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 ‘ ‘ 组成。</li><li><code>tableNumberi</code> 是 1 到 500 范围内的整数。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant" target="_blank" rel="noopener">https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 系统设计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>用map保存每桌的点餐的事物和数量。同时<code>set</code>保存所有的菜品。</li><li>每次点餐时在每桌的订单上进行数据叠加。</li><li>最后统计就非常简单了。直接map查询每周每个菜品订单的数量即可。</li><li>用<code>map</code>和<code>set</code>可以直接利用二叉查找树的自动排序功能，避免二次排序。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; displayTable(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; table;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; foods;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; type;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> order : orders)&#123;</span><br><span class="line">            table[stoi(order[<span class="number">1</span>])][order[<span class="number">2</span>]]++;</span><br><span class="line">            foods.insert(order[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        type.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : foods)&#123;</span><br><span class="line">            type.push_back(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*first colum*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        res.push_back(type);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : table)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; col;</span><br><span class="line">            col.push_back(to_string(p.first));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; type.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.second.count(type[i]))&#123;</span><br><span class="line">                    col.push_back(to_string(p.second[type[i]]));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    col.push_back(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5390-数青蛙"><a href="#5390-数青蛙" class="headerlink" title="5390. 数青蛙"></a>5390. 数青蛙</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>&quot;croak&quot;</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code>。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p><p>注意：要想发出蛙鸣 <code>&quot;croak&quot;</code>，青蛙必须 依序 输出<code>‘c’, ’r’, ’o’, ’a’, ’k’</code>这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p><p>如果字符串 <code>croakOfFrogs</code>不是由若干有效的<code>&quot;croak&quot;</code> 字符混合而成，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroak"</span></span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"crcoakroak"</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class="line">第一只青蛙 <span class="string">"crcoakroak"</span></span><br><span class="line">第二只青蛙 <span class="string">"crcoakroak"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcrook"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：给出的字符串不是 <span class="string">"croak"</span> 的有效组合。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroa"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li><li>字符串中的字符只有<code>&#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39;</code>或者 <code>&#39;k&#39;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常有点绕</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>判断是否需要数目加1</code>：遇到字母<code>c</code>时判断当前是否已经有完成呼叫的任务，如果有则直接将其拿过来进行重新呼叫一次，否则再新加进来一只青蛙进行呼叫。</li><li><code>判断当前呼叫是否合法</code>: 判断当前字母的统计数目是否大于前一个字母的数目，如果是则时非法的，表示该次呼叫未按照顺序进行拼写呼叫。全部呼叫完成后，最后判断所有的青蛙是否全部完成呼叫，即所有的字母统计数目相等。</li><li>返回字符的统计数目即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkFrog</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;  p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x != p.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="built_in">string</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"croak"</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; prev;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            prev[s[i]] = s[(i+<span class="number">4</span>)%<span class="number">5</span>];</span><br><span class="line">            cnt[s[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'c'</span> &amp;&amp; checkFrog(cnt))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); ++j) cnt[s[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[A[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(A[i] != <span class="string">'c'</span> &amp;&amp; cnt[A[i]] &gt; cnt[prev[A[i]]]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!checkValid(cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="string">'c'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5391-生成数组"><a href="#5391-生成数组" class="headerlink" title="5391. 生成数组"></a>5391. 生成数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数 <code>n、m 和 k</code>。下图描述的算法用于找出正整数数组中最大的元素。</p><p>请你生成一个具有下述属性的数组 <code>arr</code>：</p><ul><li><code>arr</code>中有 n 个整数。</li><li><code>1 &lt;= arr[i] &lt;= m</code>其中<code>(0 &lt;= i &lt; n)</code> 。</li><li>将上面提到的算法应用于 <code>arr ，search_cost</code>的值等于 k 。</li></ul><p>返回上述条件下生成数组 <code>arr</code>的 方法数 ，由于答案可能会很大，所以 必须 对 <code>10^9 + 7</code>取余。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：可能的数组分别为 [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>] [<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：可能的数组只有 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">50</span>, m = <span class="number">100</span>, k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">34549172</span></span><br><span class="line">解释：不要忘了对 <span class="number">1000000007</span> 取余</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">37</span>, m = <span class="number">17</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">418930126</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设<code>dp[i][j][k]</code>代表数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>的数组的方案数目。</li><li>我们假设当前数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>。则当数组长度为<code>i+1</code>时，如果第<code>i+1</code>个数大于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该为为<code>k+1</code>,则这时第<code>i+1</code>个数的取值范围为<code>j+1~m</code>;如果第<code>i+1</code>个数小于等于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该仍然为<code>k</code>,则这时第<code>i+1</code>个数应该取值范围为<code>1~j</code>。因此我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][j][k] = dp[i-1][j][k]*j + \sum_{x=1}^{j-1}dp[i-1][x][k-1]</script></li><li>最后我们可以得到得分为<code>k</code>的总的方案数目:<script type="math/tex; mode=display">total = \sum_{i=1}^{m}dp[n][i][k]</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">51</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[N][M][K];</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">2</span>; a &lt;= n; ++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= m; ++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= k &amp;&amp; c &lt;= b &amp;&amp; c &lt;= a; ++c)&#123;</span><br><span class="line">                    dp[a][b][c] = (b*dp[a<span class="number">-1</span>][b][c])%mod;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> mx = <span class="number">1</span>; mx &lt; b; ++mx)&#123;</span><br><span class="line">                        dp[a][b][c] = (dp[a][b][c] + dp[a<span class="number">-1</span>][mx][c<span class="number">-1</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            total = (total + dp[n][i][k])%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;185周比赛&quot;&gt;&lt;a href=&quot;#185周比赛&quot; class=&quot;headerlink&quot; title=&quot;185周比赛&quot;&gt;&lt;/a&gt;185周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。&lt;/p&gt;&lt;h2 id=&quot;5388-重新格式化字符串&quot;&gt;&lt;a href=&quot;#5388-重新格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;5388. 重新格式化字符串&quot;&gt;&lt;/a&gt;5388. 重新格式化字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。&lt;/p&gt;&lt;p&gt;请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。&lt;/p&gt;&lt;p&gt;请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第24场双周比赛</title>
    <link href="http://yoursite.com/2020/04/18/152/"/>
    <id>http://yoursite.com/2020/04/18/152/</id>
    <published>2020-04-18T10:19:10.180Z</published>
    <updated>2020-04-19T12:19:12.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24周双周比赛"><a href="#24周双周比赛" class="headerlink" title="24周双周比赛"></a>24周双周比赛</h1><p>今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部<code>AC</code>，不过跟那些大神不能比，10分钟<code>AC</code>四道题的那种。</p><h2 id="5372-逐步求和得到正数的最小值"><a href="#5372-逐步求和得到正数的最小值" class="headerlink" title="5372. 逐步求和得到正数的最小值"></a>5372. 逐步求和得到正数的最小值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 正数 <code>startValue</code> 作为初始值。</p><p>你需要从左到右遍历<code>nums</code> 数组，并将 <code>startValue</code> 依次累加上<code>nums</code>数组中的值。</p><a id="more"></a><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 <code>startValue</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：如果你选择 startValue = <span class="number">4</span>，在第三次累加时，和小于 <span class="number">1</span> 。</span><br><span class="line">                累加求和</span><br><span class="line">                startValue = <span class="number">4</span> | startValue = <span class="number">5</span> | nums</span><br><span class="line">                  (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>  | (<span class="number">5</span> <span class="number">-3</span> ) = <span class="number">2</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">1</span> +<span class="number">2</span> ) = <span class="number">3</span>  | (<span class="number">2</span> +<span class="number">2</span> ) = <span class="number">4</span>    |   <span class="number">2</span></span><br><span class="line">                  (<span class="number">3</span> <span class="number">-3</span> ) = <span class="number">0</span>  | (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">0</span> +<span class="number">4</span> ) = <span class="number">4</span>  | (<span class="number">1</span> +<span class="number">4</span> ) = <span class="number">5</span>    |   <span class="number">4</span></span><br><span class="line">                  (<span class="number">4</span> +<span class="number">2</span> ) = <span class="number">6</span>  | (<span class="number">5</span> +<span class="number">2</span> ) = <span class="number">7</span>    |   <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最小的 startValue 需要是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求前<code>n</code>项和的最小值。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们最低需要满足前<code>n</code>项和的最小值与这个数相加大于等于<code>1</code>即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res = max(res,<span class="number">1</span>-sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5373-和为-K-的最少斐波那契数字数目"><a href="#5373-和为-K-的最少斐波那契数字数目" class="headerlink" title="5373. 和为 K 的最少斐波那契数字数目"></a>5373. 和为 K 的最少斐波那契数字数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你数字 <code>k</code>，请你返回和为<code>k</code>的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><ul><li><code>F1 = 1</code></li><li><code>F2 = 1</code></li><li><code>Fn = Fn-1 + Fn-2</code> ， 其中 n &gt; 2 。</li></ul><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：斐波那契数字为：<span class="number">1</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">8</span>，<span class="number">13</span>，……</span><br><span class="line">对于 k = <span class="number">7</span> ，我们可以得到 <span class="number">2</span> + <span class="number">5</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：对于 k = <span class="number">10</span> ，我们可以得到 <span class="number">2</span> + <span class="number">8</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">19</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：对于 k = <span class="number">19</span> ，我们可以得到 <span class="number">1</span> + <span class="number">5</span> + <span class="number">13</span> = <span class="number">19</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似很简单，但当时卡壳了好久。后来仔细研究了一下，发现了规律。</li><li>我们找出所有不大于<code>k</code>的斐波那契数列，如果k在数列中，我们直接返回1.</li><li>否则我们找到最大且最接近<code>k</code>的斐波那契数<code>m</code>, 然后再递归求<code>k-m</code>最少需要多少个费不纳妾数组合。<code>fib(k)</code>表示最大的小于等于<code>K</code>的斐波那契数。<script type="math/tex; mode=display">F(k) = 1 + F(k-fib(k))</script></li><li>贴了一下证明过程，用数学归纳法证明比较有意思：</li></ol><ul><li>对于$k=1$是显然成立.</li><li>假设$k=1…N$都成立,则当$k=N+1$时，如果$k$本身是斐波那契数，自然成立，否则一定存在<code>m</code>,使得下述不等式成立：<script type="math/tex; mode=display">Fib_{m}<k<Fib_{m+1}</script></li><li>根据上述不等式可以化为：<script type="math/tex; mode=display">0<k−Fib_{m}<Fib_{m+1}−Fib_{m}=Fib_{m−1} \\k = Fib_{m} + (k-Fib_{m})</script></li><li>按照题目中的归纳条件，根据斐波那契数列数列递增的特性$Fib_{m} \le Fib_{m+1}$,显然我们可以得出<script type="math/tex; mode=display">1\le Fib_{m} \le N \\1\le (k-Fib_{m}) \le N \\k - Fib_{m} \le Fib_{m} \\</script></li><li>按照归纳条件$k−Fib_{m}$可以表示为不同的斐波那契数之和，这些斐波那契数里面显然不包括$Fib_{m}$.所以$k=N+1$也可以表示为不同的斐波那契数之和.且序列中每个数都不相等，而且必须是不连续的斐波那契数之和.因为存在以下等式：<script type="math/tex; mode=display">Fib_{m} + Fib_{m} = Fib_{m+1} \:\:\:  (m == 1) \\Fib_{m} + Fib_{m} = Fib_{m-1} + Fib_{m-2} + Fib{m}  = Fib_{m-2} + Fib_{m+1} \:\:\: (m \neq 1) \\\\Fib_{m} + Fib_{m+1} = Fib_{m+2} \\</script></li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line">        cnt.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  f3 &lt; k ; ++i)&#123;</span><br><span class="line">            f3 = f1+f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">            cnt.insert(f3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(k))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.lower_bound(k);</span><br><span class="line">            it--;</span><br><span class="line">            k -= *it;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5374-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#5374-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="5374. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个 「开心字符串」定义为：</p><ul><li>仅包含小写字母 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li><li>对所有在 1 到 <code>s.length - 1</code>之间的 i ，满足<code>s[i] != s[i + 1]</code>（字符串的下标从 1 开始）。</li></ul><p>比方说，字符串 <code>&quot;abc&quot;</code>，<code>&quot;ac&quot;，&quot;b&quot;</code>和 <code>&quot;abcbabcbcb&quot;</code> 都是开心字符串，但是<code>&quot;aa&quot;，&quot;baa&quot;</code>和<code>&quot;ababbc&quot;</code>都不是开心字符串。</p><p>给你两个整数 <code>n</code> 和 <code>k</code>，你需要将长度为 <code>n</code>的所有开心字符串按字典序排序。</p><p>请你返回排序后的第 <code>k</code> 个开心字符串，如果长度为 <code>n</code>的开心字符串少于 <code>k</code>个，那么请你返回 空字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"c"</span></span><br><span class="line">解释：列表 [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] 包含了所有长度为 <span class="number">1</span> 的开心字符串。按照字典序排序后第三个字符串为 <span class="string">"c"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的开心字符串只有 <span class="number">3</span> 个。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"cab"</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的开心字符串总共有 <span class="number">12</span> 个 [<span class="string">"aba"</span>, <span class="string">"abc"</span>, <span class="string">"aca"</span>, <span class="string">"acb"</span>, <span class="string">"bab"</span>, <span class="string">"bac"</span>, <span class="string">"bca"</span>, <span class="string">"bcb"</span>, <span class="string">"cab"</span>, <span class="string">"cac"</span>, <span class="string">"cba"</span>, <span class="string">"cbc"</span>] 。第 <span class="number">9</span> 个字符串为 <span class="string">"cab"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, k = <span class="number">100</span></span><br><span class="line">输出：<span class="string">"abacbabacb"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= n &lt;= 101 &lt;= k &lt;= 100</code></pre><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接DFS暴力匹配</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量非常小，也没啥好优化的，直接DFS搞起。</li><li>因为题目中是求得是第<code>k</code>个字符串，所以不太好弄，直接DFS模拟求出第k个即可。如果求数量得话，直接<code>DP</code>搞定。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; curr,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &gt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.back() == <span class="string">'a'</span> + i) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span> + i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span>+i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.size() != k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5375-恢复数组"><a href="#5375-恢复数组" class="headerlink" title="5375. 恢复数组"></a>5375. 恢复数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 ·<code>[1, k]</code>之间，且数组中的数字都没有前导 0 。</p><p>给你字符串 <code>s</code> 和整数<code>k</code> 。可能会有多种不同的数组恢复结果。</p><p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p><p>由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一一种可能的数组方案是 [<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在任何数组方案满足所有整数都 &gt;= <span class="number">1</span> 且 &lt;= <span class="number">10</span> 同时输出结果为 s 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1317"</span>, k = <span class="number">2000</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可行的数组方案为 [<span class="number">1317</span>]，[<span class="number">131</span>,<span class="number">7</span>]，[<span class="number">13</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">317</span>]，[<span class="number">13</span>,<span class="number">1</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">31</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"2020"</span>, k = <span class="number">30</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一可能的数组方案是 [<span class="number">20</span>,<span class="number">20</span>] 。 [<span class="number">2020</span>] 不是可行的数组方案，原因是 <span class="number">2020</span> &gt; <span class="number">30</span> 。 [<span class="number">2</span>,<span class="number">020</span>] 也不是可行的数组方案，因为 <span class="number">020</span> 含有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1234567890"</span>, k = <span class="number">90</span></span><br><span class="line">输出：<span class="number">34</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code>.</li><li><code>s 只包含数字且不包含前导 0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code>.<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/restore-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-the-array</a><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本题基本一眼看到就是动态规划。</li><li><code>dp[i]</code>代表前数组前<code>i</code>个数的组合数目，则递推公式为：<script type="math/tex; mode=display">dp[i] = \sum_{j=1}^{i} dp[i-j] \: \: if(num(i-j+1,i) \le k)</script></li><li>因为题目中给定的<code>k</code>的最大长度为<code>10</code>，所以非常简单，我们只需要判断从<code>i</code>往前数<code>i-10</code>组成的字串是否为合法的数目，且其是否大于给定的数目<code>k</code>.</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArrays</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = to_string(k).size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i-j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(stoll(s.substr(i-j,j)) &lt;= k)&#123;</span><br><span class="line">                    dp[i] = (dp[i] + dp[i-j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;24周双周比赛&quot;&gt;&lt;a href=&quot;#24周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;24周双周比赛&quot;&gt;&lt;/a&gt;24周双周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部&lt;code&gt;AC&lt;/code&gt;，不过跟那些大神不能比，10分钟&lt;code&gt;AC&lt;/code&gt;四道题的那种。&lt;/p&gt;&lt;h2 id=&quot;5372-逐步求和得到正数的最小值&quot;&gt;&lt;a href=&quot;#5372-逐步求和得到正数的最小值&quot; class=&quot;headerlink&quot; title=&quot;5372. 逐步求和得到正数的最小值&quot;&gt;&lt;/a&gt;5372. 逐步求和得到正数的最小值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。你可以选定任意的 正数 &lt;code&gt;startValue&lt;/code&gt; 作为初始值。&lt;/p&gt;&lt;p&gt;你需要从左到右遍历&lt;code&gt;nums&lt;/code&gt; 数组，并将 &lt;code&gt;startValue&lt;/code&gt; 依次累加上&lt;code&gt;nums&lt;/code&gt;数组中的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
