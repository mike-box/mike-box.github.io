<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-16T01:07:34.635Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 206周周赛</title>
    <link href="http://yoursite.com/2020/09/16/202/"/>
    <id>http://yoursite.com/2020/09/16/202/</id>
    <published>2020-09-16T01:07:30.309Z</published>
    <updated>2020-09-16T01:07:34.635Z</updated>
    
    <content type="html"><![CDATA[<h1 id="206周周赛"><a href="#206周周赛" class="headerlink" title="206周周赛"></a>206周周赛</h1><p>周日在加班，没有时间参加周赛，所以只是稍微看了下题目，前三题就是常规送分题目。</p><h2 id="1582-二进制矩阵中的特殊位置"><a href="#1582-二进制矩阵中的特殊位置" class="headerlink" title="1582. 二进制矩阵中的特殊位置"></a>1582. 二进制矩阵中的特殊位置</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>rows x cols</code> 的矩阵 <code>mat</code>，其中 <code>mat[i][j]</code>是 <code>0</code> 或 <code>1</code>，请返回 矩阵 <code>mat</code> 中特殊位置的数目 。</p><p>特殊位置 定义：如果 <code>mat[i][j] == 1</code>并且第 <code>i</code> 行和第<code>j</code>列中的所有其他元素均为<code>0</code>（行和列的下标均 从 0 开始 ），则位置 <code>(i, j)</code>被称为特殊位置。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：(<span class="number">1</span>,<span class="number">2</span>) 是一个特殊位置，因为 mat[<span class="number">1</span>][<span class="number">2</span>] == <span class="number">1</span> 且所处的行和列上所有其他元素都是 <span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：(<span class="number">0</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">1</span>) 和 (<span class="number">2</span>,<span class="number">2</span>) 都是特殊位置</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>rows == mat.length</li><li>cols == mat[i].length</li><li>1 &lt;= rows, cols &lt;= 100</li><li>mat[i][j] 是 0 或 1</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/special-positions-in-a-binary-matrix</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环，检查行与列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecial</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">bool</span> rowValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">bool</span> colValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; row; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == i) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mat[k][j] == <span class="number">1</span>) rowValid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(k == j) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(mat[i][k] == <span class="number">1</span>) colValid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rowValid&amp;&amp;colValid) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1583-统计不开心的朋友"><a href="#1583-统计不开心的朋友" class="headerlink" title="1583. 统计不开心的朋友"></a>1583. 统计不开心的朋友</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一份 <code>n</code> 位朋友的亲近程度列表，其中 <code>n</code>总是 偶数 。</p><p>对每位朋友 <code>i，preferences[i]</code> 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 <code>i</code>的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 <code>n-1</code> 之间的整数表示。</p><p>所有的朋友被分成几对，配对情况以列表 <code>pairs</code> 给出，其中 <code>pairs[i] = [xi, yi]</code>表示 <code>xi</code>与 <code>yi</code>配对，且 <code>yi</code>与<code>xi</code>配对。</p><p>但是，这样的配对情况可能会是其中部分朋友感到不开心。在 <code>x</code>与 <code>y</code> 配对且<code>u</code>与 <code>v</code> 配对的情况下，如果同时满足下述两个条件，x 就会不开心：</p><p><code>x</code> 与 <code>u</code>的亲近程度胜过 <code>x</code> 与<code>y</code>，且<br><code>u</code>与 <code>x</code>的亲近程度胜过 <code>u</code> 与<code>v</code><br>返回 不开心的朋友的数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, preferences = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]], pairs = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">朋友 <span class="number">1</span> 不开心，因为：</span><br><span class="line">- <span class="number">1</span> 与 <span class="number">0</span> 配对，但 <span class="number">1</span> 与 <span class="number">3</span> 的亲近程度比 <span class="number">1</span> 与 <span class="number">0</span> 高，且</span><br><span class="line">- <span class="number">3</span> 与 <span class="number">1</span> 的亲近程度比 <span class="number">3</span> 与 <span class="number">2</span> 高。</span><br><span class="line">朋友 <span class="number">3</span> 不开心，因为：</span><br><span class="line">- <span class="number">3</span> 与 <span class="number">2</span> 配对，但 <span class="number">3</span> 与 <span class="number">1</span> 的亲近程度比 <span class="number">3</span> 与 <span class="number">2</span> 高，且</span><br><span class="line">- <span class="number">1</span> 与 <span class="number">3</span> 的亲近程度比 <span class="number">1</span> 与 <span class="number">0</span> 高。</span><br><span class="line">朋友 <span class="number">0</span> 和 <span class="number">2</span> 都是开心的。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, preferences = <span class="string">[[1], [0]]</span>, <span class="built_in">pairs</span> = <span class="string">[[1, 0]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：朋友 <span class="number">0</span> 和 <span class="number">1</span> 都开心。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, preferences = [[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>]], pairs = [[<span class="number">1</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 500</code></li><li><code>n</code>是偶数</li><li><code>preferences.length == n</code></li><li><code>preferences[i].length == n - 1</code></li><li><code>0 &lt;= preferences[i][j] &lt;= n - 1</code></li><li><code>preferences[i]</code> 不包含<code>i</code></li><li><code>preferences[i]</code>中的所有值都是独一无二的</li><li><code>pairs.length == n/2</code></li><li><code>pairs[i].length == 2</code></li><li><code>xi != yi</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li>每位朋友都 恰好 被包含在一对中</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-unhappy-friends" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-unhappy-friends</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 纯粹送分题目</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较奇怪，直接计算任意两个不同人之间的亲密度即可，然后分别进行比较即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">unhappyFriends</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; preferences, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; preferences.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; preferences[i].size(); ++j)&#123;</span><br><span class="line">                graph[i][preferences[i][j]] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pairs.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = pairs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = pairs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">bool</span> validX = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> validY = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pairs.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = pairs[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> v = pairs[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(graph[x][u] &lt; graph[x][y] &amp;&amp; graph[u][x] &lt; graph[u][v]) validX = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[y][u] &lt; graph[y][x] &amp;&amp; graph[u][y] &lt; graph[u][v]) validY = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[x][v] &lt; graph[x][y] &amp;&amp; graph[v][x] &lt; graph[v][u]) validX = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(graph[y][v] &lt; graph[y][x] &amp;&amp; graph[v][y] &lt; graph[v][u]) validY = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(validX) ans++;</span><br><span class="line">            <span class="keyword">if</span>(validY) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1584-连接所有点的最小费用"><a href="#1584-连接所有点的最小费用" class="headerlink" title="1584. 连接所有点的最小费用"></a>1584. 连接所有点的最小费用</h2><p>给你一个<code>points</code> 数组，表示 <code>2D</code> 平面上的一些点，其中 <code>points[i] = [xi, yi]</code>。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code>的费用为它们之间的 曼哈顿距离 ：<code>|xi - xj| + |yi - yj|</code>，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">7</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">我们可以按照上图所示连接所有点得到最小总费用，总费用为 <span class="number">20</span> 。</span><br><span class="line">注意到任意两个点之间只有唯一一条路径互相到达。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">3</span>,<span class="number">12</span>],[<span class="number">-2</span>,<span class="number">5</span>],[<span class="number">-4</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">-1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">-1000000</span>,<span class="number">-1000000</span>],[<span class="number">1000000</span>,<span class="number">1000000</span>]]</span><br><span class="line">输出：<span class="number">4000000</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = <span class="string">[[0,0]]</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点<code>(xi, yi)</code>两两不同。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-cost-to-connect-all-points</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 最小生成树</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的最小生成树算法，<code>kruskal</code>或者<code>prim</code>算法即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">    Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a, Node &amp; b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x]) x = f[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> edge = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,pii&gt; graph;</span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) f[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> d = <span class="built_in">abs</span>(points[i][<span class="number">0</span>]-points[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[i][<span class="number">1</span>]-points[j][<span class="number">1</span>]);</span><br><span class="line">                pq.push(&#123;i,j,d&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">            Node curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> x1 = find(curr.x,f);</span><br><span class="line">            <span class="keyword">int</span> x2 = find(curr.y,f);</span><br><span class="line">            <span class="keyword">if</span>(x1 == x2) <span class="keyword">continue</span>;</span><br><span class="line">            f[x1] = x2;</span><br><span class="line">            edge++;</span><br><span class="line">            ans += curr.d;</span><br><span class="line">            <span class="keyword">if</span>(edge == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1585-检查字符串是否可以通过排序子字符串得到另一个字符串"><a href="#1585-检查字符串是否可以通过排序子字符串得到另一个字符串" class="headerlink" title="1585. 检查字符串是否可以通过排序子字符串得到另一个字符串"></a>1585. 检查字符串是否可以通过排序子字符串得到另一个字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code>和<code>t</code>，请你通过若干次以下操作将字符串 <code>s</code> 转化成字符串 <code>t</code>：</p><p>选择 <code>s</code>中一个 非空 子字符串并将它包含的字符就地 升序 排序。<br>比方说，对下划线所示的子字符串进行操作可以由 <code>&quot;14234&quot;</code>得到<code>&quot;12344&quot;</code>。</p><p>如果可以将字符串 <code>s</code>变成<code>t</code>，返回 <code>true</code>。否则，返回 <code>false</code> 。</p><p>一个 子字符串 定义为一个字符串中连续的若干字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"84532"</span>, t = <span class="string">"34852"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按以下操作将 s 转变为 t ：</span><br><span class="line"><span class="string">"84532"</span> （从下标 <span class="number">2</span> 到下标 <span class="number">3</span>）-&gt; <span class="string">"84352"</span></span><br><span class="line"><span class="string">"84352"</span> （从下标 <span class="number">0</span> 到下标 <span class="number">2</span>） -&gt; <span class="string">"34852"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"34521"</span>, t = <span class="string">"23415"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：你可以按以下操作将 s 转变为 t ：</span><br><span class="line"><span class="string">"34521"</span> -&gt; <span class="string">"23451"</span></span><br><span class="line"><span class="string">"23451"</span> -&gt; <span class="string">"23415"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"12345"</span>, <span class="attr">t</span> = <span class="string">"12435"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1"</span>, <span class="attr">t</span> = <span class="string">"2"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>s.length == t.length</li><li>1 &lt;= s.length &lt;= 105</li><li>s 和 t 都只包含数字字符，即 ‘0’ 到 ‘9’ 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-string-is-transformable-with-substring-sort-operations</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的相当不错，看似很简单，但是值得思考和回味的地方有很多。</li><li>设给定的字符串$s$和$t$的长度均为$n$。题目描述中允许我们将任意长度的子串进行原地升序排序，这无疑增加了操作的复杂性，我们是否可以将对长度为$ 1, 2, \cdots, n$的子串进行的操作归纳成少数的几种操作呢？<br>答案是可以的，当我们操作长度为 $1$ 的子串时，相当于没有进行任何操作，可以忽略；而当我们操作长度等于 $2$ 的子串时，我们是将相邻的两个字符根据它们的大小关系交换位置，类似于「冒泡排序」中的每一个步骤；而当我们操作长度大于等于 $3$ 的子串时，我们是将对应的子串原地升序排序，但它可以拆分成若干次冒泡排序的步骤，即我们对整个子串进行一次完整的冒泡排序，可以得到和题目描述中的操作相同的结果，而冒泡排序中的每一个步骤就是对长度为 $2$ 的子串进行题目描述中的操作。<br>因此，我们可以得到结论：</li></ol><ul><li>我们依次构建字符串t.每次构建字符串<code>t</code>的第<code>i</code>个字符<code>c</code>时，我们知道，需要进行冒泡排序将字符都一个<code>s[j] = c</code>通过从大到小的排序顺序排在最前面，将<code>c</code>排序到第<code>i</code>个位置，因此，我们需要保证前<code>j-1</code>个字符中不存在比<code>s[j]</code>大的字符，如果已经完成排序的第<code>j</code>个字符，我们可以将其从队列中删除。</li></ul></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTransformable</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[s[i] - <span class="string">'0'</span>].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = t[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos[digit].empty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; digit; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!pos[j].empty() &amp;&amp; pos[j].front() &lt; pos[digit].front()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pos[digit].pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;206周周赛&quot;&gt;&lt;a href=&quot;#206周周赛&quot; class=&quot;headerlink&quot; title=&quot;206周周赛&quot;&gt;&lt;/a&gt;206周周赛&lt;/h1&gt;&lt;p&gt;周日在加班，没有时间参加周赛，所以只是稍微看了下题目，前三题就是常规送分题目。&lt;/p&gt;&lt;h2 id=&quot;1582-二进制矩阵中的特殊位置&quot;&gt;&lt;a href=&quot;#1582-二进制矩阵中的特殊位置&quot; class=&quot;headerlink&quot; title=&quot;1582. 二进制矩阵中的特殊位置&quot;&gt;&lt;/a&gt;1582. 二进制矩阵中的特殊位置&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个大小为 &lt;code&gt;rows x cols&lt;/code&gt; 的矩阵 &lt;code&gt;mat&lt;/code&gt;，其中 &lt;code&gt;mat[i][j]&lt;/code&gt;是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt;，请返回 矩阵 &lt;code&gt;mat&lt;/code&gt; 中特殊位置的数目 。&lt;/p&gt;&lt;p&gt;特殊位置 定义：如果 &lt;code&gt;mat[i][j] == 1&lt;/code&gt;并且第 &lt;code&gt;i&lt;/code&gt; 行和第&lt;code&gt;j&lt;/code&gt;列中的所有其他元素均为&lt;code&gt;0&lt;/code&gt;（行和列的下标均 从 0 开始 ），则位置 &lt;code&gt;(i, j)&lt;/code&gt;被称为特殊位置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 205周周赛</title>
    <link href="http://yoursite.com/2020/09/06/201/"/>
    <id>http://yoursite.com/2020/09/06/201/</id>
    <published>2020-09-06T07:29:30.757Z</published>
    <updated>2020-09-11T05:52:17.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="205周周赛"><a href="#205周周赛" class="headerlink" title="205周周赛"></a>205周周赛</h1><p>周赛又翻车了，最后一题竟然还是不会，没有想明白，还是难度大的题目练习较少，没有培养出真正的深入思考的模式。<br><img src="https://i.loli.net/2020/09/11/CBeAkY5qfuaSvw6.png" alt></p><h2 id="5507-替换所有的问号"><a href="#5507-替换所有的问号" class="headerlink" title="5507. 替换所有的问号"></a>5507. 替换所有的问号</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个仅包含小写英文字母和 <code>&#39;?&#39;</code>字符的字符串<code>s&lt;var&gt; &lt;/var&gt;</code>，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。</p><a id="more"></a><p>注意：你 不能 修改非 ‘?’ 字符。</p><p>题目测试用例保证 除 ‘?’ 字符 之外，不存在连续重复的字符。</p><p>在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"?zs"</span></span><br><span class="line">输出：<span class="string">"azs"</span></span><br><span class="line">解释：该示例共有 <span class="number">25</span> 种解决方案，从 <span class="string">"azs"</span> 到 <span class="string">"yzs"</span> 都是符合题目要求的。只有 <span class="string">"z"</span> 是无效的修改，因为字符串 <span class="string">"zzs"</span> 中有连续重复的两个 'z' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ubv?w"</span></span><br><span class="line">输出：<span class="string">"ubvaw"</span></span><br><span class="line">解释：该示例共有 <span class="number">24</span> 种解决方案，只有替换成 <span class="string">"v"</span> 和 <span class="string">"w"</span> 不符合题目要求。因为 <span class="string">"ubvvw"</span> 和 <span class="string">"ubvww"</span> 都包含连续重复的字符。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"j?qg??b"</span></span><br><span class="line">输出：<span class="string">"jaqgacb"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"??yw?ipkj?"</span></span><br><span class="line">输出：<span class="string">"acywaipkja"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 仅包含小写英文字母和 ‘?’ 字符</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环,每次替换时，直接找到与前后相邻字符全不相等的字母进行直接替换即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">modifyString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'?'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">bool</span> pre = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">bool</span> bac = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[i<span class="number">-1</span>] != <span class="string">'a'</span> + j)&#123;</span><br><span class="line">                            pre = <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            pre = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(s[i+<span class="number">1</span>] != <span class="string">'a'</span> + j)&#123;</span><br><span class="line">                            bac = <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            bac = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(pre&amp;&amp;bac)&#123;</span><br><span class="line">                        s[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5508-数的平方等于两数乘积的方法数"><a href="#5508-数的平方等于两数乘积的方法数" class="headerlink" title="5508. 数的平方等于两数乘积的方法数"></a>5508. 数的平方等于两数乘积的方法数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数数组 <code>nums1</code>和 <code>nums2</code>，请你返回根据以下规则形成的三元组的数目（类型 1 和类型 2 ）：</p><ul><li>类型 1：三元组 <code>(i, j, k)</code> ，如果 $nums1[i]^{2} == nums2[j] * nums2[k]$ 其中 <code>0 &lt;= i &lt; nums1.length</code>且 <code>0 &lt;= j &lt; k &lt; nums2.length</code></li><li>类型 2：三元组 <code>(i, j, k)</code>，如果 $nums2[i]^{2} == nums1[j] * nums1[k]$ 其中 <code>0 &lt;= i &lt; nums2.length</code>且 <code>0 &lt;= j &lt; k &lt; nums1.length</code></li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">7</span>,<span class="number">4</span>], nums2 = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：类型 <span class="number">1</span>：(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>), nums1[<span class="number">1</span>]^<span class="number">2</span> = nums2[<span class="number">1</span>] * nums2[<span class="number">2</span>] (<span class="number">4</span>^<span class="number">2</span> = <span class="number">2</span> * <span class="number">8</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">1</span>], nums2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：所有三元组都符合题目要求，因为 <span class="number">1</span>^<span class="number">2</span> = <span class="number">1</span> * <span class="number">1</span></span><br><span class="line">类型 <span class="number">1</span>：(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>), (<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>), nums1[i]^<span class="number">2</span> = nums2[j] * nums2[k]</span><br><span class="line">类型 <span class="number">2</span>：(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>), nums2[i]^<span class="number">2</span> = nums1[j] * nums1[k]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>], nums2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：有两个符合题目要求的三元组</span><br><span class="line">类型 <span class="number">1</span>：(<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>), nums1[<span class="number">3</span>]^<span class="number">2</span> = nums2[<span class="number">0</span>] * nums2[<span class="number">2</span>]</span><br><span class="line">类型 <span class="number">2</span>：(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), nums2[<span class="number">3</span>]^<span class="number">2</span> = nums1[<span class="number">0</span>] * nums1[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">23</span>], nums2 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1024</span>,<span class="number">12</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在符合题目要求的三元组</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 纯粹送分题目</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>记录两个数组中每个元素的平方的统计数目，用hashmap记录统计数目即可。</li><li>直接求：<script type="math/tex; mode=display">nums1[i]^{2} == nums2[j] * nums2[k] \\nums2[i]^{2} == nums1[j] * nums1[k] \\</script>这两种情况下的发生的数目即可，啃爹的情况是需要注意乘法计算溢出的问题。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; sq1;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; sq2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = nums1[i];</span><br><span class="line">            sq1[x*x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = nums2[i];</span><br><span class="line">            sq2[x*x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> a = nums1[i];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> b = nums1[j];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = a*b;</span><br><span class="line">                <span class="keyword">if</span>(sq2.count(x)) ans += sq2[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> a = nums2[i];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> b = nums2[j];</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> x = a*b;</span><br><span class="line">                <span class="keyword">if</span>(sq1.count(x)) ans += sq1[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5509-避免重复字母的最小删除成本"><a href="#5509-避免重复字母的最小删除成本" class="headerlink" title="5509. 避免重复字母的最小删除成本"></a>5509. 避免重复字母的最小删除成本</h2><p>给你一个字符串 <code>s</code>和一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code>是从 <code>s</code> 中删除字符<code>i</code>的代价。</p><p>返回使字符串任意相邻两个字母不相同的最小删除成本。</p><p>请注意，删除一个字符后，删除其他字符的成本不会改变。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abaac"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：删除字母 <span class="string">"a"</span> 的成本为 <span class="number">3</span>，然后得到 <span class="string">"abac"</span>（字符串中相邻两个字母不相同）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无需删除任何字母，因为字符串中不存在相邻两个字母相同的情况。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabaa"</span>, cost = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：删除第一个和最后一个字母，得到字符串 (<span class="string">"aba"</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s.length == cost.length</code></li><li><code>1 &lt;= s.length, cost.length &lt;= 10^5</code></li><li><code>1 &lt;= cost[i] &lt;= 10^4</code></li><li><code>s</code> 中只含有小写英文字母</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-deletion-cost-to-avoid-repeating-letters</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次在具有连续相同字符的窗口中找到替换代价最大的字符留下，其余的相同的字符去掉即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sumCost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCost = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            sumCost = <span class="number">0</span>;</span><br><span class="line">            maxCost = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; n &amp;&amp; s[i] == s[curr])&#123;</span><br><span class="line">                sumCost += cost[i];</span><br><span class="line">                maxCost = max(maxCost,cost[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i-curr &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                ans += sumCost - maxCost;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5510-保证图可完全遍历"><a href="#5510-保证图可完全遍历" class="headerlink" title="5510. 保证图可完全遍历"></a>5510. 保证图可完全遍历</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 和 <code>Bob</code>共有一个无向图，其中包含 <code>n</code> 个节点和 3  种类型的边：</p><ul><li>类型 1：只能由 <code>Alice</code> 遍历。</li><li>类型 2：只能由 <code>Bob</code> 遍历。</li><li>类型 3：<code>Alice</code> 和 <code>Bob</code> 都可以遍历。<br>给你一个数组 <code>edges</code> ，其中 <code>edges[i] = [typei, ui, vi]</code>表示节点 <code>ui</code>和 <code>vi</code> 之间存在类型为 <code>typei</code>的双向边。请你在保证图仍能够被 <code>Alice</code>和 <code>Bob</code>完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，<code>Alice</code>和 <code>Bob</code>都可以到达所有其他节点，则认为图是可以完全遍历的。</li></ul><p>返回可以删除的最大边数，如果 <code>Alice</code>和 <code>Bob</code>无法完全遍历图，则返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果删除 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] 和 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>] 这两条边，Alice 和 Bob 仍然可以完全遍历这个图。再删除任何其他的边都无法保证图可以完全遍历。所以可以删除的最大边数是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：注意，删除任何一条边都会使 Alice 和 Bob 无法完全遍历这个图。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：在当前图中，Alice 无法从其他节点到达节点 <span class="number">4</span> 。类似地，Bob 也不能达到节点 <span class="number">1</span> 。因此，图无法完全遍历。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, 3 * n * (n-1) / 2)</code></li><li><code>edges[i].length == 3</code></li><li><code>1 &lt;= edges[i][0] &lt;= 3</code></li><li><code>1 &lt;= edges[i][1] &lt; edges[i][2] &lt;= n</code></li><li>所有元组 <code>(typei, ui, vi)</code> 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>DSU</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>首先找到能够成为连通的最小数目的数据结构，我们这里是用<code>DSU</code>.</li><li>首先我们利用<code>DSU</code>去掉多余的第三类边，第三类边我们只需要去掉一次即可，<code>dsu1</code>代表<code>Alice</code>,<code>dsu2</code>代表<code>Bob</code>。</li><li>将第一类边依次加入到<code>dsu1</code>中去，去掉多余的第一类边。将第二类边依次加入到<code>dsu2</code>中去，去掉多余的第二类边。</li><li>最后检查<code>dsu1</code>,<code>dsu1</code>是否都满足联通，如果不满足联通则返回<code>-1</code>.否则则返回结果。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">this</span>-&gt;sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(parent[x] != x) x = parent[x];</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[x1] &gt; sz[y1])&#123;</span><br><span class="line">            parent[y1] = x1;</span><br><span class="line">            sz[x1] += sz[y1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[x1] = y1;</span><br><span class="line">            sz[y1] += sz[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sz[x];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumEdgesToRemove</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; a,b,c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">Dsu <span class="title">ds1</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">Dsu <span class="title">ds2</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">1</span>) a.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">2</span>) b.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">3</span>) c.push_back(&#123;v[<span class="number">1</span>],v[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : c)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds1.find(x) == ds1.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds1.uni(x,y);</span><br><span class="line">                ds2.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : a)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds1.find(x) == ds1.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds1.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : b)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds2.find(x) == ds2.find(y))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ds2.uni(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> valid1 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> valid2 = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ds1.length(i) == n) valid1 = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ds2.length(i) == n) valid2 = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!valid1||!valid2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;205周周赛&quot;&gt;&lt;a href=&quot;#205周周赛&quot; class=&quot;headerlink&quot; title=&quot;205周周赛&quot;&gt;&lt;/a&gt;205周周赛&lt;/h1&gt;&lt;p&gt;周赛又翻车了，最后一题竟然还是不会，没有想明白，还是难度大的题目练习较少，没有培养出真正的深入思考的模式。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/11/CBeAkY5qfuaSvw6.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5507-替换所有的问号&quot;&gt;&lt;a href=&quot;#5507-替换所有的问号&quot; class=&quot;headerlink&quot; title=&quot;5507. 替换所有的问号&quot;&gt;&lt;/a&gt;5507. 替换所有的问号&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个仅包含小写英文字母和 &lt;code&gt;&amp;#39;?&amp;#39;&lt;/code&gt;字符的字符串&lt;code&gt;s&amp;lt;var&amp;gt; &amp;lt;/var&amp;gt;&lt;/code&gt;，请你将所有的 ‘?’ 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 33周双周赛</title>
    <link href="http://yoursite.com/2020/09/06/200/"/>
    <id>http://yoursite.com/2020/09/06/200/</id>
    <published>2020-09-06T07:29:30.642Z</published>
    <updated>2020-09-11T05:52:50.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33周双周赛"><a href="#33周双周赛" class="headerlink" title="33周双周赛"></a>33周双周赛</h1><p>本周双周赛题目这么简单的情况下，竟然翻车了。<br><img src="https://i.loli.net/2020/09/11/ObI7PTrFmByc4sD.png" alt></p><h2 id="5491-矩阵对角线元素的和"><a href="#5491-矩阵对角线元素的和" class="headerlink" title="5491. 矩阵对角线元素的和"></a>5491. 矩阵对角线元素的和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正方形矩阵<code>mat</code>，请你返回矩阵对角线元素的和。</p><p>请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。</p><p>示例  1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">            [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">            [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：<span class="number">25</span></span><br><span class="line">解释：对角线的和为：<span class="number">1</span> + <span class="number">5</span> + <span class="number">9</span> + <span class="number">3</span> + <span class="number">7</span> = <span class="number">25</span></span><br><span class="line">请注意，元素 mat[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span> 只会被计算一次。</span><br></pre></td></tr></table></figure><br>示例  2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = <span class="string">[[5]]</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>n == mat.length == mat[i].length</code></li><li><code>1 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= mat[i][j] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/matrix-diagonal-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/matrix-diagonal-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diagonalSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += mat[i][i];</span><br><span class="line">            ans += mat[i][n<span class="number">-1</span>-i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">1</span>) ans -= mat[n/<span class="number">2</span>][n/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5492-分割字符串的方案数"><a href="#5492-分割字符串的方案数" class="headerlink" title="5492. 分割字符串的方案数"></a>5492. 分割字符串的方案数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制串 <code>s</code>  （一个只包含 0 和 1 的字符串），我们可以将 <code>s</code>分割成 3 个 非空 字符串 <code>s1, s2, s3 （s1 + s2 + s3 = s）</code>。</p><p>请你返回分割 s 的方案数，满足 <code>s1，s2</code> 和 <code>s3</code>中字符 ‘1’ 的数目相同。</p><p>由于答案可能很大，请将它对<code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10101"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 种方法将 s 分割成含有 '<span class="number">1</span>' 数目相同的三个子字符串。</span><br><span class="line"><span class="string">"1|010|1"</span></span><br><span class="line"><span class="string">"1|01|01"</span></span><br><span class="line"><span class="string">"10|10|1"</span></span><br><span class="line"><span class="string">"10|1|01"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1001"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0000"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 种分割 s 的方法。</span><br><span class="line"><span class="string">"0|0|00"</span></span><br><span class="line"><span class="string">"0|00|0"</span></span><br><span class="line"><span class="string">"00|0|0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"100100010100110"</span></span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s[i] == &#39;0&#39; 或者 s[i] == &#39;1&#39;</code></li><li><code>3 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-34/problems/number-of-ways-to-split-a-string/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个问题好无聊，首先找到所有<code>1</code>的总数目为<code>n</code>.</li><li>从索引<code>0</code>开始从左到右中含有<code>1</code>的数目分为别$\frac{n}{3}$,$\frac{2n}{3}$的子序列个数。总的数目：<script type="math/tex; mode=display">SUM = C_{\frac{n}{3}}*C_{\frac{2n}{3}}</script></li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> m = s.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'1'</span>) ones++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ones%<span class="number">3</span> != <span class="number">0</span> || s.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ones == <span class="number">0</span>) <span class="keyword">return</span>  ((m<span class="number">-1</span>)*(m<span class="number">-2</span>)/<span class="number">2</span>)%mod;      </span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = ones/<span class="number">3</span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) curr++;</span><br><span class="line">            <span class="keyword">if</span>(curr == n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(n))&#123;</span><br><span class="line">                    cnt[curr] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f1 = max(f1,i-cnt[curr]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == <span class="number">2</span>*n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt.count(<span class="number">2</span>*n))&#123;</span><br><span class="line">                    cnt[curr] = i;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    f2 = max(f2,i-cnt[curr]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>)f1*(<span class="keyword">long</span> <span class="keyword">long</span>)f2%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5493-删除最短的子数组使剩余数组有序"><a href="#5493-删除最短的子数组使剩余数组有序" class="headerlink" title="5493. 删除最短的子数组使剩余数组有序"></a>5493. 删除最短的子数组使剩余数组有序</h2><p>给你一个整数数组 <code>arr</code> ，请你删除一个子数组（可以为空），使得 <code>arr</code> 中剩下的元素是 非递减 的。</p><p>一个子数组指的是原数组中连续的一个子序列。</p><p>请你返回满足题目要求的最短子数组的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们需要删除的最短子数组是 [<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>] ，长度为 <span class="number">3</span> 。剩余元素形成非递减数组 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>] 。</span><br><span class="line">另一个正确的解为删除子数组 [<span class="number">3</span>,<span class="number">10</span>,<span class="number">4</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 <span class="number">4</span> 的子数组，要么删除 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]，要么删除 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组已经是非递减的了，我们不需要删除任何元素。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>0 &lt;= arr[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 双指针</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目翻车了，自己把自己想的太复杂了。</li><li>先却左右两端为升序序列的最大长度，再试着截取两端合适的序列的最大长度。</li><li>我们首先确定右侧的最大升序序列长度，然后我们从最左端开始找起，找到最左端的连续的递升长度$L_{i}$，同时找到最右端能够与 <code>[0,i]</code>形成非减序列的最长长度，我们将有指针右移找到第一个不小于<code>arr[i]</code>的数即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfShortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(r &gt;= <span class="number">1</span> &amp;&amp; arr[r] &gt;= arr[r<span class="number">-1</span>])&#123;</span><br><span class="line">            maxL++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxL == n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; arr[l] &gt; arr[r]) r++;</span><br><span class="line">            maxL = max(maxL,l+<span class="number">1</span>+n-r);</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span>(arr[l] &lt; arr[l<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> n-maxL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5494-统计所有可行路径"><a href="#5494-统计所有可行路径" class="headerlink" title="5494. 统计所有可行路径"></a>5494. 统计所有可行路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 互不相同 的整数数组，其中 <code>locations[i]</code>表示第 <code>i</code> 个城市的位置。同时给你 <code>start</code>，<code>finish</code>和 <code>fuel</code>分别表示出发城市、目的地城市和你初始拥有的汽油总量</p><p>每一步中，如果你在城市 <code>i</code> ，你可以选择任意一个城市 <code>j</code>，满足  <code>j != i</code>且 <code>0 &lt;= j &lt; locations.length</code>，并移动到城市 j 。从城市 i 移动到 j 消耗的汽油量为 <code>|locations[i] - locations[j]|</code>，<code>|x|</code>表示 x 的绝对值。</p><p>请注意， <code>fuel</code> 任何时刻都 不能 为负，且你 可以 经过任意城市超过一次（包括 start 和 <code>finish</code> ）。</p><p>请你返回从 <code>start</code> 到 <code>finish</code>所有可能路径的数目。</p><p>由于答案可能很大， 请将它对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>], start = <span class="number">1</span>, finish = <span class="number">3</span>, fuel = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：以下为所有可能路径，每一条都用了 <span class="number">5</span> 单位的汽油：</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">4</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>], start = <span class="number">1</span>, finish = <span class="number">0</span>, fuel = <span class="number">6</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：以下为所有可能的路径：</span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">3</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>，使用汽油量为 fuel = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>], start = <span class="number">0</span>, finish = <span class="number">2</span>, fuel = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有办法只用 <span class="number">3</span> 单位的汽油从 <span class="number">0</span> 到达 <span class="number">2</span> 。因为最短路径需要 <span class="number">4</span> 单位的汽油。</span><br></pre></td></tr></table></figure><br>示例 4 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>], start = <span class="number">0</span>, finish = <span class="number">0</span>, fuel = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有两条可行路径，<span class="number">0</span> 和 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：locations = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], start = <span class="number">0</span>, finish = <span class="number">2</span>, fuel = <span class="number">40</span></span><br><span class="line">输出：<span class="number">615088286</span></span><br><span class="line">解释：路径总数为 <span class="number">2615088300</span> 。将结果对 <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span> 取余，得到 <span class="number">615088286</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= locations.length &lt;= 100</code></li><li><code>1 &lt;= locations[i] &lt;= 10^9</code></li><li>所有 <code>locations</code> 中的整数 互不相同 。</li><li><code>0 &lt;= start, finish &lt; locations.length</code></li><li><code>1 &lt;= fuel &lt;= 200</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-all-possible-routes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-all-possible-routes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>常规dp,找到递推公式即可。</li><li>我们设<code>dp[x][y]</code>为到达<code>x</code>处时，汽车中的汽油还剩下<code>y</code>单位的可能路径数目。<script type="math/tex; mode=display">dp[x][y] = \sum_{i=1}^{n}dp[i][y+abs(l_{i}-l_{x})]</script></li><li>实际情况下，我们倒着搜索可能更容易一些，特别是记忆化搜索，速度会快很多，因为它的剪枝条件会好很多，比单纯的<code>dp</code>快很多。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">101</span>][<span class="number">202</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[start][fuel] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[start][fuel];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == finish) ans++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="built_in">abs</span>(locations[start]-locations[i]);</span><br><span class="line">            <span class="keyword">if</span>(fuel &gt;= cost)&#123;</span><br><span class="line">                ans = (ans + dfs(locations,i,finish,fuel-cost))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][fuel] = ans;</span><br><span class="line">        <span class="keyword">return</span> dp[start][fuel];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRoutes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">return</span> dfs(locations,start,finish,fuel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">202</span>][<span class="number">101</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRoutes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; locations, <span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">int</span> fuel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = locations.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dis(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j) dis[i][j] = <span class="built_in">abs</span>(locations[i]-locations[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[fuel][start] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = fuel; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= dis[j][k]) dp[i-dis[j][k]][k] = (dp[i-dis[j][k]][k] + dp[i][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= fuel; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i][finish])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;33周双周赛&quot;&gt;&lt;a href=&quot;#33周双周赛&quot; class=&quot;headerlink&quot; title=&quot;33周双周赛&quot;&gt;&lt;/a&gt;33周双周赛&lt;/h1&gt;&lt;p&gt;本周双周赛题目这么简单的情况下，竟然翻车了。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2020/09/11/ObI7PTrFmByc4sD.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5491-矩阵对角线元素的和&quot;&gt;&lt;a href=&quot;#5491-矩阵对角线元素的和&quot; class=&quot;headerlink&quot; title=&quot;5491. 矩阵对角线元素的和&quot;&gt;&lt;/a&gt;5491. 矩阵对角线元素的和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正方形矩阵&lt;code&gt;mat&lt;/code&gt;，请你返回矩阵对角线元素的和。&lt;/p&gt;&lt;p&gt;请你返回在矩阵主对角线上的元素和副对角线上且不在主对角线上元素的和。&lt;/p&gt;&lt;p&gt;示例  1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：对角线的和为：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;请注意，元素 mat[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 只会被计算一次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例  2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：mat = &lt;span class=&quot;string&quot;&gt;[[5]]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Build a Modern Computer From First Principles:Nand to Tetris Part I</title>
    <link href="http://yoursite.com/2020/09/01/199/"/>
    <id>http://yoursite.com/2020/09/01/199/</id>
    <published>2020-09-01T08:13:44.939Z</published>
    <updated>2020-09-11T05:21:54.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course"><a href="#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course" class="headerlink" title="Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)"></a>Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)</h1><p>$~~~~$接触到这门课程是在知乎上有人强烈推荐的，感觉这种靠谱的课程特别是有意义。网上搜了下背景资料，似乎这门课程是给哈佛大学的本科生开的课程，我是在工作之余陆陆续续的将这门课程的上半部分学完了，每周差不多要花上至少三个小时，后面的project还是非常有意思的。这门课程上半部分主要是讲如何从最基本的与非门搭建成一个完成的计算机，下半部分主要是讲在自己搭建的计算机上如何实现虚拟机、高级语言编译器、操作系统等等相关的课程。总的来说课程还是非常有意思的，特别适合稍微有计算机基础的人士来学这门课程，这门课程的前置课程是哈佛大学的<code>cs101</code>计算机基础课程。在学习的过程中确实有几个<code>project</code>还是需要费点时间和精力来理解该课程。我觉得最爽的是课程的<code>project</code>，含金量非常高了，主要是有兴趣，各种<code>project</code>的难度适中，并且非常有意思。</p><a id="more"></a><ul><li><p>开发这门课程的作者为<code>Shimon Schocken</code>,作者为上个世纪毕业于<code>mit</code>高材生，目前在以色列的耶路撒冷大学任教，同时作者也是一个非常出色的教育家，在<code>youtube</code>上可以看到作者的演讲：(<a href="https://www.youtube.com/watch?v=iE7YRHxwoDs)，非常适合非专业人士业余学习计算系统。" target="_blank" rel="noopener">https://www.youtube.com/watch?v=iE7YRHxwoDs)，非常适合非专业人士业余学习计算系统。</a></p></li><li><p>通过该课程可以让人快速的接触到计算机系统的从底层到上层的全貌。虽然不如计算专业的学生对计算机系统的每个部分都学习那么深，但是确实是一门能够让人快速入门且有意思的课程，作者从最基础上的与非门讲起，然后逐步深入到<code>mux</code>与<code>demux</code>,然后到最基本的加法器，累加器，逻辑运算器<code>ALU</code>,接着深入到逻辑存储器、寄存器,再到自建的<code>hack</code>汇编语言，最后到包括最基本的<code>CPU</code>,<code>memory</code>,<code>rom</code>的最小计算机系统的搭建，最后一章的内容为搭建一个基本的<code>hack</code>汇编程序的解释器，将<code>hack</code>汇编代码直接翻译成<code>hack</code>的机器码，比较简单。课程的基本路线如下：</p></li></ul><p><img src="https://i.loli.net/2020/09/11/CYjRFA7yud2zpc3.png" alt="1"><br>上半部分课程主要讲了<code>hardware</code>平台，下班部分正在学习主要是<code>software</code>部分。都比较有意思，强烈推荐对技术感兴趣的同学学习这个课程。</p><ul><li>虽然本课程作为基础课程，基本上大部分内容在计算机专业本科的课程计算机组成原理中都学习过，不是特别难。但是本科的课程中，有许多许多的知识点并没有讲清楚，特别是本科课程中基本上只讲理论，并没有将理论联系实际，设计这么具体的计算机系统，十几年前学的计算机组成原理感觉越来越落后时代。但是基本概念还在心中，至少对计算机底层的逻辑架构有了初步的认识，对于最新的技术，其实很快就能捡起来。该课程的<code>project</code>代码全部靠自己业余时间完成，全部通过给出的测试脚本，还是满满的成就感。YouTube有个非常有名的<code>up</code>主<code>Ben Eate</code>，他的课程为自制<code>8</code>位计算机，里面有全部的原理，部分器件的原理可以参考他的<code>YouTube</code>频道，还是非常有意思,f非常不错的学习资料。(<a href="https://www.youtube.com/c/BenEater/" target="_blank" rel="noopener">https://www.youtube.com/c/BenEater/</a>)</li></ul><p>分别分章节来介绍每个章节，所有<code>project</code>的代码全部上传放在<code>github</code>上。<br><a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects" target="_blank" rel="noopener">课程代码</a></p><h2 id="week1-Boolean-Logic"><a href="#week1-Boolean-Logic" class="headerlink" title="week1 Boolean Logic"></a>week1 Boolean Logic</h2><p>$\qquad$第一章主要介绍了最基本的二进制的概念，基本的逻辑布尔代数的运算，并通过<code>HDL</code>语言由最基本的与非门组成各种各样的器件，当然最复杂的可能是<code>dmux</code>和<code>mux</code>电路，这两个基本电路用到的逻辑门器件较多，因为其中都存在各种布尔代数换算，通过公式换算即可。当然最基本的译码器与编码器是组成原理中的基本电路，非常简单。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8-way demultiplexor:</span></span><br><span class="line"><span class="comment"> * &#123;a, b, c, d, e, f, g, h&#125; = &#123;in, 0, 0, 0, 0, 0, 0, 0&#125; if sel == 000</span></span><br><span class="line"><span class="comment"> *                            &#123;0, in, 0, 0, 0, 0, 0, 0&#125; if sel == 001</span></span><br><span class="line"><span class="comment"> *                            etc.</span></span><br><span class="line"><span class="comment"> *                            &#123;0, 0, 0, 0, 0, 0, 0, in&#125; if sel == 111</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/01/DMux4Way.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4-way demultiplexor:</span></span><br><span class="line"><span class="comment"> * &#123;a, b, c, d&#125; = &#123;in, 0, 0, 0&#125; if sel == 00</span></span><br><span class="line"><span class="comment"> *                &#123;0, in, 0, 0&#125; if sel == 01</span></span><br><span class="line"><span class="comment"> *                &#123;0, 0, in, 0&#125; if sel == 10</span></span><br><span class="line"><span class="comment"> *                &#123;0, 0, 0, in&#125; if sel == 11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CHIP DMux &#123;</span><br><span class="line">    IN in, sel;</span><br><span class="line">    OUT a, b;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    Not (in = sel, out = notsel);</span><br><span class="line">    And (a = in, b = notsel, out = a);</span><br><span class="line">    And (a = in, b = sel, out = b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP DMux4Way &#123;</span><br><span class="line">    IN in, sel[<span class="number">2</span>];</span><br><span class="line">    OUT a, b, c, d;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">//using Dmux</span></span><br><span class="line">    DMux (in = in, sel = sel[<span class="number">1</span>], a = selab, b = selcd);</span><br><span class="line">    DMux (in = selab, sel = sel[<span class="number">0</span>], a = a, b = b);</span><br><span class="line">    DMux (in = selcd, sel = sel[<span class="number">0</span>], a = c, b = d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP DMux8Way &#123;</span><br><span class="line">    IN in, sel[<span class="number">3</span>];</span><br><span class="line">    OUT a, b, c, d, e, f, g, h;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">//DMux 8 way using three DMux</span></span><br><span class="line">    DMux (in = in, sel = sel[<span class="number">2</span>], a = selabcd, b = selefgh);</span><br><span class="line">    DMux4Way(in = selabcd, sel = sel[<span class="number">0.</span><span class="number">.1</span>], a = a, b = b, c = c, d = d);</span><br><span class="line">    DMux4Way(in = selefgh, sel = sel[<span class="number">0.</span><span class="number">.1</span>], a = e, b = f, c = g, d = h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2-Boolean-Arithmetic"><a href="#week2-Boolean-Arithmetic" class="headerlink" title="week2 Boolean Arithmetic"></a>week2 Boolean Arithmetic</h2><p>本课程适合有计算机基础的人士，进度非常快，基本上第二章开始就进入基本的加法器、乘法器、累加器的设计，实际还是挺复杂的，需要一定的逻辑电路基础。</p><ul><li><code>16</code>位加法器的实现,具体实现的时候分为两种办法，一种是直接用16个全加器进行串联起来，另一种就是利用公式推导快速加法器。虽然利用全加器串联起来很简单，需要用的门电路也很少，但是在实际工程中肯定是时延非常大。用快速的加法器虽然可以能够减少时延，但是用到的门电路较多，实际成本会很高。因此我们可以选择这种的办法，用4个快速的全加器串联起来组成一个16位的全加器。</li></ul><h3 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">CHIP FastAdd4 &#123;</span><br><span class="line">    IN a[<span class="number">4</span>], b[<span class="number">4</span>], c;</span><br><span class="line">    OUT out[<span class="number">4</span>],</span><br><span class="line">        carry;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    And (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = g0);</span><br><span class="line">    And (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = g1);</span><br><span class="line">    And (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = g2);</span><br><span class="line">    And (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = g3);</span><br><span class="line"></span><br><span class="line">    Or (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = p0);</span><br><span class="line">    Or (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = p1);</span><br><span class="line">    Or (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = p2);</span><br><span class="line">    Or (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = p3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c1 = g0 + p0*c0</span></span><br><span class="line">    And (a = p0, b = c, out = p0c0);</span><br><span class="line">    Or (a = g0, b = p0c0, out = c1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c2 = g1 + p1*g0 + p1*p0*c0</span></span><br><span class="line">    And (a = p1, b = g0, out = p1g0);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p1, in[<span class="number">1</span>] = p0, in[<span class="number">2</span>] = c , in[<span class="number">3</span>] = <span class="literal">true</span>, out = p1p0c0);</span><br><span class="line">    Or4Way  (in[<span class="number">0</span>] = g1, in[<span class="number">1</span>] = p1g0,in[<span class="number">2</span>] = p1p0c0, in[<span class="number">3</span>] = <span class="literal">false</span>, out = c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c3 = g2 + p2*g1 + p2*p1*g0 + p2*p1*p0*c0</span></span><br><span class="line">    And (a = p2, b = g1, out = p2g1);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p2, in[<span class="number">1</span>] = p1, in[<span class="number">2</span>] = g0, in[<span class="number">3</span>] = <span class="literal">true</span>, out = p2p1g0);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p2, in[<span class="number">1</span>] = p1, in[<span class="number">2</span>] = p0, in[<span class="number">3</span>] = c, out = p2p1p0c0);</span><br><span class="line">    Or4Way (in[<span class="number">0</span>] = g2, in[<span class="number">1</span>] = p2g1, in[<span class="number">2</span>] = p2p1g0, in[<span class="number">3</span>] = p2p1p0c0, out = c3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c4 = g3 + p3*g2 + p3*p2*g1 + p3*p2*p1*g0 + p3*p2*p1*p0*c0</span></span><br><span class="line">    And (a = p3, b = g2, out = p3g2);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = g1, in[<span class="number">3</span>] = <span class="literal">true</span>, out = p3p2g1);</span><br><span class="line">    And4Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = p1, in[<span class="number">3</span>] = g0, out = p3p2p1g0);</span><br><span class="line">    And8Way (in[<span class="number">0</span>] = p3, in[<span class="number">1</span>] = p2, in[<span class="number">2</span>] = p1, in[<span class="number">3</span>] = p0, in[<span class="number">4</span>] = c, in[<span class="number">5.</span><span class="number">.7</span>] = <span class="literal">true</span>, out = p3p2p1p0c0);</span><br><span class="line">    Or8Way (in[<span class="number">0</span>] = g3, in[<span class="number">1</span>] = p3g2, in[<span class="number">2</span>] = p3p2g1, in[<span class="number">3</span>] = p3p2p1g0, in[<span class="number">4</span>] = p3p2p1p0c0, in[<span class="number">5.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = carry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a + b</span></span><br><span class="line">    Xor (a = a[<span class="number">0</span>], b = b[<span class="number">0</span>], out = add0);</span><br><span class="line">    Xor (a = add0, b = c , out = out[<span class="number">0</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">1</span>], b = b[<span class="number">1</span>], out = add1);</span><br><span class="line">    Xor (a = add1, b = c1 , out = out[<span class="number">1</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">2</span>], b = b[<span class="number">2</span>], out = add2);</span><br><span class="line">    Xor (a = add2, b = c2 , out = out[<span class="number">2</span>]);</span><br><span class="line">    Xor (a = a[<span class="number">3</span>], b = b[<span class="number">3</span>], out = add3);</span><br><span class="line">    Xor (a = add3, b = c3 , out = out[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CHIP Add16 &#123;</span><br><span class="line">    IN a[<span class="number">16</span>], b[<span class="number">16</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">   <span class="comment">//Carry-Lookahead Adder , fast adder</span></span><br><span class="line">   FastAdd4 (a = a[<span class="number">0.</span><span class="number">.3</span>], b = b[<span class="number">0.</span><span class="number">.3</span>], c = <span class="literal">false</span>, out = out[<span class="number">0.</span><span class="number">.3</span>], carry = c4);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">4.</span><span class="number">.7</span>], b = b[<span class="number">4.</span><span class="number">.7</span>], c = c4, out = out[<span class="number">4.</span><span class="number">.7</span>], carry = c8);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">8.</span><span class="number">.11</span>], b = b[<span class="number">8.</span><span class="number">.11</span>], c = c8, out = out[<span class="number">8.</span><span class="number">.11</span>], carry = c12);</span><br><span class="line">   FastAdd4 (a = a[<span class="number">12.</span><span class="number">.15</span>], b = b[<span class="number">12.</span><span class="number">.15</span>], c = c12, out = out[<span class="number">12.</span><span class="number">.15</span>], carry = c16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全加器串联:</p><p><img src="https://i.loli.net/2020/09/11/EUjtDbwKPM6BcOy.png" alt="2"><br>全加器直接串联会导致时延</p><p><img src="https://i.loli.net/2020/09/11/mrEAYdo6Z7qsxcF.png" alt><br>全加器的推导，并进行优化</p><p><img src="https://i.loli.net/2020/09/11/PnVvFBZbwH41Eys.png" alt><br>直接对电路进行优化，可以先求出进位直接代入到加法器中。优化电路时延，减少时延。<br><img src="https://i.loli.net/2020/09/11/IvqXaKgQh3OFnZk.png" alt></p><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><ul><li><p><code>ALU</code>电路的设计，还是稍微复杂，书写<code>hdl</code>语言稍微复杂点，当时还是思考了很长时间，最后全部通过脚本测试。本质上讲控制信号全部转化为公式，很快即可写出逻辑电路语言。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/02/ALU.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The ALU (Arithmetic Logic Unit).</span></span><br><span class="line"><span class="comment"> * Computes one of the following functions:</span></span><br><span class="line"><span class="comment"> * x+y, x-y, y-x, 0, 1, -1, x, y, -x, -y, !x, !y,</span></span><br><span class="line"><span class="comment"> * x+1, y+1, x-1, y-1, x&amp;y, x|y on two 16-bit inputs, </span></span><br><span class="line"><span class="comment"> * according to 6 input bits denoted zx,nx,zy,ny,f,no.</span></span><br><span class="line"><span class="comment"> * In addition, the ALU computes two 1-bit outputs:</span></span><br><span class="line"><span class="comment"> * if the ALU output == 0, zr is set to 1; otherwise zr is set to 0;</span></span><br><span class="line"><span class="comment"> * if the ALU output &lt; 0, ng is set to 1; otherwise ng is set to 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation: the ALU logic manipulates the x and y inputs</span></span><br><span class="line"><span class="comment">// and operates on the resulting values, as follows:</span></span><br><span class="line"><span class="comment">// if (zx == 1) set x = 0        // 16-bit constant</span></span><br><span class="line"><span class="comment">// if (nx == 1) set x = !x       // bitwise not</span></span><br><span class="line"><span class="comment">// if (zy == 1) set y = 0        // 16-bit constant</span></span><br><span class="line"><span class="comment">// if (ny == 1) set y = !y       // bitwise not</span></span><br><span class="line"><span class="comment">// if (f == 1)  set out = x + y  // integer 2's complement addition</span></span><br><span class="line"><span class="comment">// if (f == 0)  set out = x &amp; y  // bitwise and</span></span><br><span class="line"><span class="comment">// if (no == 1) set out = !out   // bitwise not</span></span><br><span class="line"><span class="comment">// if (out == 0) set zr = 1</span></span><br><span class="line"><span class="comment">// if (out &lt; 0) set ng = 1</span></span><br><span class="line"></span><br><span class="line">CHIP ALU &#123;</span><br><span class="line">    IN  </span><br><span class="line">        x[<span class="number">16</span>], y[<span class="number">16</span>],  <span class="comment">// 16-bit inputs        </span></span><br><span class="line">        zx, <span class="comment">// zero the x input?</span></span><br><span class="line">        nx, <span class="comment">// negate the x input?</span></span><br><span class="line">        zy, <span class="comment">// zero the y input?</span></span><br><span class="line">        ny, <span class="comment">// negate the y input?</span></span><br><span class="line">        f,  <span class="comment">// compute out = x + y (if 1) or x &amp; y (if 0)</span></span><br><span class="line">        no; <span class="comment">// negate the out output?</span></span><br><span class="line"></span><br><span class="line">    OUT </span><br><span class="line">        out[<span class="number">16</span>], <span class="comment">// 16-bit output</span></span><br><span class="line">        zr, <span class="comment">// 1 if (out == 0), 0 otherwise</span></span><br><span class="line">        ng; <span class="comment">// 1 if (out &lt; 0),  0 otherwise</span></span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put you code here:</span></span><br><span class="line">    <span class="comment">// clear to zero</span></span><br><span class="line">    <span class="comment">// reverse bit</span></span><br><span class="line">    <span class="comment">// if (zx == 1) set x = 0 </span></span><br><span class="line">    Not (in = zx, out = notzx); </span><br><span class="line">    And1Way16 (a = x, b = notzx, out = zerox);</span><br><span class="line">    <span class="comment">// if (nx == 1) set x = !x</span></span><br><span class="line">    Xor1Way16 (a = zerox, b = nx, out = negx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (zy == 1) set y = 0 </span></span><br><span class="line">    Not (in = zy, out = notzy);</span><br><span class="line">    And1Way16 (a = y, b = notzy, out = zeroy); </span><br><span class="line">    <span class="comment">// if (ny == 1) set y = !y  </span></span><br><span class="line">    Xor1Way16 (a = zeroy, b = ny, out = negy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (f == 1)  set out = x + y</span></span><br><span class="line">    Add16 (a = negx, b = negy, out = sumxy);</span><br><span class="line">    <span class="comment">// if (f == 0)  set out = x &amp; y</span></span><br><span class="line">    And16 (a = negx, b = negy, out = andxy);</span><br><span class="line">    Mux16 (a = andxy, b = sumxy, sel = f ,out = outxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (no == 1) set out = !out </span></span><br><span class="line">    <span class="comment">// if (out &lt; 0) set ng = 1</span></span><br><span class="line">    Xor1Way16 (a = outxy, b = no, out = out);</span><br><span class="line">    Xor1Way16 (a = outxy, b = no, out[<span class="number">0.</span><span class="number">.14</span>] = negxy, out[<span class="number">15</span>] = ng);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (out == 0) set zr = 1</span></span><br><span class="line">    Or16Way  (in[<span class="number">0.</span><span class="number">.14</span>] = negxy, in[<span class="number">15</span>] = <span class="literal">false</span>,out = zeroout);</span><br><span class="line">    Not (in = zeroout, out = zr);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩展ALU</strong>：后期准备为ALU增加功能，即增加基本的乘法器、移位器、浮点运算器这些高级功能，同时对其指令集、汇编语言进行扩展。这时后期的重要工作实现。</p></li></ul><h2 id="week3-Memory"><a href="#week3-Memory" class="headerlink" title="week3 Memory"></a>week3 Memory</h2><p>第三章就稍微复杂点了，当时想了很长时间，还查阅了很多资料。这一章主要描写了最基本的<code>D</code>触发器，寄存器，<code>RAM</code>系统等相关器件和系统。在这里其实重点需要阐述一下<code>D</code>触发器，其实非常有意思，当时还在<code>youtube</code>上找到相关的视频，并进行学习。·youtube</p><h3 id="Bit"><a href="#Bit" class="headerlink" title="Bit"></a>Bit</h3><ul><li><strong><code>D</code>触发器</strong><br>D触发器是一个具有记忆功能的，具有两个稳定状态的信息存储器件，是构成多种时序电路的最基本逻辑单元，也是数字逻辑电路中一种重要的单元电路。</li></ul><p><img src="https://i.loli.net/2020/09/11/4jIJB1KmXtFs293.png" alt><br>可以参考<code>youtube</code>的视频。关于<code>d</code>触发器(<a href="https://www.youtube.com/watch?v=YW-_GkUguMM),其中将原理图如下：" target="_blank" rel="noopener">https://www.youtube.com/watch?v=YW-_GkUguMM),其中将原理图如下：</a></p><p><img src="https://i.loli.net/2020/09/11/7vCXQfioMIUTa5R.png" alt><br>我们可以通过D触发器构造基本的存储单元。</p><h3 id="Reigister"><a href="#Reigister" class="headerlink" title="Reigister"></a>Reigister</h3><ul><li><strong>寄存器</strong><br>寄存器即为将16位基本的存储单元并联即可，控制信号共享一位控制信号即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/03/a/Register.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 16-bit register:</span></span><br><span class="line"><span class="comment"> * If load[t] == 1 then out[t+1] = in[t]</span></span><br><span class="line"><span class="comment"> * else out does not change</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP Register &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load;</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    Bit (in = in[<span class="number">0</span>], load = load, out = out[<span class="number">0</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">1</span>], load = load, out = out[<span class="number">1</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">2</span>], load = load, out = out[<span class="number">2</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">3</span>], load = load, out = out[<span class="number">3</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">4</span>], load = load, out = out[<span class="number">4</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">5</span>], load = load, out = out[<span class="number">5</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">6</span>], load = load, out = out[<span class="number">6</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">7</span>], load = load, out = out[<span class="number">7</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">8</span>], load = load, out = out[<span class="number">8</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">9</span>], load = load, out = out[<span class="number">9</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">10</span>], load = load, out = out[<span class="number">10</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">11</span>], load = load, out = out[<span class="number">11</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">12</span>], load = load, out = out[<span class="number">12</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">13</span>], load = load, out = out[<span class="number">13</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">14</span>], load = load, out = out[<span class="number">14</span>]);</span><br><span class="line">    Bit (in = in[<span class="number">15</span>], load = load, out = out[<span class="number">15</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h3><ul><li><strong>RAM</strong><br>RAM则类似于多个并联的寄存器组合即可，通过地址码翻译为某个寄存器单元的控制信号即可。比较简单<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/03/a/RAM8.hdl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Memory of 8 registers, each 16 bit-wide. Out holds the value</span></span><br><span class="line"><span class="comment"> * stored at the memory location specified by address. If load==1, then </span></span><br><span class="line"><span class="comment"> * the in value is loaded into the memory location specified by address </span></span><br><span class="line"><span class="comment"> * (the loaded value will be emitted to out from the next time step onward).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">CHIP RAM8 &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load, address[<span class="number">3</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    DMux8Way (in = load, sel = address, a = load0, b = load1 , c = load2, d = load3, e = load4, f = load5, g = load6 , h = load7);</span><br><span class="line">    Register (in = in, load = load0 , out = r0);</span><br><span class="line">    Register (in = in, load = load1 , out = r1);</span><br><span class="line">    Register (in = in, load = load2 , out = r2);</span><br><span class="line">    Register (in = in, load = load3 , out = r3);</span><br><span class="line">    Register (in = in, load = load4 , out = r4);</span><br><span class="line">    Register (in = in, load = load5 , out = r5);</span><br><span class="line">    Register (in = in, load = load6 , out = r6);</span><br><span class="line">    Register (in = in, load = load7 , out = r7);</span><br><span class="line">    Mux8Way16 (a = r0, b = r1, c = r2, d = r3, e = r4, f = r5, g = r6, h = r7, sel = address, out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="week4-Machine-Language"><a href="#week4-Machine-Language" class="headerlink" title="week4 Machine Language"></a>week4 Machine Language</h2><p>本周则进入了高级编程环节，主要是讲述了自制计算机的指令编码和汇编语言。在<code>hack</code>计算机系统中，指令集只有追基本的<code>A</code> 指令和<code>C</code>指令。</p><h3 id="A-instruction"><a href="#A-instruction" class="headerlink" title="A instruction"></a>A instruction</h3><ul><li><code>A</code>指令为基本的寻址指令：这个是本科的组成原理中所描述的基本一样，基本的立即寻址、寄存器寻址等等，寻址方式多种。</li></ul><p><img src="https://i.loli.net/2020/09/11/57F2CdWSs8teQxl.png" alt></p><h3 id="C-instruction"><a href="#C-instruction" class="headerlink" title="C instruction"></a>C instruction</h3><ul><li><code>C</code>指令为基本的运算指令：该指令分为三个部分，计算指令 、存储指令、跳转指令。<br>这一章其实也非常有意思，通过最基本的指令集能够了解到计算机系统的基本面貌。</li></ul><p><img src="https://i.loli.net/2020/09/11/QkbmiatBnFzNIYV.png" alt><br>通过最基本的指令集的组合就可以完成许多高级功能。比如最基本的寻址，加减法，乘法，除法。其实还是非常有意思的，对于整个认识计算机系统有很深入而又全面的了解。<br><img src="https://i.loli.net/2020/09/11/sTAGiozmSlw8Ykv.png" alt></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>最基本的乘法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This file is part of www.nand2tetris.org</span></span><br><span class="line"><span class="comment">// and the book "The Elements of Computing Systems"</span></span><br><span class="line"><span class="comment">// by Nisan and Schocken, MIT Press.</span></span><br><span class="line"><span class="comment">// File name: projects/04/Mult.asm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiplies R0 and R1 and stores the result in R2.</span></span><br><span class="line"><span class="comment">// (R0, R1, R2 refer to RAM[0], RAM[1], and RAM[2], respectively.)</span></span><br><span class="line"><span class="comment">// created by mike meng @ 2020.7.28</span></span><br><span class="line"><span class="comment">// Put your code here.</span></span><br><span class="line">    @<span class="number">0</span></span><br><span class="line">    D=A</span><br><span class="line">    @R2</span><br><span class="line">    M=D <span class="comment">//set R2 to zero</span></span><br><span class="line"></span><br><span class="line">(LOOP)</span><br><span class="line">    @R1</span><br><span class="line">    D=M</span><br><span class="line">    @END</span><br><span class="line">    D;JEQ <span class="comment">// we first need to test if R1 is zero.</span></span><br><span class="line">    @R0</span><br><span class="line">    D=M</span><br><span class="line">    @R2</span><br><span class="line">    M=M+D <span class="comment">// we add R0 once .</span></span><br><span class="line">    @R1</span><br><span class="line">    M=M<span class="number">-1</span> <span class="comment">// we dec R1 one time.</span></span><br><span class="line">    @LOOP</span><br><span class="line">    <span class="number">0</span>;JMP</span><br><span class="line"></span><br><span class="line">(END)</span><br><span class="line">    @END</span><br><span class="line">    <span class="number">0</span>;JMP</span><br></pre></td></tr></table></figure></p><h2 id="week5-Computer-Architecture"><a href="#week5-Computer-Architecture" class="headerlink" title="week5 Computer Architecture"></a>week5 Computer Architecture</h2><p>本章的可以算是本课程上半部分的核心，主要讲之前全部设计的器件组合起来，包括ALU、存储器、PC、ROM。通过这些简单的器件组合即可完成，通过理解计算机系统的基本构成和各个部分的基本原理来理解计算机系统的构成。</p><h3 id="Computer"><a href="#Computer" class="headerlink" title="Computer"></a>Computer</h3><ul><li>冯诺依曼计算机体系的基本构成，如下图所示。代码和程序放在一个存储器中，通过不同德时钟周期，取指令和取数据来完成计算机系统的运行。另一种讲数据和指令分开存储的称之为哈佛结构，主要是用于<code>DSP</code>上居多。</li></ul><p><img src="https://i.loli.net/2020/09/11/6hswpjAoX8TQEqr.png" alt></p><ul><li>本次涉及的hack系统基本构成如下：其中<code>ROM</code>存储程序指令，<code>CPU</code>发复杂翻译指令并执行，<code>MEMORY</code>复杂存储和读取数据。<br><img src="https://i.loli.net/2020/09/11/lfxhSpP3nIM7z8o.png" alt><br>相关的逻辑部件链接如下，基本上按照图中的连线进行连接即可完成相关的计算机系统，实际非常简单。<br><img src="https://i.loli.net/2020/09/11/xuN9dYi7sKLPBnH.png" alt></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CHIP Computer &#123;</span><br><span class="line">    IN reset;</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    ROM32K(address = inAddr, out = outRom);</span><br><span class="line">    CPU(inM = outM,instruction = outRom, reset = reset,outM = value,writeM = loadM,addressM = outAddr,pc = inAddr);</span><br><span class="line">    Memory(in = value, load = loadM, address = outAddr, out = outM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><strong>CPU</strong><br><code>CPU</code>的结构示意图如下：<br><img src="https://i.loli.net/2020/09/11/nhXMcdkV9eS4W2B.png" alt><br>在<code>hack</code>系统中<code>CPU</code>负责将指令进行翻译，<code>hack</code>系统存在<code>A</code>指令与<code>C</code>指令。翻译指令还是比较复杂，如果发现为<code>A</code>指令，则直接将<code>A</code>寄存器设置为指令中的地址数据，如果发现为<code>C</code>指令则分别存储、运算、跳转三个子部分进行解释:</li></ul><ol><li><code>c</code>指令的基本结构：<br><img src="https://i.loli.net/2020/09/11/QkbmiatBnFzNIYV.png" alt></li><li>计算指令部分解析：<br><img src="https://i.loli.net/2020/09/11/fFDZK8HrBYs9uhQ.png" alt></li><li>存储指令部分解析：<br><img src="https://i.loli.net/2020/09/11/HRDN1X2iuO6BWlr.png" alt></li><li>跳转指令部分解析：<br><img src="https://i.loli.net/2020/09/11/ZNPM2d9aIQYODCl.png" alt><br>CPU的HDL代码稍微复杂点，大概花了半天时间最终搞定，有几个小问题思考花费了不少时间。特别是关于存储指令的部分，需要将<code>ALU</code>的运算结果存储到不同的存储器中需要花费不少的细节问题,可以将其存储到<code>A</code>寄存器，<code>D</code>寄存器，<code>MEMORY</code>中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CHIP CPU &#123;</span><br><span class="line">    IN  inM[<span class="number">16</span>],         <span class="comment">// M value input  (M = contents of RAM[A])</span></span><br><span class="line">        instruction[<span class="number">16</span>], <span class="comment">// Instruction for execution</span></span><br><span class="line">        reset;           <span class="comment">// Signals whether to re-start the current</span></span><br><span class="line">                         <span class="comment">// program (reset==1) or continue executing</span></span><br><span class="line">                         <span class="comment">// the current program (reset==0).</span></span><br><span class="line"></span><br><span class="line">    OUT outM[<span class="number">16</span>],        <span class="comment">// M value output</span></span><br><span class="line">        writeM,          <span class="comment">// Write to M? </span></span><br><span class="line">        addressM[<span class="number">15</span>],    <span class="comment">// Address in data memory (of M)</span></span><br><span class="line">        pc[<span class="number">15</span>];          <span class="comment">// address of next instruction</span></span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">//A Instruction</span></span><br><span class="line">    Not(in = instruction[<span class="number">15</span>], out = loadA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//C Instruction</span></span><br><span class="line">    Mux16(a = Addr, b = inM, sel = instruction[<span class="number">12</span>], out = outAM);</span><br><span class="line">    ALU(x = outD, y = outAM, zx = instruction[<span class="number">11</span>], nx = instruction[<span class="number">10</span>],zy = instruction[<span class="number">9</span>],ny = instruction[<span class="number">8</span>],f = instruction[<span class="number">7</span>], no = instruction[<span class="number">6</span>], out = outC, out = outM,zr = outZr, ng = outNg);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//store compute result</span></span><br><span class="line">    DMux8Way(in = <span class="literal">true</span>, sel = instruction[<span class="number">3.</span><span class="number">.5</span>], a = selnull, b = selM, c = selD, d = selMD, e = selA, f = selAM, g = selAD, h = selAMD);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//store M </span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selM, in[<span class="number">1</span>] = selMD, in[<span class="number">2</span>] = selMD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeM);</span><br><span class="line">    And(a = storeM, b = instruction[<span class="number">15</span>], out = writeM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store D</span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selD, in[<span class="number">1</span>] = selMD, in[<span class="number">2</span>] = selAD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeD);</span><br><span class="line">    And(a = storeD, b = instruction[<span class="number">15</span>], out = writeD);</span><br><span class="line">    DRegister(in = outC ,load = writeD, out = outD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//store A</span></span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = selA, in[<span class="number">1</span>] = selAM, in[<span class="number">2</span>] = selAD, in[<span class="number">3</span>] = selAMD,in[<span class="number">4.</span><span class="number">.7</span>] = <span class="literal">false</span>, out = storeA);</span><br><span class="line">    Mux16(a[<span class="number">15</span>] = <span class="literal">false</span>,a[<span class="number">0.</span><span class="number">.14</span>] = instruction[<span class="number">0.</span><span class="number">.14</span>], b = outC, sel = instruction[<span class="number">15</span>], out = outAddr);</span><br><span class="line">    Or(a = loadA, b = storeA, out = writeA);</span><br><span class="line">    ARegister(in = outAddr, load = writeA, out = Addr,out[<span class="number">0.</span><span class="number">.14</span>] = addressM);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Jump PC</span></span><br><span class="line">    DMux8Way(in = instruction[<span class="number">15</span>],sel = instruction[<span class="number">0.</span><span class="number">.2</span>], a = JNULL, b = JGT, c = JEQ, d = JGE, e = JLT, f = JNE, g = JLE, h = JMP);</span><br><span class="line">    Not(in = outZr, out = notZero);</span><br><span class="line">    Not(in = outNg, out = notNeg);</span><br><span class="line">    And(a = JEQ, b = outZr, out = loadEQ);</span><br><span class="line">    And(a = JNE, b = notZero, out = loadNE);</span><br><span class="line">    And(a = JLT, b = outNg, out = loadLT);</span><br><span class="line">    And(a = JGE, b = notNeg, out = loadGE);</span><br><span class="line">    And(a = notZero, b = notNeg, out = outGT);</span><br><span class="line">    And(a = outGT, b = JGT, out = loadGT);</span><br><span class="line">    Or(a = outZr, b = outNg, out = outLE);</span><br><span class="line">    And(a = outLE, b = JLE, out = loadLE);</span><br><span class="line">    Or8Way(in[<span class="number">0</span>] = loadGT, in[<span class="number">1</span>] = loadEQ, in[<span class="number">2</span>] = loadGE, in[<span class="number">3</span>] = loadLT, in[<span class="number">4</span>] = loadNE, in[<span class="number">5</span>] = loadLE, in[<span class="number">6</span>] = JMP, in[<span class="number">7</span>] = <span class="literal">false</span>, out = loadPC);</span><br><span class="line">    PC(in = Addr,load = loadPC,inc = <span class="literal">true</span>,reset = reset, out[<span class="number">0.</span><span class="number">.14</span>] = pc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul><li><strong>MEMORY</strong><br><strong>memory</strong>部分较为简单，主要是注意到地址信号线的选择计算问题即可。其余的难度不大，基本上是组成原理中学的那套东西。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CHIP Memory &#123;</span><br><span class="line">    IN in[<span class="number">16</span>], load, address[<span class="number">15</span>];</span><br><span class="line">    OUT out[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    PARTS:</span><br><span class="line">    <span class="comment">// Put your code here:</span></span><br><span class="line">    <span class="comment">//load mux</span></span><br><span class="line">    DMux(in = load, sel = address[<span class="number">14</span>] , a = loadram , b = loadmm);</span><br><span class="line">    DMux(in = loadmm, sel = address[<span class="number">13</span>], a = loadscreen, b = loadkeyboard);</span><br><span class="line">    RAM16K(in = in,load = loadram,address = address[<span class="number">0.</span><span class="number">.13</span>] , out = outram);</span><br><span class="line">    Screen(in = in,load = loadscreen,address = address[<span class="number">0.</span><span class="number">.12</span>] , out = outscreen);</span><br><span class="line">    Keyboard(out = outkeyboard);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out mux</span></span><br><span class="line">    Mux16(a = outscreen, b = outkeyboard, sel = address[<span class="number">13</span>], out = outmm);</span><br><span class="line">    Mux16(a = outram, b = outmm, sel = address[<span class="number">14</span>], out = out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="week6-Assembler"><a href="#week6-Assembler" class="headerlink" title="week6 Assembler"></a>week6 Assembler</h2><p>本章的内容其实较为简单，主要是为<code>hack</code>系统编写一个汇编解释器，将汇编语言编译为机器码，其实主要是掌握<code>hack</code>系统的基本指令即可。实际的<code>hack</code>系统中有几种指令和符号系统：</p><ul><li><strong>A</strong>指令： 这个基本的汇编语言主要是以<code>@</code>开头的汇编程序指令解析即可。</li><li><strong>C</strong>指令:  这部分也很容易主要查看是否有<code>;</code>与<code>=</code>即可判断该指令，并且将其分为三个部分，<code>计算</code>、<code>存储</code>、<code>跳转</code>。</li><li><strong>固定符号</strong>: 实际指令执行过程中我们只需要将这些固定标签翻译为特定地址即可。</li></ul><p><img src="https://i.loli.net/2020/09/11/2zXTNlhvWBJEytj.png" alt></p><ul><li><strong>变量符号</strong>: 我们在实际过程运算过程中遇到第一个<code>A</code>指令时，则认为该符号变量的地址。后续的变量地址则固定进行递增即可，按照固定的地址是从<code>16</code>开始。我们检测<code>A</code>指令时遇到的第一个标签。</li><li><strong>跳转标签</strong>: 我们在程序的运行过程中有许多程序的跳转指令，比如跳转到某个固定的指令地址起开始执行，实际即为将<code>PC</code>寄存器的内容修改为跳转地址即可。我们解析时主要解析查看汇编语言中是否存在<code>()</code>即可。</li></ul><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEGBUG_LEVEL 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO_LEVEL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WARNINT_LEVEL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_LEVEL 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ADDR 190000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> START_ADDR_OPEN 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMORY_ADDR_LEN 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> debug = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(<span class="keyword">int</span> level,<span class="built_in">string</span> text)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(debug)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;text&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimSpace</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos1 = s.find_first_not_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos1 != <span class="built_in">string</span>::npos) s.erase(<span class="number">0</span>,pos1);</span><br><span class="line">        <span class="keyword">int</span> pos2 = s.find_last_not_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos) s.erase(pos2+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trimComments</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = s.find_first_of(<span class="string">"//"</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos != <span class="built_in">string</span>::npos) s.erase(pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUpper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isNumber</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">'0'</span> &amp;&amp; s.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isDigit(s[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum = sum*<span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; MAX_ADDR) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkMnemonics</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isUpper(c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">binaryCode</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        ans = to_string(x%<span class="number">2</span>) + ans;</span><br><span class="line">        x = x&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initPredefTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; symbolTable)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*Predefined Symbols*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)&#123;</span><br><span class="line">        symbolTable[<span class="string">"R"</span> + to_string(i)] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    symbolTable[<span class="string">"SP"</span>] = <span class="number">0</span>;</span><br><span class="line">    symbolTable[<span class="string">"LCL"</span>] = <span class="number">1</span>;</span><br><span class="line">    symbolTable[<span class="string">"ARG"</span>] = <span class="number">2</span>;</span><br><span class="line">    symbolTable[<span class="string">"THIS"</span>] = <span class="number">3</span>;</span><br><span class="line">    symbolTable[<span class="string">"THAT"</span>] = <span class="number">4</span>;</span><br><span class="line">    symbolTable[<span class="string">"SCREEN"</span>] = <span class="number">16384</span>;</span><br><span class="line">    symbolTable[<span class="string">"KBD"</span>] = <span class="number">24576</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initJumpTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; jumpTable)</span></span>&#123;</span><br><span class="line">    jumpTable[<span class="string">""</span>] = <span class="string">"000"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JGT"</span>] = <span class="string">"001"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JEQ"</span>] = <span class="string">"010"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JGE"</span>] = <span class="string">"011"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JLT"</span>] = <span class="string">"100"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JNE"</span>] = <span class="string">"101"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JLE"</span>] = <span class="string">"110"</span>;</span><br><span class="line">    jumpTable[<span class="string">"JMP"</span>] = <span class="string">"111"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDestTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; destTable)</span></span>&#123;</span><br><span class="line">    destTable[<span class="string">""</span>] = <span class="string">"000"</span>;</span><br><span class="line">    destTable[<span class="string">"M"</span>] = <span class="string">"001"</span>;</span><br><span class="line">    destTable[<span class="string">"D"</span>] = <span class="string">"010"</span>;</span><br><span class="line">    destTable[<span class="string">"MD"</span>] = <span class="string">"011"</span>;</span><br><span class="line">    destTable[<span class="string">"A"</span>] = <span class="string">"100"</span>;</span><br><span class="line">    destTable[<span class="string">"AM"</span>] = <span class="string">"101"</span>;</span><br><span class="line">    destTable[<span class="string">"AD"</span>] = <span class="string">"110"</span>;</span><br><span class="line">    destTable[<span class="string">"AMD"</span>] = <span class="string">"111"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initCompTable</span><span class="params">(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; &amp; compTable)</span></span>&#123;</span><br><span class="line">    compTable[<span class="string">"0"</span>]   = <span class="string">"0101010"</span>;</span><br><span class="line">    compTable[<span class="string">"1"</span>]   = <span class="string">"0111111"</span>;</span><br><span class="line">    compTable[<span class="string">"-1"</span>]  = <span class="string">"0111010"</span>;</span><br><span class="line">    compTable[<span class="string">"D"</span>]   = <span class="string">"0001100"</span>;</span><br><span class="line">    compTable[<span class="string">"A"</span>]   = <span class="string">"0110000"</span>;</span><br><span class="line">    compTable[<span class="string">"M"</span>]   = <span class="string">"1110000"</span>;</span><br><span class="line">    compTable[<span class="string">"!D"</span>]  = <span class="string">"0001101"</span>;</span><br><span class="line">    compTable[<span class="string">"!A"</span>]  = <span class="string">"0110001"</span>;</span><br><span class="line">    compTable[<span class="string">"!M"</span>]  = <span class="string">"1110001"</span>;</span><br><span class="line">    compTable[<span class="string">"-D"</span>]  = <span class="string">"0001111"</span>;</span><br><span class="line">    compTable[<span class="string">"-A"</span>]  = <span class="string">"0110011"</span>;</span><br><span class="line">    compTable[<span class="string">"-M"</span>]  = <span class="string">"1110011"</span>;</span><br><span class="line">    compTable[<span class="string">"D+1"</span>] = <span class="string">"0011111"</span>;</span><br><span class="line">    compTable[<span class="string">"A+1"</span>] = <span class="string">"0110111"</span>;</span><br><span class="line">    compTable[<span class="string">"M+1"</span>] = <span class="string">"1110111"</span>;</span><br><span class="line">    compTable[<span class="string">"D-1"</span>] = <span class="string">"0001110"</span>;</span><br><span class="line">    compTable[<span class="string">"A-1"</span>] = <span class="string">"0110010"</span>;</span><br><span class="line">    compTable[<span class="string">"M-1"</span>] = <span class="string">"1110010"</span>;</span><br><span class="line">    compTable[<span class="string">"D+A"</span>] = <span class="string">"0000010"</span>;</span><br><span class="line">    compTable[<span class="string">"D+M"</span>] = <span class="string">"1000010"</span>;</span><br><span class="line">    compTable[<span class="string">"D-A"</span>] = <span class="string">"0010011"</span>;</span><br><span class="line">    compTable[<span class="string">"D-M"</span>] = <span class="string">"1010011"</span>;</span><br><span class="line">    compTable[<span class="string">"A-D"</span>] = <span class="string">"0000111"</span>;</span><br><span class="line">    compTable[<span class="string">"M-D"</span>] = <span class="string">"1000111"</span>;</span><br><span class="line">    compTable[<span class="string">"D&amp;A"</span>] = <span class="string">"0000000"</span>;</span><br><span class="line">    compTable[<span class="string">"D&amp;M"</span>] = <span class="string">"1000000"</span>;</span><br><span class="line">    compTable[<span class="string">"D|A"</span>] = <span class="string">"0010101"</span>;</span><br><span class="line">    compTable[<span class="string">"D|M"</span>] = <span class="string">"1010101"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">    ifstream fin;</span><br><span class="line">    ofstream fout;</span><br><span class="line">    <span class="keyword">int</span> currAddr = START_ADDR_OPEN;</span><br><span class="line">    <span class="keyword">int</span> currLine = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;  symbolTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;   labelTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; jumpTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; destTable;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt; compTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*initial symbol table*/</span></span><br><span class="line">    initPredefTable(symbolTable);</span><br><span class="line">    initJumpTable(jumpTable);</span><br><span class="line">    initDestTable(destTable);</span><br><span class="line">    initCompTable(compTable);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        trace(ERROR_LEVEL,<span class="string">"Wrong File, Bad parameter.\n\r"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fin.open(argv[<span class="number">1</span>],<span class="built_in">std</span>::ifstream::in);</span><br><span class="line">    fout.open(argv[<span class="number">2</span>],<span class="built_in">std</span>::ifstream::out);</span><br><span class="line">    <span class="keyword">if</span>(!fin||!fout)&#123;</span><br><span class="line">        trace(ERROR_LEVEL,<span class="string">"Wrong File, Bad parameter.\n\r"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*read assembler program from file*/</span></span><br><span class="line">    <span class="comment">/*parse label*/</span></span><br><span class="line">    <span class="built_in">string</span> assembler;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; assemblerArr;</span><br><span class="line">    <span class="keyword">while</span>(getline(fin,assembler))&#123;</span><br><span class="line">        trimComments(assembler); <span class="comment">// trim comments</span></span><br><span class="line">        trimSpace(assembler); <span class="comment">//trim space</span></span><br><span class="line">        <span class="keyword">if</span>(assembler.empty() || assembler.size() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(assembler[<span class="number">0</span>] == <span class="string">'('</span>)&#123;</span><br><span class="line">            <span class="comment">/*parse Label*/</span></span><br><span class="line">            <span class="keyword">if</span>(assembler.back() != <span class="string">')'</span>)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need right ')'.\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(assembler.size() &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, label can not be empty!\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">string</span> label = assembler.substr(<span class="number">1</span>,assembler.size()<span class="number">-2</span>);</span><br><span class="line">            labelTable[label] = currLine;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            assemblerArr.push_back(assembler);</span><br><span class="line">            currLine++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : assemblerArr)&#123;</span><br><span class="line">        <span class="comment">/*parse A instruction*/</span></span><br><span class="line">        <span class="built_in">string</span> instruction;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="string">'@'</span>)&#123;</span><br><span class="line">            instruction = <span class="string">"0"</span>;</span><br><span class="line">            <span class="built_in">string</span> var = v.substr(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> address = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isNumber(var))&#123;</span><br><span class="line">                address = stoi(var);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(symbolTable.count(var))&#123;</span><br><span class="line">                    address = symbolTable[var];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(labelTable.count(var))&#123;</span><br><span class="line">                    address = labelTable[var];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    address = currAddr++;</span><br><span class="line">                    symbolTable[var] = address;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instruction += binaryCode(address,MEMORY_ADDR_LEN);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/*parse C instruction*/</span></span><br><span class="line">            instruction = <span class="string">"111"</span>;</span><br><span class="line">            <span class="built_in">string</span> dest = <span class="string">""</span>;</span><br><span class="line">            <span class="built_in">string</span> comp = <span class="string">""</span>;</span><br><span class="line">            <span class="built_in">string</span> jump = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pos1 = v.find_first_of(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">int</span> pos2 = v.find_first_of(<span class="string">"="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos &amp;&amp; pos2 == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need the right command!\n\r"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                jump = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    dest = v.substr(<span class="number">0</span>,pos2);</span><br><span class="line">                    comp = v.substr(pos2+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                jump = v.substr(pos1+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(pos2 != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    dest = v.substr(<span class="number">0</span>,pos2);</span><br><span class="line">                    comp = v.substr(pos2+<span class="number">1</span>,pos1-pos2<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    comp = v.substr(<span class="number">0</span>,pos1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!jumpTable.count(jump)||</span><br><span class="line">               !compTable.count(comp)||</span><br><span class="line">               !destTable.count(dest))&#123;</span><br><span class="line">                   trace(ERROR_LEVEL,<span class="string">"Wrong Assembler, we need the right command!\n\r"</span>);</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            instruction += compTable[comp] + destTable[dest] + jumpTable[jump];</span><br><span class="line">        &#125;</span><br><span class="line">        fout&lt;&lt;instruction&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fin.close();</span><br><span class="line">    fout.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p><code>build a computer</code>该课程上半部分已经全部学完了，总的来说课程还是非常有意思，比本科时上的计算机组成原理有意思多了。还是有很多让人回味的地方，下半部分的课程主要是讲<code>虚拟机</code>,<code>编程语言</code>,<code>编译器</code>,<code>操作系统</code>等纯软件的部分。总的课程还是非常适合计算机专业或者非计算机专业认真学习的，计划在后续的两个月内完成下半部分的课程，主要是写代码较多，<code>project</code>的难度较大。</p><ul><li>后期准备将所有的<code>project</code>用<code>logsim</code>全部重新写一遍。</li><li>扩展ALU的功能，能够实现移位器、乘法器、浮点运算器的实现。</li><li>扩展<code>hack</code>汇编程序，实现基本的支持浮点运算器、移位操作、乘法操作的语言。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course&quot;&gt;&lt;a href=&quot;#Build-a-Modern-Computer-from-First-Principles-Nand-to-Tetris-Part-I-project-centered-course&quot; class=&quot;headerlink&quot; title=&quot;Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)&quot;&gt;&lt;/a&gt;Build a Modern Computer from First Principles: Nand to Tetris Part I (project-centered course)&lt;/h1&gt;&lt;p&gt;$~~~~$接触到这门课程是在知乎上有人强烈推荐的，感觉这种靠谱的课程特别是有意义。网上搜了下背景资料，似乎这门课程是给哈佛大学的本科生开的课程，我是在工作之余陆陆续续的将这门课程的上半部分学完了，每周差不多要花上至少三个小时，后面的project还是非常有意思的。这门课程上半部分主要是讲如何从最基本的与非门搭建成一个完成的计算机，下半部分主要是讲在自己搭建的计算机上如何实现虚拟机、高级语言编译器、操作系统等等相关的课程。总的来说课程还是非常有意思的，特别适合稍微有计算机基础的人士来学这门课程，这门课程的前置课程是哈佛大学的&lt;code&gt;cs101&lt;/code&gt;计算机基础课程。在学习的过程中确实有几个&lt;code&gt;project&lt;/code&gt;还是需要费点时间和精力来理解该课程。我觉得最爽的是课程的&lt;code&gt;project&lt;/code&gt;，含金量非常高了，主要是有兴趣，各种&lt;code&gt;project&lt;/code&gt;的难度适中，并且非常有意思。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公开课" scheme="http://yoursite.com/categories/%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    
    
      <category term="coursera" scheme="http://yoursite.com/tags/coursera/"/>
    
  </entry>
  
  <entry>
    <title>【AtCoder】 Contest177</title>
    <link href="http://yoursite.com/2020/08/31/198/"/>
    <id>http://yoursite.com/2020/08/31/198/</id>
    <published>2020-08-31T07:55:56.959Z</published>
    <updated>2020-09-04T04:48:07.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="abc177"><a href="#abc177" class="headerlink" title="abc177"></a>abc177</h1><p><code>atcoder</code>的题目适合初学者，且大部分为数学技巧，还是质量非常高，感觉比<code>cf</code>难度小多了。<br>但是对于实际做题来说，还是非常喜欢atcoder这种风格，主要有以下几个有点。</p><ul><li>题目不罗嗦，就是那么几句话就可以交代清楚了，好多题目啰里啰唆的一大堆才看明白题目。最烦某些OJ的题目一大堆废话，才能看明白题目，纯粹浪费时间。</li><li>题目质量非常高，代码较为精简，因为平时根本没有时间来练习哪些耗费时间的题目。</li><li>时区的问题，日本的时差与中国的时差基本上没有太大区别，<code>atcoder</code>的contest刚好是在周六和周日晚上八点，刚好符合自己的作息习惯，平时根本没有时间来刷题，刚好可以利用这两个时间段好好练习来提高自己的算法能力。</li></ul><a id="more"></a><h2 id="C-Sum-of-product-of-pairs"><a href="#C-Sum-of-product-of-pairs" class="headerlink" title="C - Sum of product of pairs"></a>C - Sum of product of pairs</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200831155743.png" alt="1"></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_c" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_c</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口实现</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接求出前缀和即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; prefix(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        prefix[i] = (prefix[i<span class="number">-1</span>] + arr[i<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        ans = (ans + (arr[i<span class="number">-1</span>]*(prefix[n] - prefix[i] + mod)%mod))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="D-Friends"><a href="#D-Friends" class="headerlink" title="D - Friends"></a>D - Friends</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200902173858.png" alt="2"></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_d</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>非常简单的DSU，求最大的集合的数目即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dsu</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dsu(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        parent = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>-&gt;sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(y);</span><br><span class="line">        <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[x1] &gt; sz[y1])&#123;</span><br><span class="line">            parent[y1] = x1;</span><br><span class="line">            sz[x1] += sz[y1];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent[x1] = y1;</span><br><span class="line">            sz[y1] += sz[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;sz[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">Dsu <span class="title">du</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        du.uni(x<span class="number">-1</span>,y<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> p = du.find(i);</span><br><span class="line">        ans = max(ans,du.length(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="E-Coprime-Editorial"><a href="#E-Coprime-Editorial" class="headerlink" title="E - Coprime Editorial"></a>E - Coprime Editorial</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200902174103.png" alt="3"></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_e" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_e</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>快速素因子筛选</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>直接求pairwise时肯定会超时。我们需要换种思路。</li><li>求出所有从$(i+1,n)$的素数因子集合，如何当前数<code>A[i]</code>的质因子中存在与集合中重复的数，则仍该该序列不为<code>pairwise</code>.</li><li>可以用到快速的最小质因子筛选，在<code>O(n)</code>的时间复杂度内完成。</li><li>我们对每个元素进行质因子分解，时间复杂度为<code>O(lgn)</code>.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ll factor[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(factor,<span class="number">0</span>,<span class="keyword">sizeof</span>(factor));</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= MAXN; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(factor[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        factor[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(ll j = i*i; j &lt; MAXN; j += i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(factor[j] == <span class="number">0</span>) factor[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 求所有的数的最小质因子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; exists;</span><br><span class="line">    <span class="keyword">bool</span> pairwise = <span class="literal">true</span>;</span><br><span class="line">    ll setwise = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; curFact;</span><br><span class="line">        ll now = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll sml = factor[now];</span><br><span class="line">            <span class="keyword">if</span> (curFact.empty() || curFact.back() != sml) curFact.push_back(sml);</span><br><span class="line">            now /= sml;</span><br><span class="line">        &#125;<span class="comment">//求出该数的所有不同的质因子。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f: curFact) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exists.count(f)) pairwise = <span class="literal">false</span>;</span><br><span class="line">            exists.insert(f);</span><br><span class="line">        &#125;<span class="comment">//如果该数所有的质因子与现有的质因子集合存在交集。</span></span><br><span class="line">        setwise = __gcd(setwise,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pairwise)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setwise == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"setwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not coprime\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="F-I-hate-Shortest-Path-Problem"><a href="#F-I-hate-Shortest-Path-Problem" class="headerlink" title="F - I hate Shortest Path Problem"></a>F - I hate Shortest Path Problem</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200904124742.png" alt="5"></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc177/tasks/abc177_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc177/tasks/abc177_f</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>线段树</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>直接求pairwise时肯定会超时。我们需要换种思路。</li><li>求出所有从$(i+1,n)$的素数因子集合，如何当前数<code>A[i]</code>的质因子中存在与集合中重复的数，则仍该该序列不为<code>pairwise</code>.</li><li>可以用到快速的最小质因子筛选，在<code>O(n)</code>的时间复杂度内完成。</li><li>我们对每个元素进行质因子分解，时间复杂度为<code>O(lgn)</code>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll MAXN = <span class="number">1e6</span>+<span class="number">1</span>;</span><br><span class="line">ll factor[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; arr(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(factor,<span class="number">0</span>,<span class="keyword">sizeof</span>(factor));</span><br><span class="line">    <span class="keyword">for</span>(ll i = <span class="number">2</span>; i &lt;= MAXN; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(factor[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        factor[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(ll j = i*i; j &lt; MAXN; j += i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(factor[j] == <span class="number">0</span>) factor[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 求所有的数的最小质因子</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; exists;</span><br><span class="line">    <span class="keyword">bool</span> pairwise = <span class="literal">true</span>;</span><br><span class="line">    ll setwise = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ll&gt; curFact;</span><br><span class="line">        ll now = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (now &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ll sml = factor[now];</span><br><span class="line">            <span class="keyword">if</span> (curFact.empty() || curFact.back() != sml) curFact.push_back(sml);</span><br><span class="line">            now /= sml;</span><br><span class="line">        &#125;<span class="comment">//求出该数的所有不同的质因子。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f: curFact) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exists.count(f)) pairwise = <span class="literal">false</span>;</span><br><span class="line">            exists.insert(f);</span><br><span class="line">        &#125;<span class="comment">//如果该数所有的质因子与现有的质因子集合存在交集。</span></span><br><span class="line">        setwise = __gcd(setwise,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pairwise)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pairwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setwise == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"setwise coprime\n"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"not coprime\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;abc177&quot;&gt;&lt;a href=&quot;#abc177&quot; class=&quot;headerlink&quot; title=&quot;abc177&quot;&gt;&lt;/a&gt;abc177&lt;/h1&gt;&lt;p&gt;&lt;code&gt;atcoder&lt;/code&gt;的题目适合初学者，且大部分为数学技巧，还是质量非常高，感觉比&lt;code&gt;cf&lt;/code&gt;难度小多了。&lt;br&gt;但是对于实际做题来说，还是非常喜欢atcoder这种风格，主要有以下几个有点。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;题目不罗嗦，就是那么几句话就可以交代清楚了，好多题目啰里啰唆的一大堆才看明白题目。最烦某些OJ的题目一大堆废话，才能看明白题目，纯粹浪费时间。&lt;/li&gt;
&lt;li&gt;题目质量非常高，代码较为精简，因为平时根本没有时间来练习哪些耗费时间的题目。&lt;/li&gt;
&lt;li&gt;时区的问题，日本的时差与中国的时差基本上没有太大区别，&lt;code&gt;atcoder&lt;/code&gt;的contest刚好是在周六和周日晚上八点，刚好符合自己的作息习惯，平时根本没有时间来刷题，刚好可以利用这两个时间段好好练习来提高自己的算法能力。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Facebook Hacker Cup】 2020 Qual</title>
    <link href="http://yoursite.com/2020/08/31/197/"/>
    <id>http://yoursite.com/2020/08/31/197/</id>
    <published>2020-08-31T07:41:53.748Z</published>
    <updated>2020-08-31T07:44:12.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="facebook-hacker-cup-quality-round"><a href="#facebook-hacker-cup-quality-round" class="headerlink" title="facebook hacker cup quality round"></a>facebook hacker cup quality round</h1><p><code>facebook hacker cup</code>比赛还是挺有意思的，前面几轮题目质量还是非常高，正规的比赛题目还是非常的不错。<code>quality round</code>题目就非常容易了，几乎是<code>leetcode medium</code>难度的水平。</p><h2 id="5185-Problem-A-Travel-Restrictions"><a href="#5185-Problem-A-Travel-Restrictions" class="headerlink" title="5185. Problem A: Travel Restrictions"></a>5185. Problem A: Travel Restrictions</h2><a id="more"></a><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定连续的航班，给定航站的规则，需要按照以下规则来进行飞行。</p><ul><li><code>in[i] = Y</code>表示第<code>i</code>个航站可以允许飞机进入，<code>in[i] = N</code>表示第<code>i</code>个航站禁止飞机进入，</li><li><code>out[i] = Y</code>表示第<code>i</code>个航站可以允许飞机飞出，<code>out[i] = N</code>表示第<code>i</code>个航站禁止飞机飞出。<br>给出所有航站的规则，求出所有航站的之间的飞行是否可达，用矩阵表示。</li></ul><p><strong>Sample Input</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">YY</span><br><span class="line">YY</span><br><span class="line"><span class="number">2</span></span><br><span class="line">NY</span><br><span class="line">YY</span><br><span class="line"><span class="number">2</span></span><br><span class="line">NN</span><br><span class="line">YY</span><br><span class="line"><span class="number">5</span></span><br><span class="line">YNNYY</span><br><span class="line">YYYNY</span><br><span class="line"><span class="number">10</span></span><br><span class="line">NYYYNNYYYY</span><br><span class="line">YYNYYNYYNY</span><br></pre></td></tr></table></figure><br><strong>Sample Output</strong><br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Case</span> <span class="meta">#1:</span></span><br><span class="line">YY</span><br><span class="line">YY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#2:</span></span><br><span class="line">YY</span><br><span class="line">NY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#3:</span></span><br><span class="line">YN</span><br><span class="line">NY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#4:</span></span><br><span class="line">YNNNN</span><br><span class="line">YYNNN</span><br><span class="line">NNYYN</span><br><span class="line">NNNYN</span><br><span class="line">NNNYY</span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#5:</span></span><br><span class="line">YYYNNNNNNN</span><br><span class="line">NYYNNNNNNN</span><br><span class="line">NNYNNNNNNN</span><br><span class="line">NNYYNNNNNN</span><br><span class="line">NNYYYNNNNN</span><br><span class="line">NNNNNYNNNN</span><br><span class="line">NNNNNNYYYN</span><br><span class="line">NNNNNNYYYN</span><br><span class="line">NNNNNNNNYN</span><br><span class="line">NNNNNNNNYY</span><br></pre></td></tr></table></figure></p><ul><li><code>1 ≤ T ≤ 100</code></li><li><code>2 ≤ N ≤ 50</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/A" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/A</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目要求的最优时间复杂度应该为<code>O(n^2)</code>。</li><li>我们可以求出飞机从航站<code>i</code>向右飞行和向左飞行的最大距离。当坚持能否从<code>i</code>飞向<code>j</code>时，判断<code>j</code>是否在航站<code>i</code>的飞行范围内即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"a.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"a.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> in,out;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line">        fin&gt;&gt;in;</span><br><span class="line">        fin&gt;&gt;out;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrive_left(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrive_right(n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxl = i;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="string">'Y'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(in[j] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(out[j] == <span class="string">'N'</span>)&#123;</span><br><span class="line">                        maxl = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxl = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrive_left[i] = maxl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> minr = i;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="string">'Y'</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(in[j] == <span class="string">'N'</span>) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">if</span>(out[j] == <span class="string">'N'</span>)&#123;</span><br><span class="line">                        minr = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    minr = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arrive_right[i] = minr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arrive_left[i] &gt;= j) fout&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">                    <span class="keyword">else</span> fout&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arrive_right[i] &lt;= j) fout&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">                    <span class="keyword">else</span> fout&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fout&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-B-Alchemy"><a href="#Problem-B-Alchemy" class="headerlink" title="Problem B: Alchemy"></a>Problem B: Alchemy</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给定连续数目的单元，每个单元的颜色要么时<code>A</code>,要么是<code>B</code>,每次连续的三个相邻的单元可以进行合并，合并的规则要求是三个单元格不能为相同的颜色，合并后的单元格的颜色与三个单元中颜色最多的单元颜色保持一致。求该数组能否最终合并成一个单元。</p><p><strong>Input</strong><br>Input begins with an integer TT, the number of Philosopher’s Stones that Edgar tries to reconstitute. For each stone there are two lines. The first contains the integer NN. The second contains the length-NN string C_{1..N}C<br>1..N.<br><strong>Output</strong><br>For the iith stone, output a line containing “Case #i: “ followed by a single character, either “Y” if it’s possible For Edgar to end up with the Philosopher’s Stone, or “N” if not.</p><p><strong>Sample Input</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">BAB</span><br><span class="line"><span class="number">3</span></span><br><span class="line">BBB</span><br><span class="line"><span class="number">5</span></span><br><span class="line">AABBA</span><br><span class="line"><span class="number">7</span></span><br><span class="line">BAAABAA</span><br><span class="line"><span class="number">11</span></span><br><span class="line">BBBAABAAAAB</span><br><span class="line"><span class="number">11</span></span><br><span class="line">BABBBABBABB</span><br></pre></td></tr></table></figure><br><strong>Sample Output</strong><br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Case</span> <span class="meta">#1: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#2: N</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#3: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#4: N</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#5: Y</span></span><br><span class="line"><span class="keyword">Case</span> <span class="meta">#6: N</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/B" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/B</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目实际蛮长，其实很简单，因为每次三个单元格合并成一个单元，数量上肯定是减少了1对<code>A,B</code>.</li><li>最终情况下，就是颜色为<code>A</code>的单元数量与颜色为<code>B</code>的单元数量的绝对值之差为<code>1</code>，如果满足这个条件即可完成最终合并，否则则不可以。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"b.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"b.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">string</span> in;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line">        fin&gt;&gt;in;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[a] == <span class="string">'A'</span>) a++;</span><br><span class="line">            <span class="keyword">else</span> b++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"N"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Y"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-C-Timber"><a href="#Problem-C-Timber" class="headerlink" title="Problem C: Timber"></a>Problem C: Timber</h2><p>第<code>i</code>棵树的坐标为<code>P[i]</code>,高度为<code>H[i]</code>,树可以向左倒也可以向右倒，如果向左倒，则形成了区间$[P[i] - H[i],P[i]]$,如果向右倒，则形成了区间$[P[i],P[i] + H[i]]$,求问给定的序列中，能够形成连续且不相交的最长区间的长度。</p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/C" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/C</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>dp</code>，设<code>dp[x]</code>代表右边终点为<code>x</code>的最长区间长度。</li><li>每次加入第<code>i</code>棵树后，形成的最长区间区间的递推公式为:<script type="math/tex; mode=display">dp[P[i]+ H[i]] = max(dp[P[i]+ H[i]],dp[P[i]] + H[i]) \\dp[P[i]] = max(dp[P[i]],dp[P[i]-H[i]] + H[i]) \\</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ios_base::sync_with_stdio(<span class="literal">false</span>), <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T; </span><br><span class="line">    <span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"c.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"c.out"</span>)</span></span>;</span><br><span class="line">    fin &gt;&gt; T;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> case_num = <span class="number">1</span>; case_num &lt;= T; case_num ++) &#123;</span><br><span class="line">        fout &lt;&lt; <span class="string">"Case #"</span> &lt;&lt; case_num &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        fin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p,h;</span><br><span class="line">            fin&gt;&gt;p&gt;&gt;h;</span><br><span class="line">            arr.emplace_back(make_pair(p,h));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[i].first;</span><br><span class="line">            <span class="keyword">int</span> h = arr[i].second;</span><br><span class="line">            dp[p+h] = dp[p] + h;</span><br><span class="line">            dp[p] = dp[p-h] + h;</span><br><span class="line">            ans = max(ans,dp[p+h]);</span><br><span class="line">            ans = max(ans,dp[p]);</span><br><span class="line">        &#125;</span><br><span class="line">        fout&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-D1-Running-on-Fumes-Chapter-1"><a href="#Problem-D1-Running-on-Fumes-Chapter-1" class="headerlink" title="Problem D1: Running on Fumes - Chapter 1"></a>Problem D1: Running on Fumes - Chapter 1</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>该题应该是<code>leetcode</code>上的原始题目，非常简单。汽车加油的行程问题。</p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D1" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D1</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>典型的dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该汽车加油从<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Problem-D2-Running-on-Fumes-Chapter-2"><a href="#Problem-D2-Running-on-Fumes-Chapter-2" class="headerlink" title="Problem D2: Running on Fumes - Chapter 2"></a>Problem D2: Running on Fumes - Chapter 2</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D2" target="_blank" rel="noopener">https://www.facebook.com/codingcompetitions/hacker-cup/2020/qualification-round/problems/D2</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;facebook-hacker-cup-quality-round&quot;&gt;&lt;a href=&quot;#facebook-hacker-cup-quality-round&quot; class=&quot;headerlink&quot; title=&quot;facebook hacker cup quality round&quot;&gt;&lt;/a&gt;facebook hacker cup quality round&lt;/h1&gt;&lt;p&gt;&lt;code&gt;facebook hacker cup&lt;/code&gt;比赛还是挺有意思的，前面几轮题目质量还是非常高，正规的比赛题目还是非常的不错。&lt;code&gt;quality round&lt;/code&gt;题目就非常容易了，几乎是&lt;code&gt;leetcode medium&lt;/code&gt;难度的水平。&lt;/p&gt;&lt;h2 id=&quot;5185-Problem-A-Travel-Restrictions&quot;&gt;&lt;a href=&quot;#5185-Problem-A-Travel-Restrictions&quot; class=&quot;headerlink&quot; title=&quot;5185. Problem A: Travel Restrictions&quot;&gt;&lt;/a&gt;5185. Problem A: Travel Restrictions&lt;/h2&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="facebook hacker cup" scheme="http://yoursite.com/tags/facebook-hacker-cup/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 204周周赛</title>
    <link href="http://yoursite.com/2020/08/30/196/"/>
    <id>http://yoursite.com/2020/08/30/196/</id>
    <published>2020-08-30T06:48:11.630Z</published>
    <updated>2020-08-30T07:09:53.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="204场周赛"><a href="#204场周赛" class="headerlink" title="204场周赛"></a>204场周赛</h1><p>周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png" alt="1"></p><h2 id="5499-重复至少-K-次且长度为-M-的模式"><a href="#5499-重复至少-K-次且长度为-M-的模式" class="headerlink" title="5499. 重复至少 K 次且长度为 M 的模式"></a>5499. 重复至少 K 次且长度为 M 的模式</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为<code>m</code>且在数组中至少重复<code>k</code>次的模式。</p><a id="more"></a><p>模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。</p><p>如果数组中存在至少重复 <code>k</code> 次且长度为<code>m</code>的模式，则返回 <code>true</code>，否则返回  <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], m = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">4</span>) 的长度为 <span class="number">1</span> ，且连续重复 <span class="number">4</span> 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，且连续重复 <span class="number">2</span> 次。另一个符合题意的模式是 (<span class="number">2</span>,<span class="number">1</span>) ，同样重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，但是只连续重复 <span class="number">2</span> 次。不存在长度为 <span class="number">2</span> 且至少重复 <span class="number">3</span> 次的模式。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 出现 <span class="number">2</span> 次但并不连续，所以不能算作连续重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：长度为 <span class="number">2</span> 的模式只有 (<span class="number">2</span>,<span class="number">2</span>) ，但是只连续重复 <span class="number">2</span> 次。注意，不能计算重叠的重复次数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较坑，直接暴力三重循环搞定，就是太容易出错了。第一题就搞了20分钟，意外的蛋疼。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsPattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span> &amp;&amp; m &lt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+m*k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+m; j &lt; i+m*k; j = j + m)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j + m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] != arr[i+k-j])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!valid) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5500-乘积为正数的最长子数组长度"><a href="#5500-乘积为正数的最长子数组长度" class="headerlink" title="5500. 乘积为正数的最长子数组长度"></a>5500. 乘积为正数的最长子数组长度</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p>示例  1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：数组本身乘积就是正数，值为 <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长乘积为正数的子数组为 [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>] ，乘积为 <span class="number">6</span> 。</span><br><span class="line">注意，我们不能把 <span class="number">0</span> 也包括到子数组中，因为这样乘积为 <span class="number">0</span> ，不是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：乘积为正数的最长子数组是 [<span class="number">-1</span>,<span class="number">-2</span>] 或者 [<span class="number">-2</span>,<span class="number">-3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">-6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前整数和负数的统计个数和第一次出现负数的位置，<code>posnum</code>和<code>negnum</code>。遇到整数是<code>posnum+1</code>,遇到负数时<code>negnum+1</code>.</li><li>假设当前的数不为<code>0</code>,如果当前统计负数的个数为偶数，以当前数为结尾的最长长度为$posnum+negnum$;如果当前统计负数的个数为奇数，则我们应当从第一个负数后面开始计算长度，以当前数为结尾的最长长度为$i-firstneg$。</li><li>如果当前的数为<code>0</code>，则我们将<code>posnum</code>和<code>negnum</code>、<code>firstneg</code>全部置为初始状态。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first_neg = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                pos += nums[i] &gt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                neg += nums[i] &lt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(neg%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,pos + neg);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(first_neg &gt;= <span class="number">0</span>) ans = max(ans,i-first_neg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(first_neg &lt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) first_neg = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos  = <span class="number">0</span>;</span><br><span class="line">                neg  = <span class="number">0</span>;</span><br><span class="line">                first_neg = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5501-使陆地分离的最少天数"><a href="#5501-使陆地分离的最少天数" class="headerlink" title="5501. 使陆地分离的最少天数"></a>5501. 使陆地分离的最少天数</h2><p>给你一个由若干 <code>0</code> 和 <code>1</code>组成的二维网格 <code>grid</code>，其中 <code>0</code>表示水，而<code>1</code>表示陆地。岛屿由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p><p>如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。</p><p>一天内，可以将任何单个陆地单元<code>（1）</code>更改为水单元<code>（0）</code>。</p><p>返回使陆地分离的最少天数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/1926_island.png" alt="2"><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少需要 2 天才能得到分离的陆地。</span><br><span class="line">将陆地 grid[<span class="string">1</span>][<span class="symbol">1</span>] 和 grid[<span class="string">0</span>][<span class="symbol">2</span>] 更改为水，得到两个分离的岛屿。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果网格中都是水，也认为是分离的 (<span class="string">[[1,1]]</span> -&gt; <span class="string">[[0,0]]</span>)，<span class="number">0</span> 岛屿。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 30</code></li><li><code>grid[i][j]</code>为 <code>0</code>或 <code>1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这题在比赛的时候没有做出来，最后看了答案感觉好简单，还是思路不对。</li><li>首先如果题目中的岛屿的数目不为<code>1</code>，则直接返回<code>0</code>即可。其次按照实际的情况下，我们最多只需要去掉<code>2</code>个单元，一定能够使得岛屿进行分离。我们查看岛屿是否存在关键节点，如果存在关键节点，如果存在关键节点，则只需要去掉一个单元即可。</li><li>检查关键节点的方法有很多，比如可以使用<code>tarjan</code>查找强连通分量或者直接暴力检查去掉某个单元后，岛屿会被会被划分成多个即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> visit[<span class="number">31</span>][<span class="number">31</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line">        <span class="keyword">int</span> island = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[i][j] &amp;&amp; grid[i][j])&#123;</span><br><span class="line">                    island++;</span><br><span class="line">                    qu.push(i*col+j);</span><br><span class="line">                    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                        qu.pop();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                            <span class="keyword">int</span> x = curr/col + d[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="keyword">int</span> y = curr%col + d[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col)&#123;</span><br><span class="line">                                <span class="keyword">if</span>(!visit[x][y] &amp;&amp; grid[x][y])&#123;</span><br><span class="line">                                    qu.push(x*col+y);</span><br><span class="line">                                    visit[x][y] = <span class="number">1</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bfs(grid) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(bfs(grid) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, sz, dfn, low;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> children = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                children++;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span> &amp;&amp; children &gt;= <span class="number">2</span>)</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dfn[u])</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v != p)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[u] == u ? u : p[u] = find(p[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u), pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[pu] &gt;= sz[pv]) &#123;</span><br><span class="line">            p[pv] = pu;</span><br><span class="line">            sz[pu] += sz[pv];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[pu] = pv;</span><br><span class="line">            sz[pv] += sz[pu];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> N = n * m;</span><br><span class="line">        p = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>);</span><br><span class="line">        sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = N;</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!grid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = i * m + j;</span><br><span class="line">                <span class="keyword">if</span> (p[u] == <span class="number">-1</span>)</span><br><span class="line">                    p[u] = u;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dy[k], nj = j + dx[k];</span><br><span class="line">                    <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= n || nj &lt; <span class="number">0</span> || nj &gt;= m || !grid[ni][nj])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = ni * m + nj;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (p[v] == <span class="number">-1</span>)</span><br><span class="line">                        p[v] = v;</span><br><span class="line">                    connect(u, v);</span><br><span class="line">                    adj[u].emplace_back(v);</span><br><span class="line">                    adj[v].emplace_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span> &amp;&amp; i == find(i))</span><br><span class="line">                components++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (components &gt;= <span class="number">2</span> || components == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                dfn = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                low = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                tarjan(i, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5502-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#5502-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="5502. 将子数组重新排序得到同一个二叉查找树的方案数"></a>5502. 将子数组重新排序得到同一个二叉查找树的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>nums</code>表示 <code>1</code> 到 <code>n</code>的一个排列。我们按照元素在 <code>nums</code>中的顺序依次插入一个初始为空的二叉查找树（<code>BST</code>）。请你统计将 <code>nums</code> 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 <code>nums</code> 原本数字顺序得到的二叉查找树相同。</p><p>比方说，给你 <code>nums = [2,1,3]</code>，我们得到一棵 <code>2</code>为根，<code>1</code> 为左孩子，<code>3</code> 为右孩子的树。数组 <code>[2,3,1]</code> 也能得到相同的 <code>BST</code>，但<code>[3,2,1]</code>会得到一棵不同的 <code>BST</code> 。</p><p>请你返回重排<code>nums</code> 后，与原数组 <code>nums</code>得到相同二叉查找树的方案数。</p><p>由于答案可能会很大，请将结果对 <code>10^9 + 7</code>取余数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们将 nums 重排， [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：下面 <span class="number">5</span> 个数组会得到相同的 BST：</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有别的排列顺序能得到相同的 BST 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/abc.png" alt="5"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">19</span></span><br></pre></td></tr></table></figure><br>示例  5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">216212978</span></span><br><span class="line">解释：得到相同 BST 的方案数是 <span class="number">3216212999</span>。将它对 <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span> 取余后得到 <span class="number">216212978</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>nums</code> 中所有数 互不相同 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>排列组合加递归</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的相当好，难度适中，有一定的思考技巧，并且特别有意思。考察基本的数学知识。</li><li>首先我们发现题意的本身要对<code>BST</code>的基本知识要有所了解，对于<code>BST</code>的插入操作时，即每次比根节点大，则插入到节点的右子树，如果比根节点小则插入到节点的左子树。我们知道如果保持根节点不变，且保证左右子树的相对前后顺序，右子树的相对顺序即比根节点大的元素的插入排序是相对固定的，左子树的相对顺序即比根节点小的元素的插入排序是相对固定的，并且保证根节点的值不变，在保证这三个条件的前提下，不同的插入序列一定保证能够得到相同的<code>BST</code>.我们设左子树的节点个数为<code>left</code>,右子树的节点个数为<code>right</code>，即为基本的排列组合，从<code>left+right</code>个位置中选出<code>left</code>个位置放置左子树的节点，则相应的总的排序个数按照排列组合应该为:<script type="math/tex; mode=display">num = C_{left+right}^{left}</script></li><li>我们知道<code>2</code>的基本理论后，下面的推论就很方便。我们仔细思考下，左右子树是否存在相同的情况？左子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合，右子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合。根据<code>3</code>的推论，则我们总的节点的排序数应该为:<script type="math/tex; mode=display">F(tree) = C_{left+right}^{left}*F(leftTree)*F(rightTree)</script></li><li>我们用<code>DFS</code>递归，按照<code>3</code>的排列组合理论，很快就可以求出来总的个数，最后将总的个数减去<code>1</code>即为所求。最终的解法总是非常的简洁和优美，如果自己写代码写的很复杂，可能是自己思考错了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">                left.push_back(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = left.size();</span><br><span class="line">        <span class="keyword">int</span> r = right.size();</span><br><span class="line">        <span class="keyword">return</span> ((C[l+r][r]*dfs(left))%mod*dfs(right))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            C[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                   C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125; <span class="comment">// 计算Cmn</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(nums) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;204场周赛&quot;&gt;&lt;a href=&quot;#204场周赛&quot; class=&quot;headerlink&quot; title=&quot;204场周赛&quot;&gt;&lt;/a&gt;204场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5499-重复至少-K-次且长度为-M-的模式&quot;&gt;&lt;a href=&quot;#5499-重复至少-K-次且长度为-M-的模式&quot; class=&quot;headerlink&quot; title=&quot;5499. 重复至少 K 次且长度为 M 的模式&quot;&gt;&lt;/a&gt;5499. 重复至少 K 次且长度为 M 的模式&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数数组 &lt;code&gt;arr&lt;/code&gt;，请你找出一个长度为&lt;code&gt;m&lt;/code&gt;且在数组中至少重复&lt;code&gt;k&lt;/code&gt;次的模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google Kickstart】 2020 roundE</title>
    <link href="http://yoursite.com/2020/08/27/195/"/>
    <id>http://yoursite.com/2020/08/27/195/</id>
    <published>2020-08-27T05:52:13.942Z</published>
    <updated>2020-08-27T05:52:20.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-kickstart-2020-roundE"><a href="#google-kickstart-2020-roundE" class="headerlink" title="google kickstart 2020 roundE"></a>google kickstart 2020 roundE</h1><p>类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。<code>google kickstart</code>的比赛界面不是特别友好，不如<code>leetcode</code>那么人性化，但是题目质量非常高。</p><a id="more"></a><h2 id="Longest-Arithmetic"><a href="#Longest-Arithmetic" class="headerlink" title="Longest Arithmetic"></a>Longest Arithmetic</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>An arithmetic array is an array that contains at least two integers and the differences between consecutive integers are equal. For example, [9, 10], [3, 3, 3], and [9, 7, 5, 3] are arithmetic arrays, while [1, 3, 3, 7], [2, 1, 2], and [1, 2, 4] are not arithmetic arrays.</p><p>Sarasvati has an array of N non-negative integers. The i-th integer of the array is Ai. She wants to choose a contiguous arithmetic subarray from her array that has the maximum length. Please help her to determine the length of the longest contiguous arithmetic subarray.</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Ai.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the length of the longest contiguous arithmetic subarray.</p><p><strong>Limits</strong></p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li><p>0 ≤ Ai ≤ 109.</p></li><li><p>Test Set 1<br>2 ≤ N ≤ 2000.</p></li><li><p>Test Set 2<br>2 ≤ N ≤ 2 × 105 for at most 10 test cases.<br>For the remaining cases, 2 ≤ N ≤ 2000.</p></li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">3</span>: <span class="number">3</span></span><br><span class="line">Case #<span class="number">4</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求连续子数组为等差数列的最长长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求连续子数组为等差数列的最长长度。这个题目基本上<code>leetcode</code> easy级别的水平题目。差不多10行代码搞定。</li><li>主要判断以下条件即可<script type="math/tex; mode=display">arr[i] - arr[i-1] == arr[i-1] - arr[i-2]</script>如果满足以上条件则便是当前元素可以和前两个元素构成等差序列。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        arr.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) == (arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="High-Buildings"><a href="#High-Buildings" class="headerlink" title="High Buildings"></a>High Buildings</h3><p><strong>Problem</strong><br>in an unspecified country, Google has an office campus consisting of N office buildings in a line, numbered from 1 to N from left to right. When represented in meters, the height of each building is an integer between 1 to N, inclusive.</p><p>Andre and Sule are two Google employees working in this campus. On their lunch break, they wanted to see the skyline of the campus they are working in. Therefore, Andre went to the leftmost point of the campus (to the left of building 1), looking towards the rightmost point of the campus (to the right of building N). Similarly, Sule went to the rightmost point of the campus, looking towards the leftmost point of the campus.</p><p>To Andre, a building x is visible if and only if there is no building to the left of building x that is strictly higher than building x. Similarly, to Sule, a building x is visible if and only if there is no building to the right of building x that is strictly higher than building x.</p><p>Andre learned that there are A buildings that are visible to him, while Sule learned that there are B buildings that are visible to him. After they regrouped and exchanged information, they also learned that there are C buildings that are visible to both of them.</p><p>They are wondering about the height of each building. They are giving you the value of N, A, B, and C for your information. As their friend, you would like to construct a possible height for each building such that the information learned on the previous paragraph is correct, or indicate that there is no possible height construction that matches the information learned (thus at least one of them must have been mistaken).</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of a single line with four integers N, A, B, and C: the information given by Andre and Sule.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is IMPOSSIBLE if there is no possible height for each building according to the above information, or N space-separated integers otherwise. The i-th integer in y must be the height of the i-th building (in meters) between 1 to N.</p><p>Limits</p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ C ≤ N.</li><li>C ≤ A ≤ N.</li><li><p>C ≤ B ≤ N.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 5.</li><li>Test Set 2</li><li>1 ≤ N ≤ 100.</li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">Case #<span class="number">2</span>: IMPOSSIBLE</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂实际是非常简单的一道类似于小学奥数的题目。<code>Andre</code>在最左侧只能看到严格非递减的楼栋，<code>Sule</code>只能在最右侧看到严格非递减的楼栋，<code>Andre</code>看到的的楼栋的数目为A,<code>Sule</code>看到的建筑的数目为<code>B</code>,两人共同看到的建筑数目为<code>C</code>.题目要求给出符合条件的<code>n</code>个建筑的高度。</li><li>首先我们检测有哪些不符合的情况，整个建筑的数目为<code>n</code>.两人共同看到的数目<code>c</code>肯定为<code>n</code>个建筑中最高的建筑。因此我们首先判断这种情况不可能:<script type="math/tex; mode=display">A + B - C > N</script>因为<code>Andre</code>看到了A个建筑其中包括了<code>C</code>个最高的建筑，同样<code>Sule</code>也看到了<code>B</code>个建筑，也包括了<code>C</code>个最高的建筑。<br>另一种情况，也需要讨论，当<code>A == C</code>且<code>B == C</code>时，这时表示Andre和Sule都只看到了最高的建筑数目<code>C</code>,表示有<code>C</code>个相同高度且最高的建筑。假如当<code>N</code>为<code>1</code>时，则此时C == 1符合条件。假如<code>N &gt; 2</code>时，则此时必须满足第<code>1</code>个建筑和第<code>N</code>个建筑都为最高高度才可以，否则则不可能出现<code>A == C</code>且<code>B == C</code>，因为肯定会有次矮的建筑被看到。</li></ol></blockquote><ol><li>我们再来构建即可，我们直接<code>Andre</code>看到了A个建筑，其中包含C个建筑为最高高度<code>x</code>，次高的建筑数目为<code>A-C</code>个；我们知道<code>Sule</code>看到了B个建筑，其中包含C个建筑为最高高度，次高的建筑数目为<code>B-C</code>个；剩余<code>Andre</code>和<code>Sule</code>未看到的建筑数目为<code>N-A-B+C</code>.我们直接令建筑的组成如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200826174654.png" alt="1"></li><li>我们仔细思考一下3的解法，实际有问题，当<code>A == C或者B == C</code>或者 <code>N == 2</code>时上面的建筑的高度分布就有问题，需要重新思考排列方式。因此我们应该分为几种情况来排列即可。</li></ol><ul><li>当<code>A == C 或者 C &gt;= 2</code>时，则我们优先在左侧放置最高高度的建筑。我们优先放置高度为<code>1</code>的建筑可能会被看到。</li><li>当<code>C == 1 或者 B == C</code>时，则我们优先在右侧放置最高高度的建筑。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> isPossible = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b-c&gt;n || a &lt; c || b &lt; c)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == c &amp;&amp; b == c &amp;&amp; c &lt; min(n,<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = n - a - b + c;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="number">2</span> || a == c)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Toys"><a href="#Toys" class="headerlink" title="Toys"></a>Toys</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>Little Axel has N toys numbered from 1 to N. Each toy has two properties:</p><ul><li><strong>Ei—enjoyment</strong>, which is the number of minutes Axel can play with toy number i without getting bored with it;</li><li><strong>Ri—remembrance</strong>, which is the number of minutes it takes Axel to forget toy number i after having played with it.<br>The toys are arranged in a circle, from 1 to N clockwise. Axel plays with them one by one.</li></ul><p>When Axel reaches toy i which he has not played with yet, or which he has already forgotten about, he plays with it for Ei minutes and then immediately moves to the next one (clockwise).</p><p>If he reaches a toy that he has not forgotten yet (if less than Ri minutes have passed since the last time he finished playing with it), he will stop and cry.</p><p>We can define the time Axel spent playing as the sum of Ei of every toy Axel played with before stopping. If Axel played with a toy several times, it should be counted that many times.</p><p>Given the description of the toys, remove the smallest possible number of them in order to make Axel play either an indefinitely long time, or (if that is not possible) as long as possible before he stops.</p><p>Note:</p><ul><li>Axel has never played with these toys before;</li><li>he cannot be left without toys;</li><li>he always starts with the toy that has the smallest number;</li><li>after finishing playing with the toy that has the largest number, he + will move to the toy that has the smallest number.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. Next N lines contain 2 integers each: Ei and Ri. The i-th line is describing the toy number i.</li></ul><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y z, where:</p><p>x is the test case number (starting from 1);<br>y is the minimal number of toys to remove so that Axel could play with the rest of them either indefinitely or as long as possible;<br>z is the longest time Axel will play in minutes or “INDEFINITELY” (without quotes) if he will play indefinitely long time.<br><strong>Limits</strong></p><ul><li>Time limit: 30 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ Ei ≤ 109.</li><li><p>1 ≤ Ri ≤ 109.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 12.</li><li>Test Set 2</li><li>1 ≤ N ≤ 105.</li></ul><p>Sample<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">30</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">0</span> <span class="number">5</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">0</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">1</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">4</span>: <span class="number">0</span> <span class="number">25</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bede9</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 一圈玩具，题目给出了每个玩具的把玩时间和冷却时间，冷却时间即为下一次玩耍该玩具时必须等待的时间，题目要求可以移走部分玩具，求最长可以玩耍游戏的时间是多少。</span><br><span class="line"><span class="number">2.</span> 我们首先分析一下，假设只有`<span class="number">1</span>`个玩具，该玩具的$E_&#123;i&#125; &gt;= R_&#123;i&#125;$,则表示`Axel`可以一直玩该玩具，否则他最多只能玩一次该玩具后，必须等待冷却时间才可以。</span><br><span class="line">由此，我们首先求出第$n (n&gt; <span class="number">1</span>)$次玩第`i`个玩具的等待时间为：</span><br><span class="line">$$W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125;$$</span><br><span class="line">我们必须满足它的等待时间刚好大于或者等于它的冷却时间，则它刚好可以接着玩该玩具。</span><br><span class="line">$$</span><br><span class="line">W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125; \ge R_&#123;i&#125; \\</span><br><span class="line">\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;</span><br><span class="line">$$</span><br><span class="line">即该玩具的冷却时间和玩耍时间之和必须小于等于所有玩具的玩耍时间之和，首先需要把这类玩具去掉。</span><br><span class="line"><span class="number">3.</span> 我们不断更新，如果出现剩余的所有的玩具都满足</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125; $$</span><br><span class="line">则这时表示剩下的玩具可以无限玩，直接返回`INDEFINITELY`即可。</span><br><span class="line"><span class="number">4.</span> 如果不能满足出现`INDEFINITELY`，则我们求出剩余的去除部分玩具的可玩的最大时间。首先我们可以肯定所有的玩具都不会被玩三次，如果该玩具被连续玩了三次，则表示 所有的玩具都被玩了两次，则该部分玩具可以被无限的玩`n`次。</span><br><span class="line"><span class="number">5.</span> 首先我们看到假如一个玩具都不会被删除，则在第一次时，所有的玩具都会被玩一次，在第二圈时，可能部分玩具能够被再玩耍一次。</span><br><span class="line"><span class="number">6.</span> 我们首先将所有的玩具按照顺序，依次加入到可玩的优先级序列中，如果发现有玩具`i`出现条件：g</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \le R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">则这时我们认为第`i`个玩具肯定不能加入到队列中，次吃我们将所有玩具的等待时间减去$E_&#123;i&#125;$,此时我们更新队列,同时判断队列中的元素是否都符合可以玩第二次的条件。</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">如果发现不符合，则将其从队列中剔除掉。如果第`i`个玩具符合条件，则将其加入到待选队列中。</span><br><span class="line"><span class="number">7.</span>总的来说该题目还是非常经典。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> cmp(pii &amp; a, pii &amp; b)&#123;</span><br><span class="line">    <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cmp1&#123;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>()(pii &amp; a,pii &amp;b)&#123;</span><br><span class="line">        <span class="built_in">if</span>(a.first == b.first) </span><br><span class="line">            <span class="built_in">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> slove()&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; enjoy;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; remembrance;</span><br><span class="line">    vector&lt;pii&gt; arr;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> e,r;</span><br><span class="line">        cin&gt;&gt;e&gt;&gt;r;</span><br><span class="line">        enjoy.emplace_back(e);</span><br><span class="line">        remembrance.emplace_back(r);</span><br><span class="line">        arr.emplace_back(make_pair(e+r,i));</span><br><span class="line">        total += e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*count the array*/</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = total;</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(arr[i].first &gt; sum)&#123;</span><br><span class="line">            sum -= enjoy[arr[i].second];</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;n-i<span class="number">-1</span>&lt;&lt;<span class="string">" INDEFINITELY"</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,cmp1&gt; pq;</span><br><span class="line">    sum = total;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_val = total;</span><br><span class="line">    <span class="keyword">int</span> min_del = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cdel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cval = total;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(enjoy[i] + remembrance[i] &lt;= sum)&#123;</span><br><span class="line">            pq.push(make_pair(enjoy[i] + remembrance[i],i));</span><br><span class="line">            cval += enjoy[i];</span><br><span class="line">            <span class="built_in">if</span>(cval &gt; max_val)&#123;</span><br><span class="line">                max_val = cval;</span><br><span class="line">                min_del = cdel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">           sum -= enjoy[i];</span><br><span class="line">           cval -= enjoy[i];</span><br><span class="line">           cdel++;</span><br><span class="line">           <span class="built_in">while</span>(!pq.empty() &amp;&amp; pq.top().first &gt; sum)&#123;</span><br><span class="line">               <span class="keyword">int</span> x = pq.top().second;</span><br><span class="line">               pq.pop();</span><br><span class="line">               sum -= enjoy[x];</span><br><span class="line">               cval -= <span class="number">2</span>*enjoy[x];</span><br><span class="line">               cdel--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;min_del&lt;&lt;<span class="string">" "</span>&lt;&lt;max_val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;google-kickstart-2020-roundE&quot;&gt;&lt;a href=&quot;#google-kickstart-2020-roundE&quot; class=&quot;headerlink&quot; title=&quot;google kickstart 2020 roundE&quot;&gt;&lt;/a&gt;google kickstart 2020 roundE&lt;/h1&gt;&lt;p&gt;类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。&lt;code&gt;google kickstart&lt;/code&gt;的比赛界面不是特别友好，不如&lt;code&gt;leetcode&lt;/code&gt;那么人性化，但是题目质量非常高。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="google kickstart" scheme="http://yoursite.com/tags/google-kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 203周周赛</title>
    <link href="http://yoursite.com/2020/08/23/194/"/>
    <id>http://yoursite.com/2020/08/23/194/</id>
    <published>2020-08-23T09:00:11.295Z</published>
    <updated>2020-08-23T09:36:44.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203场周赛"><a href="#203场周赛" class="headerlink" title="203场周赛"></a>203场周赛</h1><p>周赛的题目质量确实要高一些，双周赛的题目简单太多了。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png" alt="1"></p><h2 id="5495-圆形赛道上经过次数最多的扇区"><a href="#5495-圆形赛道上经过次数最多的扇区" class="headerlink" title="5495. 圆形赛道上经过次数最多的扇区"></a>5495. 圆形赛道上经过次数最多的扇区</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code>个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code>个阶段组成。其中，第 i 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code>结束。举例来说，第 1 阶段从 <code>rounds[0]</code> 开始，到<code>rounds[1]</code>结束。</p><a id="more"></a><p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。</p><p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154505.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：本场马拉松比赛从扇区 <span class="number">1</span> 开始。经过各个扇区的次序如下所示：</span><br><span class="line"><span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span>（阶段 <span class="number">1</span> 结束）--&gt; <span class="number">4</span> --&gt; <span class="number">1</span>（阶段 <span class="number">2</span> 结束）--&gt; <span class="number">2</span>（阶段 <span class="number">3</span> 结束，即本场马拉松结束）</span><br><span class="line">其中，扇区 <span class="number">1</span> 和 <span class="number">2</span> 都经过了两次，它们是经过次数最多的两个扇区。扇区 <span class="number">3</span> 和 <span class="number">4</span> 都只经过了一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, rounds = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>rounds.length == m + 1</code></li><li><code>1 &lt;= rounds[i] &lt;= n</code></li><li><code>rounds[i] != rounds[i + 1] ，其中 0 &lt;= i &lt; m.</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂，但实际非常简单，主要是循环数组的处理。</li><li>循环统计每个扇区的通过次数，然后取统计次数的最大值即可。题目可以再增加难度，比如赛道通过的圈数可以为<code>n</code>圈，这样的加法处理又稍微复杂点。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mostVisited(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size(); ++i)&#123;</span><br><span class="line">            rounds[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rounds[i]; j != rounds[i+<span class="number">1</span>] ; j = (j + <span class="number">1</span>)%n)&#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[rounds.back()]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            maxV = max(cnt[i],maxV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == maxV) ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5496-你可以获得的最大硬币数目"><a href="#5496-你可以获得的最大硬币数目" class="headerlink" title="5496. 你可以获得的最大硬币数目"></a>5496. 你可以获得的最大硬币数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p><p>每一轮中，你将会选出 任意<code>3</code> 堆硬币（不一定连续）。<br><code>Alice</code> 将会取走硬币数量最多的那一堆。<br>你将会取走硬币数量第二多的那一堆。<br>Bob 将会取走最后一堆。<br>重复这个过程，直到没有更多硬币。<br>给你一个整数数组 <code>piles</code>，其中 <code>piles[i]</code>是第 <code>i</code>堆中硬币的数目。</p><p>返回你可以获得的最大硬币数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：选出 (<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>) ，Alice 取走 <span class="number">8</span> 枚硬币的那堆，你取走 <span class="number">7</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">选出 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>) , Alice 取走 <span class="number">4</span> 枚硬币的那堆，你取走 <span class="number">2</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">你可以获得的最大硬币数目：<span class="number">7</span> + <span class="number">2</span> = <span class="number">9.</span></span><br><span class="line">考虑另外一种情况，如果选出的是 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>) 和 (<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>) ，你就只能得到 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span> 枚硬币，这不是最优解。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= piles.length &lt;= 10^5</code></li><li><code>piles.length % 3 == 0</code></li><li><code>1 &lt;= piles[i] &lt;= 10^4</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如何取最大值，本质是数学问题，我们应当保证尽可能的取到最大值。首先想到的是我们对数组按照从小到大进行排列。</li><li>设数组的长度为<code>3n</code>,则每次取得索引数为$(piles[i],piles[n+2<em>i-1],piles[n+2</em>i])$,则这时</li></ol><ul><li><code>Alice</code>取得得硬币为：<br>$piles[n+2],piles[n+4],…,piles[3n]$</li><li><code>Bob</code>取得得硬币为：<br>$piles[1],piles[2],…,piles[n]$</li><li>自己取得的硬币为：<br>$piles[n+1],piles[n+3],…,piles[3n-1]$</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="keyword">int</span> x = n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(piles.begin(),piles.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; n; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5497-查找大小为-M-的最新分组"><a href="#5497-查找大小为-M-的最新分组" class="headerlink" title="5497. 查找大小为 M 的最新分组"></a>5497. 查找大小为 M 的最新分组</h2><p>给你一个数组 <code>arr</code>，该数组表示一个从 <code>1</code> 到 <code>n</code>的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。</p><p>在从 1 到<code>n</code> 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置<code>arr[i]</code>的位将会设为 1 。</p><p>给你一个整数<code>m</code>，请你找出二进制字符串上存在长度为 <code>m</code>的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。</p><p>返回存在长度 恰好 为 <code>m</code>的 一组 <code>1</code>  的最后步骤。如果不存在这样的步骤，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"00101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"11101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"111"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">存在长度为 <span class="number">1</span> 的一组 <span class="number">1</span> 的最后步骤是步骤 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"10100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"10111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"111"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">不管是哪一步骤都无法形成长度为 <span class="number">2</span> 的一组 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == arr.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= n</code></li><li><code>arr</code> 中的所有整数 互不相同</li><li><code>1 &lt;= m &lt;= arr.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-latest-group-of-size-m</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>left[x]</code>代表从索引<code>x</code>处开始向左连续的最长<code>1</code>的数目，<code>right[x]</code>代表从索引<code>x</code>处开始向右连续的最长<code>1</code>的数目。<code>count[l]</code>代表当前状态中连续<code>1</code>的长度为<code>l</code>的统计数目。</li><li>每次将<code>x</code>位置为<code>1</code>时，则我们进行左右的连续的<code>1</code>的序列合并，这时合并的总长度为: $l = left[x-1] + 1 + right[x+1]$<br>则我们同时将该区间<code>l</code>的两端的left与right进行更新。同时将连续长度为<code>left[x-1],right[x+1]</code>的统计数目减<code>1</code>,将连续长度为<code>l</code>的统计数目加<code>1</code>.</li><li>每次更新完长度的统计数目后，如果发现长度为<code>m</code>的统计数目大于<code>0</code>，则我们认为此时存在大小为<code>m</code>的最新分组。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823171258.png" alt="3"></li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i];</span><br><span class="line">            <span class="keyword">int</span> l = left[x<span class="number">-1</span>] + <span class="number">1</span> + right[x+<span class="number">1</span>];</span><br><span class="line">            left[x + right[x+<span class="number">1</span>]] = l;</span><br><span class="line">            right[x - left[x<span class="number">-1</span>]] = l;</span><br><span class="line">            count[left[x<span class="number">-1</span>]]--;</span><br><span class="line">            count[right[x+<span class="number">1</span>]]--;</span><br><span class="line">            count[l]++;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(count[m] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5498-石子游戏-V"><a href="#5498-石子游戏-V" class="headerlink" title="5498. 石子游戏 V"></a>5498. 石子游戏 V</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p><p>游戏中的每一轮：<code>Alice</code> 会将这行石子分成两个 非空行（即，左侧行和右侧行）；<code>Bob</code> 负责计算每一行的值，即此行中所有石子的值的总和。<code>Bob</code>会丢弃值最大的行，<code>Alice</code>的得分为剩下那行的值（每轮累加）。如果两行的值相等，<code>Bob</code> 让 <code>Alice</code>决定丢弃哪一行。下一轮从剩下的那一行开始。</p><p>只 剩下一块石子 时，游戏结束。<code>Alice</code>的分数最初为 0 。</p><p>返回 <code>Alice</code>能够获得的最大分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：在第一轮中，Alice 将行划分为 [<span class="number">6</span>，<span class="number">2</span>，<span class="number">3</span>]，[<span class="number">4</span>，<span class="number">5</span>，<span class="number">5</span>] 。左行的值是 <span class="number">11</span> ，右行的值是 <span class="number">14</span> 。Bob 丢弃了右行，Alice 的分数现在是 <span class="number">11</span> 。</span><br><span class="line">在第二轮中，Alice 将行分成 [<span class="number">6</span>]，[<span class="number">2</span>，<span class="number">3</span>] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 <span class="number">16</span>（<span class="number">11</span> + <span class="number">5</span>）。</span><br><span class="line">最后一轮 Alice 只能将行分成 [<span class="number">2</span>]，[<span class="number">3</span>] 。Bob 扔掉右行，Alice 的分数现在是 <span class="number">18</span>（<span class="number">16</span> + <span class="number">2</span>）。游戏结束，因为这行只剩下一块石头了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stoneValue.length &lt;= 500</code></li><li><code>1 &lt;= stoneValue[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-v" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-v</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs记忆化搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题其实比较简单，不过刚开始自己考虑太复杂了，首先知道是要用<code>dp</code>。但是直接推导<code>dp</code>发现时间复杂度为<code>o(n^3)</code>不太好推，后来想想干脆不如用记忆化搜索。</li><li>首先看到题目中要求数组分组并求数组的左右分组的和，这时肯定想到是要用数组的前缀和，因为利用数组的前缀和可以在<code>o(1)</code>时间复杂度内求出数组的区间的和。</li><li>我们通过<code>dfs</code>搜索区间数组<code>[l,r]</code>时，<code>Alice</code>能取得的最大值。则每次我们从<code>x</code>处断开，分别可以求得数组从<code>l</code>到<code>x</code>的和为<code>sum[l][x]</code>,数组从<code>x+1</code>到<code>r</code>的和为<code>sum[x+1][r]</code>,我们判断其大小，然后根据题意进行下一次迭代即可。</li></ol><ul><li>如果：<code>sum[l][x] &gt; sum[x+1][r]</code>,则<script type="math/tex; mode=display">dp[l][r] = max(dp[l][r],sum[x+1][r] + dp[x+1][r])</script></li><li>如过<code>sum[l][x] &lt; sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x])</script>.</li><li>如过<code>sum[l][x] = sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x],sum[x+1][r] + dp[x+1][r])</script>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sum,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l][r] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            dp[l][r] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> lsum = sum[i] - sum[l<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> rsum = sum[r] - sum[i];</span><br><span class="line">                <span class="keyword">if</span>(lsum &gt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lsum &lt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += stoneValue[i];</span><br><span class="line">            sum[i+<span class="number">1</span>] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(sum,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;203场周赛&quot;&gt;&lt;a href=&quot;#203场周赛&quot; class=&quot;headerlink&quot; title=&quot;203场周赛&quot;&gt;&lt;/a&gt;203场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，双周赛的题目简单太多了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5495-圆形赛道上经过次数最多的扇区&quot;&gt;&lt;a href=&quot;#5495-圆形赛道上经过次数最多的扇区&quot; class=&quot;headerlink&quot; title=&quot;5495. 圆形赛道上经过次数最多的扇区&quot;&gt;&lt;/a&gt;5495. 圆形赛道上经过次数最多的扇区&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; 和一个整数数组 &lt;code&gt;rounds&lt;/code&gt; 。有一条圆形赛道由 &lt;code&gt;n&lt;/code&gt;个扇区组成，扇区编号从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 &lt;code&gt;m&lt;/code&gt;个阶段组成。其中，第 i 个阶段将会从扇区 &lt;code&gt;rounds[i - 1]&lt;/code&gt; 开始，到扇区 &lt;code&gt;rounds[i]&lt;/code&gt;结束。举例来说，第 1 阶段从 &lt;code&gt;rounds[0]&lt;/code&gt; 开始，到&lt;code&gt;rounds[1]&lt;/code&gt;结束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 33周双周赛</title>
    <link href="http://yoursite.com/2020/08/23/193/"/>
    <id>http://yoursite.com/2020/08/23/193/</id>
    <published>2020-08-23T00:40:24.315Z</published>
    <updated>2020-08-30T07:27:21.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33场双周赛"><a href="#33场双周赛" class="headerlink" title="33场双周赛"></a>33场双周赛</h1><p>双周赛的题目都好简单，第三题卡壳了好长时间。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png" alt="1"></p><h2 id="5479-千位分隔数"><a href="#5479-千位分隔数" class="headerlink" title="5479. 千位分隔数"></a>5479. 千位分隔数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。</p><p>示例 1：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">987</span></span><br><span class="line">输出：<span class="string">"987"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1234</span></span><br><span class="line">输出：<span class="string">"1.234"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">123456789</span></span><br><span class="line">输出："<span class="number">123.456</span>.<span class="number">789</span>"</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">0</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= n &lt; 2^31</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/thousand-separator" target="_blank" rel="noopener">https://leetcode-cn.com/problems/thousand-separator</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">thousandSeparator</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            ans = to_string(n%<span class="number">10</span>) + ans;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; curr%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = <span class="string">"."</span> + ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5480-可以到达所有点的最少点数目"><a href="#5480-可以到达所有点的最少点数目" class="headerlink" title="5480. 可以到达所有点的最少点数目"></a>5480. 可以到达所有点的最少点数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有向无环图 ， <code>n</code>个节点编号为 <code>0</code>到 <code>n-1</code> ，以及一个边数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示一条从点  <code>fromi</code>到点 <code>toi</code>的有向边。</p><p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p><p>你可以以任意顺序返回这些节点编号。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">解释：从单个节点出发无法到达所有节点。从 <span class="number">0</span> 出发我们可以到达 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>] 。从 <span class="number">3</span> 出发我们可以到达 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] 。所以我们输出 [<span class="number">0</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：注意到节点 <span class="number">0</span>，<span class="number">3</span> 和 <span class="number">2</span> 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 <span class="number">1</span> 和 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt; n</code></li><li>所有点对 <code>(fromi, toi)</code> 互不相同。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质就是找到图的入度为<code>0</code>的节点即可，这个题目应该更难点为好。太过于简单了。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestSetOfVertices(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5481-得到目标数组的最少函数调用次数"><a href="#5481-得到目标数组的最少函数调用次数" class="headerlink" title="5481. 得到目标数组的最少函数调用次数"></a>5481. 得到目标数组的最少函数调用次数</h2><p>给你一个与 nums 大小相同且初始值全为 <code>0</code>的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>。<br>请你返回将 <code>arr</code>变成 <code>nums</code> 的最少函数调用次数。<br>答案保证在 <code>32</code> 位有符号整数以内。<br><img src="https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png" alt="3"></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：给第二个数加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] 变成 [<span class="number">0</span>, <span class="number">1</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ：[<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">0</span>, <span class="number">2</span>] -&gt; [<span class="number">0</span>, <span class="number">4</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">5</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">总操作次数为：<span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] -&gt; [<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">1</span>, <span class="number">1</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ： [<span class="number">1</span>, <span class="number">1</span>] -&gt; [<span class="number">2</span>, <span class="number">2</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">总操作次数为： <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：（初始）[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] （nums 数组）。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>对于数目乘以<code>2</code>的次数与数组中最大的数相关，所以乘以<code>2</code>的次数就等于max取<code>log</code>。</li><li>其余剩下的操作次数即为所有元素取2的模为1的次数。</li><li>这种类型的题目非常好，带有数学问题，并且带有一定的难度。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v%<span class="number">2</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    --v;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                    v /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lg = max(lg,t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans += lg;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5482-二维网格图中探测环"><a href="#5482-二维网格图中探测环" class="headerlink" title="5482. 二维网格图中探测环"></a>5482. 二维网格图中探测环</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维字符网格数组 <code>grid</code> ，大小为<code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 相同值 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 大于等于 <code>4</code> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 grid 中有相同值形成的环，请你返回 <code>true</code>，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png" alt="5"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png" alt="6"><br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>]]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：如下图所示，有 <span class="number">2</span> 个用不同颜色标出来的环：</span><br></pre></td></tr></table></figure><br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png" alt="7"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png" alt="8"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"a"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"e"</span>,<span class="string">"c"</span>],[<span class="string">"f"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>]]</span><br><span class="line">输出：true</span><br><span class="line">解释：如下图所示，只有高亮所示的一个合法环：</span><br></pre></td></tr></table></figure><br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png" alt="9"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 500</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>grid</code> 只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-cycles-in-2d-grid</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs或者BFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题非常简单，就是简单的BFS或者DFS即可。判断是否有环即可。不晓得为什么是<code>hard</code>难度。</li><li>最后一题都 <code>AC</code>600+了说明非常简单。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = _x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = _y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFrom</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">0</span> &amp;&amp; y == <span class="number">1</span>)||(x == <span class="number">1</span> &amp;&amp; y == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">2</span> &amp;&amp; y == <span class="number">3</span>)||(x == <span class="number">3</span> &amp;&amp; y == <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(row &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> c = grid[i][j];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> d = k;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                        qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                        visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    Node curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isFrom(k,curr.d)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> x = curr.x + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr.y + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> d = k;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;33场双周赛&quot;&gt;&lt;a href=&quot;#33场双周赛&quot; class=&quot;headerlink&quot; title=&quot;33场双周赛&quot;&gt;&lt;/a&gt;33场双周赛&lt;/h1&gt;&lt;p&gt;双周赛的题目都好简单，第三题卡壳了好长时间。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5479-千位分隔数&quot;&gt;&lt;a href=&quot;#5479-千位分隔数&quot; class=&quot;headerlink&quot; title=&quot;5479. 千位分隔数&quot;&gt;&lt;/a&gt;5479. 千位分隔数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;987&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;987&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;1.234&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;123456789&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&quot;&lt;span class=&quot;number&quot;&gt;123.456&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;789&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>火与烬</title>
    <link href="http://yoursite.com/2020/08/17/192/"/>
    <id>http://yoursite.com/2020/08/17/192/</id>
    <published>2020-08-17T04:29:41.217Z</published>
    <updated>2020-08-17T04:32:27.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火与烬"><a href="#火与烬" class="headerlink" title="火与烬"></a>火与烬</h1><p>断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。</p><ul><li>为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。</li><li>国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。</li><li>国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。</li><li>文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。</li></ul><a id="more"></a><h2 id="作者背景"><a href="#作者背景" class="headerlink" title="作者背景"></a>作者背景</h2><p>作者英文名迈克尔·伊格纳季耶夫（Michael Ignatieff），中文名叶礼庭,出身在加拿大的一个政治世家，祖父是莎皇时代的教育部长, 在 1917年俄国红色十月革命后逃往满地可, 父亲是加拿大外交官, 他的舅父是 著名 政治哲学家George Grant, 他的姨祖母Alice Massey是前加拿大总督 Vincent Massey的妻子. 家族显赫。他在多伦 多大学历史系毕业，1979年在哈佛大学取得历史博士学，曾在剑桥大学和哈佛大学任教，可以称之为西方世界的精英实至名归。作者在加拿大自由党派的领导人的劝说下，从美国返回到加拿大，后来成为加拿大自由党的党魁，而后又被党内推选为加拿大总理的候选人，参加2008年的加拿大总理竞选，而后又失败</p><h2 id="蹈火（初入政治）"><a href="#蹈火（初入政治）" class="headerlink" title="蹈火（初入政治）"></a>蹈火（初入政治）</h2><p>作者因为家族背景的原因，也是因为自身影响力的原理，从哈佛任教转回加拿大，涉入政坛。由于背景的加持，在党内快速上升，很快就成为加拿大自由党党领袖的候选人，然后第一次党内选举中落败，后来又成为党内的副领袖。200年的经济危机中，由于自由党在竞选中落败，党领袖下台，而他又以外的被推举为自由党的党魁，而又作为在野党的议员，参与行政议政，在议政过程中描写了部分与执政党的有分歧事情和他通过部分事件描述执政党总理的部分观点和看法。从他描述的部分参政议政的过程中，从而对国外的议会制的立法和行政过程有所了解。</p><h2 id="烬余（竞选中期）"><a href="#烬余（竞选中期）" class="headerlink" title="烬余（竞选中期）"></a>烬余（竞选中期）</h2><p>在竞选初期，作者作为自由党的党魁而被党内一致推举为竞选总理的候选人，但反对党借机利用媒体就作者的身份进行大肆宣传，故意丑化作者，“他来自美国，只是一个过客”，这样深入人心的标语，有意丑化候选人，很快就让叶礼庭在大选前的民调中的支持率大幅下降。而竞选过程中并没有我们从前想的那么伟大神圣，保守党主要精力放在恶意丑化对方，能够故意让对方阻挡于“竞选”之外，而并没有去刻意去向选民宣传自己得竞选理念，去争取更多得投标人得支持。自由党作为在野党弱势的一方，作者本身极为辛苦的进行全国巡演，用传统的竞选方式去宣传自己的参政纲领和理念，去与民众亲近，去各地演讲从而寻得全国各地的选民的支持，然而最终竞选结果出来后竞选失败，令作者感到难受，开始反思自己在竞选中所犯的各种错误。</p><h2 id="竞选落败回忆"><a href="#竞选落败回忆" class="headerlink" title="竞选落败回忆"></a>竞选落败回忆</h2><p>作者有句很鲜明的理论，所有的著名的政治学理论都是政治失败者所撰写的，我想只有作者这种亲身参与这样极为重要的政治活动才得出来得理论总结，作者列举了许多著名得政治理论著作，都是由一些落魄得政治失败者反思后所总结撰写得理论，“要么在台上，要么回去教书”，多么形象的比喻。作者总结出，政治这个游戏对参与者的素质要求太高，门槛太高，并不是一般的人能够玩转的。<br>他反思，理论家的独特天分在于，“不计成败的率直、缜密、意志力，以及对独创性的敏锐探寻”，但往往缺乏政界人物需要的谨慎、掩饰、党性、对时势变化的敏锐、灵活的身段、阿谀奉承的口才。尽管叶礼庭自认远远无法与西塞罗、托克维尔这些思想大师并肩，但他的长处依然是在理论研究而非政治实务上，六年从政之路虽然不后悔，但政坛确实不是他真正擅长的地方。<br>“我追求权力的火焰，看到希望逐渐减少为灰烬。”缓慢走出败选阴影的叶礼庭，终于又拿起了笔，唤回那个作为作家的自己。在《火与烬》这本书中，他平和、真诚地讲述自己经历的点点滴滴，毫不留情地分析自己的稚嫩和错误，节制地表达幻灭的痛苦，给我们留下了一份丰富而不失优雅的心灵记录。<br>不得不说，透过本书的描述，让我们对政治生活更有一份客观而又正确的看待，在政治活动中，并没有所谓的绝对的“对与错”，妥协与隐藏是政治活动中的常态，劝诫从政活动中更重要的是要坚守内心的信仰，而不是固守所有的道德准则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;火与烬&quot;&gt;&lt;a href=&quot;#火与烬&quot; class=&quot;headerlink&quot; title=&quot;火与烬&quot;&gt;&lt;/a&gt;火与烬&lt;/h1&gt;&lt;p&gt;断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。&lt;/li&gt;
&lt;li&gt;国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。&lt;/li&gt;
&lt;li&gt;国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。&lt;/li&gt;
&lt;li&gt;文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 202周赛</title>
    <link href="http://yoursite.com/2020/08/16/191/"/>
    <id>http://yoursite.com/2020/08/16/191/</id>
    <published>2020-08-16T05:25:21.003Z</published>
    <updated>2020-08-16T05:25:30.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202场周赛"><a href="#202场周赛" class="headerlink" title="202场周赛"></a>202场周赛</h1><p>本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。</p><h2 id="5185-存在连续三个奇数的数组"><a href="#5185-存在连续三个奇数的数组" class="headerlink" title="5185. 存在连续三个奇数的数组"></a>5185. 存在连续三个奇数的数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/three-consecutive-odds" target="_blank" rel="noopener">https://leetcode-cn.com/problems/three-consecutive-odds</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-2</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i<span class="number">-1</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5488-使数组中所有元素相等的最小操作数"><a href="#5488-使数组中所有元素相等的最小操作数" class="headerlink" title="5488. 使数组中所有元素相等的最小操作数"></a>5488. 使数组中所有元素相等的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>存在一个长度为 <code>n</code>的数组 <code>arr</code>，其中 <code>arr[i] = (2 * i) + 1 （ 0 &lt;= i &lt; n ）</code>。</p><p>一次操作中，你可以选出两个下标，记作 <code>x</code>和 <code>y （ 0 &lt;= x, y &lt; n ）</code>并使 <code>arr[x]</code> 减去 1 、<code>arr[y]</code>加上 1 （即 <code>arr[x] -=1</code>且 <code>arr[y] += 1</code>）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p><p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 最小操作数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">第一次操作选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，使数组变为 [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">第二次操作继续选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，数组将会变成 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本质就是个数学问题，弄清楚等差数列的元素和长度，即可很快的求出来。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (n*n)/<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>)*(n+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5489-两球之间的磁力"><a href="#5489-两球之间的磁力" class="headerlink" title="5489. 两球之间的磁力"></a>5489. 两球之间的磁力</h2><p>在代号为 <code>C-137</code>的地球上，<code>Rick</code> 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。<code>Rick</code> 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> ，<code>Morty</code>想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于<code>x</code>和<code>y</code>，那么它们之间的磁力为<code>|x - y|</code>。</p><p>给你一个整数数组 <code>position</code>和一个整数<code>m</code>，请你返回最大化的最小磁力。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], m = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将 <span class="number">3</span> 个球分别放入位于 <span class="number">1</span>，<span class="number">4</span> 和 <span class="number">7</span> 的三个篮子，两球间的磁力分别为 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]。最小磁力为 <span class="number">3</span> 。我们没办法让最小磁力大于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1000000000</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">999999999</span></span><br><span class="line">解释：我们使用位于 <span class="number">1</span> 和 <span class="number">1000000000</span> 的篮子时最小磁力最大。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == position.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= position[i] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ 所有` position `中的整数 互不相同 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= m &lt;= position.length`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/magnetic-force-between-two-balls</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  二分查找</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的二分查找解法。与之前的类似的题目切巧克力基本上一样的题目，一看基本就直到解法。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> check(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m,<span class="built_in">int</span> distance)&#123;</span><br><span class="line">        m--;</span><br><span class="line">        <span class="built_in">int</span> curr = position[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; position.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position[i] - curr &gt;= distance)&#123;</span><br><span class="line">                curr = position[i];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDistance(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = position.size();</span><br><span class="line">        long long l = <span class="number">1</span>;</span><br><span class="line">        long long r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        sort(position.begin(),position.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(position,m,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5490-吃掉-N-个橘子的最少天数"><a href="#5490-吃掉-N-个橘子的最少天数" class="headerlink" title="5490. 吃掉 N 个橘子的最少天数"></a>5490. 吃掉 N 个橘子的最少天数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><p>吃掉一个橘子。<br>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 n/2 个橘子。<br>如果剩余橘子数 <code>n</code>能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。<br>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code>个橘子的最少天数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你总共有 <span class="number">10</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span>。</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">6</span> 个橘子，剩余橘子数 <span class="number">9</span> - <span class="number">2</span>*(<span class="number">9</span>/<span class="number">3</span>) = <span class="number">9</span> - <span class="number">6</span> = <span class="number">3</span>。（<span class="number">9</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。</span><br><span class="line">第 <span class="number">4</span> 天：吃掉最后 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你需要至少 <span class="number">4</span> 天吃掉 <span class="number">10</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你总共有 <span class="number">6</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">3</span> 个橘子，剩余橘子数 <span class="number">6</span> - <span class="number">6</span>/<span class="number">2</span> = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>。（<span class="number">6</span> 可以被 <span class="number">2</span> 整除）</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。（<span class="number">3</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃掉剩余 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你至少需要 <span class="number">3</span> 天吃掉 <span class="number">6</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">56</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs + 记忆式搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本质是典型的记忆式搜素，题目非常简单。</li><li>或者简单的BFS快速搜素即可，也没什么好讨论的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(n)) <span class="keyword">return</span> cnt[n];</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">2</span>) + n%<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">3</span>) + n%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        cnt[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = que.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> q = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">3</span>);</span><br><span class="line">                    s.insert(q / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">2</span>);</span><br><span class="line">                    s.insert(q / <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.count(q - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q - <span class="number">1</span>);</span><br><span class="line">                    s.insert(q - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;202场周赛&quot;&gt;&lt;a href=&quot;#202场周赛&quot; class=&quot;headerlink&quot; title=&quot;202场周赛&quot;&gt;&lt;/a&gt;202场周赛&lt;/h1&gt;&lt;p&gt;本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。&lt;/p&gt;&lt;h2 id=&quot;5185-存在连续三个奇数的数组&quot;&gt;&lt;a href=&quot;#5185-存在连续三个奇数的数组&quot; class=&quot;headerlink&quot; title=&quot;5185. 存在连续三个奇数的数组&quot;&gt;&lt;/a&gt;5185. 存在连续三个奇数的数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：不存在连续三个元素都是奇数的情况。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：存在连续三个元素都是奇数的情况，即 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 201周周赛</title>
    <link href="http://yoursite.com/2020/08/09/190/"/>
    <id>http://yoursite.com/2020/08/09/190/</id>
    <published>2020-08-09T08:21:04.153Z</published>
    <updated>2020-08-09T09:26:54.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="201周周赛"><a href="#201周周赛" class="headerlink" title="201周周赛"></a>201周周赛</h1><p>本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png" alt="1"><br>不过整体来说，感觉题目质量非常高，leetcode出题还是用心。</p><h2 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code>和 <code>s[i + 1]</code>不会同时满足下述条件：</p><a id="more"></a><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</li></ul><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leEeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：无论你第一次选的是 <span class="selector-tag">i</span> = <span class="number">1</span> 还是 <span class="selector-tag">i</span> = <span class="number">2</span>，都会使 <span class="string">"leEeetcode"</span> 缩减为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abBAcC"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"aAcC"</span> --&gt; <span class="string">"cC"</span> --&gt; <span class="string">""</span></span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"abBA"</span> --&gt; <span class="string">"aA"</span> --&gt; <span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"s"</span></span><br><span class="line">输出：<span class="string">"s"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-string-great" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-string-great</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  堆栈</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题感觉比较坑，简单的题目估计卡住不少人，感觉可以到达mid难度。</li><li>模拟堆栈即可，遍历字符串，如果当前字符串中的元素与栈顶的元素的绝对值之差为<code>32</code>，则出栈即可。最后返回栈中剩余的元素即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res.push_back(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res.back()-s[i]) == <span class="number">32</span>)&#123;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code><br>其中 + 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转<code>x</code>中的每一位（<code>0</code>变为 <code>1</code>，而 <code>1</code> 变为 <code>0</code>）</li></ul><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code><br>请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：S3 为 <span class="string">"0111001"</span>，其第 <span class="number">1</span> 位为 <span class="string">"0"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br><span class="line">解释：S4 为 <span class="string">"011100110110001"</span>，其第 <span class="number">11</span> 位为 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 找规律</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>先找到规律，刚拿到题目感觉没法下手，直接去求解的话，感觉很难。</li><li>仔细发现一下找到规律即可，实际我们直到$S_{n}$与$S_{n+1}$之间的递推关系，实际我们就可以用递归求解即可。我们可以讲字符串滑下来。</li><li>我们可以举例<code>S4</code>：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809165248.png" alt="1">。<br>首先我们可以直到$S_{n}$的长度$len(S_{n}) = 2^{n}-1$.假如<code>k</code>刚好在当前字符串中间的话，则直接返回<code>1</code>,因为我们直到除<code>S1</code>以外的字符串，最中间的字符都为<code>1</code>,最中间的位置刚好为：$2^{n-1}$<br>所以我们分为三种情况来讨论：</li></ol><ul><li>当$K &lt; 2^{n-1}$时：则此时$S_{n}[k] = S_{n-1}[k]$</li><li>当$K = 2^{n-1}$时：则此时$S_{n}[K] = 1$</li><li>当$K &gt; 2^{n-1}$时：则此时稍微麻烦点，由于后半部分是$reverse(invert(S_{n-1}))$,则$S_{n}[K] = inverse(S_{n-1}[2^{n}-k])$.</li><li>当$n = 0$时，则返回<code>0</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,<span class="built_in">pow</span>(<span class="number">2</span>,n)-k) == <span class="string">'0'</span>?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5471-和为目标值的最大数目不重叠非空子数组数目"><a href="#5471-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="5471. 和为目标值的最大数目不重叠非空子数组数目"></a>5471. 和为目标值的最大数目不重叠非空子数组数目</h2><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个不重叠子数组（加粗数字表示） [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] ，它们的和为目标值 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个子数组和为 <span class="number">6</span> 。</span><br><span class="line">([<span class="number">5</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>]) 但只有前 <span class="number">2</span> 个是不重叠的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目有点意思，我们设<code>dp[i]</code>代表前<code>i</code>个元素中含有最多的非连续符合条件且不重合的子数组的数目。</li><li>我们每次从在索引<code>i</code>初找到由元素<code>a[i]</code>作为符合条件的子数组的最后一个元素。我们利用前缀和，每次找到<code>prefixsum[i]-tagret</code>的索引<code>j</code>处。则可以得到以下递推公式.<script type="math/tex; mode=display">ans = max(ans,dp[j] + 1)</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            curr += nums[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[curr-target];</span><br><span class="line">                dp[i] = max(dp[i],dp[x] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,dp[i]);</span><br><span class="line">            cnt[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5486-切棍子的最小成本"><a href="#5486-切棍子的最小成本" class="headerlink" title="5486. 切棍子的最小成本"></a>5486. 切棍子的最小成本</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一根长度为<code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <code>6</code> 的棍子可以标记如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171755.png" alt="1"><br>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。<br>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 最小总成本 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, cuts = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：按 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] 的顺序切割的情况如下所示：</span><br><span class="line"></span><br><span class="line">第一次切割长度为 <span class="number">7</span> 的棍子，成本为 <span class="number">7</span> 。第二次切割长度为 <span class="number">6</span> 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 <span class="number">4</span> 的棍子，最后切割长度为 <span class="number">3</span> 的棍子。总成本为 <span class="number">7</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> = <span class="number">20</span> 。</span><br><span class="line">而将切割顺序重新排列为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>] 后，总成本 = <span class="number">16</span>（如示例图中 <span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">16</span>）。</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171815.png" alt="2"><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, cuts = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 <span class="number">25</span> 。总成本 &lt;= <span class="number">25</span> 的切割顺序很多，例如，[<span class="number">4</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">2</span>，<span class="number">1</span>] 的总成本 = <span class="number">22</span>，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，这种类型的题目已经见了很多了。</li><li>为了方便计算，我们首先讲头和尾加入<code>cuts</code>.我们用<code>dp[i][j]</code>代表<code>cuts[i]</code>到<code>cuts[j]</code>之间的切割最小成本。我们可以直到<code>dp[i][i] = 0</code>和 <code>dp[i][i+1]</code>，因为不需要切割。</li><li>我们很容易得出递推公式：<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j] + cuts[j] - cuts[i]) \qquad ( i \le k \le j</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;        </span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="keyword">int</span> m = cuts.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        </span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[m<span class="number">-1</span>][m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j+i; ++k)&#123;</span><br><span class="line">                    dp[j][j+i] = min(dp[j][j+i],dp[j][k] + dp[k][j+i] + cuts[j+i] - cuts[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;201周周赛&quot;&gt;&lt;a href=&quot;#201周周赛&quot; class=&quot;headerlink&quot; title=&quot;201周周赛&quot;&gt;&lt;/a&gt;201周周赛&lt;/h1&gt;&lt;p&gt;本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;不过整体来说，感觉题目质量非常高，leetcode出题还是用心。&lt;/p&gt;&lt;h2 id=&quot;5483-整理字符串&quot;&gt;&lt;a href=&quot;#5483-整理字符串&quot; class=&quot;headerlink&quot; title=&quot;5483. 整理字符串&quot;&gt;&lt;/a&gt;5483. 整理字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由大小写英文字母组成的字符串 &lt;code&gt;s&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一个整理好的字符串中，两个相邻字符 &lt;code&gt;s[i]&lt;/code&gt;和 &lt;code&gt;s[i + 1]&lt;/code&gt;不会同时满足下述条件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 32周双周赛</title>
    <link href="http://yoursite.com/2020/08/09/189/"/>
    <id>http://yoursite.com/2020/08/09/189/</id>
    <published>2020-08-09T02:13:37.052Z</published>
    <updated>2020-08-09T14:45:51.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32周双周赛"><a href="#32周双周赛" class="headerlink" title="32周双周赛"></a>32周双周赛</h1><p>本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。</p><h2 id="5468-第-k-个缺失的正整数"><a href="#5468-第-k-个缺失的正整数" class="headerlink" title="5468. 第 k 个缺失的正整数"></a>5468. 第 k 个缺失的正整数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格升序排列 的正整数数组<code>arr</code>和一个整数 <code>k</code>。</p><p>请你找到这个数组里第 <code>k</code> 个缺失的正整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,...] 。第 <span class="number">5</span> 个缺失的正整数为 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,...] 。第 <span class="number">2</span> 个缺失的正整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li>对于所有 <code>1 &lt;= i &lt; j &lt;= arr.length</code>的 <code>i</code>和 <code>j</code>满足 <code>arr[i] &lt; arr[j]</code>.</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-missing-positive-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-missing-positive-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力计数即可，如果发现当前的计数出现在数组中，则k不变，否则k进行减一操作。</li><li>当<code>k</code>为0时返回当前计数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; arr.size() &amp;&amp; curr == arr[idx])&#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5469-K-次操作转变字符串"><a href="#5469-K-次操作转变字符串" class="headerlink" title="5469. K 次操作转变字符串"></a>5469. K 次操作转变字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，你的目标是在<code>k</code>次操作以内把字符串 <code>s</code> 转变成 <code>t</code>。</p><p>在第 <code>i</code>次操作时<code>（1 &lt;= i &lt;= k）</code>，你可以选择进行如下操作：</p><p>选择字符串 <code>s</code> 中满足 <code>1 &lt;= j &lt;= s.length</code> 且之前未被选过的任意下标 <code>j</code>（下标从<code>1</code>开始），并将此位置的字符切换 <code>i</code>次。<br>不进行任何操作。<br>切换 <code>1</code> 次字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 ‘z’ 切换后会变成 ‘a’）。</p><p>请记住任意一个下标<code>j</code> 最多只能被操作 <code>1</code> 次。</p><p>如果在不超过 <code>k</code> 次操作内可以把字符串 <code>s</code>转变成<code>t</code> ，那么请你返回 <code>true</code> ，否则请你返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"input"</span>, t = <span class="string">"ouput"</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">6</span> 次操作时，我们将 <span class="string">'i'</span> 切换 <span class="number">6</span> 次得到 <span class="string">'o'</span> 。第 <span class="number">7</span> 次操作时，我们将 <span class="string">'n'</span> 切换 <span class="number">7</span> 次得到 <span class="string">'u'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, t = <span class="string">"bcd"</span>, k = <span class="number">10</span></span><br><span class="line">输出：false</span><br><span class="line">解释：我们需要将每个字符切换 <span class="number">1</span> 次才能得到 t 。我们可以在第 <span class="number">1</span> 次操作时将 'a' 切换成 'b' ，但另外 <span class="number">2</span> 个字母在剩余操作中无法再转变为 t 中对应字母。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aab"</span>, t = <span class="string">"bbb"</span>, k = <span class="number">27</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">1</span> 次操作时，我们将第一个 <span class="string">'a'</span> 切换 <span class="number">1</span> 次得到 <span class="string">'b'</span> 。在第 <span class="number">27</span> 次操作时，我们将第二个字母 <span class="string">'a'</span> 切换 <span class="number">27</span> 次得到 <span class="string">'b'</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>1 &lt;= s.length, t.length &lt;= 10^5<br>0 &lt;= k &lt;= 10^9<br>s 和 t 只包含小写英文字母。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-convert-string-in-k-moves</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5470-平衡括号字符串的最少插入次数"><a href="#5470-平衡括号字符串的最少插入次数" class="headerlink" title="5470. 平衡括号字符串的最少插入次数"></a>5470. 平衡括号字符串的最少插入次数</h2><p>给你一个括号字符串 <code>s</code> ，它只包含字符 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。一个括号字符串被称为平衡的当它满足：</p><ul><li>任何左括号 ‘(‘ 必须对应两个连续的右括号 ‘))’ 。</li><li>左括号 ‘(‘ 必须在对应的连续两个右括号 ‘))’ 之前。<br>比方说 “())”， “())(())))” 和 “(())())))” 都是平衡的， “)()”， “()))” 和 “(()))” 都是不平衡的。</li></ul><p>你可以在任意位置插入字符 ‘(‘ 和 ‘)’ 使字符串平衡。</p><p>请你返回让 s 平衡的最少插入次数。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()))"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 <span class="string">"(())))"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"())"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经平衡了。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"))())("</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(((((("</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：添加 <span class="number">12</span> 个 ')' 得到平衡字符串。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")))))))"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在字符串开头添加 <span class="number">4</span> 个 '(' 并在结尾添加 <span class="number">1</span> 个 ')' ，字符串变成平衡字符串 <span class="string">"(((())))))))"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目真心是好题，看似简单，实则需要思考的深度很多，不容易作对，并且做到最简单的方法夜不容易。</li><li>第一种思路，首先补齐右括号<code>)</code>，我们将所有的连续的右括号全部填充成偶数个，然后再将两个右括号<code>))</code>换成单个右括号<code>)</code>,然后再进行匹配，找出最少需要多少个右括号和左括号才能能完成匹配即可。这样做的是思路非常简单容易理解，不容易出错。</li><li>第二种思路，遇到左括号则我们进行计数加<code>1</code>,如果遇到连续的两个右括号，我们将指针指针移动两位，如果遇到<code>1</code>个右括号，我们则将其补齐，这时再看是否有左括号是否能够匹配，如果有左括号可以匹配，我们将左括号计数减一，否则我们补齐一个左括号，最后将剩余的计数的左括号全部补齐匹配即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                curr.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.size() &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!curr.empty())&#123;</span><br><span class="line">                    curr.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans + curr.size()*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5485-找出最长的超赞子字符串"><a href="#5485-找出最长的超赞子字符串" class="headerlink" title="5485. 找出最长的超赞子字符串"></a>5485. 找出最长的超赞子字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>。请返回<code>s</code> 中最长的 超赞子字符串 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><p>该字符串是 <code>s</code> 的一个非空子字符串<br>进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3242415"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：<span class="string">"24241"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"24142"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"12345678"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"213123"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">"213123"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"231132"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-longest-awesome-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-longest-awesome-substring</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目跟之前的<code>1317</code>题目很像，不过这个题目是求得连续子数组为回文串得最长长度。</li><li>题目还是非常有技巧的，首先我们要分析以下，什么样的字串可以通过无数次变化后变为回文字符串：</li></ol><ul><li>2.1字符串中所有字符的统计个数都为偶数。</li><li>2.2字符串中所有字符的统计个数只有一个字符的统计个数为奇数，其余的都为偶数。</li></ul><ol><li>看到上述描述后，由于题目中的字符串只有好友<code>0-9</code>的数字，因此最多只有10种字符，因此我们最多用10位即可表示10种字符的奇偶状态。比如：</li></ol><ul><li><code>0000000000</code>:代表字符<code>0~9</code>的统计个数都为偶数。</li><li><code>1000000000</code>:代表字符<code>1~9</code>的统计个数都为偶数，字符<code>0</code>的统计个数为奇数。</li><li><code>0110000000</code>:代表字符<code>0,3,4,5,6,7,8,9</code>的统计个数都为偶数,字符<code>1,2</code>的统计个数为奇数。</li></ul><ol><li>所以总共有<code>1024</code>种状态，我们获取当前字符索引<code>i</code>的奇偶状态<code>state[i]</code>，同时获取与<code>state[i]</code>相同的最小前缀<code>j</code>，可以得到以当前字符结束的且符合<code>2.1</code>条件的最长字串;当同时依次反转某个字符的奇偶状态得到<code>inverse_state[i]</code>，同时获取与<code>inverse_state[i]</code>相同的最小前缀<code>j</code>,可以得到以当前字符结束的且符合<code>2.2</code>条件的最长字串长度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(<span class="number">1</span>&lt;&lt;<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line">        prev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[i<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            mask ^= (<span class="number">1</span>&lt;&lt;ch);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = mask^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">if</span>(prev[next] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,i-prev[next]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(prev[mask] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                ans = max(ans,i-prev[mask]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev[mask] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;32周双周赛&quot;&gt;&lt;a href=&quot;#32周双周赛&quot; class=&quot;headerlink&quot; title=&quot;32周双周赛&quot;&gt;&lt;/a&gt;32周双周赛&lt;/h1&gt;&lt;p&gt;本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。&lt;/p&gt;&lt;h2 id=&quot;5468-第-k-个缺失的正整数&quot;&gt;&lt;a href=&quot;#5468-第-k-个缺失的正整数&quot; class=&quot;headerlink&quot; title=&quot;5468. 第 k 个缺失的正整数&quot;&gt;&lt;/a&gt;5468. 第 k 个缺失的正整数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 严格升序排列 的正整数数组&lt;code&gt;arr&lt;/code&gt;和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;请你找到这个数组里第 &lt;code&gt;k&lt;/code&gt; 个缺失的正整数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Programming Languages</title>
    <link href="http://yoursite.com/2020/08/05/188/"/>
    <id>http://yoursite.com/2020/08/05/188/</id>
    <published>2020-08-05T04:11:55.607Z</published>
    <updated>2020-08-05T04:12:00.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Programming-languages"><a href="#Programming-languages" class="headerlink" title="Programming languages"></a>Programming languages</h1><p>一直听说<code>coursera</code>上<code>UW</code>的<code>Programming languages</code>的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了<code>part A</code>和<code>part B</code>部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的<code>皮毛</code>,对所谓的<code>lambda</code>表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看<code>python</code>的好多特性都可以在这几门课中找到，特别是<code>yeild,lambda,@,stream</code>等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用<code>rackets</code>编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。<code>PL</code>领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。</p><a id="more"></a><ul><li><code>dynamic type</code>： 最大的好处写起来很爽，非常容易扩展和迁移，但是如果用这种动态语言来做大型工程项目来说，我感觉就是噩梦，因为没有强制的类型和规则，意味着处处都有可能产生<code>bug</code>，因为参数和返回值的类型由运行时决定，意外的产生<code>bug</code>会非常难以调试.并且动态类型语言的效率还是个非常大的问题，因为从语言的实现角度来看，如果真要实现动态类型，实际是需要加许多<code>tag</code>的附加信息来标记类型。</li><li><code>static type</code>:最大的好处是有强制的类型和规则校验，编译器会自动做类型检查，帮程序员发现不必要的类型匹配错误，并静态类型语言很容易编译成机器码，效率会很高，占用的内存会较小。非常适合于大型的工程项目。<br>所以的<code>homework project source code</code>都放在<code>github</code>上。实际还是非常花功夫来完成这些<code>project</code>，又熬了好多次夜才完成这些<code>homework</code>,作为二胎的父亲刷网课不易。</li></ul><p><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages" target="_blank" rel="noopener">programming languages</a></p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111309.png" alt="1"><br><code>part A</code>部分主要讲述了<code>ML</code>语言，其实是一门学术上研究的语言，实际上很少人会用<code>ML</code>语言来开发项目，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。<br>partA 主要学习了不少概念性的东西：</p><ul><li>hw1:主要学习了递归，<code>list</code>和函数的基本概念，以及类型的基本概念，还是颠覆了原来的认知，函数式编程最大的特点就是各种递归操作。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week1" target="_blank" rel="noopener">hw1</a></li><li>hw2:主要学习了<code>pair,tuple</code>以及<code>option</code>,<code>datatype</code>的各种基本概念。非常绕口的概念，跟过程式编程的体会完全不一样。过程式编程主要考虑程序的顺序执行，函数式编程考虑的怎样函数套函数。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week2" target="_blank" rel="noopener">hw2</a></li><li>hw3:学习了基本的<code>curry</code>的概念，感觉印象深刻，其实本质概念，一个函数接受了一个函数作为参数，返回了另一个函数，相当于可以根据参数类型，动态生成一个函数。学到了更高级的<code>map</code>和<code>filter</code>的函数的写法，感觉10行的代码实现了<code>c</code>语言几百行的工作量，非常的优雅，写起来很爽。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week3" target="_blank" rel="noopener">hw3</a></li><li>hw4: 学习了<code>ml</code>基本的模块的概念，如何编写模块和访问控制权限，类似<code>C++</code>中类的基本概念。</li></ul><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111406.png" alt="2"><br><code>part B</code>部分主要讲述了<code>racket</code>语言，其实是一门学术上研究的语言，是由<code>lisp</code>语言发展来的分支，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。</p><ul><li>hw5:学习了<code>racket</code>语言的基本语法和概念，学习了<code>stream</code>和<code>marco</code>的基本使用，毫无疑问的来说<code>stream</code>是个强大的工具，相当于函数本身返回一个函数，然后可以再反复调用这个函数。内部的实现原理其实很简单。<code>racket</code>据说有非常强的<code>marco</code>,不过在这一章里面只写了一个非常简单的皮毛而已。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week5" target="_blank" rel="noopener">hw5</a></li><li>hw6:这章里面主要的就是如何写一个简单的脚本解释器，利用<code>struct</code>创造类型出来，然后各种非常骚的操作写脚本解释器，还有一个很重要的<code>clouser</code>的概念。这章的<code>homework</code>还是比较有意思。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week6" target="_blank" rel="noopener">hw6</a><br>虽然每次的<code>homework</code>代码量不大，但是需要思考的很多，很多其实非常有意思，如果把这么课理解透了，对于理解函数的<code>闭包</code>这种概念就会非常的深刻。</li></ul><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Programming-languages&quot;&gt;&lt;a href=&quot;#Programming-languages&quot; class=&quot;headerlink&quot; title=&quot;Programming languages&quot;&gt;&lt;/a&gt;Programming languages&lt;/h1&gt;&lt;p&gt;一直听说&lt;code&gt;coursera&lt;/code&gt;上&lt;code&gt;UW&lt;/code&gt;的&lt;code&gt;Programming languages&lt;/code&gt;的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了&lt;code&gt;part A&lt;/code&gt;和&lt;code&gt;part B&lt;/code&gt;部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的&lt;code&gt;皮毛&lt;/code&gt;,对所谓的&lt;code&gt;lambda&lt;/code&gt;表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看&lt;code&gt;python&lt;/code&gt;的好多特性都可以在这几门课中找到，特别是&lt;code&gt;yeild,lambda,@,stream&lt;/code&gt;等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用&lt;code&gt;rackets&lt;/code&gt;编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。&lt;code&gt;PL&lt;/code&gt;领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PL" scheme="http://yoursite.com/categories/PL/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 Brainfuck编译器</title>
    <link href="http://yoursite.com/2020/08/04/187/"/>
    <id>http://yoursite.com/2020/08/04/187/</id>
    <published>2020-08-04T02:34:26.152Z</published>
    <updated>2020-08-04T02:34:32.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Brain-fuck语言"><a href="#Brain-fuck语言" class="headerlink" title="Brain fuck语言"></a>Brain fuck语言</h1><p>第一次听到<code>brain fuck</code>语言是在提交<code>spoj</code>第二道题目时，竟然用<code>brain fuck</code>语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。</p><ul><li>背景：<code>Brainfuck</code>是一种极小化的计算机语言，它是由<code>Urban Müller</code>在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段<code>brain fuck</code>代码：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/111.png" alt="1"><br>这段奇怪的符号实际为<code>100</code>行的<code>Brainfuck</code>虚拟机，实际代码非常晦涩难懂。</li><li>现状：实际上<code>brain fuck</code>只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。</li></ul><a id="more"></a><h2 id="语言规则"><a href="#语言规则" class="headerlink" title="语言规则"></a>语言规则</h2><p>实际上<code>brain fuck</code>只规定了8种基本的机器操作，分别为：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。每个操作用一个符号来替代。下表为实际的操作说明。</p><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th><th>C语言实现</th></tr></thead><tbody><tr><td>&gt;</td><td>当前的地址加1</td><td>ptr++</td></tr><tr><td>&lt;</td><td>当前的地址加1</td><td>ptr—</td></tr><tr><td>+</td><td>指针指向的字节的值加一</td><td>++*ptr;</td></tr><tr><td>-</td><td>指针指向的字节的值减一</td><td>—*ptr;</td></tr><tr><td>.</td><td>输出指针指向的单元内容（ASCII码）</td><td>putchar(*ptr);</td></tr><tr><td>,</td><td>输入内容到指针指向的单元（ASCII码）</td><td>*ptr =getchar();</td></tr><tr><td>[</td><td>如果当前指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</td><td>while (*ptr){</td></tr><tr><td>]</td><td>如果当前指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</td><td>}</td></tr></tbody></table></div><p>实际用<code>brain fuck</code>语言来写程序的话，非常锻炼你的机器思维。</p><ul><li><p>在屏幕上打印<code>hello word!</code>:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&lt;&lt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure></li><li><p>目前位置归零,我们可以看到当执行到<code>[</code>时，如果当前指针值不等于<code>0</code>则顺序执行<code>-</code>,否则跳到下一个<code>]</code>的后一条指令，当执行到<code>]</code>时，如果当前指针值不等于<code>0</code>则跳转到<code>-</code>，一直循环直到当前指针的位置为<code>0</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name"><span class="builtin-name">-</span></span>]</span><br></pre></td></tr></table></figure></li><li><p>字符I/O,从键盘中读取一个字符，然后打印出来。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,.</span><br></pre></td></tr></table></figure></li><li><p>简单的循环读取键盘字符,直到输入字符<code>\0</code>结束。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="string">[.,]</span></span><br></pre></td></tr></table></figure></li><li><p>将所有的输入的字符全部保存到内存中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;,<span class="string">[.&gt;,]</span></span><br></pre></td></tr></table></figure></li><li><p>加法,这个比较有趣，每次将当前的位置元素减<code>1</code>,同时将下一个指针的元素的元素加<code>1</code>,直到当前元素的元素为<code>0</code>.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;+&lt;]</span><br></pre></td></tr></table></figure></li><li><p>条件指令.这个程序会把从键盘读来的小写字符转换成大写。按回车键退出程序,每次读取大写字符<code>x</code>,然后将其减去<code>34</code>即可，如果读到回车键，则它的<code>ascii</code>码为<code>10</code>,刚好<code>10</code>的时候，程序会退出。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure></li><li><p>加法器 <code>add(summand, addend, *sum)</code></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&lt;&lt;&lt; // clear cell <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">[-&gt;&gt;+&gt;+&lt;&lt;&lt;] // transfer cell <span class="string">#0</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#0</span></span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // transfer cell <span class="string">#1</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#1</span></span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure><p>该代码以 cell #3 作为临时变量，将保存在 cell #0 和 cell #1 中的两个整数相加，<br>结果保存在 cell #2；同时维持原来的两个存储单元数值不变，方便以后使用。<br>代码运行前，设定指针指向 cell #0，<br>第一步，先将 cell #2 和 cell #3 清空，确保不会有脏数据影响运算结果；<br>第二步，将 cell #0 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #0 的值；<br>第三步，将 cell #1 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #1 的值；<br>最后，指针归位（回到初始位置，即指向 cell #0），方便后续运算。</p></li><li><p>乘法器 <code>multiply(multiplicand, multiplier, *product)</code></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&gt;[-]&lt;&lt;&lt;&lt; // clear cell <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span> <span class="keyword">and</span> <span class="symbol">#4</span></span><br><span class="line">[-&gt;</span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // <span class="keyword">add</span> cell <span class="symbol">#1</span> <span class="keyword">to</span> <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">[-&lt;&lt;+&gt;&gt;] // move cell <span class="symbol">#3</span> back <span class="keyword">to</span> <span class="symbol">#1</span></span><br><span class="line">&gt;+&lt; // copy cell <span class="symbol">#0</span> <span class="keyword">to</span> <span class="symbol">#4</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">&lt;]</span><br><span class="line">&gt;&gt;&gt;&gt;[-&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt; // move cell <span class="symbol">#4</span> back <span class="keyword">to</span> <span class="symbol">#0</span></span><br></pre></td></tr></table></figure><p>跟上面的“加法器”类似，这个“乘法器”将保存在 cell #0 和 cell #1 的两个整数相乘，结果保存在 cell</p><h1 id="2；同时维持原来的两个存储单元数值不变，方便以后使用。"><a href="#2；同时维持原来的两个存储单元数值不变，方便以后使用。" class="headerlink" title="2；同时维持原来的两个存储单元数值不变，方便以后使用。"></a>2；同时维持原来的两个存储单元数值不变，方便以后使用。</h1></li></ul><p>从以上几个例子，我们可以看出实际上<code>brain fuck</code>实际还是非常有意思的，非常锻炼逻辑思维能力，但是实际工业界和学术界肯定不会用这么低效的语言来开发实际程序。</p><h2 id="brainfuck-解释器"><a href="#brainfuck-解释器" class="headerlink" title="brainfuck 解释器"></a>brainfuck 解释器</h2><p>由于<code>brain fuck</code>语言的功能很简单，只有8个指令，实际上我们可以C语言大概<code>100</code>行左右就可以实现该语言的解释器。</p><ul><li>直接翻译为C语言：这个就比较简单,我们直接翻译即可，转换为C语言。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"brainfuck_out.c"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    out&lt;&lt;<span class="string">"#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"int main()&#123;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char arr[1000000];\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char *ptr = arr;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  memset(arr,0,sizeof(arr));\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: out&lt;&lt;<span class="string">"    ++ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: out&lt;&lt;<span class="string">"    --ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: out&lt;&lt;<span class="string">"    ++*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: out&lt;&lt;<span class="string">"    --*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: out&lt;&lt;<span class="string">"    putchar(*ptr);\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: out&lt;&lt;<span class="string">"    *ptr =getchar();\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: out&lt;&lt;<span class="string">"    while (*ptr) &#123;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: out&lt;&lt;<span class="string">"    &#125;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;<span class="string">"&#125;\n"</span>;</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>直接源程序文件，进行解析。稍微复杂点的是需要找到左括号<code>[</code>最近的右括号，同时需要找到右括号<code>]</code>最近的左括号，我们用<code>skip_table</code>存放跳转指令即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="built_in">string</span> code;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">       code.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* check '[]'*/</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; skip_table;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; code.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(code[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">            assert(!st.empty());</span><br><span class="line">            skip_table[i] = st.top();</span><br><span class="line">            <span class="keyword">if</span>(!skip_table.count(st.top()))&#123;</span><br><span class="line">                skip_table[st.top()] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = arr;</span><br><span class="line">    <span class="keyword">while</span>(ip &lt; code.size())&#123;</span><br><span class="line">        c = code[ip];</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;assert(ptr &lt; (arr+MAX_SIZE<span class="number">-1</span>)); ptr++;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;assert(ptr &gt; arr); ptr--;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: &#123;++*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: &#123;--*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: &#123;<span class="built_in">putchar</span>(*ptr);&#125;  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: &#123;*ptr = getchar();&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: <span class="keyword">if</span>(*ptr == <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(*ptr != <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ip++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h2><ul><li>将当前字节减去<code>100</code>，当然我们可以书写成连续<code>100</code>个<code>-</code>,但是这明显太长了。我们可以用<code>10</code>个循环减去<code>10</code>来完成。</li></ul><ol><li>首先将下一个字节作为计数器，首先对下一个字节清零，然后直接加上10;</li><li>我们对上一个字节减去<code>10</code>，然后对下一个字节减去<code>1</code>;</li><li>直到下一个字节为<code>0</code>即可。<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">[-]</span>++++++++++<span class="string">[&lt;----------&gt;-]</span>&lt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><code>Brainfuck</code>总的来说还是非常烧脑的程序，用来写非常普通的计算程序会非常麻烦，但是我们需要这样的练习。对于负数或者浮点数感觉非常的复杂，应为<code>ieee754</code>浮点数的标准解析浮点数是非常蛋疼的一件事。目前只看到部分非常蛋疼的<code>OJ</code>上有要求用<code>brainfuck</code>代码来解题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Brain-fuck语言&quot;&gt;&lt;a href=&quot;#Brain-fuck语言&quot; class=&quot;headerlink&quot; title=&quot;Brain fuck语言&quot;&gt;&lt;/a&gt;Brain fuck语言&lt;/h1&gt;&lt;p&gt;第一次听到&lt;code&gt;brain fuck&lt;/code&gt;语言是在提交&lt;code&gt;spoj&lt;/code&gt;第二道题目时，竟然用&lt;code&gt;brain fuck&lt;/code&gt;语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;背景：&lt;code&gt;Brainfuck&lt;/code&gt;是一种极小化的计算机语言，它是由&lt;code&gt;Urban Müller&lt;/code&gt;在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段&lt;code&gt;brain fuck&lt;/code&gt;代码：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/111.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;这段奇怪的符号实际为&lt;code&gt;100&lt;/code&gt;行的&lt;code&gt;Brainfuck&lt;/code&gt;虚拟机，实际代码非常晦涩难懂。&lt;/li&gt;
&lt;li&gt;现状：实际上&lt;code&gt;brain fuck&lt;/code&gt;只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 200周赛</title>
    <link href="http://yoursite.com/2020/08/02/186/"/>
    <id>http://yoursite.com/2020/08/02/186/</id>
    <published>2020-08-02T07:53:24.458Z</published>
    <updated>2020-08-02T07:53:57.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="200场周赛"><a href="#200场周赛" class="headerlink" title="200场周赛"></a>200场周赛</h1><p>本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的<code>dp</code>即可做出来，四道题全部AC，周赛排名<code>150</code>。</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png" alt="image-20200802145522515"></p><h2 id="5475-统计好三元组"><a href="#5475-统计好三元组" class="headerlink" title="5475. 统计好三元组"></a>5475. 统计好三元组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> ，以及 <code>a、b 、c</code>三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 好三元组 。</p><a id="more"></a><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code><br>其中 <code>|x|</code> 表示 <code>x</code>的绝对值。</li></ul><p>返回 好三元组的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>], a = <span class="number">7</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一共有 <span class="number">4</span> 个好三元组：[(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-good-triplets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-triplets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力三重循环即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-arr[j]) &lt;= a &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[j]-arr[k]) &lt;= b &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[i]-arr[k]) &lt;= c)&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5476-找出数组游戏的赢家"><a href="#5476-找出数组游戏的赢家" class="headerlink" title="5476. 找出数组游戏的赢家"></a>5476. 找出数组游戏的赢家</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 不同 整数组成的整数数组 <code>arr</code>和一个整数 <code>k</code>。</p><p>每回合游戏都在数组的前两个元素（即<code>arr[0]</code>和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code>与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code>，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code>个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>返回赢得比赛的整数。</p><p>题目数据 保证 游戏存在赢家。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一起看一下本场游戏每回合的情况：</span><br><span class="line"></span><br><span class="line">因此将进行 <span class="number">4</span> 回合比赛，其中 <span class="number">5</span> 是赢家，因为它连胜 <span class="number">2</span> 回合。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 将会在前 <span class="number">10</span> 个回合中连续获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>], k = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">99</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>arr</code> 所含的整数 各不相同 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-winner-of-an-array-game</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5477-排布二进制网格的最少交换次数"><a href="#5477-排布二进制网格的最少交换次数" class="headerlink" title="5477. 排布二进制网格的最少交换次数"></a>5477. 排布二进制网格的最少交换次数</h2><p>给你一个<code>n x n</code>的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 相邻两行 进行交换。</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <code>0</code>。</p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <code>-1</code> 。</p><p>主对角线指的是从 <code>(1, 1)</code>到 <code>(n, n)</code> 的这些格子。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152236.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152257.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：所有行都是一样的，交换相邻行无法使网格符合要求。</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152310.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>grid[i][j]</code>要么是 <code>0</code>要么是 <code>1</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先取出所有行的末尾0的个数。</li><li>如果按照条件要求满足第<code>i</code>行末尾<code>0</code>的个数必须要大于等于<code>n-1-i</code>,如果不存在满足要求的行则认为该矩阵无法变换成满足要求，否则则找到一个满足要求的行<code>j</code>,与第<code>i</code>行进行交换，然后第<code>i</code>行至第<code>j-1</code>行全部往后移动一行即可。</li><li>依次循环下一行，典型的贪心算法，找到第一个满足要求的行，然后交换。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero(row,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) zero[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*mini swap*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zero[i] &gt;= (row<span class="number">-1</span>-i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zero[j] &gt;= (row<span class="number">-1</span>-i))&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t<span class="number">-1</span>; j &gt;= i; --j)&#123;</span><br><span class="line">                swap(zero[j],zero[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (t-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5478-最大得分"><a href="#5478-最大得分" class="headerlink" title="5478. 最大得分"></a>5478. 最大得分</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有两个 有序 且数组内元素互不相同的数组 <code>nums1</code>和 <code>nums2</code>。</p><p>一条 合法路径 定义如下：</p><p>选择数组 <code>nums1</code> 或者 <code>nums2</code>开始遍历（从下标 <code>0</code>处开始）。<br>从左到右遍历当前数组。<br>如果你遇到了<code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。<br>得分定义为合法路径中不同数字的和。</p><p>请你返回所有可能合法路径中的最大得分。</p><p>由于答案可能很大，请你将它对 <code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802155350.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">30</span></span><br><span class="line">解释：合法路径包括：</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>],（从 nums1 开始遍历）</span><br><span class="line">[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  （从 nums2 开始遍历）</span><br><span class="line">最大得分为上图中的绿色路径 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], nums2 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>]</span><br><span class="line">输出：<span class="number">109</span></span><br><span class="line">解释：最大得分由路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], nums2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：nums1 和 nums2 之间无相同数字。</span><br><span class="line">最大得分由路径 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">19</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">61</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 10^5</code></li><li><code>1 &lt;= nums2.length &lt;= 10^5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/get-the-maximum-score" target="_blank" rel="noopener">https://leetcode-cn.com/problems/get-the-maximum-score</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，跟以前的某个题目很想，即两个数组中取最大的路径。</li><li>本身题目一眼看到就直到怎么做，所以肯定可以做出来，直接copy排名第一的代码。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000001</span>;</span><br><span class="line">        boolean[] a = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        boolean[] b = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums1)a[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums2)b[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> da = <span class="number">0</span>, db = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])da += i;</span><br><span class="line">        <span class="keyword">if</span>(b[i])db += i;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">        da = Math.max(da, db);</span><br><span class="line">        db = da;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>)(Math.max(da, db)%<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;200场周赛&quot;&gt;&lt;a href=&quot;#200场周赛&quot; class=&quot;headerlink&quot; title=&quot;200场周赛&quot;&gt;&lt;/a&gt;200场周赛&lt;/h1&gt;&lt;p&gt;本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的&lt;code&gt;dp&lt;/code&gt;即可做出来，四道题全部AC，周赛排名&lt;code&gt;150&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png&quot; alt=&quot;image-20200802145522515&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5475-统计好三元组&quot;&gt;&lt;a href=&quot;#5475-统计好三元组&quot; class=&quot;headerlink&quot; title=&quot;5475. 统计好三元组&quot;&gt;&lt;/a&gt;5475. 统计好三元组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; ，以及 &lt;code&gt;a、b 、c&lt;/code&gt;三个整数。请你统计其中好三元组的数量。&lt;/p&gt;&lt;p&gt;如果三元组 &lt;code&gt;(arr[i], arr[j], arr[k])&lt;/code&gt; 满足下列全部条件，则认为它是一个 好三元组 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 199周赛</title>
    <link href="http://yoursite.com/2020/07/26/185/"/>
    <id>http://yoursite.com/2020/07/26/185/</id>
    <published>2020-07-26T10:17:23.607Z</published>
    <updated>2020-08-02T07:58:45.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199场周赛"><a href="#199场周赛" class="headerlink" title="199场周赛"></a>199场周赛</h1><p>稳定的三道选手，最后一题<code>hard</code>难度不会。</p><h2 id="5472-重新排列字符串"><a href="#5472-重新排列字符串" class="headerlink" title="5472. 重新排列字符串"></a>5472. 重新排列字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个 长度相同 的整数数组 <code>indices</code> 。</p><p>请你重新排列字符串 s ，其中第 i 个字符需要移动到<code>indices[i]</code>指示的位置。</p><p>返回重新排列后的字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"codeleet"</span>, indices = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：如图所示，<span class="string">"codeleet"</span> 重新排列后变为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, indices = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"abc"</span></span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aiohn"</span>, indices = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">"nihao"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaiougrt"</span>, indices = [<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="string">"arigatou"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"art"</span>, indices = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"rat"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/shuffle-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shuffle-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(n,<span class="string">'a'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[indices[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5473-灯泡开关-IV"><a href="#5473-灯泡开关-IV" class="headerlink" title="5473. 灯泡开关 IV"></a>5473. 灯泡开关 IV</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>房间中有 n 个灯泡，编号从 <code>0</code>到 <code>n-1</code> ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。</p><p>请你设法使得灯泡的开关状态和 <code>target</code>描述的状态一致，其中 <code>target[i]</code>等于 <code>1</code>第 <code>i</code>个灯泡是开着的，等于 0 意味着第 <code>i</code>个灯是关着的。</p><p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p><p>选择当前配置下的任意一个灯泡（下标为 i ）<br>翻转下标从<code>i</code>到 <code>n-1</code> 的每个灯泡<br>翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。</p><p>返回达成 <code>target</code>描述的状态所需的 最少 翻转次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"10111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：初始配置 <span class="string">"00000"</span>.</span><br><span class="line">从第 <span class="number">3</span> 个灯泡（下标为 <span class="number">2</span>）开始翻转 <span class="string">"00000"</span> -&gt; <span class="string">"00111"</span></span><br><span class="line">从第 <span class="number">1</span> 个灯泡（下标为 <span class="number">0</span>）开始翻转 <span class="string">"00111"</span> -&gt; <span class="string">"11000"</span></span><br><span class="line">从第 <span class="number">2</span> 个灯泡（下标为 <span class="number">1</span>）开始翻转 <span class="string">"11000"</span> -&gt; <span class="string">"10111"</span></span><br><span class="line">至少需要翻转 <span class="number">3</span> 次才能达成 target 描述的状态</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="string">"000"</span> -&gt; <span class="string">"111"</span> -&gt; <span class="string">"100"</span> -&gt; <span class="string">"101"</span>.</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"00000"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"001011101"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>target[i] == &#39;0&#39; 或者 target[i] == &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iv</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目还是稍微有点<code>corner</code>,最终就是统计连续的<code>1</code>和<code>0</code>即可。</li><li>需要仔细思考一下，实际上我们可以将数目划分成初始状态相同的连续段即可，每一段作为整体翻转即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> curr = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c != curr)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                curr = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5474-好叶子节点对的数量"><a href="#5474-好叶子节点对的数量" class="headerlink" title="5474. 好叶子节点对的数量"></a>5474. 好叶子节点对的数量</h2><p>给你二叉树的根节点<code>root</code> 和一个整数 <code>distance</code>。</p><p>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 <code>distance</code>，那它们就可以构成一组 好叶子节点对 。</p><p>返回树中 好叶子节点对的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：树的叶节点是 <span class="number">3</span> 和 <span class="number">4</span> ，它们之间的最短路径的长度是 <span class="number">3</span> 。这是唯一的好叶子节点对。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好叶子节点对为 [<span class="number">4</span>,<span class="number">5</span>] 和 [<span class="number">6</span>,<span class="number">7</span>] ，最短路径长度都是 <span class="number">2</span> 。但是叶子节点对 [<span class="number">4</span>,<span class="number">6</span>] 不满足要求，因为它们之间的最短路径长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一的好叶子节点对是 [<span class="number">2</span>,<span class="number">5</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">100</span>], distance = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], distance = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>tree</code> 的节点数在<code>[1, 2^10]</code> 范围内。</li><li>每个节点的值都在 <code>[1, 100]</code>之间。</li><li><code>1 &lt;= distance &lt;= 10</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 标准的dfs</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的DFS，每次统计当前节点下，所有叶子节点到该根节点的距离。</li><li>每次DFS时，先计算左子树和右子树下的所有叶子节点到子树根节点的距离。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dfs(TreeNode * root,<span class="keyword">int</span> distance,<span class="keyword">int</span> &amp; res)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            left = dfs(root-&gt;left,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[lv.first + <span class="number">1</span>] += lv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            right = dfs(root-&gt;right,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv : right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[rv.first+<span class="number">1</span>] += rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv: right)&#123;</span><br><span class="line">                <span class="keyword">if</span>((lv.first + rv.first + <span class="number">2</span>) &lt;= distance)&#123;</span><br><span class="line">                    res += lv.second*rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root,distance,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5462-压缩字符串-II"><a href="#5462-压缩字符串-II" class="headerlink" title="5462. 压缩字符串 II"></a>5462. 压缩字符串 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code>，将 “aa” 替换为 “a2” ，”ccc” 替换为<code>&quot;c3&quot;</code>。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code>。</p><p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p><p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p><p>请你返回删除最多 <code>k</code>个字符后，s 行程长度编码的最小长度 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabcccd"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在不删除任何内容的情况下，压缩后的字符串是 <span class="string">"a3bc3d"</span> ，长度为 <span class="number">6</span> 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 <span class="string">"a3c3"</span> ，长度是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabbaa"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 <span class="number">2</span> 的 <span class="string">"a4"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaaaaaaaa"</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：由于 k 等于 <span class="number">0</span> ，不能删去任何字符。压缩后的字符串是 <span class="string">"a11"</span> ，长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= k &lt;= s.length</code></li><li><code>s</code> 仅包含小写英文字母</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/string-compression-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-compression-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始想到的也是<code>dp</code>，但是没有想到<code>dp</code>的递推公式到底该怎么写？</li><li><code>dp</code>或者记忆化搜索。</li><li>动态规划状态转移方程定义为<code>dp[i][j]</code>：</li></ol><ul><li>代表到达当前索引<code>i</code>处，已经选择删除了<code>j</code>个字符的最短长度。</li><li>假设对于当前索引<code>i+1</code>处的字符，如果我们选择删除第<code>i+1</code>个字符，则此时<script type="math/tex; mode=display">dp[i+1][j+1] = dp[i][j]</script>此时因为第<code>i+1</code>个字符已经被删除，所以我们实际上就相当于等于<code>dp[i][j]</code>.</li></ul></blockquote><ul><li>假设我们保留索引<code>i</code>处的字符，则我们应该选择后续与字符<code>i</code>相同的字符进行保留。则此时的状态转移方程为：<script type="math/tex; mode=display">dp[l][j+l-i-same(s[i],i,l)] = min(dp[i][j], len(same(s[i],i,l))]</script></li><li>方程比较难理解，意思假如我们保留当前字符串，则我们尝试在后续过程中连续增加与该字符相同的字符数量。</li></ul><ol><li>不管怎么算，最优解肯定包含在这个递推公式中，这也是动态规划的魅力。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+<span class="number">1</span>] = c[i];</span><br><span class="line">            c[i+<span class="number">1</span>][s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            len[i] = to_string(i).size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">                f[i][j] = INF;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> pos = i+<span class="number">1</span>; pos &lt;= n; ++pos)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">26</span>; ++nxt)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> has = c[pos][nxt]-c[i][nxt];</span><br><span class="line">                        <span class="keyword">if</span> (has == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i)] = min(f[pos][j+(pos-i)], f[i][j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i-has) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i-has)] = min(f[pos][j+(pos-i-has)], f[i][j]+len[has]+<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            res = min(res, f[n][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> dp[N][N][N][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> killed, <span class="keyword">int</span> len, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n) <span class="keyword">return</span> len &lt;= <span class="number">1</span> ? len : to_string(len).size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>&amp; ret = dp[pos][killed][len][last];</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        ret = N;</span><br><span class="line">        <span class="keyword">if</span> (killed + <span class="number">1</span> &lt;= m) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed + <span class="number">1</span>, len, last));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = s[pos] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == last) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed, len + <span class="number">1</span>, k));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = min((<span class="keyword">int</span>)ret, (len &lt;= <span class="number">1</span> ? len : (<span class="keyword">int</span>)to_string(len).size() + <span class="number">1</span>) + solve(pos + <span class="number">1</span>, killed, <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        n = s.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">255</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ret = solve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">1</span> &amp;&amp; k &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt;= <span class="number">10</span> &amp;&amp; k &lt; <span class="number">100</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">2</span>,INF));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; k) dp[i][j+<span class="number">1</span>] = min(dp[i][j+<span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> del = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = i; m &lt;= n; ++m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[m<span class="number">-1</span>] == s[i<span class="number">-1</span>]) same++;</span><br><span class="line">                    <span class="keyword">else</span> del++;</span><br><span class="line">                    <span class="keyword">if</span>(j + del &lt;= k)&#123;</span><br><span class="line">                        dp[m][j+del] = min(dp[m][j+del],len(same) + dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;199场周赛&quot;&gt;&lt;a href=&quot;#199场周赛&quot; class=&quot;headerlink&quot; title=&quot;199场周赛&quot;&gt;&lt;/a&gt;199场周赛&lt;/h1&gt;&lt;p&gt;稳定的三道选手，最后一题&lt;code&gt;hard&lt;/code&gt;难度不会。&lt;/p&gt;&lt;h2 id=&quot;5472-重新排列字符串&quot;&gt;&lt;a href=&quot;#5472-重新排列字符串&quot; class=&quot;headerlink&quot; title=&quot;5472. 重新排列字符串&quot;&gt;&lt;/a&gt;5472. 重新排列字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 s 和一个 长度相同 的整数数组 &lt;code&gt;indices&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;请你重新排列字符串 s ，其中第 i 个字符需要移动到&lt;code&gt;indices[i]&lt;/code&gt;指示的位置。&lt;/p&gt;&lt;p&gt;返回重新排列后的字符串。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如图所示，&lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt; 重新排列后变为 &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：重新排列后，每个字符都还留在原来的位置上。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aiohn&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;nihao&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aaiougrt&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;arigatou&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;art&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;rat&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 31周双周赛</title>
    <link href="http://yoursite.com/2020/07/26/184/"/>
    <id>http://yoursite.com/2020/07/26/184/</id>
    <published>2020-07-26T01:53:36.554Z</published>
    <updated>2020-07-26T01:53:40.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="31场双周赛"><a href="#31场双周赛" class="headerlink" title="31场双周赛"></a>31场双周赛</h1><p>题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名<code>387</code>.</p><h2 id="5456-在区间范围内统计奇数数目"><a href="#5456-在区间范围内统计奇数数目" class="headerlink" title="5456. 在区间范围内统计奇数数目"></a>5456. 在区间范围内统计奇数数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">3</span>, high = <span class="number">7</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 到 <span class="number">7</span> 之间奇数数字为 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">8</span>, high = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">8</span> 到 <span class="number">10</span> 之间奇数数字为 [<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学数学问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>小学数学问题，仔细推理一下就得到结果。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOdds</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> between = high - low;</span><br><span class="line">        <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (between+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> between/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5457-和为奇数的子数组数目"><a href="#5457-和为奇数的子数组数目" class="headerlink" title="5457. 和为奇数的子数组数目"></a>5457. 和为奇数的子数组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> 。请你返回和为 奇数 的子数组数目。</p><p>由于答案可能会很大，请你将结果对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有的子数组为 [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">5</span>]] 。</span><br><span class="line">所有子数组的和为 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>].</span><br><span class="line">奇数和包括 [<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>] ，所以答案为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有子数组为 [[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">4</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">6</span>]] 。</span><br><span class="line">所有子数组和为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>] 。</span><br><span class="line">所有子数组和都是偶数，所以答案为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">99</span>,<span class="number">99</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的动态规划，有两种思路。</li><li>第一种统计直到当前索引处，之前的前缀和中存在的偶数的数目和奇数的数目。</li><li>第二种统计以前一个元素<code>i-1</code>为结尾的子数组的和的数目中有多少个为偶数，有多少个为奇数。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                even++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = odd;</span><br><span class="line">                odd = even+<span class="number">1</span>;</span><br><span class="line">                even = t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + odd)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5458-字符串的好分割数目"><a href="#5458-字符串的好分割数目" class="headerlink" title="5458. 字符串的好分割数目"></a>5458. 字符串的好分割数目</h2><p>给你一个字符串<code>s</code>，一个分割被称为 「好分割」 当它满足：将 s 分割成 <code>2</code>个字符串 <code>p</code>和 <code>q</code>，它们连接起来等于 <code>s</code> 且<code>p</code> 和 <code>q</code>中不同字符的数目相同。</p><p>请你返回 <code>s</code>中好分割的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aacaba"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">5</span> 种分割字符串 <span class="string">"aacaba"</span> 的方法，其中 <span class="number">2</span> 种是好分割。</span><br><span class="line">(<span class="string">"a"</span>, <span class="string">"acaba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aa"</span>, <span class="string">"caba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aac"</span>, <span class="string">"aba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aaca"</span>, <span class="string">"ba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aacab"</span>, <span class="string">"a"</span>) 左边字符串和右边字符串分别包含 <span class="number">3</span> 个和 <span class="number">1</span> 个不同的字符。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcd"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：好分割为将字符串分割成 (<span class="string">"ab"</span>, <span class="string">"cd"</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaa"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有分割都是好分割。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"acbadbaada"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s</code> 只包含小写英文字母。</li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 统计字符个数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次将字符串分裂为两部分，求左右两部分的字符统计个数。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSplits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            right[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            right[s[i]-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[j] &gt; <span class="number">0</span>) l++;</span><br><span class="line">                <span class="keyword">if</span>(right[j] &gt; <span class="number">0</span>) r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5459-形成目标数组的子数组最少增加次数"><a href="#5459-形成目标数组的子数组最少增加次数" class="headerlink" title="5459. 形成目标数组的子数组最少增加次数"></a>5459. 形成目标数组的子数组最少增加次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>target</code>和一个数组 <code>initial</code> ，<code>initial</code> 数组与 <code>target</code>  数组有同样的维度，且一开始全部为 0 。</p><p>请你返回从 <code>initial</code> 得到  <code>target</code> 的最少操作次数，每次操作需遵循以下规则：</p><p>在 <code>initial</code> 中选择 任意 子数组，并将子数组中每个元素增加 1 。<br>答案保证在 <code>32</code>位有符号整数以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们需要至少 <span class="number">3</span> 次操作从 <span class="built_in">int</span>ial 数组得到 target 数组。</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 将下标为 <span class="number">0</span> 到 <span class="number">4</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 将下标为 <span class="number">1</span> 到 <span class="number">3</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 将下表为 <span class="number">2</span> 的元素增加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] 得到了目标数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] (target) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] </span><br><span class="line">                                  -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>] (target)。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>1 &lt;= target[i] &lt;= 10^5</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>仔细分析一下，我们可以将类似的图画出来,数组的上升和下降描述如图所示。<br><img src="https://pic.leetcode-cn.com/3be4e85cf2f773d84ad514812a541ceabe6e333a6ae9a2bb3ed0c572051cc0bd-5.png" alt="1"></li><li>类似于爬坡，由于子数组每次增加的大小为1，我们只需要统计从每个区间从谷底爬到谷峰需要的数目之和即可。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOperations</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == null || target.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = target[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            <span class="comment">//若target[i] - target[i - 1] &gt; 0</span></span><br><span class="line">            ans += Math.max(target[i] - target[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;31场双周赛&quot;&gt;&lt;a href=&quot;#31场双周赛&quot; class=&quot;headerlink&quot; title=&quot;31场双周赛&quot;&gt;&lt;/a&gt;31场双周赛&lt;/h1&gt;&lt;p&gt;题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名&lt;code&gt;387&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;5456-在区间范围内统计奇数数目&quot;&gt;&lt;a href=&quot;#5456-在区间范围内统计奇数数目&quot; class=&quot;headerlink&quot; title=&quot;5456. 在区间范围内统计奇数数目&quot;&gt;&lt;/a&gt;5456. 在区间范围内统计奇数数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://yoursite.com/2020/07/20/183/"/>
    <id>http://yoursite.com/2020/07/20/183/</id>
    <published>2020-07-20T03:39:33.773Z</published>
    <updated>2020-07-20T15:00:57.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在<code>O(lgn)</code>时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下<code>lowbit</code>的概念.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过lowbit本质即快速的求出一个数二进制最低位的1.<br>对于原始数组<code>A[n]</code>,我们定义一个服装数组<code>tr[n]</code>.其中tr[i]为数组中<code>i</code>开始的前<code>lowbit(i)</code>个元素的和，我们可以用以下公式表示:</p><a id="more"></a><script type="math/tex; mode=display">tr[i] = \sum_{j = (i-lowbit(i)+1)}^{i}A[j]</script><p>实际上我们也可以利用前缀和，快速的求出<code>tr[i]</code>.</p><script type="math/tex; mode=display">tr[i] = presum[i] - presum[i-lowbit(i)]</script><p>利用前缀和即可在<code>O(n)</code>的时间复杂度内初始化<code>tr</code>数组。</p><ul><li><strong>单点更新</strong>：数组A[i]单点更新数组中元素单点跟新后，我们只需要找到它的父节点进行传递更新即可，采用累加<code>lowbit</code>即可。原理其实很简单，本质上是递归。将数组中<code>tr</code>中含有<code>A[i]</code>的节点全部进行更新即可。<br>更新的技巧为，我们不断的叠加<code>lowbit</code>直到<code>i</code>的大于<code>n</code>，我们如何快速的查找它的父节点呢？</li></ul><ol><li>比如<code>i</code>为12，我们如何快速找到12的父节点呢，A[12]最近的父节点为<code>tr[12]</code>.</li><li>第一次加上<code>lowbit(12)</code>,<code>i</code>变为<code>16</code>，A[12]的第二个父节点为<code>tr[16]</code>.,</li><li>第一次加上<code>lowbit(16)</code>,<code>i</code>变为<code>32</code>，A[12]的第三个父节点为<code>tr[32]</code>.,</li><li>直到<code>i</code>大于数组的长度<code>n</code>结束。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) </span><br><span class="line">        tr[i] += a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间和获取</strong>：我们可以快速的获取数组A中前<code>i</code>个元素，则区间和即为<code>tr[i]-tr[j]</code>。其实本质上我们是对<code>i</code>按照二进制进行分解，分别求出前$2^{k}$个元素。<script type="math/tex; mode=display">i = \sum_{j = 1}^{k} 2^{a^{j}}</script>可以举个例子来说明，比如数字12的二进制位<code>1100</code>,可以分解位<code>12 = 8 + 4</code>.</li></ul><ol><li>取第一次<code>lowbit(i)</code>为<code>4</code>，这时我们取得数字<code>12</code>的前4个数组中的元素分别为<code>A[12],A[11],A[10],A[9]</code>。</li><li>减掉第一个<code>lowbit(i)</code>，则数字<code>i</code>变为<code>8</code>，我们再次获取<code>i</code>的<code>lowbit(i)</code>个元素,即获取前8个元素，则这时的取得元素为：<code>A[8],A[7],A[6],A[5],A[4],A[3],A[2],A[1]</code>.<br>通过上面这个例子我们即可以看出如何进行分别求合。原理非常巧妙。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))  res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间更新</strong>：区间更新稍微复杂点，比如我们对数组<code>A</code>的区间<code>[i,j]</code>进行更新，比如同时在区间<code>[i,j]</code>中的元素都加上<code>x</code>,这时我们求范围和该如何解决呢？<br>首先我们思考以下，原始数组的前缀和$sum[i]$能否用辅助数组$tr$来表示呢？<script type="math/tex; mode=display">sum[i] = \sum_{k=1}^{i}A[k] = A[1] + A[2] + A[3] + ... + A[i]</script>试想一下，我们假设能够构造出差分数组$C[i]$满足如下所示：<script type="math/tex; mode=display">A[i] = C[i] - C[i-1] \\sum[n] = \sum_{i=1}^{n}A[i] = A[1] + A[2] + A[3] + ... + A[n] \\\qquad \\= (C[1]) + (C[1] + C[2]) + ... + (C[1] + C[2] + ...+ C[n]) \\\qquad \\= n*C[1] + (n-1)*C[2] + (n-2)*C[3] + ... + C[n] \\\qquad= n*(C[1] + C[2] + C[3] + ... + C[n]) - (0*C[1] + 1*C[2] + ...+(n-1)*C[n]) \\\qquad \\= n\sum_{i=1}^{n}C[i] - \sum_{i=1}^{n}C[i]*(i-1)</script>所以我们需要维护再维护两个树状数组，能够利用树状数组快速的求和，我们知道数组<code>C[i]</code>和<code>C[i]*(i-1)</code>很容易求出来。能够快速的求出<code>C[i]</code>和<code>C[i]*(i-1)</code>的区间和即可。<br>我们维护两个树状数组：<script type="math/tex; mode=display">TA[i] = C[i], TB[i] = C[i]*(i-1)</script>我们进行区间更新时，比如我们需要将原始数组<code>A[n]</code>的区间<code>[l,r]</code>中的元素都增加<code>x</code>,此时我们只需要先将<code>A[1]~A[r]</code>的元素都增加<code>x</code>,然后再将<code>A[1]~A[l]</code>中的元素都减少<code>x</code>即可。</li><li>单点更新：在<code>x</code>处增减<code>val</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += (i&amp;-i))<span class="comment">//更新后缀的父节点</span></span><br><span class="line">&#123;</span><br><span class="line">TA[i] += val;</span><br><span class="line">TB[i] += val * (x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h3 id="2-区间求极值"><a href="#2-区间求极值" class="headerlink" title="2. 区间求极值"></a>2. 区间求极值</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot; class=&quot;headerlink&quot; title=&quot;树状数组&quot;&gt;&lt;/a&gt;树状数组&lt;/h1&gt;&lt;p&gt;关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在&lt;code&gt;O(lgn)&lt;/code&gt;时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下&lt;code&gt;lowbit&lt;/code&gt;的概念.&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lowbit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x &amp;amp; -x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;通过lowbit本质即快速的求出一个数二进制最低位的1.&lt;br&gt;对于原始数组&lt;code&gt;A[n]&lt;/code&gt;,我们定义一个服装数组&lt;code&gt;tr[n]&lt;/code&gt;.其中tr[i]为数组中&lt;code&gt;i&lt;/code&gt;开始的前&lt;code&gt;lowbit(i)&lt;/code&gt;个元素的和，我们可以用以下公式表示:&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
