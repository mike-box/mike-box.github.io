<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-20T14:10:21.013Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【MIT6.S081】 Lab4 Traps</title>
    <link href="http://yoursite.com/2021/08/19/316/"/>
    <id>http://yoursite.com/2021/08/19/316/</id>
    <published>2021-08-19T01:00:50.977Z</published>
    <updated>2021-08-20T14:10:21.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><p>最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。<br>特别<code>alarm</code>这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin" target="_blank" rel="noopener">git repo</a></p><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><a id="more"></a><p>这个<code>lab</code>主要事熟悉risc-v汇编语言的基本语法，跟x86的语法很不同的是，函数的参数不是压入栈，而是存放在寄存器中，所以我们在调试时需要注意这个问题，典型的X86的栈如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">arg[n-1]</span><br><span class="line">arg[n-2]</span><br><span class="line">arg[n-3]</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">arg[0]</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">return address-----------&gt;frame pointer</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">prev  frame      |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">saved register   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>   |</span><br><span class="line">Local variable   |</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>&lt;----|</span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure><br>risc-v的栈帧最大的区别就是函数的参数可能并不在栈上存储，可能在寄存器中存储。所以我觉得还算是非常容易理解的lab，采用risck gdb调试即可。</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p><code>backtrace</code>这一个lab可以说是为了能够深刻理解<code>stack machine</code>机制的设计的，每当调用函数时，首先需要将返回地址，之前的栈帧地址入栈，由于risck-v存储是以Little-Endian存储的，而栈空间的地址也是从高地址往低地址增长的，所以当前的栈帧的偏移8个字节即为<code>return address</code>，我们需要每次打印出返回地址，同时偏移16个字节则为前一个栈帧的地址，我们依次往前寻找，直到当前的栈帧的起始地址为<code>PGROUNDUP(fp)</code>，我们直到risc-v中每个栈空间的大小为4096byte，所以我们可以快速计算出栈顶和栈底的地址：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64 <span class="keyword">bottom </span>= PGROUNDUP(<span class="built_in">fp</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><br>每次我们可以读寄存器fp即可得到当前栈的栈帧指向的地址，代码实现其实非常简单，但是需要仔细思考其中的原理。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add by mike meng</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uint64 fp = r_fp();</span><br><span class="line">uint64 bottom = PGROUNDUP(fp);</span><br><span class="line">uint64 address;</span><br><span class="line"><span class="keyword">char</span> path[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> line;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"backtrace:\n"</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//printf("%p\n",*((uint64 *)(fp-8)));</span></span><br><span class="line">address = *((uint64 *)(fp<span class="number">-8</span>));</span><br><span class="line">    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="keyword">sizeof</span>(path));</span><br><span class="line">ltaddr2line(address,path,&amp;line);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"pc = %p, %s:%d\n"</span>,address,path,line);</span><br><span class="line">fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">    <span class="keyword">if</span>(fp &gt;= bottom) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个<code>alarm</code>的lab还真心很难，想了很长时间没有想出来，后来看了好多参考书才有了一点眉目。首先需要了解<code>CPU</code>对于trap的处理原理，刚开始确实没有仔细阅读材料，导致浪费了很多时间。不过这门课程的视频课程讲的真心很好，感觉还是不能单看<code>textbook</code>。首先我们需要仔细理解<code>xv6</code>系统的<code>trap</code>的处理流程：<br><img src="https://i.loli.net/2021/08/20/UdOR1sVEX9xISYg.png" alt><br>上图为标准的syscall的处理流程。基本处理流程如下，<code>stvec</code>寄存器中设置的<code>trap</code>处理的入口地址处，一旦有<code>trap</code>需要处理时，首先CPU会把<code>PC</code>跳转到<code>stvec</code>寄存器设置的入口地址处,一般我们我们需要处理<code>usertrap</code>和<code>kernel trap</code>.trap的处理流程基本相似：<br><img src="https://i.loli.net/2021/08/20/HBkiRNlXGYn4sbU.png" alt></p><ul><li><code>kernel trap</code>：kernel trap主要处理设备的特殊中断请求。</li><li><code>usertrap</code>：user trap主要处理用户进程的trap处理。流程稍微复杂一点。最重要的两个函数为<code>usertrap</code>和<code>usertrapret</code>。我们仔细查找一下<code>usertrap</code>的入口函数，发现很难找到。实际上入口都是用汇编来完成，我们首先看一下<code>uservec</code>的具体内容用汇编实现的：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        # sscratch points to where the process's p-&gt;trapframe is</span><br><span class="line">        <span class="meta"># mapped into user space, at TRAPFRAME.</span></span><br><span class="line">        #</span><br><span class="line">        </span><br><span class="line">    <span class="meta"># swap a0 and sscratch</span></span><br><span class="line">        <span class="meta"># so that a0 is TRAPFRAME</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 保存寄存器内容到TRAPFRAME所指向的地址上</span><br><span class="line">        <span class="meta"># save the user registers in TRAPFRAME</span></span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd sp, <span class="number">48</span>(a0)</span><br><span class="line">        sd gp, <span class="number">56</span>(a0)</span><br><span class="line">        sd tp, <span class="number">64</span>(a0)</span><br><span class="line">        sd t0, <span class="number">72</span>(a0)</span><br><span class="line">        sd t1, <span class="number">80</span>(a0)</span><br><span class="line">        sd t2, <span class="number">88</span>(a0)</span><br><span class="line">        sd s0, <span class="number">96</span>(a0)</span><br><span class="line">        sd s1, <span class="number">104</span>(a0)</span><br><span class="line">        sd a1, <span class="number">120</span>(a0)</span><br><span class="line">        sd a2, <span class="number">128</span>(a0)</span><br><span class="line">        sd a3, <span class="number">136</span>(a0)</span><br><span class="line">        sd a4, <span class="number">144</span>(a0)</span><br><span class="line">        sd a5, <span class="number">152</span>(a0)</span><br><span class="line">        sd a6, <span class="number">160</span>(a0)</span><br><span class="line">        sd a7, <span class="number">168</span>(a0)</span><br><span class="line">        sd s2, <span class="number">176</span>(a0)</span><br><span class="line">        sd s3, <span class="number">184</span>(a0)</span><br><span class="line">        sd s4, <span class="number">192</span>(a0)</span><br><span class="line">        sd s5, <span class="number">200</span>(a0)</span><br><span class="line">        sd s6, <span class="number">208</span>(a0)</span><br><span class="line">        sd s7, <span class="number">216</span>(a0)</span><br><span class="line">        sd s8, <span class="number">224</span>(a0)</span><br><span class="line">        sd s9, <span class="number">232</span>(a0)</span><br><span class="line">        sd s10, <span class="number">240</span>(a0)</span><br><span class="line">        sd s11, <span class="number">248</span>(a0)</span><br><span class="line">        sd t3, <span class="number">256</span>(a0)</span><br><span class="line">        sd t4, <span class="number">264</span>(a0)</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># save the user a0 in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">        # 将a0用户的寄存器保存到frame上</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span><br><span class="line">        ld sp, <span class="number">8</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 将usertrap的入口地址写给a0</span><br><span class="line">        <span class="meta"># load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span><br><span class="line">        # 将kernel的pagetable写入到satp寄存器，并刷新页表</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line">        csrw satp, t1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        # a0 is no longer valid, since the kernel page</span><br><span class="line">        <span class="meta"># table does not specially map p-&gt;tf.</span></span><br><span class="line"></span><br><span class="line">        # 跳转到usertrap()</span><br><span class="line">        <span class="meta"># jump to usertrap(), which does not return</span></span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure>大致就是保存寄存器到<code>tramfram</code>上,然后<code>kstack</code>的地址写入sp寄存器，将hartid标记位写入到寄存器中，将<code>kernel</code>的页表写入到<code>satp</code>寄存器中，然后跳转到<code>usertrap</code>中，usertrap函数以下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">usertrap(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取当前模式，是否为 user trap</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">"usertrap: not from user mode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we're now in the kernel.</span></span><br><span class="line">  <span class="comment">// interrupts process will be set to kernelvec.</span></span><br><span class="line">  <span class="comment">// 将trap的入口设置为kernel trap</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 保存当前的pc值</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the interrupts is system call</span></span><br><span class="line">  <span class="comment">// 判断当前的trap类型</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;<span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 如果为系统调用，则将恢复的PC指向它的下一个指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don't enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//open interrrupt</span></span><br><span class="line">    <span class="comment">// 关闭 trap，打开中断处理</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line"><span class="comment">// system call</span></span><br><span class="line">    <span class="comment">// 处理系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常trap,则直接关闭当前进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"usertrap(): unexpected scause %p pid=%d\n"</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"            sepc=%p stval=%p\n"</span>, r_sepc(), r_stval());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复</span></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>userret</code>：我们从<code>userret</code>的相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.</span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line"><span class="meta"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p>处理流程为首先将用户的页表切换到寄存器中，然后从<code>trapframe</code>中取出已经保存的值，将其恢复到寄存器中，然后将<code>trapframe</code>进行恢复到默认值，将PC的值恢复到之前的值，指令将会继续之前的PC的值进行执行。</p></li><li><p>我们实际在处理sigalarm时，首先需要将<code>sigalarm</code>和<code>sigalarmret</code>函数处理加入到<code>system call</code>中，然后在处理<code>usertrap</code>时，首先我们需要处理来自<code>timer</code>的trap,此时我们可以将<code>trap</code>恢复后的<code>pc</code>指向<code>alarmhandler</code>函数，我们运行时，即可发现可以运行<code>handler</code>函数，但是运行完成后，发现出了不少问题。我们仔细思考就可以发现，因为<code>PC</code>指向的指令地址改变后，我们可以仔细分析一下，函数执行时，我们看到当前栈帧返回时会返回正确的地址，因为此时<code>RA</code>寄存器存放的为正确的return address.但是periodic函数在执行过程中可能会将其中的寄存器污染，所以会出现<code>alarm</code>打印逻辑出错。所以我们在执行<code>handler</code>时，必须要将相关的寄存器进行保存，保存完成后再执行<code>handler</code>，执行完成<code>handler</code>后，我们再恢复寄存器，同时恢复<code>pc</code>.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">0</span>:<span class="number">1141</span>                addisp,sp,<span class="number">-16</span></span><br><span class="line">   <span class="number">2</span>:e406                sdra,<span class="number">8</span>(sp)</span><br><span class="line">   <span class="number">4</span>:e022                sds0,<span class="number">0</span>(sp)</span><br><span class="line">   <span class="number">6</span>:<span class="number">0800</span>                addis0,sp,<span class="number">16</span></span><br><span class="line">  count = count + <span class="number">1</span>;</span><br><span class="line">   <span class="number">8</span>:<span class="number">00001797</span>          auipca5,<span class="number">0x1</span></span><br><span class="line">   c:d407a783          lwa5,<span class="number">-704</span>(a5) # d48 &lt;count&gt;</span><br><span class="line">  <span class="number">10</span>:<span class="number">2785</span>                addiwa5,a5,<span class="number">1</span></span><br><span class="line">  <span class="number">12</span>:<span class="number">00001717</span>          auipca4,<span class="number">0x1</span></span><br><span class="line">  <span class="number">16</span>:d2f72b23          swa5,<span class="number">-714</span>(a4) # d48 &lt;count&gt;</span><br><span class="line">  printf(<span class="string">"alarm!\n"</span>);</span><br><span class="line">  <span class="number">1</span>a:<span class="number">00001517</span>          auipca0,<span class="number">0x1</span></span><br><span class="line">  <span class="number">1</span>e:b6650513          addia0,a0,<span class="number">-1178</span> # b80 &lt;malloc+<span class="number">0xea</span>&gt;</span><br><span class="line">  <span class="number">22</span>:<span class="number">00001097</span>          auipcra,<span class="number">0x1</span></span><br><span class="line">  <span class="number">26</span>:<span class="number">9</span>b6080e7          jalr<span class="number">-1610</span>(ra) # <span class="number">9</span>d8 &lt;printf&gt;</span><br><span class="line">  sigreturn();</span><br><span class="line">  <span class="number">2</span>a:<span class="number">00000097</span>          auipcra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">2</span>e:<span class="number">6</span>c6080e7          jalr<span class="number">1734</span>(ra) # <span class="number">6f</span>0 &lt;sigreturn&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>刚开始我的想法是再申请一个物理页，然后用汇编将所有的寄存器的值，都保存到这个新申请的物理页中，待到函数执行完成后，我们再利用系统调用，将该物理页中保存的值再重新加载到寄存器中，刚开始想着是模仿<code>userret</code>和<code>uservec</code>的汇编代码来模仿实现。后来感觉太复杂了，看了提示之后，在进入<code>alarm handler</code>之前所有的寄存器其实都已经全部保存在tramp fram中，我们可以申请新的tramp fram结构，在<code>usertrapret</code>恢复寄存器时，暂时不恢复寄存器的值，只是将<code>PC</code>的值进行跳转。在<code>alarmreturn</code>时，此时我们再将已经保存的tramp fram中的寄存器和<code>PC</code>的值全部切换回去即可。</li></ul><ol><li><code>alarm</code>时，我们将handler和interval进行指定保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ticks;</span><br><span class="line">    uint64 ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(argaddr(<span class="number">1</span>,&amp;ptr) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">acquire(&amp;p-&gt;lock);</span><br><span class="line">p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarminterval = ticks;</span><br><span class="line">p-&gt;alarmhandler = (func)ptr;</span><br><span class="line">release(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>执行trap时，如果当前的ticks达到<code>alarminterval</code>时，则我们首先将<code>PC</code>的返回值替换为<code>handler</code>的入口地址，同时将当前<code>trap frame</code>的值进行保存。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  p-&gt;alarmtick++;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line"><span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line"><span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line"><span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line"><span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">memmove(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>执行<code>sigreturn</code>时，则我们将保存的<code>tramfram</code>切换回去即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;alarmworking)&#123;</span><br><span class="line">memmove(p-&gt;trapframe,&amp;p-&gt;alarmtrap,<span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge"><a href="#Optional-challenge" class="headerlink" title="Optional challenge"></a>Optional challenge</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print <span class="keyword">the</span> names <span class="keyword">of</span> <span class="keyword">the</span> functions <span class="keyword">and</span> <span class="built_in">line</span> numbers <span class="keyword">in</span> backtrace() instead <span class="keyword">of</span> numerical addresses</span><br></pre></td></tr></table></figure>按照要求对<code>backtrace</code>进行扩展，使得其能够打印出相应的文件和行号，刚开始拿到这个以为很简单，但是实际上实现起来还是挺复杂。主要查找的信息来源于<code>addr2line</code>的实现，在github上找了一堆实现<code>addr2line</code>的代码，后来发现一个<code>c++</code>还凑合，就拿过来读了一下，然后通过查找<code>debug_line</code>的具体参数定义，然后找到dwarf 3.0的标准，对战标准和代码把相关的功能全部重新移植到xv6上，虽然代码写的很烂，但是凑合还能用吧，其中<code>debug</code>的时间还挺长。具体实现原理如下：</li><li>改写makefile,把生成kernel的elf文件做到文件系统中，然后系统运行后，通过用户进程调用函数读取和解析elf文件，这里最大的坑是用户进程未初始化时，我直接用内核读取文件，发现会<code>panic</code>,后来仔细检查了很多遍，发现因为在内核文件的读取都会加载进程的文件锁，而这时用户进行还未初始化，这时如果去调用mypoc函数就会出现指针跑飞的问题。解决办法只有等待用户进行调度起来后，可以单独起一个用户进程读取和解析elf文件。</li><li>系统起来后，在内核空间中从文件系统读取elf文件，找到.debug_line这个section，然后按照dwarf 3.0的标准来解析header和opcode，具体可以Google相关的标准，标准本身还是挺复杂的，具体实现时参考这个github的代码：<a href="https://github.com/evmar/maddr" target="_blank" rel="noopener">https://github.com/evmar/maddr</a> ，里面解析opcode时有不少小bug，关键时刻还算看标准靠谱。</li><li>解析完成后，将解析生成的matrix放入到数组中，然后我们对line table按照地址从小到大进行排序，我们解析的line table中也可以看到每行代码可能会对应多个<code>instruction</code>，我们直到<code>pc</code>每次递增的。每次进行查询时，我们在line table表中查找小于等于等于给定地址p的第一个元素，然后返回查询结果即可，查询结果包含了文件名和行号，返回给trace即可。</li><li>熬了几天夜，终于把功能基本实现了，总体来说还算非常蛋疼的功能。<br><img src="https://i.loli.net/2021/08/20/hlpDCfavUjYydiR.png" alt></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;traps&quot;&gt;&lt;a href=&quot;#traps&quot; class=&quot;headerlink&quot; title=&quot;traps&quot;&gt;&lt;/a&gt;traps&lt;/h1&gt;&lt;p&gt;最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。&lt;br&gt;特别&lt;code&gt;alarm&lt;/code&gt;这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;RISC-V-assembly&quot;&gt;&lt;a href=&quot;#RISC-V-assembly&quot; class=&quot;headerlink&quot; title=&quot;RISC-V assembly&quot;&gt;&lt;/a&gt;RISC-V assembly&lt;/h2&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab4 Trap Alarm</title>
    <link href="http://yoursite.com/2021/08/16/315/"/>
    <id>http://yoursite.com/2021/08/16/315/</id>
    <published>2021-08-16T01:35:41.482Z</published>
    <updated>2021-08-16T01:36:07.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="page-tables"><a href="#page-tables" class="headerlink" title="page tables"></a>page tables</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab3</code>的内容作完了，<code>lab3</code>的难度感觉还是非常大的，不过最终把<code>lab3</code>完成后，就对虚拟内存管理有了深刻的认识。对于<code>vm</code>的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.<br><img src="https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png" alt><br><a href="https://github.com/mike-box/MIT6.S081" target="_blank" rel="noopener">git repo</a></p><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>在<code>xv6</code>系统中，物理内存都被分成了<code>4096</code>byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)<code>offset</code>。由下图我们可以看到虚拟地址到物理地址的映射。<br><img src="https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png" alt><br>但在<code>xv6</code>系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在<code>xv6</code>系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。<br><img src="https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png" alt></p><a id="more"></a><ul><li>我们通过下图可以看到一个虚拟地址实际包含5部分，保留位为25位，紧接着为9位的一级页表内的的<code>offset</code>，紧接着为9位的二级页表内的的<code>offset</code>，紧接着为9位的三级页表内的的<code>offset</code>，三级页表中则存储的为该虚拟地址对应的实际物理页编号，我们取出物理页编号，再加上<code>offset</code>即可得到实际的物理地址。<br><img src="https://i.loli.net/2021/08/07/O6GLjEMNrFSfb9w.png" alt><br>我们可以看到代码中几个比较重要的宏定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个物理页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="comment">// 物理页的offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">//取出物理地址转换为对应的页表项</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">//通过页表得到对应的物理页对应的编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 取出页表项中对应的标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li><li>三级页表中同时存储的有<code>flags</code>,<code>flags</code>代表该页表是否有效,我们需要判断每一页的访问权，只需要判断标志位即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt; user can access</span></span></span><br></pre></td></tr></table></figure>我们通过虚拟地址的12~39位，实际为该虚拟地址的三级页表的偏移地址，通过三级页表的偏移地址，最终可以得到该虚拟地址对应的物理页号。<h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To <span class="keyword">help</span> you learn about RISC-V page <span class="keyword">tables</span>, <span class="keyword">and</span> perhaps <span class="keyword">to</span> aid future debugging, your <span class="keyword">first</span> task <span class="keyword">is</span> <span class="keyword">to</span> write a <span class="keyword">function</span> that prints the <span class="keyword">contents</span> <span class="keyword">of</span> a page table.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Define</span> a <span class="keyword">function</span> called vmprint(). It should take a pagetable_t argument, <span class="keyword">and</span> print that pagetable <span class="keyword">in</span> the <span class="keyword">format</span> described below. <span class="keyword">Insert</span> <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable) <span class="keyword">in</span> exec.c just <span class="keyword">before</span> the <span class="keyword">return</span> argc, <span class="keyword">to</span> print the <span class="keyword">first</span> process<span class="string">'s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</span></span><br></pre></td></tr></table></figure>这部分比较简单，打印出页表的内容，我们知道三级页表的原理，这个即为简单的<code>dfs</code>遍历即可，遍历三级页表中的内容，每一级页表有<code>512</code>项，每一级页表有标志位，判断标志位是否有效，即是否包含PTE_V，则表示该页表有效。如果有效则向下遍历即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pteprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[i];</span><br><span class="line">    <span class="comment">// level page table entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// page table is valid</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; level; --j)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">".. "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"..%d: pte %p pa %p\n\r"</span>,i,*pte,(<span class="keyword">pagetable_t</span>)PTE2PA(*pte));</span><br><span class="line">      <span class="keyword">if</span>(level &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">         pteprint((<span class="keyword">pagetable_t</span>)PTE2PA(*pte),level<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2.A kernel page table per process"></a>2.A kernel page table per process</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Xv6 has a single kernel page <span class="keyword">table</span> that<span class="string">'s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address x maps to physical address x. Xv6 also has a separate page table for each process'</span>s <span class="keyword">user</span> address space, containing <span class="keyword">only</span> mappings <span class="keyword">for</span> that process<span class="string">'s user memory, starting at virtual address zero. Because the kernel page table doesn'</span>t contain these mappings, <span class="keyword">user</span> addresses are <span class="keyword">not</span> <span class="keyword">valid</span> <span class="keyword">in</span> the kernel. Thus, <span class="keyword">when</span> the kernel needs <span class="keyword">to</span> use a <span class="keyword">user</span> pointer passed <span class="keyword">in</span> a <span class="keyword">system</span> <span class="keyword">call</span> (e.g., the buffer pointer passed <span class="keyword">to</span> <span class="keyword">write</span>()), the kernel must first translate the pointer <span class="keyword">to</span> a physical address. The goal <span class="keyword">of</span> this section <span class="keyword">and</span> the next <span class="keyword">is</span> <span class="keyword">to</span> allow the kernel <span class="keyword">to</span> directly dereference <span class="keyword">user</span> pointers.</span><br><span class="line"></span><br><span class="line">Your first job <span class="keyword">is</span> <span class="keyword">to</span> modify the kernel so that every process uses its own <span class="keyword">copy</span> <span class="keyword">of</span> the kernel page <span class="keyword">table</span> <span class="keyword">when</span> executing <span class="keyword">in</span> the kernel. Modify struct proc <span class="keyword">to</span> maintain a kernel page <span class="keyword">table</span> <span class="keyword">for</span> <span class="keyword">each</span> process, <span class="keyword">and</span> modify the scheduler <span class="keyword">to</span> switch kernel page <span class="keyword">tables</span> <span class="keyword">when</span> switching processes. <span class="keyword">For</span> this step, <span class="keyword">each</span> per-process kernel page <span class="keyword">table</span> should be identical <span class="keyword">to</span> the existing <span class="keyword">global</span> kernel page <span class="keyword">table</span>. You pass this part <span class="keyword">of</span> the lab <span class="keyword">if</span> usertests runs correctly.</span><br><span class="line">``` </span><br><span class="line">+ 题目本质是说进行内核空间的虚拟地址和用户空间的虚拟地址因为不在同一个页表里，所以内核的地址空间和用户的地址无法正常进行访问，必须要通过转换，特别在内核态访问用户态传过来的地址时，无法直接访问，需要通过转换才可以，因此我们需要在内核态将用户态的虚拟地址空间也需要做映射，这样我们就可以在内核态直接访问用户态的地址。</span><br><span class="line">+ 在此时，我们需要重新为进行申请一个内核态的页表，每个进程则有一个独立的内核页表，并将访问系统的所有的特殊的接口地址全部映射到该页表中，同时将该进程的内核栈也映射到该页表。每个进程都有一个独立的内核栈，由于内核栈空间与用户空间的地址映射在同一个地址表中，因此可以直接访问。</span><br><span class="line"><span class="number">1.</span> 为进程建立一个内核页表，并做好地址映射。新建页表，并做好内核地址的映射。</span><br><span class="line">```c++</span><br><span class="line">pagetable_t</span><br><span class="line">prockvminit()&#123;</span><br><span class="line">pagetable_t pagetable = (pagetable_t) kalloc();</span><br><span class="line"><span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">panic("kalloc");</span><br><span class="line"></span><br><span class="line">// <span class="keyword">each</span> page size <span class="keyword">is</span> <span class="number">4096</span> byte = <span class="number">4</span>KB</span><br><span class="line">// kernel page <span class="keyword">table</span></span><br><span class="line">memset(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">// uart registers</span><br><span class="line">// uart mmmap</span><br><span class="line">prockvmmap(pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// virtio mmio disk interface</span><br><span class="line">prockvmmap(pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// CLINT</span><br><span class="line">//prockvmmap(pagetable,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// PLIC</span><br><span class="line">prockvmmap(pagetable,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// map kernel <span class="type">text</span> executable <span class="keyword">and</span> <span class="keyword">read</span>-<span class="keyword">only</span>.</span><br><span class="line">prockvmmap(pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">// map kernel data <span class="keyword">and</span> the physical RAM w<span class="string">e'll make use of.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="string">// the highest virtual address in the kernel.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return pagetable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void</span></span><br><span class="line"><span class="string">prockvmmap(pagetable_t pagetable,uint64 va, uint64 pa, uint64 sz, int perm)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  if(mappages(pagetable, va, sz, pa, perm) != 0)&#123;</span></span><br><span class="line"><span class="string">  printf("total free = %d \n\r",totalfree());</span></span><br><span class="line"><span class="string">  printf("va = %p sz = %p \n\r",va,sz);</span></span><br><span class="line"><span class="string">    panic("prockvmmap");</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>在进程初始化时，我们可以保持不变，初始化时即为每个进程分配内核栈，映射到全局的<code>kernel_table</code>中,我们在进行进程<code>alloc</code>时，可以将该内核栈物理页再做一遍映射，映射到进程的内核表中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">procinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">"nextpid"</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">"proc"</span>);</span><br><span class="line">  p-&gt;kallocstats = <span class="number">0</span>;</span><br><span class="line">    p-&gt;kfreestats = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"kalloc"</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">  kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line"> p-&gt;kpagetable = prockvminit();</span><br><span class="line"> prockvmmap(p-&gt;kpagetable,p-&gt;kstack,kvmpa(p-&gt;kstack),PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"> <span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// An empty user page table.</span></span><br><span class="line"> p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">   freeproc(p);</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>进程释放时，也需要对该进程的内核页表进行释放,但是释放时由于内核空间只是做了物理页的映射，因此我们只需要释放页表的空间即可，不需要释放物理页的空间。但在代码中加入了对每个进程执行<code>kalloc</code>和<code>kfree</code>的次数统计,发现实际确实存在内存泄漏,申请的物理页没有被释放的问题.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release trap frame</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release user page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release kernel page table and kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable) &#123; </span><br><span class="line">  procfreekpt(p-&gt;kpagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li>我们用一个遍历即可，但是总感觉这个函数写的有点问题，没有释放所有的物理页，存在内存泄漏的问题，这个问题查找了很长时间没有解决。从github上下载了几个代码运行了一下，发现也都有问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages except leaf</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">procfreekpt</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; (PTE_R|PTE_W|PTE_X)) &#123;</span><br><span class="line">  uint64 child = PTE2PA(pte);</span><br><span class="line">  procfreekpt((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">  pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>进程调度时,当前进程如果被调度时,则此时我们需要将该进行的内核页表的地址加载到页表的寄存器中,此时我们访问地址进行转换时,则通过该页表查找物理页的地址.我们可以看到在完成上下文切换前,将页表加载完成即可.当前如果所有的进程都空闲时,则我们将全局的<code>kernel pagetable</code>进行加载.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">       p-&gt;state = RUNNING;</span><br><span class="line">       c-&gt;proc = p;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// load kernel pagetable address into page table</span></span><br><span class="line">    prockvminithart(p-&gt;kpagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load process kernel page table</span></span><br><span class="line">       swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Process is done running for now.</span></span><br><span class="line">       <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">       c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// found</span></span><br><span class="line">       found = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// the current has no process runing</span></span><br><span class="line">   <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// use kernel pagetable when no process runing</span></span><br><span class="line">  kvminithart();</span><br><span class="line">  </span><br><span class="line">     intr_on();</span><br><span class="line">  <span class="comment">// load kernel page table</span></span><br><span class="line">     <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-copyin-copyinstr"><a href="#3-copyin-copyinstr" class="headerlink" title="3.copyin/copyinstr"></a>3.copyin/copyinstr</h3></li><li>需要自己重新写<code>copyin</code>和<code>copyinstr</code>的代码，这个其实比较简单，在上一个练习中我们将内核中的所有的地址全部挂接到内核表中，在这个练习中我们需要将所有的用户空间的地址要全部映射到内核的页表中，这样在进程运行时，内核即可进行对用户空间的虚拟地址进行访问.我们可以重写一个函数对页表的物理页进行映射.下面函数的作用即是将一个页表中的虚地址全部映射到一个页表中.实际只做了物理页的映射,而并有实际的物理页的申请.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">procuvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> uvm,<span class="keyword">pagetable_t</span> kvm,uint64 old_sz, uint64 new_sz)</span></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line">uint64 pa, i;</span><br><span class="line">uint flags;</span><br><span class="line"></span><br><span class="line">old_sz = PGROUNDUP(old_sz);</span><br><span class="line"><span class="keyword">if</span> (new_sz &lt;= old_sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = old_sz; i &lt; new_sz; i += PGSIZE)&#123;</span><br><span class="line"><span class="keyword">if</span>((pte = walk(uvm, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: pte should exist"</span>);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: page not present"</span>);</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line">flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="keyword">if</span>(mappages(kvm, i, PGSIZE, pa, flags&amp;(~PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">"procuvmcopy: remap"</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">uvmunmap(kvm, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们仔细阅读提示,发现有几个函数需要进行此类操作和映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</span><br><span class="line">At each point where the kernel changes a process's user mappings, change the process's kernel page table in the same way. Such points include fork(), exec(), and sbrk().</span><br><span class="line">Don't forget that to include the first process's user page table in its kernel page table in userinit.</span><br><span class="line">What permissions <span class="keyword">do</span> the PTEs <span class="keyword">for</span> user addresses need in a process's kernel page table? (A page with PTE_U <span class="built_in">set</span> cannot be accessed in kernel mode.)</span><br><span class="line">Don't forget about the above-mentioned PLIC limit.</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>userinit</code>函数的修改,我们需要将<code>initcode</code>中加载的一个物理页进行<code>copy</code>映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy one page of the </span></span><br><span class="line">  procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable,<span class="number">0</span>,PGSIZE) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure></li><li><code>fork()</code>函数的修改, 我们发现<code>uvmcopy</code>时需要将父进程的用户空间页表全部拷贝到子进程,我们在完成拷贝时,则需要将该进程的用户空间的页表也全部拷贝一遍.将所有的页全部拷贝映射一遍即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Copy user memory mapper the kernel page table to child</span></span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(np-&gt;pagetable, np-&gt;kpagetable,<span class="number">0</span>,np-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><code>exec()</code>函数,我们可以看到<code>exec</code>函数函数执行时,首先会将<code>elf</code>文件里面的所有的段加载到内存中,并将其全部映射到进程的用户态页表中.首先我们需要将该进程的所有的内核的页表中所有的物理页映射全部去掉,然后就重新将用户空间的页表全部重新映射到内核的页表中.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">'/'</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we remove the old mapper and We mapper new pages to the kernel page table</span></span><br><span class="line">  uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(p-&gt;pagetable,p-&gt;kpagetable,<span class="number">0</span>,p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">  </span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp;          <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li><li><code>sbrk</code>函数,我们实际需要修改<code>sys_sbrk</code>函数,当用户空间的物理内存增长时,此时我们需要将新增的地址空间页全部映射到内核的页表中,如果用户的物理内存缩小时,则此时我们需要将已经去掉的地址空间的映射全部取消掉.我们判断地址增长的时候会判断该地址是否增长超过了系统的限制.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">growproc(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// check the virtual address is no more than 0x0c000000L</span></span><br><span class="line">  <span class="keyword">if</span>((sz + n) &gt;= PLIC)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// malloc </span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// mapper user page to kernel page table</span></span><br><span class="line"><span class="keyword">if</span>((procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line"><span class="comment">// remove all the pages from the kernel table</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable,PGROUNDUP(sz),(PGROUNDUP(p-&gt;sz)-PGROUNDUP(sz))/PGSIZE,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>总的来说这一章的<code>lab</code>还是非常有难度的,特别时调试的部分,花了很长时间都没有非常好的结果,感觉是目前遇到的难度最大的<code>lab</code>.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;page-tables&quot;&gt;&lt;a href=&quot;#page-tables&quot; class=&quot;headerlink&quot; title=&quot;page tables&quot;&gt;&lt;/a&gt;page tables&lt;/h1&gt;&lt;p&gt;最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把&lt;code&gt;lab3&lt;/code&gt;的内容作完了，&lt;code&gt;lab3&lt;/code&gt;的难度感觉还是非常大的，不过最终把&lt;code&gt;lab3&lt;/code&gt;完成后，就对虚拟内存管理有了深刻的认识。对于&lt;code&gt;vm&lt;/code&gt;的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;page&quot;&gt;&lt;a href=&quot;#page&quot; class=&quot;headerlink&quot; title=&quot;page&quot;&gt;&lt;/a&gt;page&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;xv6&lt;/code&gt;系统中，物理内存都被分成了&lt;code&gt;4096&lt;/code&gt;byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)&lt;code&gt;offset&lt;/code&gt;。由下图我们可以看到虚拟地址到物理地址的映射。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png&quot; alt&gt;&lt;br&gt;但在&lt;code&gt;xv6&lt;/code&gt;系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在&lt;code&gt;xv6&lt;/code&gt;系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 254</title>
    <link href="http://yoursite.com/2021/08/11/314/"/>
    <id>http://yoursite.com/2021/08/11/314/</id>
    <published>2021-08-11T02:42:04.552Z</published>
    <updated>2021-08-15T13:26:34.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-254"><a href="#leetcode-contest-254" class="headerlink" title="leetcode contest 254"></a>leetcode contest 254</h1><p>本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。<br><img src="https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png" alt></p><h2 id="5843-作为子字符串出现在单词中的字符串数目"><a href="#5843-作为子字符串出现在单词中的字符串数目" class="headerlink" title="5843. 作为子字符串出现在单词中的字符串数目"></a>5843. 作为子字符串出现在单词中的字符串数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>patterns</code> 和一个字符串 <code>word</code> ，统计 <code>patterns</code> 中有多少个字符串是 <code>word</code> 的子字符串。返回字符串数目。</p><a id="more"></a><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"abc"</span>,<span class="string">"bc"</span>,<span class="string">"d"</span>], <span class="built_in">word</span> = <span class="string">"abc"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"abc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"bc"</span> 是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">- <span class="string">"d"</span> 不是 <span class="string">"abc"</span> 的子字符串。</span><br><span class="line">patterns 中有 <span class="number">3</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>], <span class="built_in">word</span> = <span class="string">"aaaaabbbbb"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- <span class="string">"a"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"b"</span> 是 <span class="string">"aaaaabbbbb"</span> 的子字符串。</span><br><span class="line">- <span class="string">"c"</span> 不是 <span class="string">"aaaaabbbbb"</span> 的字符串。</span><br><span class="line">patterns 中有 <span class="number">2</span> 个字符串作为子字符串出现在 <span class="built_in">word</span> 中。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：patterns = [<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>], word = <span class="comment">"ab"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：patterns 中的每个字符串都作为子字符串出现在 word <span class="comment">"ab"</span> 中。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= patterns.length &lt;= 100</code></li><li><code>1 &lt;= patterns[i].length &lt;= 100</code></li><li><code>1 &lt;= word.length &lt;= 100</code></li><li><code>patterns[i]</code> 和 <code>word</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测字符串里面是否含有特定的字符串，用<code>stl</code>库函数<code>find</code>即可。算法时间复杂度为$O(n)$,算法空间复杂度为$O(1)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfStrings</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; patterns, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : patterns)&#123;</span><br><span class="line">            <span class="keyword">if</span>(word.find(p) != <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5832-构造元素不等于两相邻元素平均值的数组"><a href="#5832-构造元素不等于两相邻元素平均值的数组" class="headerlink" title="5832. 构造元素不等于两相邻元素平均值的数组"></a>5832. 构造元素不等于两相邻元素平均值的数组</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 下标从 0 开始 的数组 <code>nums</code> ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。</p><p>更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 <code>1 &lt;= i &lt; nums.length - 1</code> 中的每个 <code>i</code> ，<code>(nums[i-1] + nums[i+1]) / 2</code>不等于 <code>nums[i]</code> 均成立 。</p><p>返回满足题意的任一重排结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">1</span>+<span class="number">4</span>) / <span class="number">2</span> = <span class="number">2.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">4</span>, 两相邻元素平均值为 (<span class="number">2</span>+<span class="number">5</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">5</span>, 两相邻元素平均值为 (<span class="number">4</span>+<span class="number">3</span>) / <span class="number">2</span> = <span class="number">3.5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">9</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">i=<span class="number">1</span>, nums[i] = <span class="number">7</span>, 两相邻元素平均值为 (<span class="number">9</span>+<span class="number">6</span>) / <span class="number">2</span> = <span class="number">7.5</span></span><br><span class="line">i=<span class="number">2</span>, nums[i] = <span class="number">6</span>, 两相邻元素平均值为 (<span class="number">7</span>+<span class="number">2</span>) / <span class="number">2</span> = <span class="number">4.5</span></span><br><span class="line">i=<span class="number">3</span>, nums[i] = <span class="number">2</span>, 两相邻元素平均值为 (<span class="number">6</span>+<span class="number">0</span>) / <span class="number">2</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始想了很长时间，后来想了一种简单办法，首先我们将数组按照从小到大排序，数组索引从<code>0</code>开始，然后我们将奇数位的数与前一个数进行交换，这样我们即可满足如下：</li></ol><ul><li>对于索引为奇数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] < nums[i-1] \\nums[i] < nums[i+1] \\nums[i-1] + nums[i+1] > nums[i]*2</script></li><li>对于索引为偶数位的元素我们发现一定满足：<script type="math/tex; mode=display">nums[i] > nums[i-1] \\nums[i] > nums[i+1] \\nums[i-1] + nums[i+1] < nums[i]*2 \\</script></li></ul><ol><li>时间复杂度为$O(nlgn + n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>)&#123;</span><br><span class="line">           swap(nums[i<span class="number">-1</span>],nums[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5844-数组元素的最小非零乘积"><a href="#5844-数组元素的最小非零乘积" class="headerlink" title="5844. 数组元素的最小非零乘积"></a>5844. 数组元素的最小非零乘积</h2><p>给你一个正整数 <code>p</code>。你有一个下标从 1 开始的数组 <code>nums</code>，这个数组包含范围<code>[1, 2p - 1]</code>内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：</p><p>从 <code>nums</code>中选择两个元素 <code>x</code> 和 <code>y</code>  。<br>选择 x 中的一位与 <code>y</code> 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。<br>比方说，如果<code>x = 1101</code>且 <code>y = 0011</code>，交换右边数起第 2 位后，我们得到 <code>x = 1111</code> 和 <code>y = 0001</code> 。</p><p>请你算出进行以上操作 任意次 以后，<code>nums</code> 能得到的 最小非零 乘积。将乘积对 <code>109 + 7</code> 取余 后返回。</p><p>注意：答案应为取余 之前 的最小值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：nums = [<span class="number">1</span>] 。</span><br><span class="line">只有一个元素，所以乘积为该元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：nums = [<span class="number">01</span>, <span class="number">10</span>, <span class="number">11</span>] 。</span><br><span class="line">所有交换要么使乘积变为 <span class="number">0</span> ，要么乘积与初始乘积相同。</span><br><span class="line">所以，数组乘积 <span class="number">1</span> * <span class="number">2</span> * <span class="number">3</span> = <span class="number">6</span> 已经是最小值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：p = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1512</span></span><br><span class="line">解释：nums = [<span class="number">001</span>, <span class="number">010</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">110</span>, <span class="number">111</span>]</span><br><span class="line">- 第一次操作中，我们交换第二个和第五个元素最左边的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">011</span>, <span class="number">100</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">- 第二次操作中，我们交换第三个和第四个元素中间的数位。</span><br><span class="line">    - 结果数组为 [<span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">001</span>, <span class="number">110</span>, <span class="number">111</span>] 。</span><br><span class="line">数组乘积 <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">1</span> * <span class="number">6</span> * <span class="number">7</span> = <span class="number">1512</span> 是最小乘积。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= p &lt;= 60</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们仔细观察一下，实际上最后发现所有的数，交换之后最终成为如下形式时，乘积最小：<script type="math/tex; mode=display">000...0001,111...1110,000...0001,111...1110,...,000...0001,111...1110,111...1111</script></li><li>我们知道这种类似的分布以后我们只需数出$(000…0001,111…1110)$数对的数目即可，我们知道从$1$到$2^{p}-1$总共$2^{p-1}-1$对，因此我们可以知道最终的求和公式为如下：<script type="math/tex; mode=display">ans = (2^{p} -1)*(2^{p}-2)^{2^{p-1}-1}</script></li><li>算法负责度为$O(n)$.比赛中竟然把乘方数进行取模，结果怎么算结果都不对。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%<span class="number">2</span>) ans = (ans*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">            n /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNonZeroProduct</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = fastpow(<span class="number">2</span>,p,mod)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> y = (<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">1</span>&lt;&lt;(p<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> fastpow(x<span class="number">-1</span>,y<span class="number">-1</span>,mod)*x%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5845-你能穿过矩阵的最后一天"><a href="#5845-你能穿过矩阵的最后一天" class="headerlink" title="5845. 你能穿过矩阵的最后一天"></a>5845. 你能穿过矩阵的最后一天</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 1 开始的二进制矩阵，其中 <code>0</code> 表示陆地，<code>1</code> 表示水域。同时给你 <code>row</code> 和 <code>col</code> 分别表示矩阵中行和列的数目。</p><p>一开始在第 0 天，整个 矩阵都是 陆地 。但每一天都会有一块新陆地被 水 淹没变成水域。给你一个下标从 1 开始的二维数组 <code>cells</code> ，其中 <code>cells[i] = [ri, ci]</code> 表示在第 <code>i</code> 天，第<code>ri</code> 行 <code>ci</code> 列（下标都是从 1 开始）的陆地会变成 水域 （也就是 0 变成 1 ）。</p><p>你想知道从矩阵最 上面 一行走到最 下面 一行，且只经过陆地格子的 最后一天 是哪一天。你可以从最上面一行的 任意 格子出发，到达最下面一行的 任意 格子。你只能沿着 四个 基本方向移动（也就是上下左右）。</p><p>请返回只经过陆地格子能从最 上面 一行走到最 下面 一行的 最后一天 。</p><p>示例 1：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">2</span> 天。</span><br></pre></td></tr></table></figure><p>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">2</span>, col = <span class="number">2</span>, cells = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">1</span> 天。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：row = <span class="number">3</span>, col = <span class="number">3</span>, cells = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：上图描述了矩阵从第 <span class="number">0</span> 天开始是如何变化的。</span><br><span class="line">可以从最上面一行到最下面一行的最后一天是第 <span class="number">3</span> 天。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= row, col &lt;= 2 * 104</code></li><li><code>4 &lt;= row * col &lt;= 2 * 104</code></li><li><code>cells.length == row * col</code></li><li><code>1 &lt;= ri &lt;= row</code></li><li><code>1 &lt;= ci &lt;= col</code></li><li><code>cells</code> 中的所有格子坐标都是 唯一 的。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-day-where-you-can-still-cross" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-day-where-you-can-still-cross</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 集合</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>二分查找，我们通过<code>bfs</code>检测矩阵的上下是否联通，二分查找需要耗费的时间为$lg(n)$,每次检测需要耗费的时间为$O(row<em>col)$,这种算法较为简单，算法时间复杂度为$O(row</em>col*lgn).</li><li>我们采用倒序的检测方法，每次将水域变成陆地，可以看到假如存在陆地满足上下连通，即是最后一天。此时我们用集合检测即可。实际只需要一点小技巧即可。</li><li>总的来说这题难度较低，不是很难的题目。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchButtom,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; touchUp,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">        <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">        <span class="keyword">if</span>(x1 &lt; y1)&#123;</span><br><span class="line">            f[x1] = y1;</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];         </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x1 &gt; y1)&#123;</span><br><span class="line">            f[y1] = x1;</span><br><span class="line">            touchButtom[x1] = touchButtom[x1]||touchButtom[y1];</span><br><span class="line">            touchUp[x1] = touchUp[x1]||touchUp[y1];</span><br><span class="line">            touchButtom[y1] = touchButtom[y1]||touchButtom[x1];</span><br><span class="line">            touchUp[y1] = touchUp[y1]||touchUp[x1];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(touchButtom[y1] &amp;&amp; touchUp[y1]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">latestDayToCross</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; cells)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cells.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchButtom(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; touchUp(row*col,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(row*col,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.size(); ++i)&#123;</span><br><span class="line">            cells[i][<span class="number">0</span>]--;</span><br><span class="line">            cells[i][<span class="number">1</span>]--;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            touchUp[i] = <span class="literal">true</span>;</span><br><span class="line">            touchButtom[(row<span class="number">-1</span>)*col+i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row*col; ++i) f[i] = i;     </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">int</span> x = d[k][<span class="number">0</span>] + i;</span><br><span class="line">                        <span class="keyword">int</span> y = d[k][<span class="number">1</span>] + j;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(uni(f,touchButtom,touchUp,i*col+j,x*col+y))&#123;</span><br><span class="line">                                <span class="keyword">return</span> n;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cells[i][<span class="number">0</span>] + d[k][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y = cells[i][<span class="number">1</span>] + d[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(uni(f,touchButtom,touchUp,cells[i][<span class="number">0</span>]*col + cells[i][<span class="number">1</span>],x*col+y))&#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            grid[cells[i][<span class="number">0</span>]][cells[i][<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-254&quot;&gt;&lt;a href=&quot;#leetcode-contest-254&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 254&quot;&gt;&lt;/a&gt;leetcode contest 254&lt;/h1&gt;&lt;p&gt;本周的题目的难度始终，难度不是很大，第三题竟然犯了个很坑爹错误，竟然把乘方数也取模了，结果一直结果不对。结果一直卡壳，以为我的算法错误。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/15/XuFZObePsBH1LwM.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5843-作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;a href=&quot;#5843-作为子字符串出现在单词中的字符串数目&quot; class=&quot;headerlink&quot; title=&quot;5843. 作为子字符串出现在单词中的字符串数目&quot;&gt;&lt;/a&gt;5843. 作为子字符串出现在单词中的字符串数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;patterns&lt;/code&gt; 和一个字符串 &lt;code&gt;word&lt;/code&gt; ，统计 &lt;code&gt;patterns&lt;/code&gt; 中有多少个字符串是 &lt;code&gt;word&lt;/code&gt; 的子字符串。返回字符串数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 253</title>
    <link href="http://yoursite.com/2021/08/08/313/"/>
    <id>http://yoursite.com/2021/08/08/313/</id>
    <published>2021-08-08T07:36:53.218Z</published>
    <updated>2021-08-08T08:19:12.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-253"><a href="#leetcode-contest-253" class="headerlink" title="leetcode contest 253"></a>leetcode contest 253</h1><p>本周题目都是手速场，确实难度太低了。</p><h2 id="5838-检查字符串是否为数组前缀"><a href="#5838-检查字符串是否为数组前缀" class="headerlink" title="5838. 检查字符串是否为数组前缀"></a>5838. 检查字符串是否为数组前缀</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>words</code>，请你判断 <code>s</code> 是否为 <code>words</code> 的 前缀字符串 。</p><p>字符串 <code>s</code> 要成为 <code>words</code>的 前缀字符串 ，需要满足：<code>s</code>可以由 <code>words</code> 中的前 <code>k</code>（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 <code>words.length</code> 。</p><a id="more"></a><p>如果 <code>s</code> 是<code>words</code>的 前缀字符串 ，返回 <code>true</code> ；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>,<span class="string">"apples"</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：</span><br><span class="line">s 可以由 <span class="string">"i"</span>、<span class="string">"love"</span> 和 <span class="string">"leetcode"</span> 相连得到。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"iloveleetcode"</span>, <span class="attr">words</span> = [<span class="string">"apples"</span>,<span class="string">"i"</span>,<span class="string">"love"</span>,<span class="string">"leetcode"</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：</span><br><span class="line">数组的前缀相连无法得到 s 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 20</code></li><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>words[i]</code> 和 <code>s</code> 仅由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求出字符串数组中所有可能的前缀，然后与目标字符串进行比较即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPrefixString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">string</span> curr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                curr += words[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr == s) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5839-移除石子使总数最小"><a href="#5839-移除石子使总数最小" class="headerlink" title="5839. 移除石子使总数最小"></a>5839. 移除石子使总数最小</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>piles</code> ，数组 下标从 <code>0</code> 开始 ，其中 <code>piles[i]</code> 表示第 <code>i</code> 堆石子中的石子数量。另给你一个整数<code>k</code> ，请你执行下述操作 恰好 <code>k</code> 次：</p><p>选出任一石子堆 <code>piles[i]</code>，并从中 移除 <code>floor(piles[i] / 2)</code> 颗石子。<br>注意：你可以对 同一堆 石子多次执行此操作。</p><p>返回执行<code>k</code> 次操作后，剩下石子的 最小 总数。</p><p><code>floor(x)</code> 为 小于 或 等于<code>x</code>的 最大 整数。（即，对 <code>x</code>向下取整）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：可能的执行情景如下：</span><br><span class="line">- 对第 <span class="number">2</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>] 。</span><br><span class="line">- 对第 <span class="number">3</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">- 对第 <span class="number">0</span> 堆石子执行移除操作，石子分布情况变成 [<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>] 。</span><br><span class="line">剩下石子的总数为 <span class="number">12</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= piles.length &lt;= 105</code></li><li><code>1 &lt;= piles[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-253/problems/remove-stones-to-minimize-the-total/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>每次从队列中取出最大的元素，然后去掉最大元素的一半，然后将剩余的元素重新放入到队列中，典型的优先级队列。</li><li>时间复杂度为$O(Klgn)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStoneSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            pq.push(piles[i]);</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.empty()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> curr = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            ans -= (curr/<span class="number">2</span>);</span><br><span class="line">            pq.push(curr-(curr/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5840-使字符串平衡的最小交换次数"><a href="#5840-使字符串平衡的最小交换次数" class="headerlink" title="5840. 使字符串平衡的最小交换次数"></a>5840. 使字符串平衡的最小交换次数</h2><p>给你一个字符串<code>s</code> ，下标从 <code>0</code> 开始 ，且长度为偶数<code>n</code>。字符串 恰好 由 <code>n / 2</code>个开括号 <code>&#39;[&#39;</code> 和 <code>n / 2</code>个闭括号<code>&#39;]&#39;</code> 组成。</p><p>只有能满足下述所有条件的字符串才能称为 平衡字符串 ：</p><ul><li>字符串是一个空字符串，或者</li><li>字符串可以记作 <code>AB</code>，其中 <code>A</code> 和 <code>B</code> 都是 平衡字符串 ，或者</li><li>字符串可以写成<code>[C]</code> ，其中<code>C</code> 是一个 平衡字符串 。<br>你可以交换 任意 两个下标所对应的括号 任意 次数。</li></ul><p>返回使<code>s</code>变成 平衡字符串 所需要的 最小 交换次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"][]["</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：交换下标 <span class="number">0</span> 和下标 <span class="number">3</span> 对应的括号，可以使字符串变成平衡字符串。</span><br><span class="line">最终字符串变成 <span class="string">"[[]]"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "]]][[["</span><br><span class="line">输出：2</span><br><span class="line">解释：执行下述操作可以使字符串变成平衡字符串：</span><br><span class="line"><span class="bullet">- </span>交换下标 0 和下标 4 对应的括号，s = "[<span class="string"></span>]][[]" 。</span><br><span class="line"><span class="bullet">- </span>交换下标 1 和下标 5 对应的括号，s = "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br><span class="line">最终字符串变成 "[<span class="string">[</span>][<span class="symbol"></span>]]" 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"[]"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个字符串已经是平衡字符串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == s.length</code></li><li><code>2 &lt;= n &lt;= 106</code></li><li><code>n</code>为偶数</li><li><code>s[i]</code> 为<code>&#39;[&#39;</code> 或 <code>&#39;]&#39;</code></li><li>开括号 <code>&#39;[&#39;</code> 的数目为 <code>n / 2</code> ，闭括号 <code>&#39;]&#39;</code> 的数目也是 <code>n / 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本质即为括号匹配问题，我们检测如果发现右括号<code>]</code>没有匹配时，则从字符串的末尾找到一个<code>[</code>来进行交换。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curr--;</span><br><span class="line">                <span class="keyword">if</span>(curr &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span>(r &gt; i &amp;&amp; s[r] == <span class="string">']'</span>) r--;</span><br><span class="line">                    swap(s[i],s[r]);</span><br><span class="line">                    ans++;</span><br><span class="line">                    curr += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5841-找出到每个位置为止最长的有效障碍赛跑路线"><a href="#5841-找出到每个位置为止最长的有效障碍赛跑路线" class="headerlink" title="5841. 找出到每个位置为止最长的有效障碍赛跑路线"></a>5841. 找出到每个位置为止最长的有效障碍赛跑路线</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你打算构建一些障碍赛跑路线。给你一个 下标从<code>0</code> 开始 的整数数组 <code>obstacles</code> ，数组长度为 n ，其中 <code>obstacles[i]</code> 表示第 i 个障碍的高度。</p><p>对于每个介于 0 和 <code>n - 1</code> 之间（包含 <code>0</code>和 <code>n - 1</code>）的下标  i ，在满足下述条件的前提下，请你找出 <code>obstacles</code> 能构成的最长障碍路线的长度：</p><p>你可以选择下标介于 0 到 <code>i</code>之间（包含 0 和 i）的任意个障碍。<br>在这条路线中，必须包含第 <code>i</code>个障碍。<br>你必须按障碍在 <code>obstacles</code>中的 出现顺序 布置这些障碍。<br>除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。<br>返回长度为 n 的答案数组 <code>ans</code> ，其中 <code>ans[i]</code> 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 长度为 <span class="number">3</span></span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">2</span>], [<span class="number">2</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">2</span>,<span class="number">2</span>], [<span class="number">2</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">输入：obstacles = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释：每个位置的最长有效障碍路线是：</span><br><span class="line">- i = <span class="number">0</span>: [<span class="number">3</span>], [<span class="number">3</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">1</span>: [<span class="number">3</span>,<span class="number">1</span>], [<span class="number">1</span>] 长度为 <span class="number">1</span></span><br><span class="line">- i = <span class="number">2</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>], [<span class="number">3</span>,<span class="number">5</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">5</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">3</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>] 长度为 <span class="number">3</span>, [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">4</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>], [<span class="number">3</span>,<span class="number">4</span>] 长度为 <span class="number">2</span>, [<span class="number">1</span>,<span class="number">4</span>] 也是有效的障碍赛跑路线</span><br><span class="line">- i = <span class="number">5</span>: [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>] 长度为 <span class="number">2</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == obstacles.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= obstacles[i] &lt;= <span class="number">107</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/count-number-of-special-subsequences</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  LIS问题</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的LIS问题变形，常见的`LIS`问题中要求每个元素严格递增，但在本题中要求后一个元素大于等于前一个元素。我们用`dp[i]`表示长度为`i+<span class="number">1</span>`的非递减数组中的最后一个元素。我们每次遇到当前元素`curr`时，则我们在已经组成元素查找第一个比`curr`大的元素，并用`curr`去替换该元素，即可得到以`curr`为结尾的最长递增序列。熟悉`lis`问题的人则会对改题目很容易理解。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(nlgn)$,空间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; longestObstacleCourseAtEachPosition(vector&lt;<span class="built_in">int</span>&gt;&amp; obstacles) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = obstacles.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; lcs;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">auto</span> it = upper_bound(lcs.begin(),lcs.end(),obstacles[i]);</span><br><span class="line">            <span class="keyword">if</span>(it == lcs.end())&#123;</span><br><span class="line">                ans[i] = lcs.size() + <span class="number">1</span>;</span><br><span class="line">                lcs.push_back(obstacles[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans[i] = it - lcs.begin() + <span class="number">1</span>;</span><br><span class="line">                *it = obstacles[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-253&quot;&gt;&lt;a href=&quot;#leetcode-contest-253&quot; class=&quot;headerlink&quot; title=&quot;leetcode contest 253&quot;&gt;&lt;/a&gt;leetcode contest 253&lt;/h1&gt;&lt;p&gt;本周题目都是手速场，确实难度太低了。&lt;/p&gt;&lt;h2 id=&quot;5838-检查字符串是否为数组前缀&quot;&gt;&lt;a href=&quot;#5838-检查字符串是否为数组前缀&quot; class=&quot;headerlink&quot; title=&quot;5838. 检查字符串是否为数组前缀&quot;&gt;&lt;/a&gt;5838. 检查字符串是否为数组前缀&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; 和一个字符串数组 &lt;code&gt;words&lt;/code&gt;，请你判断 &lt;code&gt;s&lt;/code&gt; 是否为 &lt;code&gt;words&lt;/code&gt; 的 前缀字符串 。&lt;/p&gt;&lt;p&gt;字符串 &lt;code&gt;s&lt;/code&gt; 要成为 &lt;code&gt;words&lt;/code&gt;的 前缀字符串 ，需要满足：&lt;code&gt;s&lt;/code&gt;可以由 &lt;code&gt;words&lt;/code&gt; 中的前 &lt;code&gt;k&lt;/code&gt;（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 &lt;code&gt;words.length&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 58</title>
    <link href="http://yoursite.com/2021/08/08/312/"/>
    <id>http://yoursite.com/2021/08/08/312/</id>
    <published>2021-08-08T06:25:48.674Z</published>
    <updated>2021-08-08T12:56:47.596Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-58"><a href="#leetcode-biweekly-contest-58" class="headerlink" title="leetcode  biweekly contest 58"></a>leetcode  biweekly contest 58</h1><p>本次的双周赛题目，前三题感觉都是正常的题目，第四题是<code>manacher</code>算法，这个算法确实很少会遇到。<br><img src="https://i.loli.net/2021/08/08/jCEKGQTAiPNSqlJ.png" alt></p><h2 id="5193-删除字符使字符串变好"><a href="#5193-删除字符使字符串变好" class="headerlink" title="5193. 删除字符使字符串变好"></a>5193. 删除字符使字符串变好</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。</p><p>给你一个字符串 <code>s</code> ，请你从 <code>s</code> 删除 最少 的字符，使它变成一个 好字符串 。</p><a id="more"></a><p>请你返回删除后的字符串。题目数据保证答案总是 唯一的 。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：</span><br><span class="line">从第一组 'e' 里面删除一个 'e' ，得到 <span class="string">"leetcode"</span> 。</span><br><span class="line">没有连续三个相同字符，所以返回 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabaaaa"</span></span><br><span class="line">输出：<span class="string">"aabaa"</span></span><br><span class="line">解释：</span><br><span class="line">从第一组 'a' 里面删除一个 'a' ，得到 <span class="string">"aabaaaa"</span> 。</span><br><span class="line">从第二组 'a' 里面删除两个 'a' ，得到 <span class="string">"aabaa"</span> 。</span><br><span class="line">没有连续三个相同字符，所以返回 <span class="string">"aabaa"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aab"</span></span><br><span class="line">输出：<span class="string">"aab"</span></span><br><span class="line">解释：没有连续三个相同字符，所以返回 <span class="string">"aab"</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= s.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址 </span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-58/problems/delete-characters-to-make-fancy-string/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   暴力检测</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 暴力检测其中连续的字符串，去掉多余的字符即可。</span><br><span class="line"><span class="number">2.</span> 算法复杂度为$O(n)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">string</span> makeFancyString(<span class="keyword">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">string</span> ans;</span><br><span class="line">        <span class="keyword">char</span> curr;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        curr = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == curr)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt &amp;&amp; j &lt; <span class="number">2</span>; ++j)&#123;</span><br><span class="line">                ans.push_back(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; s.size())&#123;</span><br><span class="line">                curr = s[i];</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5827-检查操作是否合法"><a href="#5827-检查操作是否合法" class="headerlink" title="5827. 检查操作是否合法"></a>5827. 检查操作是否合法</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 0 开始的 <code>8 x 8</code> 网格<code>board</code> ，其中<code>board[r][c]</code>表示游戏棋盘上的格子 <code>(r, c)</code> 。棋盘上空格用 ‘.’ 表示，白色格子用 <code>&#39;W&#39;</code>表示，黑色格子用 <code>&#39;B&#39;</code>表示。</p><p>游戏中每次操作步骤为：选择一个空格子，将它变成你正在执行的颜色（要么白色，要么黑色）。但是，合法 操作必须满足：涂色后这个格子是 好线段的一个端点 （好线段可以是水平的，竖直的或者是对角线）。</p><p>好线段 指的是一个包含 三个或者更多格子（包含端点格子）的线段，线段两个端点格子为 同一种颜色 ，且中间剩余格子的颜色都为 另一种颜色 （线段上不能有任何空格子）。你可以在下图找到好线段的例子：</p><p>给你两个整数 <code>rMove</code> 和 <code>cMove</code> 以及一个字符 <code>color</code> ，表示你正在执行操作的颜色（白或者黑），如果将格子 <code>(rMove, cMove)</code>变成颜色 <code>color</code>后，是一个 合法 操作，那么返回 <code>true</code> ，如果不是合法操作返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"W"</span>,<span class="string">"B"</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"W"</span>,<span class="string">"W"</span>,<span class="string">"B"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]], rMove = <span class="number">4</span>, cMove = <span class="number">3</span>, color = <span class="string">"B"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">'.'</span>，<span class="string">'W'</span> 和 <span class="string">'B'</span> 分别用颜色蓝色，白色和黑色表示。格子 (rMove, cMove) 用 <span class="string">'X'</span> 标记。</span><br><span class="line">以选中格子为端点的两个好线段在上图中用红色矩形标注出来了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"W"</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"W"</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>]], rMove = <span class="number">4</span>, cMove = <span class="number">4</span>, color = <span class="string">"W"</span></span><br><span class="line">输出：false</span><br><span class="line">解释：虽然选中格子涂色后，棋盘上产生了好线段，但选中格子是作为中间格子，没有产生以选中格子为端点的好线段。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>board.length == board[r].length == 8</code></li><li><code>0 &lt;= rMove, cMove &lt; 8</code></li><li><code>board[rMove][cMove] == &#39;.&#39;</code></li><li><code>color</code> 要么是 <code>&#39;B&#39;</code> 要么是 <code>&#39;W&#39;</code> 。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-58/problems/check-if-move-is-legal/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-58/problems/check-if-move-is-legal/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力检测是否合法即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测八个方向的线段是否合法即可，感觉题目非常无意义的题目，建议不要出现此类题目。<br>2.算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkMove</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> rMove, <span class="keyword">int</span> cMove, <span class="keyword">char</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = board.size();</span><br><span class="line">        <span class="keyword">int</span> col = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*up*/</span></span><br><span class="line">        i = rMove - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; board[i][cMove] != <span class="string">'.'</span> &amp;&amp; board[i][cMove] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][cMove] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*down*/</span></span><br><span class="line">        i = rMove + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; board[i][cMove] != <span class="string">'.'</span> &amp;&amp; board[i][cMove] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][cMove] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        i = cMove - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; board[rMove][i] != <span class="string">'.'</span> &amp;&amp; board[rMove][i] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i != cMove<span class="number">-1</span> &amp;&amp; board[rMove][i] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        i = cMove + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; col &amp;&amp; board[rMove][i] != <span class="string">'.'</span> &amp;&amp; board[rMove][i] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; col &amp;&amp; i != cMove+<span class="number">1</span> &amp;&amp; board[rMove][i] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove<span class="number">-1</span>;</span><br><span class="line">        j = cMove<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove+<span class="number">1</span>;</span><br><span class="line">        j = cMove+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &lt; col &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; j &lt; col &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove<span class="number">-1</span>;</span><br><span class="line">        j = cMove+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; col &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; col &amp;&amp; i != rMove<span class="number">-1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        i = rMove+<span class="number">1</span>;</span><br><span class="line">        j = cMove<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; board[i][j] != <span class="string">'.'</span> &amp;&amp; board[i][j] != color)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i != rMove+<span class="number">1</span> &amp;&amp; board[i][j] == color) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5828-K-次调整数组大小浪费的最小总空间"><a href="#5828-K-次调整数组大小浪费的最小总空间" class="headerlink" title="5828. K 次调整数组大小浪费的最小总空间"></a>5828. K 次调整数组大小浪费的最小总空间</h2><p>你正在设计一个动态数组。给你一个下标从 0 开始的整数数组 <code>nums</code>，其中 <code>nums[i]</code> 是<code>i</code> 时刻数组中的元素数目。除此以外，你还有一个整数 k ，表示你可以 调整 数组大小的 最多 次数（每次都可以调整成 任意 大小）。</p><p>t 时刻数组的大小 <code>sizet</code>必须大于等于 <code>nums[t]</code>，因为数组需要有足够的空间容纳所有元素。t 时刻 浪费的空间 为 <code>sizet - nums[t]</code> ，总 浪费空间为满足 <code>0 &lt;= t &lt; nums.length</code>的每一个时刻 <code>t</code> 浪费的空间 之和 。</p><p>在调整数组大小不超过<code>k</code> 次的前提下，请你返回 最小总浪费空间 。</p><p>注意：数组最开始时可以为 任意大小 ，且 不计入 调整大小的操作次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：size = [<span class="number">20</span>,<span class="number">20</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">20</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">20</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：size = [<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">20</span> ，然后时刻 <span class="number">2</span> 调整大小为 <span class="number">30</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">20</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) + (<span class="number">30</span> - <span class="number">30</span>) = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">30</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">15</span></span><br><span class="line">解释：size = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>].</span><br><span class="line">我们可以让数组初始大小为 <span class="number">10</span> ，时刻 <span class="number">1</span> 调整大小为 <span class="number">20</span> ，时刻 <span class="number">3</span> 调整大小为 <span class="number">30</span> 。</span><br><span class="line">总浪费空间为 (<span class="number">10</span> - <span class="number">10</span>) + (<span class="number">20</span> - <span class="number">20</span>) + (<span class="number">20</span> - <span class="number">15</span>) + (<span class="number">30</span> - <span class="number">30</span>) + (<span class="number">30</span> - <span class="number">20</span>) = <span class="number">15</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">200</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums[i] &lt;= <span class="number">106</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= k &lt;= nums.length - <span class="number">1</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-58/problems/minimum-total-space-wasted-with-k-resizing-operations/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  DP</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的`dp`，我们设递推公式为`dp[i][j]`表示前`i`个元素经过`j`次调整后，所能得到的最小浪费空间，则我们可以知道递推公式为为</span><br><span class="line">$$</span><br><span class="line">dp[i][j] = min(dp[i][j],dp[k][j<span class="number">-1</span>] + cost[k+<span class="number">1</span>][j])</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 我们可以提前计算出数组$cost[i][j]$,表示数组从`i`到`j`调整一次后所需要的最小浪费空间，我们利用递推可以知道:</span><br><span class="line">$$</span><br><span class="line">cost[i][j] = max[i][j]*(j-i+<span class="number">1</span>) - (sum[j] - sum[i<span class="number">-1</span>])</span><br><span class="line">$$</span><br><span class="line">我们可以知道从`i`到`j`调整一次满足题目要求的最小元素应该为$max[i][j]$,即数组从索引`i`到`j`之间的最大元素。$sum[i]$表示数组前`i`个元素的前缀和。</span><br><span class="line"><span class="number">3.</span> 算法时间复杂度为$O(n*(k+n))$,算法的空间复杂度为$O(n*n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minSpaceWastedKResizing(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; dp(n,vector&lt;long long&gt;(k+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        vector&lt;vector&lt;long long&gt;&gt; cost(n,vector&lt;long long&gt;(n));</span><br><span class="line">        vector&lt;long long&gt; sum(n+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> curr = nums[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                curr = max(curr,nums[j]);</span><br><span class="line">                cost[i][j] = curr*(j-i+<span class="number">1</span>) - (sum[j+<span class="number">1</span>] - sum[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = cost[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i &amp;&amp; j &lt;= k; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> l = i<span class="number">-1</span>; l &gt;= j<span class="number">-1</span>; --l)&#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j],dp[l][j<span class="number">-1</span>] + cost[l+<span class="number">1</span>][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5220-两个回文子字符串长度的最大乘积"><a href="#5220-两个回文子字符串长度的最大乘积" class="headerlink" title="5220. 两个回文子字符串长度的最大乘积"></a>5220. 两个回文子字符串长度的最大乘积</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <code>0</code> 开始的字符串<code>s</code> ，你需要找到两个 不重叠的回文 子字符串，它们的长度都必须为 奇数 ，使得它们长度的乘积最大。</p><p>更正式地，你想要选择四个整数 <code>i ，j ，k ，l</code>，使得 <code>0 &lt;= i &lt;= j &lt; k &lt;= l &lt; s.length</code> ，且子字符串 <code>s[i...j]</code>和 <code>s[k...l]</code>都是回文串且长度为奇数。<code>s[i...j]</code> 表示下标从 <code>i</code> 到 <code>j</code> 且 包含 两端下标的子字符串。</p><p>请你返回两个不重叠回文子字符串长度的 最大 乘积。</p><p>回文字符串 指的是一个从前往后读和从后往前读一模一样的字符串。子字符串 指的是一个字符串中一段连续字符。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"ababbb"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：子字符串 <span class="string">"aba"</span> 和 <span class="string">"bbb"</span> 为奇数长度的回文串。乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"zaaaxbbby"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：子字符串 <span class="string">"aaa"</span> 和 <span class="string">"bbb"</span> 为奇数长度的回文串。乘积为 <span class="number">3</span> * <span class="number">3</span> = <span class="number">9</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= s.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/count-number-of-special-subsequences</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  manacher算法</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 求回文字符串的长度，我们先利用`manacher`算法求出每个以索引`i`为中点的最长回文串的半径。这一步的算法时间时间复杂度为$O(n)$.详细解释可以参考[manacher](https:<span class="comment">//oi-wiki.org/string/manacher/),写的非常好，该算法的特点利用回文字符串的对称性，可以快速省去部分检测方法，确实是非常巧妙的算法。主要是如果知道对称性性的基本原理，则还可以将这个算法推导出来。</span></span><br><span class="line"><span class="number">2.</span> 此时我们可以求出每个以前缀`i`的最长回文串的长度$prefix[i]$，我们将字符串翻转，同时求出以`i`为起点的后缀的最长回文串长度$suffix[i]$，此时我们遍历每一个可能的组合:</span><br><span class="line">$$</span><br><span class="line">prod = prefix[i]*suffix[i+<span class="number">1</span>]</span><br><span class="line">$$</span><br><span class="line">求出$prod$的最大值即可。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; manacher(<span class="built_in">string</span> &amp; s)&#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; d1(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; hi(n,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">-1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">int</span> k = i &gt; r? <span class="number">1</span> : min(d1[r+l-i],r - i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span>( i &gt;= k &amp;&amp; i + k &lt; n &amp;&amp; s[i-k] == s[i+k]) k++;</span><br><span class="line">            d1[i] = k--;</span><br><span class="line">            <span class="keyword">if</span>(i+k &gt; r)&#123;</span><br><span class="line">                r = i+k;</span><br><span class="line">                l = i-k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> chi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            hi[i] = max(hi[i],hi[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">while</span>(chi + d1[chi] &lt;= i) chi++;</span><br><span class="line">            hi[i] = max(hi[i],(i-chi)*<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long long maxProduct(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = s.size();</span><br><span class="line">        long long ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; prefix = manacher(s);</span><br><span class="line">        reverse(s.begin(),s.end());</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; suffix = manacher(s);</span><br><span class="line">        reverse(rhi.begin(),rhi.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            ans = max(ans,(long long)prefix[i]*suffix[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-58&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-58&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 58&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 58&lt;/h1&gt;&lt;p&gt;本次的双周赛题目，前三题感觉都是正常的题目，第四题是&lt;code&gt;manacher&lt;/code&gt;算法，这个算法确实很少会遇到。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/08/jCEKGQTAiPNSqlJ.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5193-删除字符使字符串变好&quot;&gt;&lt;a href=&quot;#5193-删除字符使字符串变好&quot; class=&quot;headerlink&quot; title=&quot;5193. 删除字符使字符串变好&quot;&gt;&lt;/a&gt;5193. 删除字符使字符串变好&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。&lt;/p&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你从 &lt;code&gt;s&lt;/code&gt; 删除 最少 的字符，使它变成一个 好字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab3 Pagetable</title>
    <link href="http://yoursite.com/2021/08/06/311/"/>
    <id>http://yoursite.com/2021/08/06/311/</id>
    <published>2021-08-06T06:34:23.578Z</published>
    <updated>2021-08-10T09:56:22.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="page-tables"><a href="#page-tables" class="headerlink" title="page tables"></a>page tables</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab3</code>的内容作完了，<code>lab3</code>的难度感觉还是非常大的，不过最终把<code>lab3</code>完成后，就对虚拟内存管理有了深刻的认识。对于<code>vm</code>的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.<br><img src="https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png" alt><br><a href="https://github.com/mike-box/MIT6.S081" target="_blank" rel="noopener">git repo</a></p><h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>在<code>xv6</code>系统中，物理内存都被分成了<code>4096</code>byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)<code>offset</code>。由下图我们可以看到虚拟地址到物理地址的映射。<br><img src="https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png" alt><br>但在<code>xv6</code>系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在<code>xv6</code>系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。<br><img src="https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png" alt></p><a id="more"></a><ul><li>我们通过下图可以看到一个虚拟地址实际包含5部分，保留位为25位，紧接着为9位的一级页表内的的<code>offset</code>，紧接着为9位的二级页表内的的<code>offset</code>，紧接着为9位的三级页表内的的<code>offset</code>，三级页表中则存储的为该虚拟地址对应的实际物理页编号，我们取出物理页编号，再加上<code>offset</code>即可得到实际的物理地址。<br><img src="https://i.loli.net/2021/08/07/O6GLjEMNrFSfb9w.png" alt><br>我们可以看到代码中几个比较重要的宏定义<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一个物理页的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="comment">// 物理页的offset</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">//取出物理地址转换为对应的页表项</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">//通过页表得到对应的物理页对应的编号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 取出页表项中对应的标志位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li><li>三级页表中同时存储的有<code>flags</code>,<code>flags</code>代表该页表是否有效,我们需要判断每一页的访问权，只需要判断标志位即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTE_U (1L <span class="meta-string">&lt;&lt; 4) // 1 -&gt; user can access</span></span></span><br></pre></td></tr></table></figure>我们通过虚拟地址的12~39位，实际为该虚拟地址的三级页表的偏移地址，通过三级页表的偏移地址，最终可以得到该虚拟地址对应的物理页号。<h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">To <span class="keyword">help</span> you learn about RISC-V page <span class="keyword">tables</span>, <span class="keyword">and</span> perhaps <span class="keyword">to</span> aid future debugging, your <span class="keyword">first</span> task <span class="keyword">is</span> <span class="keyword">to</span> write a <span class="keyword">function</span> that prints the <span class="keyword">contents</span> <span class="keyword">of</span> a page table.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Define</span> a <span class="keyword">function</span> called vmprint(). It should take a pagetable_t argument, <span class="keyword">and</span> print that pagetable <span class="keyword">in</span> the <span class="keyword">format</span> described below. <span class="keyword">Insert</span> <span class="keyword">if</span>(p-&gt;pid==<span class="number">1</span>) vmprint(p-&gt;pagetable) <span class="keyword">in</span> exec.c just <span class="keyword">before</span> the <span class="keyword">return</span> argc, <span class="keyword">to</span> print the <span class="keyword">first</span> process<span class="string">'s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</span></span><br></pre></td></tr></table></figure>这部分比较简单，打印出页表的内容，我们知道三级页表的原理，这个即为简单的<code>dfs</code>遍历即可，遍历三级页表中的内容，每一级页表有<code>512</code>项，每一级页表有标志位，判断标志位是否有效，即是否包含PTE_V，则表示该页表有效。如果有效则向下遍历即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pteprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable,<span class="keyword">int</span> level)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> *pte = &amp;pagetable[i];</span><br><span class="line">    <span class="comment">// level page table entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// page table is valid</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &gt; level; --j)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">".. "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"..%d: pte %p pa %p\n\r"</span>,i,*pte,(<span class="keyword">pagetable_t</span>)PTE2PA(*pte));</span><br><span class="line">      <span class="keyword">if</span>(level &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">         pteprint((<span class="keyword">pagetable_t</span>)PTE2PA(*pte),level<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2.A kernel page table per process"></a>2.A kernel page table per process</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Xv6 has a single kernel page <span class="keyword">table</span> that<span class="string">'s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address x maps to physical address x. Xv6 also has a separate page table for each process'</span>s <span class="keyword">user</span> address space, containing <span class="keyword">only</span> mappings <span class="keyword">for</span> that process<span class="string">'s user memory, starting at virtual address zero. Because the kernel page table doesn'</span>t contain these mappings, <span class="keyword">user</span> addresses are <span class="keyword">not</span> <span class="keyword">valid</span> <span class="keyword">in</span> the kernel. Thus, <span class="keyword">when</span> the kernel needs <span class="keyword">to</span> use a <span class="keyword">user</span> pointer passed <span class="keyword">in</span> a <span class="keyword">system</span> <span class="keyword">call</span> (e.g., the buffer pointer passed <span class="keyword">to</span> <span class="keyword">write</span>()), the kernel must first translate the pointer <span class="keyword">to</span> a physical address. The goal <span class="keyword">of</span> this section <span class="keyword">and</span> the next <span class="keyword">is</span> <span class="keyword">to</span> allow the kernel <span class="keyword">to</span> directly dereference <span class="keyword">user</span> pointers.</span><br><span class="line"></span><br><span class="line">Your first job <span class="keyword">is</span> <span class="keyword">to</span> modify the kernel so that every process uses its own <span class="keyword">copy</span> <span class="keyword">of</span> the kernel page <span class="keyword">table</span> <span class="keyword">when</span> executing <span class="keyword">in</span> the kernel. Modify struct proc <span class="keyword">to</span> maintain a kernel page <span class="keyword">table</span> <span class="keyword">for</span> <span class="keyword">each</span> process, <span class="keyword">and</span> modify the scheduler <span class="keyword">to</span> switch kernel page <span class="keyword">tables</span> <span class="keyword">when</span> switching processes. <span class="keyword">For</span> this step, <span class="keyword">each</span> per-process kernel page <span class="keyword">table</span> should be identical <span class="keyword">to</span> the existing <span class="keyword">global</span> kernel page <span class="keyword">table</span>. You pass this part <span class="keyword">of</span> the lab <span class="keyword">if</span> usertests runs correctly.</span><br><span class="line">``` </span><br><span class="line">+ 题目本质是说进行内核空间的虚拟地址和用户空间的虚拟地址因为不在同一个页表里，所以内核的地址空间和用户的地址无法正常进行访问，必须要通过转换，特别在内核态访问用户态传过来的地址时，无法直接访问，需要通过转换才可以，因此我们需要在内核态将用户态的虚拟地址空间也需要做映射，这样我们就可以在内核态直接访问用户态的地址。</span><br><span class="line">+ 在此时，我们需要重新为进行申请一个内核态的页表，每个进程则有一个独立的内核页表，并将访问系统的所有的特殊的接口地址全部映射到该页表中，同时将该进程的内核栈也映射到该页表。每个进程都有一个独立的内核栈，由于内核栈空间与用户空间的地址映射在同一个地址表中，因此可以直接访问。</span><br><span class="line"><span class="number">1.</span> 为进程建立一个内核页表，并做好地址映射。新建页表，并做好内核地址的映射。</span><br><span class="line">```c++</span><br><span class="line">pagetable_t</span><br><span class="line">prockvminit()&#123;</span><br><span class="line">pagetable_t pagetable = (pagetable_t) kalloc();</span><br><span class="line"><span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">panic("kalloc");</span><br><span class="line"></span><br><span class="line">// <span class="keyword">each</span> page size <span class="keyword">is</span> <span class="number">4096</span> byte = <span class="number">4</span>KB</span><br><span class="line">// kernel page <span class="keyword">table</span></span><br><span class="line">memset(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">// uart registers</span><br><span class="line">// uart mmmap</span><br><span class="line">prockvmmap(pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// virtio mmio disk interface</span><br><span class="line">prockvmmap(pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// CLINT</span><br><span class="line">//prockvmmap(pagetable,CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// PLIC</span><br><span class="line">prockvmmap(pagetable,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">// map kernel <span class="type">text</span> executable <span class="keyword">and</span> <span class="keyword">read</span>-<span class="keyword">only</span>.</span><br><span class="line">prockvmmap(pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">// map kernel data <span class="keyword">and</span> the physical RAM w<span class="string">e'll make use of.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// map the trampoline for trap entry/exit to</span></span><br><span class="line"><span class="string">// the highest virtual address in the kernel.</span></span><br><span class="line"><span class="string">prockvmmap(pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return pagetable;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void</span></span><br><span class="line"><span class="string">prockvmmap(pagetable_t pagetable,uint64 va, uint64 pa, uint64 sz, int perm)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  if(mappages(pagetable, va, sz, pa, perm) != 0)&#123;</span></span><br><span class="line"><span class="string">  printf("total free = %d \n\r",totalfree());</span></span><br><span class="line"><span class="string">  printf("va = %p sz = %p \n\r",va,sz);</span></span><br><span class="line"><span class="string">    panic("prockvmmap");</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>在进程初始化时，我们可以保持不变，初始化时即为每个进程分配内核栈，映射到全局的<code>kernel_table</code>中,我们在进行进程<code>alloc</code>时，可以将该内核栈物理页再做一遍映射，映射到进程的内核表中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">procinit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  </span><br><span class="line">  initlock(&amp;pid_lock, <span class="string">"nextpid"</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      initlock(&amp;p-&gt;lock, <span class="string">"proc"</span>);</span><br><span class="line">  p-&gt;kallocstats = <span class="number">0</span>;</span><br><span class="line">    p-&gt;kfreestats = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line">  <span class="keyword">char</span> *pa = kalloc();</span><br><span class="line">  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"kalloc"</span>);</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">  kvmmap(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  kvminithart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line"> p-&gt;kpagetable = prockvminit();</span><br><span class="line"> prockvmmap(p-&gt;kpagetable,p-&gt;kstack,kvmpa(p-&gt;kstack),PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"> <span class="keyword">if</span>((p-&gt;trapframe = (struct trapframe *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// An empty user page table.</span></span><br><span class="line"> p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">   freeproc(p);</span><br><span class="line">   release(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>进程释放时，也需要对该进程的内核页表进行释放,但是释放时由于内核空间只是做了物理页的映射，因此我们只需要释放页表的空间即可，不需要释放物理页的空间。但在代码中加入了对每个进程执行<code>kalloc</code>和<code>kfree</code>的次数统计,发现实际确实存在内存泄漏,申请的物理页没有被释放的问题.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release trap frame</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release user page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release kernel page table and kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable) &#123; </span><br><span class="line">  procfreekpt(p-&gt;kpagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li>我们用一个遍历即可，但是总感觉这个函数写的有点问题，没有释放所有的物理页，存在内存泄漏的问题，这个问题查找了很长时间没有解决。从github上下载了几个代码运行了一下，发现也都有问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages except leaf</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">procfreekpt</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; (PTE_R|PTE_W|PTE_X)) &#123;</span><br><span class="line">  uint64 child = PTE2PA(pte);</span><br><span class="line">  procfreekpt((<span class="keyword">pagetable_t</span>)child);</span><br><span class="line">  pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  kfree((<span class="keyword">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>进程调度时,当前进程如果被调度时,则此时我们需要将该进行的内核页表的地址加载到页表的寄存器中,此时我们访问地址进行转换时,则通过该页表查找物理页的地址.我们可以看到在完成上下文切换前,将页表加载完成即可.当前如果所有的进程都空闲时,则我们将全局的<code>kernel pagetable</code>进行加载.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">       p-&gt;state = RUNNING;</span><br><span class="line">       c-&gt;proc = p;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// load kernel pagetable address into page table</span></span><br><span class="line">    prockvminithart(p-&gt;kpagetable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load process kernel page table</span></span><br><span class="line">       swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Process is done running for now.</span></span><br><span class="line">       <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">       c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// found</span></span><br><span class="line">       found = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     release(&amp;p-&gt;lock);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// the current has no process runing</span></span><br><span class="line">   <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// use kernel pagetable when no process runing</span></span><br><span class="line">  kvminithart();</span><br><span class="line">  </span><br><span class="line">     intr_on();</span><br><span class="line">  <span class="comment">// load kernel page table</span></span><br><span class="line">     <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"wfi"</span>)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-copyin-copyinstr"><a href="#3-copyin-copyinstr" class="headerlink" title="3.copyin/copyinstr"></a>3.copyin/copyinstr</h3></li><li>需要自己重新写<code>copyin</code>和<code>copyinstr</code>的代码，这个其实比较简单，在上一个练习中我们将内核中的所有的地址全部挂接到内核表中，在这个练习中我们需要将所有的用户空间的地址要全部映射到内核的页表中，这样在进程运行时，内核即可进行对用户空间的虚拟地址进行访问.我们可以重写一个函数对页表的物理页进行映射.下面函数的作用即是将一个页表中的虚地址全部映射到一个页表中.实际只做了物理页的映射,而并有实际的物理页的申请.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">procuvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> uvm,<span class="keyword">pagetable_t</span> kvm,uint64 old_sz, uint64 new_sz)</span></span>&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line">uint64 pa, i;</span><br><span class="line">uint flags;</span><br><span class="line"></span><br><span class="line">old_sz = PGROUNDUP(old_sz);</span><br><span class="line"><span class="keyword">if</span> (new_sz &lt;= old_sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = old_sz; i &lt; new_sz; i += PGSIZE)&#123;</span><br><span class="line"><span class="keyword">if</span>((pte = walk(uvm, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: pte should exist"</span>);</span><br><span class="line"><span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">"procuvmcopy: page not present"</span>);</span><br><span class="line">pa = PTE2PA(*pte);</span><br><span class="line">flags = PTE_FLAGS(*pte);</span><br><span class="line"><span class="keyword">if</span>(mappages(kvm, i, PGSIZE, pa, flags&amp;(~PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">"procuvmcopy: remap"</span>);</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">uvmunmap(kvm, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>我们仔细阅读提示,发现有几个函数需要进行此类操作和映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Replace copyin() with a call to copyin_new first, and make it work, before moving on to copyinstr.</span><br><span class="line">At each point where the kernel changes a process's user mappings, change the process's kernel page table in the same way. Such points include fork(), exec(), and sbrk().</span><br><span class="line">Don't forget that to include the first process's user page table in its kernel page table in userinit.</span><br><span class="line">What permissions <span class="keyword">do</span> the PTEs <span class="keyword">for</span> user addresses need in a process's kernel page table? (A page with PTE_U <span class="built_in">set</span> cannot be accessed in kernel mode.)</span><br><span class="line">Don't forget about the above-mentioned PLIC limit.</span><br></pre></td></tr></table></figure></li></ul><ol><li><code>userinit</code>函数的修改,我们需要将<code>initcode</code>中加载的一个物理页进行<code>copy</code>映射.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  p = allocproc();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init's instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  uvminit(p-&gt;pagetable, initcode, <span class="keyword">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy one page of the </span></span><br><span class="line">  procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable,<span class="number">0</span>,PGSIZE) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first "return" from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  safestrcpy(p-&gt;name, <span class="string">"initcode"</span>, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = namei(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure></li><li><code>fork()</code>函数的修改, 我们发现<code>uvmcopy</code>时需要将父进程的用户空间页表全部拷贝到子进程,我们在完成拷贝时,则需要将该进程的用户空间的页表也全部拷贝一遍.将所有的页全部拷贝映射一遍即可.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = allocproc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Copy user memory mapper the kernel page table to child</span></span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(np-&gt;pagetable, np-&gt;kpagetable,<span class="number">0</span>,np-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><code>exec()</code>函数,我们可以看到<code>exec</code>函数函数执行时,首先会将<code>elf</code>文件里面的所有的段加载到内存中,并将其全部映射到进程的用户态页表中.首先我们需要将该进程的所有的内核的页表中所有的物理页映射全部去掉,然后就重新将用户空间的页表全部重新映射到内核的页表中.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">'/'</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  safestrcpy(p-&gt;name, last, <span class="keyword">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we remove the old mapper and We mapper new pages to the kernel page table</span></span><br><span class="line">  uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(procuvmcopy(p-&gt;pagetable,p-&gt;kpagetable,<span class="number">0</span>,p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">  </span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp;          <span class="comment">// initial stack pointer</span></span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li><li><code>sbrk</code>函数,我们实际需要修改<code>sys_sbrk</code>函数,当用户空间的物理内存增长时,此时我们需要将新增的地址空间页全部映射到内核的页表中,如果用户的物理内存缩小时,则此时我们需要将已经去掉的地址空间的映射全部取消掉.我们判断地址增长的时候会判断该地址是否增长超过了系统的限制.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">growproc(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// check the virtual address is no more than 0x0c000000L</span></span><br><span class="line">  <span class="keyword">if</span>((sz + n) &gt;= PLIC)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// malloc </span></span><br><span class="line">    <span class="keyword">if</span>((sz = uvmalloc(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// mapper user page to kernel page table</span></span><br><span class="line"><span class="keyword">if</span>((procuvmcopy(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = uvmdealloc(p-&gt;pagetable, sz, sz + n);</span><br><span class="line"><span class="comment">// remove all the pages from the kernel table</span></span><br><span class="line">uvmunmap(p-&gt;kpagetable,PGROUNDUP(sz),(PGROUNDUP(p-&gt;sz)-PGROUNDUP(sz))/PGSIZE,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>总的来说这一章的<code>lab</code>还是非常有难度的,特别时调试的部分,花了很长时间都没有非常好的结果,感觉是目前遇到的难度最大的<code>lab</code>.<h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;page-tables&quot;&gt;&lt;a href=&quot;#page-tables&quot; class=&quot;headerlink&quot; title=&quot;page tables&quot;&gt;&lt;/a&gt;page tables&lt;/h1&gt;&lt;p&gt;最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把&lt;code&gt;lab3&lt;/code&gt;的内容作完了，&lt;code&gt;lab3&lt;/code&gt;的难度感觉还是非常大的，不过最终把&lt;code&gt;lab3&lt;/code&gt;完成后，就对虚拟内存管理有了深刻的认识。对于&lt;code&gt;vm&lt;/code&gt;的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png&quot; alt&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/MIT6.S081&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;page&quot;&gt;&lt;a href=&quot;#page&quot; class=&quot;headerlink&quot; title=&quot;page&quot;&gt;&lt;/a&gt;page&lt;/h2&gt;&lt;p&gt;在&lt;code&gt;xv6&lt;/code&gt;系统中，物理内存都被分成了&lt;code&gt;4096&lt;/code&gt;byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)&lt;code&gt;offset&lt;/code&gt;。由下图我们可以看到虚拟地址到物理地址的映射。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png&quot; alt&gt;&lt;br&gt;但在&lt;code&gt;xv6&lt;/code&gt;系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在&lt;code&gt;xv6&lt;/code&gt;系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode   Contest 252</title>
    <link href="http://yoursite.com/2021/08/01/310/"/>
    <id>http://yoursite.com/2021/08/01/310/</id>
    <published>2021-08-01T08:00:59.210Z</published>
    <updated>2021-08-01T09:01:24.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-252"><a href="#leetcode-contest-252" class="headerlink" title="leetcode  contest 252"></a>leetcode  contest 252</h1><p>本周周赛题目放水严重，基本上都是<code>mid</code>难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。<br><img src="https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png" alt></p><h2 id="5830-三除数"><a href="#5830-三除数" class="headerlink" title="5830. 三除数"></a>5830. 三除数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数<code>n</code> 。如果 <code>n</code> 恰好有三个正除数 ，返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>如果存在整数 <code>k</code>，满足 <code>n = k * m</code>，那么整数<code>m</code>就是 <code>n</code> 的一个 除数 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：<span class="number">2</span> 只有两个除数：<span class="number">1</span> 和 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：<span class="number">4</span> 有三个除数：<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">4</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line"></span><br><span class="line">### 地址 </span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/three-divisors</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   直接换算</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接暴力检测除数的个数即可，算法时间复杂度为$O(n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> isThree(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i * i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i != n / i)&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 为不同整数</span></span><br><span class="line">                    cnt += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 此时 i 与 n / i 相等</span></span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5831-你可以工作的最大周数"><a href="#5831-你可以工作的最大周数" class="headerlink" title="5831. 你可以工作的最大周数"></a>5831. 你可以工作的最大周数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你 <code>n</code>个项目，编号从 0 到 <code>n - 1</code>。同时给你一个整数数组 <code>milestones</code> ，其中每个<code>milestones[i]</code>表示第 i 个项目中的阶段任务数量。</p><p>你可以按下面两个规则参与项目中的工作：</p><ul><li>每周，你将会完成 某一个 项目中的 恰好一个 阶段任务。你每周都 必须 工作。</li><li>在 连续的 两周中，你 不能 参与并完成同一个项目中的两个阶段任务。<br>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 停止工作 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</li></ul><p>返回在不违反上面规则的情况下你 最多 能工作多少周。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">​​​​- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：milestones = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：一种可能的情形是：</span><br><span class="line">- 第 <span class="number">1</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">2</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">3</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">4</span> 周，你参与并完成项目 <span class="number">1</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">5</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">6</span> 周，你参与并完成项目 <span class="number">2</span> 中的一个阶段任务。</span><br><span class="line">- 第 <span class="number">7</span> 周，你参与并完成项目 <span class="number">0</span> 中的一个阶段任务。</span><br><span class="line">总周数是 <span class="number">7</span> 。</span><br><span class="line">注意，你不能在第 <span class="number">8</span> 周参与完成项目 <span class="number">0</span> 中的最后一个阶段任务，因为这会违反规则。</span><br><span class="line">因此，项目 <span class="number">0</span> 中会有一个阶段任务维持未完成状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == milestones.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= milestones[i] &lt;= 109</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-weeks-for-which-you-can-work</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 贪心算法</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直接假设需要将相邻的两周分配成为不同的任务即可，我们采购从高到底进行分配，我们可以看到，加入数量最多的任务可以被完成，则剩余的任务一定可以被完成。</li><li>我们实际可以看到剩余的任务为$rest = sum - longest$,如果$rest &gt;= longest - 1$,我们把剩余的任务看成一组，我们可以看到总有办法可以让相邻的两个任务交替运行且不相等。</li><li>算法时间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">numberOfWeeks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; milestones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = milestones.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        sort(milestones.begin(),milestones.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum += milestones[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(milestones.back()*<span class="number">2</span> &gt; sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> (sum - milestones.back())*<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5187-收集足够苹果的最小花园周长"><a href="#5187-收集足够苹果的最小花园周长" class="headerlink" title="5187. 收集足够苹果的最小花园周长"></a>5187. 收集足够苹果的最小花园周长</h2><p>给你一个用无限二维网格表示的花园，每一个 整数坐标处都有一棵苹果树。整数坐标 <code>(i, j)</code>处的苹果树有<code>|i| + |j|</code>个苹果。</p><p>你将会买下正中心坐标是 <code>(0, 0)</code>的一块 正方形土地 ，且每条边都与两条坐标轴之一平行。</p><p>给你一个整数 <code>neededApples</code>，请你返回土地的 最小周长 ，使得 至少 有 <code>neededApples</code> 个苹果在土地 里面或者边缘上。</p><p><code>|x|</code> 的值定义为：</p><p>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code><br>如果 <code>x &lt; 0</code>，那么值为 <code>-x</code></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：边长长度为 <span class="number">1</span> 的正方形不包含任何苹果。</span><br><span class="line">但是边长为 <span class="number">2</span> 的正方形包含 <span class="number">12</span> 个苹果（如上图所示）。</span><br><span class="line">周长为 <span class="number">2</span> * <span class="number">4</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">13</span></span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：neededApples = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">5040</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= neededApples &lt;= 1015</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-garden-perimeter-to-collect-enough-apples</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的数学问题，我们先观察规律求出数列的通项公式，我们设正方形的边上为$2n$,则我们可以先观察正方形右下部分的数字分布规律，当前正方形的右上方也为正方形，边长为$n$.<script type="math/tex; mode=display">0 ,1 ,2 ,3, ... ,n \\1 ,2 ,3 ,4, ... ,n+1 \\2 ,3 ,4 ,5, ... ,n+2 \\... \\n, n+1, n+2, n+3, ... ,n+n \\</script>所以我们对每一列求数列之和为:<script type="math/tex; mode=display">sum = \frac{(n+1)(0+n)}{2} + \frac{(n+1)(1+n+1)}{2}+ \frac{(n+1)(2+n+2)}{2} + ... + \frac{(n+1)(n+n+n)}{2} \\= \frac{(n+1)(\frac{(n+1)(n+3*n)}{2})}{2} \\= n*(n+1)^{2}</script>我们求出了一部分的通项和，此时我们需要相加，并减去充分的边缘。<script type="math/tex; mode=display">total = 4*n*(n+1)^{2} - 4*\frac{(n+1)*(0+n)}{2} \\= 4*n*(n+1)^{2} - 2n*(n+1) \\= 2n*(2n+1)*(n+1)</script></li><li>由<code>1</code>式我们得出通项公式，则此时我们即可利用二分查找的方式，来快速确定周长小于等于$neededApples$的正方形。</li><li>算法时间复杂度为$O(n^{\frac{1}{3}})$.</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">minimumPerimeter</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> neededApples)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> r = <span class="number">1e6</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">2</span>*mid*(<span class="number">2</span>*mid + <span class="number">1</span>)*(mid + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt;= neededApples)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans*<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5833-统计特殊子序列的数目"><a href="#5833-统计特殊子序列的数目" class="headerlink" title="5833. 统计特殊子序列的数目"></a>5833. 统计特殊子序列的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>特殊序列 是由 正整数 个<code>0</code> ，紧接着 正整数 个 <code>1</code> ，最后 正整数 个 <code>2</code> 组成的序列。</p><ul><li>比方说，[0,1,2] 和 [0,0,1,1,1,2] 是特殊序列。</li><li>相反，[2,1,0] ，[1] 和 [0,1,2,0] 就不是特殊序列。</li><li>给你一个数组 nums （仅 包含整数 0，1 和 2），请你返回 不同特殊子序列的数目 。由于答案可能很大，请你将它对 109 + 7 取余 后返回。</li></ul><p>一个数组的 子序列 是从原数组中删除零个或者若干个元素后，剩下元素不改变顺序得到的序列。如果两个子序列的 下标集合 不同，那么这两个子序列是 不同的 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：特殊子序列为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 和 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：数组 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>] 中没有特殊子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：特殊子序列包括：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">- [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>0 &lt;= nums[i] &lt;= 2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-special-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-special-subsequences</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>最后一题为简单的<code>dp</code>，感觉可能难度只有<code>mid</code>.我们设<code>dp[i][j]</code>表示前<code>i</code>个元素中组成以<code>j</code>为结尾的合法的字串的个数。则我们可以知道:</li></ol><ul><li>当<code>nums[i] == 0</code>时，则我们可以知道要么当前的<code>0</code>作为独立的字符串开始，要么当前的<code>0</code>可以加在其余为<code>0</code>为结尾的字串中，要么当前的<code>0</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][0] = 1 + dp[i-1][0] + dp[i-1][0]</script></li><li>当<code>nums[i] == 1</code>时，则我们可以知道要么当前的<code>1</code>可以加在其余为<code>1</code>为结尾的字串中，要么当前的<code>1</code>加在以<code>0</code>为结尾的字串中，要么当前的<code>1</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][1] + dp[i-1][0] + dp[i-1][1]</script></li><li>当<code>nums[i] == 2</code>时，则我们可以知道要么当前的<code>2</code>可以加在其余为<code>2</code>为结尾的字串中，要么当前的<code>2</code>加在以<code>1</code>为结尾的字串中，要么当前的<code>2</code>不要，此时我们可以知道:<script type="math/tex; mode=display">dp[i][1] = dp[i-1][2] + dp[i-1][1] + dp[i-1][2]</script></li></ul><ol><li>本身来说是非常常规的<code>dp</code>，算法时间复杂度为$O(3n)$,空间复杂度为$O(3n)$. <h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSpecialSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) dp[i+<span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">0</span>] = (dp[i][<span class="number">0</span>] + dp[i][<span class="number">0</span>] + <span class="number">1</span>)%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">1</span>] = (dp[i][<span class="number">1</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">0</span>])%mod;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="number">2</span>] = (dp[i][<span class="number">2</span>] + dp[i][<span class="number">1</span>] + dp[i][<span class="number">2</span>])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[n][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-252&quot;&gt;&lt;a href=&quot;#leetcode-contest-252&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 252&quot;&gt;&lt;/a&gt;leetcode  contest 252&lt;/h1&gt;&lt;p&gt;本周周赛题目放水严重，基本上都是&lt;code&gt;mid&lt;/code&gt;难度而已，不过自己还是太水,不晓得积分到达2200.不过感觉参加的周赛越多，排名和积分掉落的可能性越大。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/08/01/jHsWTAZgwkRiSNY.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5830-三除数&quot;&gt;&lt;a href=&quot;#5830-三除数&quot; class=&quot;headerlink&quot; title=&quot;5830. 三除数&quot;&gt;&lt;/a&gt;5830. 三除数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数&lt;code&gt;n&lt;/code&gt; 。如果 &lt;code&gt;n&lt;/code&gt; 恰好有三个正除数 ，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果存在整数 &lt;code&gt;k&lt;/code&gt;，满足 &lt;code&gt;n = k * m&lt;/code&gt;，那么整数&lt;code&gt;m&lt;/code&gt;就是 &lt;code&gt;n&lt;/code&gt; 的一个 除数 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/25/309/"/>
    <id>http://yoursite.com/2021/07/25/309/</id>
    <published>2021-07-25T06:38:08.473Z</published>
    <updated>2021-07-25T07:34:47.322Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-251"><a href="#leetcode-contest-251" class="headerlink" title="leetcode  contest 251"></a>leetcode  contest 251</h1><p>周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。<br><img src="https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png" alt></p><h2 id="5823-字符串转化后的各位数字之和"><a href="#5823-字符串转化后的各位数字之和" class="headerlink" title="5823. 字符串转化后的各位数字之和"></a>5823. 字符串转化后的各位数字之和</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由小写字母组成的字符串 <code>s</code>，以及一个整数 <code>k</code> 。</p><p>首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。</p><a id="more"></a><p>例如，如果 <code>s = &quot;zbax&quot;</code> 且<code>k = 2</code>，那么执行下述步骤后得到的结果是整数 8 ：</p><ul><li>转化：<code>&quot;zbax&quot; ➝ &quot;(26)(2)(1)(24)&quot; ➝ &quot;262124&quot; ➝ 262124</code></li><li>转换 <code>#1：262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17</code></li><li>转换 <code>#2：17 ➝ 1 + 7 ➝ 8</code><br>返回执行上述操作后得到的结果整数。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"iiii"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">36</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"iiii"</span> ➝ <span class="string">"(9)(9)(9)(9)"</span> ➝ <span class="string">"9999"</span> ➝ <span class="number">9999</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">9999</span> ➝ <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> + <span class="number">9</span> ➝ <span class="number">36</span></span><br><span class="line">因此，结果整数为 <span class="number">36</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：操作如下：</span><br><span class="line">- 转化：<span class="string">"leetcode"</span> ➝ <span class="string">"(12)(5)(5)(20)(3)(15)(4)(5)"</span> ➝ <span class="string">"12552031545"</span> ➝ <span class="number">12552031545</span></span><br><span class="line">- 转换 #<span class="number">1</span>：<span class="number">12552031545</span> ➝ <span class="number">1</span> + <span class="number">2</span> + <span class="number">5</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">0</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">5</span> + <span class="number">4</span> + <span class="number">5</span> ➝ <span class="number">33</span></span><br><span class="line">- 转换 #<span class="number">2</span>：<span class="number">33</span> ➝ <span class="number">3</span> + <span class="number">3</span> ➝ <span class="number">6</span></span><br><span class="line">因此，结果整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>1 &lt;= k &lt;= 10</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-of-digits-of-string-after-convert</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  直接换算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一步首先我们需要将字母全部转换为数字。</li><li>我们依次执行<code>k</code>次变换，每次对数字求和然后转换为新的字符串。算法时间复杂度为$O(nk)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLucky</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            curr = curr + to_string(c-<span class="string">'a'</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : curr)&#123;</span><br><span class="line">                sum += c - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = to_string(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5824-子字符串突变后可能得到的最大整数"><a href="#5824-子字符串突变后可能得到的最大整数" class="headerlink" title="5824. 子字符串突变后可能得到的最大整数"></a>5824. 子字符串突变后可能得到的最大整数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>，该字符串表示一个大整数。另给你一个长度为 10 且 下标从 0  开始 的整数数组 <code>change</code> ，该数组将 0-9 中的每个数字映射到另一个数字。更规范的说法是，数字 d 映射为数字 <code>change[d]</code> 。</p><p>你可以选择 突变 <code>num</code>的任一子字符串。突变 子字符串意味着将每位数字 num[i] 替换为该数字在 <code>change</code>中的映射（也就是说，将 <code>num[i]</code>替换为 <code>change[num[i]]</code>）。</p><p>请你找出在对 num 的任一子字符串执行突变操作（也可以不执行）后，可能得到的 最大整数 ，并用字符串表示返回。</p><p>子字符串 是字符串中的一个连续序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"132"</span>, change = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="string">"832"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"1"</span>：</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">8</span> 。</span><br><span class="line">因此 <span class="string">"132"</span> 变为 <span class="string">"832"</span> 。</span><br><span class="line"><span class="string">"832"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"021"</span>, change = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="string">"934"</span></span><br><span class="line">解释：替换子字符串 <span class="string">"021"</span>：</span><br><span class="line">- <span class="number">0</span> 映射为 change[<span class="number">0</span>] = <span class="number">9</span> 。</span><br><span class="line">- <span class="number">2</span> 映射为 change[<span class="number">2</span>] = <span class="number">3</span> 。</span><br><span class="line">- <span class="number">1</span> 映射为 change[<span class="number">1</span>] = <span class="number">4</span> 。</span><br><span class="line">因此，<span class="string">"021"</span> 变为 <span class="string">"934"</span> 。</span><br><span class="line"><span class="string">"934"</span> 是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5"</span>, change = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="string">"5"</span></span><br><span class="line">解释：<span class="string">"5"</span> 已经是可以构造的最大整数，所以返回它的字符串表示。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由数字 0-9 组成</li><li><code>change.length == 10</code></li><li><code>0 &lt;= change[d] &lt;= 9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/largest-number-after-mutating-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-number-after-mutating-substring</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>本质为贪心算法，我们优先找到最左侧可以替换为较大数字的字符，直到出现当前的字符<code>c</code>比<code>change[c]</code>大为止则结束。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(1)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">maximumNumber</span><span class="params">(<span class="built_in">string</span> num, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; change)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="keyword">bool</span> start = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(change[x] &gt; x)&#123;</span><br><span class="line">                num[i] = change[x] + <span class="string">'0'</span>;</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(change[x] &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(start) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5825-最大兼容性评分和"><a href="#5825-最大兼容性评分和" class="headerlink" title="5825. 最大兼容性评分和"></a>5825. 最大兼容性评分和</h2><p>有一份由 n 个问题组成的调查问卷，每个问题的答案要么是 0（<code>no</code>，否），要么是 1（<code>yes</code>，是）。</p><p>这份调查问卷被分发给 <code>m</code> 名学生和 <code>m</code> 名导师，学生和导师的编号都是从 0 到 m - 1 。学生的答案用一个二维整数数组 <code>students</code>表示，其中 <code>students[i]</code>是一个整数数组，包含第 i 名学生对调查问卷给出的答案（下标从 0 开始）。导师的答案用一个二维整数数组<code>mentors</code> 表示，其中 <code>mentors[j]</code>是一个整数数组，包含第 <code>j</code> 名导师对调查问卷给出的答案（下标从 0 开始）。</p><p>每个学生都会被分配给 一名 导师，而每位导师也会分配到 一名 学生。配对的学生与导师之间的兼容性评分等于学生和导师答案相同的次数。</p><ul><li>例如，学生答案为<code>[1, 0, 1]</code> 而导师答案为 <code>[0, 0, 1]</code> ，那么他们的兼容性评分为 2 ，因为只有第二个和第三个答案相同。<br>请你找出最优的学生与导师的配对方案，以 最大程度上 提高 兼容性评分和 。</li></ul><p>给你 <code>students</code> 和 <code>mentors</code> ，返回可以得到的 最大兼容性评分和 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]], mentors = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：按下述方式分配学生和导师：</span><br><span class="line">- 学生 <span class="number">0</span> 分配给导师 <span class="number">2</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">- 学生 <span class="number">1</span> 分配给导师 <span class="number">0</span> ，兼容性评分为 <span class="number">2</span> 。</span><br><span class="line">- 学生 <span class="number">2</span> 分配给导师 <span class="number">1</span> ，兼容性评分为 <span class="number">3</span> 。</span><br><span class="line">最大兼容性评分和为 <span class="number">3</span> + <span class="number">2</span> + <span class="number">3</span> = <span class="number">8</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：students = [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>]], mentors = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：任意学生与导师配对的兼容性评分都是 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == students.length == mentors.length</code></li><li><code>n == students[i].length == mentors[j].length</code></li><li><code>1 &lt;= m, n &lt;= 8</code></li><li><code>students[i][k] 为 0 或 1</code></li><li><code>mentors[j][k] 为 0 或 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-compatibility-score-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-compatibility-score-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的状态压缩<code>dp</code>,我们用<code>dp[x][y]</code>表示<code>x</code>表示的学生的二进制位图与<code>y</code>所表示的导师的二进制位图两者进行配对时的最大值，则此时我们可以直到<code>x</code>表示的学生个数一定与<code>y</code>表示的导师的个数相等。</li><li>我们可以直到递推公式如下：<script type="math/tex; mode=display">dp[x][y] = max(dp[x][y], dp[a][b] + score[x\oplus a][y\oplus b])</script>其中<code>a</code>为<code>x</code>的子集，<code>b</code>为<code>y</code>的子集。</li><li>算法时间复杂度为$O(n^{2}<em>2^{2</em>m})$,空间复杂度为$O(2^{2m})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOne</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCompatibilitySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; students, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mentors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = students.size();</span><br><span class="line">        <span class="keyword">int</span> n = students[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mask = (<span class="number">1</span>&lt;&lt;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(mask,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(mask));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; score(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(students[i][k] == mentors[j][k])&#123;</span><br><span class="line">                        val++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                score[i][j] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = countOne(i);</span><br><span class="line">                <span class="keyword">int</span> y = countOne(j);</span><br><span class="line">                <span class="keyword">if</span>(x != y) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; m; ++a)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; m; ++b)&#123;</span><br><span class="line">                        <span class="keyword">if</span>((i&amp;(<span class="number">1</span>&lt;&lt;a))&amp;&amp;(j&amp;(<span class="number">1</span>&lt;&lt;b)))&#123;</span><br><span class="line">                            <span class="keyword">int</span> cx = i&amp;(~(<span class="number">1</span>&lt;&lt;a));</span><br><span class="line">                            <span class="keyword">int</span> cy = j&amp;(~(<span class="number">1</span>&lt;&lt;b));</span><br><span class="line">                            dp[i][j] = max(dp[i][j],dp[cx][cy] + score[a][b]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[mask<span class="number">-1</span>][mask<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5826-删除系统中的重复文件夹"><a href="#5826-删除系统中的重复文件夹" class="headerlink" title="5826. 删除系统中的重复文件夹"></a>5826. 删除系统中的重复文件夹</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>由于一个漏洞，文件系统中存在许多重复文件夹。给你一个二维数组<code>paths</code>，其中 <code>paths[i]</code>是一个表示文件系统中第 i 个文件夹的绝对路径的数组。</p><ul><li><p>例如，<code>[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]</code>表示路径 <code>&quot;/one/two/three&quot;</code> 。<br>如果两个文件夹（不需要在同一层级）包含 非空且相同的 子文件夹 集合 并具有相同的子文件夹结构，则认为这两个文件夹是相同文件夹。相同文件夹的根层级 不 需要相同。如果存在两个（或两个以上）相同 文件夹，则需要将这些文件夹和所有它们的子文件夹 标记 为待删除。</p></li><li><p>例如，下面文件结构中的文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 相同。它们（以及它们的子文件夹）应该被 全部 标记为待删除：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/a</span></span><br><span class="line"><span class="string">/a/x</span></span><br><span class="line"><span class="string">/a/x/y</span></span><br><span class="line"><span class="string">/a/z</span></span><br><span class="line"><span class="string">/b</span></span><br><span class="line"><span class="string">/b/x</span></span><br><span class="line"><span class="string">/b/x/y</span></span><br><span class="line"><span class="string">/b/z</span></span><br></pre></td></tr></table></figure></li><li>然而，如果文件结构中还包含路径 <code>&quot;/b/w&quot;</code> ，那么文件夹 <code>&quot;/a&quot;</code> 和 <code>&quot;/b&quot;</code> 就不相同。注意，即便添加了新的文件夹 <code>&quot;/b/w&quot;</code>，仍然认为 <code>&quot;/a/x&quot;</code>和 <code>&quot;/b/x&quot;</code>相同。<br>一旦所有的相同文件夹和它们的子文件夹都被标记为待删除，文件系统将会 删除 所有上述文件夹。文件系统只会执行一次删除操作。执行完这一次删除操作后，不会删除新出现的相同文件夹。</li></ul><p>返回二维数组<code>ans</code> ，该数组包含删除所有标记文件夹之后剩余文件夹的路径。路径可以按 任意顺序 返回。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"d"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"d"</span>],[<span class="string">"d"</span>,<span class="string">"a"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"b"</span> 的空文件夹。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"w"</span>],[<span class="string">"w"</span>,<span class="string">"y"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"b"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/b/x"</span> 和 <span class="string">"/w"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">注意，文件夹 <span class="string">"/a"</span> 和 <span class="string">"/c"</span> 在删除后变为相同文件夹，但这两个文件夹不会被删除，因为删除只会进行一次，且它们没有在删除前被标记。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>,<span class="string">"b"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"c"</span>],[<span class="string">"a"</span>]]</span><br><span class="line">输出：[[<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"b"</span>]]</span><br><span class="line">解释：文件系统中所有文件夹互不相同。</span><br><span class="line">注意，返回的数组可以按不同顺序返回文件夹路径，因为题目对顺序没有要求。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：文件结构如上所示。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含名为 <span class="string">"y"</span> 的空文件夹。</span><br><span class="line">文件夹 <span class="string">"/a"</span> 和 <span class="string">"/b"</span>（以及它们的子文件夹）都会被标记为待删除，因为它们都包含一个名为 <span class="string">"z"</span> 的空文件夹以及上面提到的文件夹 <span class="string">"x"</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>],[<span class="string">"a"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>],[<span class="string">"b"</span>,<span class="string">"x"</span>,<span class="string">"y"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>]]</span><br><span class="line">输出：[[<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"w"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>],[<span class="string">"a"</span>],[<span class="string">"a"</span>,<span class="string">"z"</span>]]</span><br><span class="line">解释：本例与上例的结构基本相同，除了新增 <span class="string">"/b/w"</span> 文件夹。</span><br><span class="line">文件夹 <span class="string">"/a/x"</span> 和 <span class="string">"/b/x"</span> 仍然会被标记，但 <span class="string">"/a"</span> 和 <span class="string">"/b"</span> 不再被标记，因为 <span class="string">"/b"</span> 中有名为 <span class="string">"w"</span> 的空文件夹而 <span class="string">"/a"</span> 没有。</span><br><span class="line">注意，<span class="string">"/a/z"</span> 和 <span class="string">"/b/z"</span> 不会被标记，因为相同子文件夹的集合必须是非空集合，但这两个文件夹都是空的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= paths.length &lt;= 2 * 104</code></li><li><code>1 &lt;= paths[i].length &lt;= 500</code></li><li><code>1 &lt;= paths[i][j].length &lt;= 10</code></li><li><code>1 &lt;= sum(paths[i][j].length) &lt;= 2 * 105</code></li><li><code>path[i][j]</code>由小写英文字母组成</li><li>不会存在两个路径都指向同一个文件夹的情况</li><li>对于不在根层级的任意文件夹，其父文件夹也会包含在输入中</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/delete-duplicate-folders-in-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-duplicate-folders-in-system</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + hash</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>如果了解了题目的本意本题应该不是很难，难点在于如何序列化的编码表示一颗多叉树的子树，在此时处理中我们字符串来表示一棵二叉树，用递归来处理，假设以<code>root</code>为根的节点的多叉树的子树的字符串表示分别为$[s_{1},s_{2},s_{3},…,s{k}]$,根节点的关键字为$val$,我们编码如下：</li></ol><ul><li>以<code>root</code>为根节点的所有的子树且不包含<code>root</code>的字符串编码依次以用<code>,</code>进行相连，编码表示为:<script type="math/tex; mode=display">s_{1} , s_{2} , s_{3} .... ,s{k}</script></li><li><ul><li>以<code>root</code>为根节点的所有的子树且包含<code>root</code>的字符串编码依次以用<code>.</code>进行相连，<code>root</code>节点且包含<code>root</code>节点的子树编码表示为:<script type="math/tex; mode=display">val．s_{1}，s_{2}，s_{3} ....，s{k}</script>采用以上编码即可唯一的标识一颗多叉树，关键一点记住所有的孩子节点都按照字典序进行排序。这样可以防止乱序，但是节点还是相等。这种编码很简单，但是感觉容易出效率问题，最好还是老老实实用字符串<code>hash</code>这种快速的映射方法。</li></ul></li></ul><ol><li>我们首先读取所有的<code>path</code>，然后按照顺序进行建立二叉树；我们第一遍用<code>dfs</code>遍历二叉树，可以得到所有子树的字符串编码，此时我们进行判断，判定子树的字符串编码是否已经存在，如果已经存在，我们则认为当前根结点可以设置为待删除节点，如果不存在则我们更新字典库；最后一次<code>dfs</code>时，我们判断当前节点是否被标记，如果已经被标记，则我们直接跳过即可，依次即可得到最终去重后的树的遍历结果。</li><li>算法时间复杂度为$O(2N + NlgN)$,空间复杂度为$O(N)$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> val;</span><br><span class="line">    <span class="keyword">bool</span> valid;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,Node *&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertTree</span><span class="params">(Node * root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; path)</span></span>&#123;</span><br><span class="line">        Node * node = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;child.count(path[i]))&#123;</span><br><span class="line">                node-&gt;child[path[i]] = <span class="keyword">new</span> Node();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;child[path[i]];</span><br><span class="line">            node-&gt;val = path[i];</span><br><span class="line">            node-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">dfs1</span><span class="params">(Node * root,<span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; &amp; key)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> stree;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;child.size() == <span class="number">0</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            stree += dfs1(v.second,key) + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key.count(stree)) &#123;</span><br><span class="line">            root-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">            key[stree]-&gt;valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            key[stree] = root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="string">"."</span> + stree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(Node *root,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; curr,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;valid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : root-&gt;child)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second-&gt;valid)&#123;</span><br><span class="line">                curr.push_back(v.first);</span><br><span class="line">                res.push_back(curr);</span><br><span class="line">                dfs2(v.second,curr,res);</span><br><span class="line">                curr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; deleteDuplicateFolder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = paths.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,Node *&gt; key;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; arr;</span><br><span class="line">       </span><br><span class="line">        Node * root = <span class="keyword">new</span> Node(); </span><br><span class="line">        root-&gt;val = <span class="string">""</span>;</span><br><span class="line">        root-&gt;valid = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            insertTree(root,paths[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs1(root,key);</span><br><span class="line">        dfs2(root,arr,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-251&quot;&gt;&lt;a href=&quot;#leetcode-contest-251&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest 251&quot;&gt;&lt;/a&gt;leetcode  contest 251&lt;/h1&gt;&lt;p&gt;周赛的题目质量依然很好，最后一题还是依靠自己的思考给解出来了，感觉这才是值得自己思考的地方，叶看到了自己的进步。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/2xsDzHhLZqYRyJG.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5823-字符串转化后的各位数字之和&quot;&gt;&lt;a href=&quot;#5823-字符串转化后的各位数字之和&quot; class=&quot;headerlink&quot; title=&quot;5823. 字符串转化后的各位数字之和&quot;&gt;&lt;/a&gt;5823. 字符串转化后的各位数字之和&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由小写字母组成的字符串 &lt;code&gt;s&lt;/code&gt;，以及一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;首先，用字母在字母表中的位置替换该字母，将 s 转化 为一个整数（也就是，’a’ 用 1 替换，’b’ 用 2 替换，… ‘z’ 用 26 替换）。接着，将整数 转换 为其 各位数字之和 。共重复 转换 操作 k 次 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Biweekly Contest 57</title>
    <link href="http://yoursite.com/2021/07/24/308/"/>
    <id>http://yoursite.com/2021/07/24/308/</id>
    <published>2021-07-24T15:36:28.653Z</published>
    <updated>2021-07-24T16:11:12.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-biweekly-contest-57"><a href="#leetcode-biweekly-contest-57" class="headerlink" title="leetcode  biweekly contest 57"></a>leetcode  biweekly contest 57</h1><p>双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。<br><img src="https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png" alt></p><h2 id="5804-检查是否所有字符出现次数相同"><a href="#5804-检查是否所有字符出现次数相同" class="headerlink" title="5804. 检查是否所有字符出现次数相同"></a>5804. 检查是否所有字符出现次数相同</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，如果 <code>s</code>是一个 好 字符串，请你返回<code>true</code>，否则请返回 <code>false</code>。</p><p>如果 <code>s</code> 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 <code>s</code>是 好 字符串。</p><a id="more"></a><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abacbc"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span>，<span class="string">'b'</span> 和 <span class="string">'c'</span> 。s 中所有字符均出现 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabb"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：s 中出现过的字符为 <span class="string">'a'</span> 和 <span class="string">'b'</span> 。</span><br><span class="line"><span class="string">'a'</span> 出现了 <span class="number">3</span> 次，<span class="string">'b'</span> 出现了 <span class="number">2</span> 次，两者出现次数不同。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= s.length &lt;= <span class="number">1000</span>`</span><br><span class="line">+ `s` 只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址 </span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-number-of-words-you-can-type</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;   暴力检测</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 统计字符串中所有字符的个数即可得到结果。</span><br><span class="line"><span class="number">2.</span> 算法时间复杂度为$O(n)$,空间复杂度为$O(<span class="number">26</span>)$.</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> areOccurrencesEqual(<span class="keyword">string</span> s) &#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(auto c : s) cnt[c]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(auto v : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v.second != x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5805-最小未被占据椅子的编号"><a href="#5805-最小未被占据椅子的编号" class="headerlink" title="5805. 最小未被占据椅子的编号"></a>5805. 最小未被占据椅子的编号</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 n 个朋友在举办一个派对，这些朋友从 <code>0</code> 到 <code>n - 1</code>编号。派对里有 无数 张椅子，编号为 0 到<code>infinity</code>。当一个朋友到达派对时，他会占据 编号最小 且未被占据的椅子。</p><p>比方说，当一个朋友到达时，如果椅子 <code>0</code> ，<code>1</code>和 <code>5</code>被占据了，那么他会占据 2 号椅子。<br>当一个朋友离开派对时，他的椅子会立刻变成未占据状态。如果同一时刻有另一个朋友到达，可以立即占据这张椅子。</p><p>给你一个下标从 0 开始的二维整数数组 <code>times</code>，其中<code>times[i] = [arrivali, leavingi]</code>表示第 i 个朋友到达和离开的时刻，同时给你一个整数 targetFriend 。所有到达时间 互不相同 。</p><p>请你返回编号为 <code>targetFriend</code> 的朋友占据的 椅子编号 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">6</span>]], targetFriend = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">3</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">4</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">4</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">朋友 <span class="number">1</span> 占据椅子 <span class="number">1</span> ，所以返回 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">输入：times = [[<span class="number">3</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">6</span>]], targetFriend = <span class="number">0</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">1</span> 到达，占据椅子 <span class="number">0</span> 。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">2</span> 到达，占据椅子 <span class="number">1</span> 。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">3</span> 到达，占据椅子 <span class="number">2</span> 。</span><br><span class="line">- 朋友 <span class="number">1</span> 时刻 <span class="number">5</span> 离开，椅子 <span class="number">0</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">2</span> 时刻 <span class="number">6</span> 离开，椅子 <span class="number">1</span> 变成未占据。</span><br><span class="line">- 朋友 <span class="number">0</span> 时刻 <span class="number">10</span> 离开，椅子 <span class="number">2</span> 变成未占据。</span><br><span class="line">朋友 <span class="number">0</span> 占据椅子 <span class="number">2</span> ，所以返回 <span class="number">2</span> 。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == times.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">104</span>`</span><br><span class="line">+ `times[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= arrivali &lt; leavingi &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= targetFriend &lt;= n - <span class="number">1</span>`</span><br><span class="line">+ 每个 `arrivali` 时刻 互不相同 。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心 + 优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 仔细观察题目，基本就是套路的优先级队列，我们设两个优先级队列，队列`<span class="number">1</span>`保存当前空闲的椅子的编号，并按照标号从小到大排列我们每次可以从队列中取得标号最小的椅子；队列`<span class="number">2</span>`保存当前已经已经占用的椅子的标号，按照椅子释放的时间先后进行排序，我们每次可以取得当前最近会被释放的椅子的编号。</span><br><span class="line"><span class="number">2.</span> 我们首先将所有的朋友按照到达时间的先后进行排序，每次排序完成后，我们每次从队列`<span class="number">1</span>`中取椅子之前，首先将队列`<span class="number">2</span>`中所有释放时间小于等于当前达到时间的椅子全部出队列，并将这些已经释放椅子的编号放入到队列`<span class="number">1</span>`中；然后我们再从队列中取出编号最小的椅子，同时将该椅子的释放时间进入到队列`<span class="number">2</span>`中。按照如上贪心算法即可得到最优结果。</span><br><span class="line"><span class="number">3.</span> 算法时间复杂度为$O(<span class="number">2</span>*(n + nlgn))$,空间复杂度为$O(<span class="number">2</span>n)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    <span class="built_in">bool</span> operator()(pii &amp; a,pii &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> smallestChair(vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt;&amp; times, <span class="built_in">int</span> targetFriend) &#123;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="built_in">int</span>,vector&lt;<span class="built_in">int</span>&gt;,greater&lt;<span class="built_in">int</span>&gt;&gt; pq1;</span><br><span class="line">        priority_queue&lt;pii,vector&lt;pii&gt;,cmp&gt; pq2;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">int</span> n = times.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            times[i].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(times.begin(),times.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) pq1.push(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq2.empty() &amp;&amp; pq2.top().first &lt;= times[i][<span class="number">0</span>])&#123;</span><br><span class="line">                pq1.push(pq2.top().second);</span><br><span class="line">                pq2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> x = pq1.top();</span><br><span class="line">            <span class="keyword">if</span>(targetFriend == times[i][<span class="number">2</span>]) ans = x;</span><br><span class="line">            pq1.pop();</span><br><span class="line">            pq2.push(make_pair(times[i][<span class="number">1</span>],x));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5806-描述绘画结果"><a href="#5806-描述绘画结果" class="headerlink" title="5806. 描述绘画结果"></a>5806. 描述绘画结果</h2><p>给你一个细长的画，用数轴表示。这幅画由若干有重叠的线段表示，每个线段有 独一无二 的颜色。给你二维整数数组<code>segments</code>，其中 <code>segments[i] = [starti, endi, colori]</code>表示线段为 半开区间 <code>[starti, endi)</code>且颜色为 <code>colori</code> 。</p><p>线段间重叠部分的颜色会被 混合 。如果有两种或者更多颜色混合时，它们会形成一种新的颜色，用一个 集合 表示这个混合颜色。</p><p>比方说，如果颜色 2 ，4 和 6 被混合，那么结果颜色为 <code>{2,4,6}</code>。<br>为了简化题目，你不需要输出整个集合，只需要用集合中所有元素的 和 来表示颜色集合。</p><p>你想要用 最少数目 不重叠 半开区间 来 表示 这幅混合颜色的画。这些线段可以用二维数组 <code>painting</code>表示，其中<code>painting[j] = [leftj, rightj, mixj]</code> 表示一个 半开区间<code>[leftj, rightj)</code> 的颜色 和 为 <code>mixj</code> 。</p><p>比方说，这幅画由 <code>segments = [[1,4,5],[1,7,7]]</code>组成，那么它可以表示为 <code>painting = [[1,4,12],[4,7,7]]</code> ，因为：<br>[1,4) 由颜色 {5,7} 组成（和为 12），分别来自第一个线段和第二个线段。<br>[4,7) 由颜色 {7} 组成，来自第二个线段。<br>请你返回二维数组<code>painting</code>，它表示最终绘画的结果（没有 被涂色的部分不出现在结果中）。你可以按 任意顺序 返回最终数组的结果。</p><p>半开区间 <code>[a, b)</code> 是数轴上点 <code>a</code>和点<code>b</code>之间的部分，包含 点 a 且 不包含 点 b 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">7</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">14</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">16</span>]]</span><br><span class="line">解释：绘画借故偶可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">9</span>&#125; （和为 <span class="number">14</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">7</span>,<span class="number">9</span>&#125; （和为 <span class="number">16</span>），分别来自第二和第三个线段。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">6</span>,<span class="number">9</span>],[<span class="number">6</span>,<span class="number">7</span>,<span class="number">24</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">15</span>],[<span class="number">8</span>,<span class="number">10</span>,<span class="number">7</span>]]</span><br><span class="line">解释：绘画结果可以以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">6</span>) 颜色为 <span class="number">9</span> ，来自第一个线段。</span><br><span class="line">- [<span class="number">6</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">9</span>,<span class="number">15</span>&#125; （和为 <span class="number">24</span>），来自第一和第二个线段。</span><br><span class="line">- [<span class="number">7</span>,<span class="number">8</span>) 颜色为 <span class="number">15</span> ，来自第二个线段。</span><br><span class="line">- [<span class="number">8</span>,<span class="number">10</span>) 颜色为 <span class="number">7</span> ，来自第三个线段。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：segments = [[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[[<span class="number">1</span>,<span class="number">4</span>,<span class="number">12</span>],[<span class="number">4</span>,<span class="number">7</span>,<span class="number">12</span>]]</span><br><span class="line">解释：绘画结果可以表示为：</span><br><span class="line">- [<span class="number">1</span>,<span class="number">4</span>) 颜色为 &#123;<span class="number">5</span>,<span class="number">7</span>&#125; （和为 <span class="number">12</span>），分别来自第一和第二个线段。</span><br><span class="line">- [<span class="number">4</span>,<span class="number">7</span>) 颜色为 &#123;<span class="number">1</span>,<span class="number">11</span>&#125; （和为 <span class="number">12</span>），分别来自第三和第四个线段。</span><br><span class="line">注意，只返回一个单独的线段 [<span class="number">1</span>,<span class="number">7</span>) 是不正确的，因为混合颜色的集合不相同。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= segments.length &lt;= 2 * 104</code></li><li><code>segments[i].length == 3</code></li><li><code>1 &lt;= starti &lt; endi &lt;= 105</code></li><li><code>1 &lt;= colori &lt;= 109</code></li><li>每种颜色 <code>colori</code>互不相同。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的差分数组题目。感觉看到类似的线段区间的题目基本上都可以用差分数组搞定。跟求区间内重合的线段的次数基本上一样的题目。</li><li>我们将区间进行标记，对于区间的左端点则标记为$colori$,区间的右端点标记为$-colori$,当我们到达一个新的区间的左端点时，则此时和肯定会增加，在区间右端点时则减去该线段的贡献。基本上就是套路题目吧。</li><li>因为用了<code>map</code>，所以时间复杂度为$O(nlg)$，用数组的话时间复杂度可以优化到$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; splitPainting(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; segments) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = segments.size();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            cnt[segments[i][<span class="number">0</span>]].push_back(segments[i][<span class="number">2</span>]);</span><br><span class="line">            cnt[segments[i][<span class="number">1</span>]].push_back(-segments[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">            l = r;</span><br><span class="line">            r = v.first;</span><br><span class="line">            <span class="keyword">if</span>(l &gt; <span class="number">0</span> &amp;&amp; sum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr = &#123;l,r,sum&#125;;</span><br><span class="line">                ans.push_back(arr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : v.second)&#123;</span><br><span class="line">                sum += x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5196-队列中可以看到的人数"><a href="#5196-队列中可以看到的人数" class="headerlink" title="5196. 队列中可以看到的人数"></a>5196. 队列中可以看到的人数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有 <code>n</code> 个人排成一个队列，从左到右 编号为 0 到 <code>n - 1</code>。给你以一个整数数组 <code>heights</code> ，每个整数 互不相同，<code>heights[i]</code> 表示第 i 个人的高度。</p><p>一个人能 看到 他右边另一个人的条件是这两人之间的所有人都比他们两人 矮 。更正式的，第 i 个人能看到第 j 个人的条件是 <code>i &lt; j</code> 且<code>min(heights[i], heights[j]) &gt; max(heights[i+1], heights[i+2], ..., heights[j-1])</code>。</p><p>请你返回一个长度为 n 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 i 个人在他右侧队列中能 看到 的 人数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">10</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">9</span>]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 个人能看到编号为 <span class="number">1</span> ，<span class="number">2</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">1</span> 个人能看到编号为 <span class="number">2</span> 的人。</span><br><span class="line">第 <span class="number">2</span> 个人能看到编号为 <span class="number">3</span> 和 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">3</span> 个人能看到编号为 <span class="number">4</span> 的人。</span><br><span class="line">第 <span class="number">4</span> 个人能看到编号为 <span class="number">5</span> 的人。</span><br><span class="line">第 <span class="number">5</span> 个人谁也看不到因为他右边没人。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == heights.length`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= heights[i] &lt;= <span class="number">105</span>`</span><br><span class="line">+ `heights` 中所有数 互不相同 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-57/problems/number-of-visible-people-in-a-queue/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  单调栈</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 典型的单调栈，不过稍微复杂一点，需要稍微处理.由于我们用单调栈保存右边身高的人，并按照从小到大进行排列。我们每次将找到第一个大于等于当前的人的高度的人，则我们记数当前从队列中弹出的人数加`<span class="number">1</span>`即为可以看见的人数。比赛的时候竟然很搓的二分查找搞定。</span><br><span class="line"><span class="number">2.</span> 时间复杂度为$O(N)$,空间复杂为$O(N)$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; canSeePersonsCount(vector&lt;<span class="built_in">int</span>&gt;&amp; heights) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = heights.size();</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; ans(n);</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        arr.push_back(heights[n<span class="number">-1</span>]);</span><br><span class="line">        ans[n<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!arr.empty() &amp;&amp; heights[i] &gt;= arr.back())&#123;</span><br><span class="line">                ans[i]++;</span><br><span class="line">                arr.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!arr.empty()) ans[i]++;</span><br><span class="line">            arr.push_back(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-biweekly-contest-57&quot;&gt;&lt;a href=&quot;#leetcode-biweekly-contest-57&quot; class=&quot;headerlink&quot; title=&quot;leetcode  biweekly contest 57&quot;&gt;&lt;/a&gt;leetcode  biweekly contest 57&lt;/h1&gt;&lt;p&gt;双周赛的题目还是简单啊，基本上思路都不是很复杂，又AK了一次。整体思路不是很难。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/25/myIAJqo7MT16ZB3.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5804-检查是否所有字符出现次数相同&quot;&gt;&lt;a href=&quot;#5804-检查是否所有字符出现次数相同&quot; class=&quot;headerlink&quot; title=&quot;5804. 检查是否所有字符出现次数相同&quot;&gt;&lt;/a&gt;5804. 检查是否所有字符出现次数相同&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，如果 &lt;code&gt;s&lt;/code&gt;是一个 好 字符串，请你返回&lt;code&gt;true&lt;/code&gt;，否则请返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;如果 &lt;code&gt;s&lt;/code&gt; 中出现过的 所有 字符的出现次数 相同 ，那么我们称字符串 &lt;code&gt;s&lt;/code&gt;是 好 字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 250</title>
    <link href="http://yoursite.com/2021/07/18/307/"/>
    <id>http://yoursite.com/2021/07/18/307/</id>
    <published>2021-07-18T06:22:38.780Z</published>
    <updated>2021-07-18T11:48:23.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-250"><a href="#leetcode-contest-250" class="headerlink" title="leetcode  contest  250"></a>leetcode  contest  250</h1><p>周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。<br><img src="https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png" alt></p><h2 id="5161-可以输入的最大单词数"><a href="#5161-可以输入的最大单词数" class="headerlink" title="5161. 可以输入的最大单词数"></a>5161. 可以输入的最大单词数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。</p><p>给你一个由若干单词组成的字符串 <code>text</code> ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 <code>brokenLetters</code> ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 <code>text</code> 中单词的数目。</p><a id="more"></a><p>示例 1：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"hello world"</span>, brokenLetters = <span class="string">"ad"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"world"</span> ，因为字母键 <span class="string">'d'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"lt"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：无法输入 <span class="string">"leet"</span> ，因为字母键 <span class="string">'l'</span> 和 <span class="string">'t'</span> 已损坏。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leet code"</span>, brokenLetters = <span class="string">"e"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：无法输入任何单词，因为字母键 <span class="string">'e'</span> 已损坏。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 104</code></li><li><code>0 &lt;= brokenLetters.length &lt;= 26</code></li><li><code>text</code> 由若干用单个空格分隔的单词组成，且不含任何前导和尾随空格</li><li>每个单词仅由小写英文字母组成</li><li><code>brokenLetters</code> 由 互不相同 的小写英文字母组成</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-words-you-can-type</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力检测</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>通过split函数分离出单词，然后依次检验每个单词是否合法即可统计出合法的单词数目。</li><li>算法时间复杂度为$O(n)$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">string</span> &amp; str)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.size())&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] == <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = i;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; curr)&#123;</span><br><span class="line">                ans.push_back(str.substr(curr,i-curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canBeTypedWords</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> brokenLetters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; valid(<span class="number">26</span>,<span class="literal">true</span>);        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curr = split(text);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : brokenLetters)&#123;</span><br><span class="line">            valid[c-<span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!valid[curr[i][j]-<span class="string">'a'</span>]) &#123;</span><br><span class="line">                    isValid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5814-新增的最少台阶数"><a href="#5814-新增的最少台阶数" class="headerlink" title="5814. 新增的最少台阶数"></a>5814. 新增的最少台阶数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格递增 的整数数组 <code>rungs</code> ，用于表示梯子上每一台阶的 高度 。当前你正站在高度为 0 的地板上，并打算爬到最后一个台阶。</p><p>另给你一个整数 <code>dist</code> 。每次移动中，你可以到达下一个距离你当前位置（地板或台阶）不超过 <code>dist</code> 高度的台阶。当然，你也可以在任何正 整数 高度处插入尚不存在的新台阶。</p><p>返回爬到最后一阶时必须添加到梯子上的 最少 台阶数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">10</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">现在无法到达最后一阶。</span><br><span class="line">在高度为 <span class="number">7</span> 和 <span class="number">8</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">10</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>], dist = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：</span><br><span class="line">这个梯子无需增设新台阶也可以爬上去。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], dist = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">现在无法从地板到达梯子的第一阶。 </span><br><span class="line">在高度为 <span class="number">1</span> 的位置增设新的台阶，以爬上梯子。 </span><br><span class="line">梯子在高度为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>] 的位置上有台阶。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：rungs = [<span class="number">5</span>], dist = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：这个梯子无需增设新台阶也可以爬上去。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs.length &lt;= <span class="number">105</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= rungs[i] &lt;= <span class="number">109</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= dist &lt;= <span class="number">109</span>`</span><br><span class="line">+ `rungs` 严格递增</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/add-minimum-number-of-rungs</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  贪心算法</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 直接模拟即可，题目要求两个台阶的高度不超过`dist`，则我们可以知道根据贪心算法，我们应该尽可能的跨向高度更高的梯子，$x$与$y$两者之间所需要加的梯子即为向下取整即可，$\frac&#123;y-x<span class="number">-1</span>&#125;&#123;dist&#125;$.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> addRungs(vector&lt;<span class="built_in">int</span>&gt;&amp; rungs, <span class="built_in">int</span> dist) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = rungs.size();</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans += (rungs[i] - h <span class="number">-1</span>)/dist;</span><br><span class="line">            h = rungs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5815-扣分后的最大得分"><a href="#5815-扣分后的最大得分" class="headerlink" title="5815. 扣分后的最大得分"></a>5815. 扣分后的最大得分</h2><p>给你一个 <code>m x n</code>的整数矩阵 <code>points</code> （下标从 0 开始）。一开始你的得分为 0 ，你想最大化从矩阵中得到的分数。</p><p>你的得分方式为：每一行 中选取一个格子，选中坐标为 <code>(r, c)</code>的格子会给你的总得分 增加 <code>points[r][c]</code> 。</p><p>然而，相邻行之间被选中的格子如果隔得太远，你会失去一些得分。对于相邻行 <code>r</code>和 <code>r + 1</code> （其中 <code>0 &lt;= r &lt; m - 1</code>），选中坐标为 <code>(r, c1)</code>和 <code>(r + 1, c2)</code>的格子，你的总得分 减少 <code>abs(c1 - c2)</code>。</p><p>请你返回你能得到的 最大 得分。</p><p><code>abs(x)</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code>，那么值为 <code>x</code> 。</li><li>如果 <code>x &lt; 0</code> ，那么值为 <code>-x</code> 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">2</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">3</span> + <span class="number">5</span> + <span class="number">3</span> = <span class="number">11</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">2</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">2</span> 。</span><br><span class="line">你的最终得分为 <span class="number">11</span> - <span class="number">2</span> = <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：</span><br><span class="line">蓝色格子是最优方案选中的格子，坐标分别为 (<span class="number">0</span>, <span class="number">1</span>)，(<span class="number">1</span>, <span class="number">1</span>) 和 (<span class="number">2</span>, <span class="number">0</span>) 。</span><br><span class="line">你的总得分增加 <span class="number">5</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">12</span> 。</span><br><span class="line">但是你的总得分需要扣除 abs(<span class="number">1</span> - <span class="number">1</span>) + abs(<span class="number">1</span> - <span class="number">0</span>) = <span class="number">1</span> 。</span><br><span class="line">你的最终得分为 <span class="number">12</span> - <span class="number">1</span> = <span class="number">11</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == points.length</code></li><li><code>n == points[r].length</code></li><li><code>1 &lt;= m, n &lt;= 105</code></li><li><code>1 &lt;= m * n &lt;= 105</code></li><li><code>0 &lt;= points[r][c] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-points-with-cost</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划<code>dp</code>，我们如果直接利用动态规划转移方程，则会超时，时间复杂度为$O(m*n^{2})$,应该如何优化利用前缀，我们可以知道递推公式为:<script type="math/tex; mode=display">dp[i][j] = max(dp[i][j],max(dp[i-1][k] - k) + points[i][j]) \quad (k\le j) \\dp[i][j] = max(dp[i][j],max(dp[i-1][k] - (n-1-k)) + points[i][j]) \quad (k\ge j) \\</script></li><li>我们利用前缀，可以快速的求出前<code>k</code>项中的$(dp[i-1][k] - k)$的最大值，同时可以利用后缀快速的求出后$n-k$项中的$dp[i-1][k] - (n-1-k)$的最大值。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$O(n)$.比赛中竟然用了坑爹的线段树，快速的把这个题搞定，还是没有仔细思考到点，本来是很简单的题目,线段树只能说真心是利器什么题目都可以搞定。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(col,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(col,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            maxCurr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                maxCurr = max(maxCurr,dp[j]);</span><br><span class="line">                ndp[j] = max(ndp[j],maxCurr + points[i][j]);</span><br><span class="line">                maxCurr--;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *max_element(dp.begin(),dp.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line">segTreeNode tree[MAXN*<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="keyword">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lmax = tree[CHL(idx)].val + tree[CHL(idx)].add;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> rmax = tree[CHR(idx)].val + tree[CHR(idx)].add;</span><br><span class="line">    tree[idx].val = max(lmax,rmax);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp; arr)</span></span>&#123;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].l = l;</span><br><span class="line">        tree[idx].r = r;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    buildTree(CHL(idx),l,mid,arr);</span><br><span class="line">    buildTree(CHR(idx),mid+<span class="number">1</span>,r,arr);</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">addTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt; l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r)&#123;</span><br><span class="line">        tree[idx].add += val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        addTree(CHL(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        addTree(CHR(idx),l,r,val);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        addTree(CHL(idx),l,mid,val);</span><br><span class="line">        addTree(CHR(idx),mid+<span class="number">1</span>,r,val);</span><br><span class="line">    &#125;</span><br><span class="line">    pushUpTree(idx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTree</span><span class="params">(<span class="keyword">int</span> idx,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l &gt;= l &amp;&amp; tree[idx].r &lt;= r) <span class="keyword">return</span> tree[idx].val + tree[idx].add;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHL(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> queryTree(CHR(idx),l,r);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> lmax = queryTree(CHL(idx),l,mid);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> rmax = queryTree(CHR(idx),mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> max(lmax,rmax) + tree[idx].add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">maxPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = points.size();</span><br><span class="line">        <span class="keyword">int</span> col = points[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = points[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; curr = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                curr[j] -= j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(tree,<span class="number">0</span>,col*<span class="number">4</span>);</span><br><span class="line">            buildTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>,curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                dp[i][j] = queryTree(<span class="number">1</span>,<span class="number">0</span>,col<span class="number">-1</span>) + points[i][j];</span><br><span class="line">                addTree(<span class="number">1</span>,<span class="number">0</span>,j,<span class="number">-1</span>);</span><br><span class="line">                addTree(<span class="number">1</span>,j+<span class="number">1</span>,col<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            ans = max(ans,dp[row<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5816-查询最大基因差"><a href="#5816-查询最大基因差" class="headerlink" title="5816. 查询最大基因差"></a>5816. 查询最大基因差</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵 n 个节点的有根树，节点编号从 <code>0</code> 到 <code>n - 1</code>。每个节点的编号表示这个节点的 独一无二的基因值 （也就是说节点<code>x</code> 的基因值为 x）。两个基因值的 基因差 是两者的 异或和 。给你整数数组 <code>parents</code>，其中 <code>parents[i]</code>是节点 i 的父节点。如果节点 x 是树的 根 ，那么 <code>parents[x] == -1</code> 。</p><p>给你查询数组<code>queries</code> ，其中 <code>queries[i] = [nodei, vali]</code> 。对于查询<code>i</code>，请你找到 <code>vali</code> 和 <code>pi</code> 的 最大基因差 ，其中 <code>pi</code> 是节点<code>nodei</code>到根之间的任意节点（包含 <code>nodei</code> 和根节点）。更正式的，你想要最大化 <code>vali XOR pi</code> 。</p><p>请你返回数组 <code>ans</code>，其中 <code>ans[i]</code> 是第 <code>i</code> 个查询的答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], queries = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">0</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">2</span> XOR <span class="number">0</span> = <span class="number">2</span> 。</span><br><span class="line">- [<span class="number">3</span>,<span class="number">2</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">2</span> XOR <span class="number">1</span> = <span class="number">3</span> 。</span><br><span class="line">- [<span class="number">2</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：parents = [<span class="number">3</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>], queries = [[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">15</span>],[<span class="number">0</span>,<span class="number">5</span>]]</span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">14</span>,<span class="number">7</span>]</span><br><span class="line">解释：查询数组处理如下：</span><br><span class="line">- [<span class="number">4</span>,<span class="number">6</span>]：最大基因差的对应节点为 <span class="number">0</span> ，基因差为 <span class="number">6</span> XOR <span class="number">0</span> = <span class="number">6</span> 。</span><br><span class="line">- [<span class="number">1</span>,<span class="number">15</span>]：最大基因差的对应节点为 <span class="number">1</span> ，基因差为 <span class="number">15</span> XOR <span class="number">1</span> = <span class="number">14</span> 。</span><br><span class="line">- [<span class="number">0</span>,<span class="number">5</span>]：最大基因差的对应节点为 <span class="number">2</span> ，基因差为 <span class="number">5</span> XOR <span class="number">2</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= parents.length &lt;= 105</code></li><li>对于每个 不是 根节点的 <code>i</code> ，有 <code>0 &lt;= parents[i] &lt;= parents.length - 1</code> 。</li><li><code>parents[root] == -1</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nodei &lt;= parents.length - 1</code></li><li><code>0 &lt;= vali &lt;= 2 * 105</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-genetic-difference-query" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-genetic-difference-query</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS + Trie树</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目类似的题目见过，跟<code>google kickstart 2021 roundB</code>的$D$题非常像，感觉难度并不是很大。并且基本上一看到求异或最大值的题目，基本上可以肯定是需要用<code>trie</code>树的结构的。</li><li>我们首先将所有的查询离线化处理，即保存当前节点的所有查询。我们通过从根节点开始<code>dfs</code>遍历，每遍历一个节点<code>x</code>，则我们将节点<code>x</code>的值加入到<code>trie</code>树中，当遍历到当前节点<code>node</code>时，我们利用<code>trie</code>树去查询，跟节点<code>node</code>相关的值$val$进行查询,我们利用<code>dfs</code>遍历，每退出一个节点<code>x</code>时，则将<code>x</code>从<code>trie</code>树中删除。</li><li>本题的难点在于如何从<code>trie</code>中删除一个值<code>val</code>，这时就需要一点技巧来处理，我们为每个<code>trie</code>节点增加一个<code>count</code>的值，利用<code>count</code>记录以当前节点为根的子数下存在有多少个值。我们每次在节点<code>node</code>下增加一个<code>val</code>时，则我们将<code>count + 1</code>;我们每次在节点<code>node</code>下删除一个<code>val</code>时，则我们将<code>count - 1</code>。如果发现<code>count = 0</code>则我们直接将该节点<code>node</code>从树中删除即可。</li><li>空间复杂度为$O((N + Q)*32)$,空间复杂度为$(N + Q + 2^{K})$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">31</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    TrieNode * next[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[idx])&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = val;</span><br><span class="line">    node-&gt;cnt++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eraseTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    node-&gt;cnt--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">        node-&gt;cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[idx]-&gt;cnt == <span class="number">0</span>)&#123;</span><br><span class="line">            node-&gt;next[idx] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchTrie</span><span class="params">(TrieNode * root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = MAXN; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = ((val&gt;&gt;i)&amp;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;next[<span class="number">1</span>^idx])&#123;</span><br><span class="line">            node = node-&gt;next[<span class="number">1</span>^idx];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node = node-&gt;next[idx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root,TrieNode * trie,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; graph,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; &amp; cnt,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(root))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y] : cnt[root])&#123;</span><br><span class="line">                ans[x] = y^searchTrie(trie,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[root])&#123;</span><br><span class="line">            insertTrie(trie,v);</span><br><span class="line">            dfs(v,trie,graph,cnt,ans);</span><br><span class="line">            eraseTrie(trie,v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxGeneticDifference(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; parents, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = parents.size();</span><br><span class="line">        <span class="keyword">int</span> m = queries.size();</span><br><span class="line">        <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); ++i)&#123;</span><br><span class="line">            cnt[queries[i][<span class="number">0</span>]].push_back(&#123;i,queries[i][<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parents[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">                root = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                graph[parents[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TrieNode * trie = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        insertTrie(trie,root);</span><br><span class="line">        dfs(root,trie,graph,cnt,ans);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-250&quot;&gt;&lt;a href=&quot;#leetcode-contest-250&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  250&quot;&gt;&lt;/a&gt;leetcode  contest  250&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，还是前3题，不过第三题竟然用了最复杂的线段树搞定。真心是。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/18/Jlbu3VOKG9SYHrE.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5161-可以输入的最大单词数&quot;&gt;&lt;a href=&quot;#5161-可以输入的最大单词数&quot; class=&quot;headerlink&quot; title=&quot;5161. 可以输入的最大单词数&quot;&gt;&lt;/a&gt;5161. 可以输入的最大单词数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;键盘出现了一些故障，有些字母键无法正常工作。而键盘上所有其他键都能够正常工作。&lt;/p&gt;&lt;p&gt;给你一个由若干单词组成的字符串 &lt;code&gt;text&lt;/code&gt; ，单词间由单个空格组成（不含前导和尾随空格）；另有一个字符串 &lt;code&gt;brokenLetters&lt;/code&gt; ，由所有已损坏的不同字母键组成，返回你可以使用此键盘完全输入的 &lt;code&gt;text&lt;/code&gt; 中单词的数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Kickstart】 Kickstart 2021 roundD</title>
    <link href="http://yoursite.com/2021/07/14/306/"/>
    <id>http://yoursite.com/2021/07/14/306/</id>
    <published>2021-07-14T14:28:50.732Z</published>
    <updated>2021-07-16T05:19:50.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kickstart-2021-roundD"><a href="#kickstart-2021-roundD" class="headerlink" title="kickstart 2021 roundD"></a>kickstart 2021 roundD</h1><p><code>kick start</code>的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。<br><img src="https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png" alt></p><h2 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a>Arithmetic Square</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png" alt></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813</a></p><a id="more"></a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>第一题比较简单，大意就是给定一个<code>3x3</code>的矩阵，求问修改最中间的数，使得上下和对角线的三个数字组成的等差序列最多。暴力尝试所有可能的等差数列即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; matrix(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">0</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">0</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">2</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">2</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">2</span>])) ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[a/<span class="number">2</span> + matrix[<span class="number">1</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> b = matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[b/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c = matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[c/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(d%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[d/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">2</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        curr = max(curr,v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += curr;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Cutting-Intervals"><a href="#Cutting-Intervals" class="headerlink" title="Cutting Intervals"></a>Cutting Intervals</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/r3pNfjUB9gtw6TE.png" alt></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 差分数组 + 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>给定一系列的二维空间中的线段，在限定的切割操作中，求问最多可以把这些线段切成多少段？</li><li>我们可以参考线段的切割情况如下：<br><img src="https://i.loli.net/2021/07/16/uNaOd3vMG4fDtXi.png" alt><br>我们可以看到可以利用查分数组，即可计算连续的区间内每切一次可以增加多少条线段，我们设区间$[x,y]$总共有<code>d</code>条线段重合，则我们首先可以知道在区间$[x+1,y-1]$我们每切割一次则可以增加<code>d</code>条线段，但在区间两个端点处需要特殊处理，我们此时需要判断在点$y$处需要特殊处理，因为端点处；我们首先讲可以进行切割的区间加入到待选队列中，并按照重合的次数进行排序。但是我们需要注意的是区间的右端点，需要将右端点为结束端点的线段去掉。<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">__</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">     </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">________</span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">——</span>|<span class="string">————————</span>|<span class="string">——</span>|<span class="string">        </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">  </span>|<span class="string">  </span>|<span class="string">        </span>|<span class="string">__</span>|<span class="string">________</span>|<span class="string">_____</span>|</span><br><span class="line">1  2  3        6  7        10    12</span><br></pre></td></tr></table></figure></li><li>如上图所示，我们可以看到在区间<code>[1,2]</code>之间只有1条线段重合，在区间<code>[2,3]</code>之间有两条线段重合，在区间<code>[3,6]</code>之间只有3条线段重合，<code>[6,7]</code>之间有3条线段重合，<code>[7,10]</code>之间有两条线段重合，<code>[10,12]</code>之间有两条线段重合。我们知道区间分布如下：</li></ol><ul><li><code>[1,2]</code>无法分割。</li><li><code>[2,3]</code>无法分割。</li><li><code>[3,6]</code>在<code>(4,5)</code>处每分割一次即可增加3个线段但在<code>6</code>处进行分割只能增加两条线段。</li><li><code>[7，10]</code>在(8,9)处分割每分割一次即可增加2个线段，但在<code>10</code>分割只能增加<code>1</code>个线段</li><li><code>[10,12]</code>在(11)处分割每分割一次即可增加<code>1</code>个线段，但在<code>12</code>处无法分割。</li></ul><ol><li>我们利用查分数组很快即可以计算出每个区间内重叠的线段的次数，并按照次数的大小进行排序即可，我们使用贪心策略，每次选取分割区间最大的点即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n,c;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; prev;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrl;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; arrr;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="comment">// 查分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l,r;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        prev[l]++;</span><br><span class="line">        prev[r]--;</span><br><span class="line">        arrl[l]++;</span><br><span class="line">        arrr[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录左端点与右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : prev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[curr] += v.first - left - <span class="number">1</span>;</span><br><span class="line">            arr[curr-arrr[v.first]]++;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心策略每次取切割可以得到的最大线段的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = arr.rbegin(); it != arr.rend(); it++)&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x = min(c,it-&gt;second);</span><br><span class="line">        ans += x*it-&gt;first;</span><br><span class="line">        c -= x;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="Final-Exam"><a href="#Final-Exam" class="headerlink" title="Final Exam"></a>Final Exam</h2><p><img src="https://i.loli.net/2021/07/14/UkblX734ZqG61JF.png" alt></p><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>感觉第三题要比第二题简单许多，就是一个典型的二分查找的应用即可。我们知道给定难度<code>P</code>,则我们知道绝对值最小值得点肯定在距离点<code>p</code>最近的两个区间，我们利用二分查找，查找距离点<code>p</code>最近的两个区间$[l_{1},r_{1}],[l_{2},r_{2}]$且满足$l_{1}\le r_{1}\le l_{2}\le r_{2}$，如果点<code>p</code>在区间$[l_{1},r_{1}]$范围内，则我们可以知道当前最小的绝对值为<code>0</code>，则我们将<code>p</code>从区间内取出，并将原有区间$[l_{1},r_{1}]$划分为两个新的区间$[l_{1},p-1],[p+1,r_{1}]$,并将这两个新的区间加入到待选序列中。<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">_____</span><span class="strong">___  |    __</span><span class="strong">_____</span><span class="emphasis">___</span></span><br><span class="line">[l1,r1]  p       [l2,r2]</span><br></pre></td></tr></table></figure></li><li>如果不在区间内，则肯定距离<code>p</code>最近的点要么为$r_{1},l_{2}$,则我们优先从这两个点中选择距离最近的点即可，假设$r_{1}$距离点<code>p</code>最近，则我们将$r_{1}$从区间内取出，然后再更新区间为$[l_{1},r_{1}-1]$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">map</span>&lt;LL,LL&gt; pb;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; arr = <span class="built_in">vector</span>&lt;LL&gt;(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LL a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        pb[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">auto</span> it = pb.lower_bound(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == pb.end())&#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans.push_back(it-&gt;first);</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            pb.erase(a);</span><br><span class="line">            a--;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= b) pb[a] = b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(it == pb.begin())&#123;</span><br><span class="line">                    ans.push_back(b);</span><br><span class="line">                    b++;</span><br><span class="line">                    pb.erase(a);</span><br><span class="line">                    <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    LL c = it-&gt;first;</span><br><span class="line">                    LL d = it-&gt;second;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-c) &gt; <span class="built_in">abs</span>(arr[i] - b))&#123;</span><br><span class="line">                        ans.push_back(b);</span><br><span class="line">                        b++;</span><br><span class="line">                        pb.erase(a);</span><br><span class="line">                        <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.push_back(c);</span><br><span class="line">                        pb.erase(c);</span><br><span class="line">                        c--;</span><br><span class="line">                        <span class="keyword">if</span>(d &lt;= c) pb[c] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(arr[i]);</span><br><span class="line">                LL c = arr[i] - <span class="number">1</span>;</span><br><span class="line">                LL d = arr[i] + <span class="number">1</span>;</span><br><span class="line">                pb.erase(a);</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= b) pb[c] = b;</span><br><span class="line">                <span class="keyword">if</span>(d &lt;= a) pb[a] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); ++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kickstart-2021-roundD&quot;&gt;&lt;a href=&quot;#kickstart-2021-roundD&quot; class=&quot;headerlink&quot; title=&quot;kickstart 2021 roundD&quot;&gt;&lt;/a&gt;kickstart 2021 roundD&lt;/h1&gt;&lt;p&gt;&lt;code&gt;kick start&lt;/code&gt;的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;Arithmetic-Square&quot;&gt;&lt;a href=&quot;#Arithmetic-Square&quot; class=&quot;headerlink&quot; title=&quot;Arithmetic Square&quot;&gt;&lt;/a&gt;Arithmetic Square&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png&quot; alt&gt;&lt;/p&gt;&lt;h3 id=&quot;地址&quot;&gt;&lt;a href=&quot;#地址&quot; class=&quot;headerlink&quot; title=&quot;地址&quot;&gt;&lt;/a&gt;地址&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/305/"/>
    <id>http://yoursite.com/2021/07/11/305/</id>
    <published>2021-07-11T15:54:04.710Z</published>
    <updated>2021-07-13T16:02:49.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>确实感觉看了别人的思路感觉非常简单，主要是记住有以下几点:</li></ol><ul><li>二叉树的根节点的值均不相同，如果存在值相同的根节点，则不可能构成二叉查找树。</li><li>二叉树的叶子节点的值均不相同，如果存在值相同的叶子节点，则不可能构成二叉查找树。</li><li>二叉树的根节点如果可以唯一可以在叶子节点中查找到，则该节点一定不是最终二叉树的根节点，因此我们需要过滤掉那些根节点在叶子节点集合中的二叉树，最终应该只剩下一棵二叉树，该二叉树的根节点即有可能为最终的根节点。</li></ul><ol><li>我们可以利用<code>bfs</code>来重建二叉树，检测是否所有的节点都被用到。然后我们利用中序遍历，遍历所有的节点的值即可，检测其是否按照从小到大的顺序排列。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            dfs(root-&gt;left,res);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            dfs(root-&gt;right,res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">canMerge</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode*&gt;&amp; trees)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,TreeNode *&gt; root;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; leaf;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; arr;</span><br><span class="line">        TreeNode * node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = trees.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = trees[i]-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(root.count(val)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            root[val] = trees[i];</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">int</span> lval = trees[i]-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(lval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(lval);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(trees[i]-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> rval = trees[i]-&gt;right-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(leaf.count(rval)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                leaf.insert(rval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the root</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v: root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!leaf.count(v.first))&#123;</span><br><span class="line">                arr.push_back(v.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr.size() != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode * ret = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.push(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            TreeNode * node = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            root.erase(node-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;left-&gt;val))&#123;</span><br><span class="line">                    node-&gt;left = root[node-&gt;left-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(root.count(node-&gt;right-&gt;val))&#123;</span><br><span class="line">                    node-&gt;right = root[node-&gt;right-&gt;val];</span><br><span class="line">                    qu.push(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!root.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        dfs(ret,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; res.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &lt;= res[i<span class="number">-1</span>]) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 249</title>
    <link href="http://yoursite.com/2021/07/11/304/"/>
    <id>http://yoursite.com/2021/07/11/304/</id>
    <published>2021-07-11T15:02:27.779Z</published>
    <updated>2021-07-11T15:52:01.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-249"><a href="#leetcode-contest-249" class="headerlink" title="leetcode  contest  249"></a>leetcode  contest  249</h1><p>周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。<br><img src="https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png" alt></p><h2 id="5808-数组串联"><a href="#5808-数组串联" class="headerlink" title="5808. 数组串联"></a>5808. 数组串联</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。请你构建一个长度为<code>2n</code>的答案数组<code>ans</code> ，数组下标 从 <code>0</code>开始计数 ，对于所有 <code>0 &lt;= i &lt; n</code>的 i ，满足下述所有要求：</p><a id="more"></a><ul><li><code>ans[i] == nums[i]</code></li><li><code>ans[i + n] == nums[i]</code><br>具体而言，<code>ans</code> 由两个 <code>nums</code> 数组 串联 形成。</li></ul><p>返回数组 <code>ans</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">解释：数组 ans 按下述方式形成：</span><br><span class="line">- ans = [nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>],nums[<span class="number">0</span>],nums[<span class="number">1</span>],nums[<span class="number">2</span>],nums[<span class="number">3</span>]]</span><br><span class="line">- ans = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/concatenation-of-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/concatenation-of-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测代码即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getConcatenation(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = nums;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5809-长度为-3-的不同回文子序列"><a href="#5809-长度为-3-的不同回文子序列" class="headerlink" title="5809. 长度为 3 的不同回文子序列"></a>5809. 长度为 3 的不同回文子序列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code> ，返回 <code>s</code> 中 长度为 3 的不同回文子序列 的个数。</p><p>即便存在多种方法来构建相同的子序列，但相同的子序列只计数一次。</p><p>回文 是正着读和反着读一样的字符串。</p><p>子序列 是由原字符串删除其中部分字符（也可以不删除）且不改变剩余字符之间相对顺序形成的一个新字符串。</p><p>例如，<code>&quot;ace&quot;</code> 是<code>&quot;abcde&quot;</code> 的一个子序列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabca"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的 <span class="number">3</span> 个回文子序列分别是：</span><br><span class="line">- <span class="string">"aba"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aaa"</span> (<span class="string">"aabca"</span> 的子序列)</span><br><span class="line">- <span class="string">"aca"</span> (<span class="string">"aabca"</span> 的子序列)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adc"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：<span class="string">"adc"</span> 不存在长度为 <span class="number">3</span> 的回文子序列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = "bbcbaba"</span><br><span class="line">输出：4</span><br><span class="line">解释：长度为 3 的 4 个回文子序列分别是：</span><br><span class="line">-<span class="ruby"> <span class="string">"bbb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bcb"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"bab"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br><span class="line"><span class="ruby">- <span class="string">"aba"</span> (<span class="string">"bbcbaba"</span> 的子序列)</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= s.length &lt;= 105</code></li><li><code>s</code>仅由小写英文字母组成</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-length-3-palindromic-subsequences</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的滑动窗口，我们设<code>left[i]</code>表示字符串索引从<code>0</code>到<code>i</code>截至时，所拥有的字符的状态，<code>right[i]</code>表示字符串索引从<code>i</code>到<code>n-1</code>截至时所拥有的字符的状态，我们用二进制位图表示字符的状态则我们可以知道前缀和后缀的递推公式如下：<script type="math/tex; mode=display">left[i] = left[i-1] | (1<<(s[i] - a)) \\right[i] = right[i+1] | (1<<(s[i] - a))</script></li><li>我们在判断是否存在字符串时，我们遍历当前位置<code>i</code>左右两边的位图，判断每一位是否左右都包含相同的字符。</li><li>我们可以用<code>hash</code>值来存储<code>3</code>位的字符串，算法时间复杂度为$O(26n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPalindromicSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>];</span><br><span class="line">            right[i] |= (<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        left[<span class="number">0</span>] = (<span class="number">1</span>&lt;&lt;(s[<span class="number">0</span>] - <span class="string">'a'</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((left[i<span class="number">-1</span>]&amp;(<span class="number">1</span>&lt;&lt;j))&amp;&amp;(right[i+<span class="number">1</span>]&amp;(<span class="number">1</span>&lt;&lt;j)))&#123;</span><br><span class="line">                    cnt.insert(j*<span class="number">26</span>*<span class="number">26</span> + (s[i]-<span class="string">'a'</span>)*<span class="number">26</span> + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>];</span><br><span class="line">            left[i] |=(<span class="number">1</span>&lt;&lt;(s[i] - <span class="string">'a'</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cnt.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5811-用三种不同颜色为网格涂色"><a href="#5811-用三种不同颜色为网格涂色" class="headerlink" title="5811. 用三种不同颜色为网格涂色"></a>5811. 用三种不同颜色为网格涂色</h2><p>给你两个整数 <code>m</code>和<code>n</code> 。构造一个 <code>m x n</code>的网格，其中每个单元格最开始是白色。请你用 红、绿、蓝 三种颜色为每个单元格涂色。所有单元格都需要被涂色。</p><p>涂色方案需要满足：不存在相邻两个单元格颜色相同的情况 。返回网格涂色的方法数。因为答案可能非常大， 返回 对 <code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：如上图所示，存在三种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">1</span>, n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：如上图所示，存在六种可能的涂色方案。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = <span class="number">5</span>, n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">580986</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 5</code></li><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors" target="_blank" rel="noopener">https://leetcode-cn.com/problems/painting-a-grid-with-three-different-colors</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划<code>dp</code>.</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的动态规划，此题跟力扣上某个题目很像，基本上是那个题目的改进版本即可，我们设$dp[i][state]$表示第<code>i</code>列的状态为<code>state</code>时所有的方案数。则我们可以知道第<code>i+1</code>列的状态其实只与第<code>i</code>列的状态有关，所有我们很容易想到<code>dp</code>。</li><li>首先我们做预处理，即计算处装$state_x$所表示的状态下，后一列有哪些状态能够与$state_x$可以兼容符合题目要求，这个其实非常简单，我们只需要遍历所有的状态组合即可，我们可以求处哪些状态能够兼容，这个计算过程非常简单，双层遍历即可。</li><li>我们可以利用<code>dp</code>的递推关系，如果状态$x$能够与状态$y$兼容，则我们可以知道如下递推公式:<script type="math/tex; mode=display">dp[i+1][y] = (dp[i+1][y] + dp[i][x])</script>根据递推公式则可以很快的计算出结果。</li><li>时间复杂度为$O(3^{2m} + O(n*3^{2m}))$,空间复杂度为$O(3^{2m} + n)$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">colorTheGrid</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="built_in">pow</span>(<span class="number">3</span>,m);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr2;</span><br><span class="line">                <span class="keyword">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> x = i;</span><br><span class="line">                <span class="keyword">int</span> y = j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    arr1.push_back(x%<span class="number">3</span>);</span><br><span class="line">                    arr2.push_back(y%<span class="number">3</span>);</span><br><span class="line">                    x = x/<span class="number">3</span>;</span><br><span class="line">                    y = y/<span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr1[k] == arr2[k]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; (arr1[k] == arr1[k<span class="number">-1</span>] || arr2[k] == arr2[k<span class="number">-1</span>]))&#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(isValid)&#123;</span><br><span class="line">                    next[i].push_back(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(mask);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : next)&#123;</span><br><span class="line">            dp[v.first] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ndp(mask);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mask; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[j])&#123;</span><br><span class="line">                        ndp[v] = (ndp[v] + dp[j])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = ndp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mask; ++i)&#123;</span><br><span class="line">            ans = (ans + dp[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5810-合并多棵二叉搜索树"><a href="#5810-合并多棵二叉搜索树" class="headerlink" title="5810. 合并多棵二叉搜索树"></a>5810. 合并多棵二叉搜索树</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个 二叉搜索树的根节点 ，存储在数组 <code>trees</code> 中（下标从 0 开始），对应 n 棵不同的二叉搜索树。<code>trees</code>中的每棵二叉搜索树 最多有 3 个节点 ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p><ul><li>选择两个 不同的 下标 <code>i</code>和 <code>j</code> ，要求满足在 <code>trees[i]</code>中的某个 叶节点 的值等于 <code>trees[j]</code>的 根节点的值 。</li><li>用 <code>trees[j]</code> 替换 <code>trees[i]</code>中的那个叶节点。</li><li>从 <code>trees</code> 中移除 <code>trees[j]</code>。<br>如果在执行<code>n - 1</code>次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 根节点 ；如果无法构造一棵有效的二叉搜索树，返回 <code>null</code> 。</li></ul><p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p><ul><li>任意节点的左子树中的值都 严格小于 此节点的值。</li><li>任意节点的右子树中的值都 严格大于 此节点的值。</li><li>叶节点是不含子节点的节点。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">第一步操作中，选出 i=<span class="number">1</span> 和 j=<span class="number">0</span> ，并将 trees[<span class="number">0</span>] 合并到 trees[<span class="number">1</span>] 中。</span><br><span class="line">删除 trees[<span class="number">0</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">在第二步操作中，选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">4</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">选出 i=<span class="number">0</span> 和 j=<span class="number">1</span> ，然后将 trees[<span class="number">1</span>] 合并到 trees[<span class="number">0</span>] 中。</span><br><span class="line">删除 trees[<span class="number">1</span>] ，trees = [[<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>]] 。</span><br><span class="line"></span><br><span class="line">结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 <span class="literal">null</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = <span class="string">[[5,4],[3]]</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：无法执行任何操作。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：trees = [[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">解释：trees 中只有一棵树，且这棵树已经是一棵有效的二叉搜索树，所以返回该树的根节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == trees.length</code></li><li><code>1 &lt;= n &lt;= 5 * 104</code></li><li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li><li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li><li>输入中的所有树都是 有效的二叉树搜索树 。</li><li><code>1 &lt;= TreeNode.val &lt;= 5 * 104</code>.</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-bsts-to-create-single-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-249&quot;&gt;&lt;a href=&quot;#leetcode-contest-249&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  249&quot;&gt;&lt;/a&gt;leetcode  contest  249&lt;/h1&gt;&lt;p&gt;周赛的题目质量还是非常高，不过还是依旧突破不了4题，感觉还是智商有限，天赋有限。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/RJ3xVv4MEG92Dsa.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5808-数组串联&quot;&gt;&lt;a href=&quot;#5808-数组串联&quot; class=&quot;headerlink&quot; title=&quot;5808. 数组串联&quot;&gt;&lt;/a&gt;5808. 数组串联&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;nums&lt;/code&gt; 。请你构建一个长度为&lt;code&gt;2n&lt;/code&gt;的答案数组&lt;code&gt;ans&lt;/code&gt; ，数组下标 从 &lt;code&gt;0&lt;/code&gt;开始计数 ，对于所有 &lt;code&gt;0 &amp;lt;= i &amp;lt; n&lt;/code&gt;的 i ，满足下述所有要求：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode Biweekly Contest 56</title>
    <link href="http://yoursite.com/2021/07/11/303/"/>
    <id>http://yoursite.com/2021/07/11/303/</id>
    <published>2021-07-10T23:53:28.496Z</published>
    <updated>2021-07-11T15:02:58.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-56"><a href="#leetcode-contest-56" class="headerlink" title="leetcode  contest  56"></a>leetcode  contest  56</h1><p>今天双周赛的第四题特别简单，就是典型的<code>dijistra</code>算法求最短距离即可，可惜的是第三题竟然没有做出来，智商捉急。<br><img src="https://i.loli.net/2021/07/11/4BXACGqyV56jPEW.png" alt></p><h2 id="5792-统计平方和三元组的数目"><a href="#5792-统计平方和三元组的数目" class="headerlink" title="5792. 统计平方和三元组的数目"></a>5792. 统计平方和三元组的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个 平方和三元组 <code>(a,b,c)</code> 指的是满足 <code>a2 + b2 = c2</code> 的 整数 三元组 <code>a，b</code> 和 <code>c</code>。</p><a id="more"></a><p>给你一个整数 <code>n</code>，请你返回满足 <code>1 &lt;= a, b, c &lt;= n</code>的 平方和三元组 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：平方和三元组为 (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) 和 (<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：平方和三元组为 (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)，(<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>)，(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>) 和 (<span class="number">8</span>,<span class="number">6</span>,<span class="number">10</span>) 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 250</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-square-sum-triples" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-square-sum-triples</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力检测即可，遍历所有可能的$a^{2} + b^{2}$,检测是否存在符合要求的$c$.</li><li>算法时间复杂度为$O(n^{2})$,空间复杂度为$O(n)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriples</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) curr.insert(i*i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = i*i + j*j;</span><br><span class="line">                <span class="keyword">if</span>(curr.count(x)) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5793-迷宫中离入口最近的出口"><a href="#5793-迷宫中离入口最近的出口" class="headerlink" title="5793. 迷宫中离入口最近的出口"></a>5793. 迷宫中离入口最近的出口</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m x n</code>的迷宫矩阵 <code>maze</code>（下标从 0 开始），矩阵中有空格子（用 ‘.’ 表示）和墙（用 ‘+’ 表示）。同时给你迷宫的入口 <code>entrance</code>，用 <code>entrance = [entrancerow, entrancecol]</code>表示你一开始所在格子的行和列。</p><p>每一步操作，你可以往 上，下，左 或者 右 移动一个格子。你不能进入墙所在的格子，你也不能离开迷宫。你的目标是找到离 <code>entrance</code>最近 的出口。出口 的含义是 maze 边界 上的 空格子。<code>entrance</code>格子 不算 出口。</p><p>请你返回从 <code>entrance</code>到最近出口的最短路径的 步数 ，如果不存在这样的路径，请你返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"."</span>,<span class="string">"+"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"+"</span>],[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"."</span>]], entrance = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个出口，分别位于 (<span class="number">1</span>,<span class="number">0</span>)，(<span class="number">0</span>,<span class="number">2</span>) 和 (<span class="number">2</span>,<span class="number">3</span>) 。</span><br><span class="line">一开始，你在入口格子 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">- 你可以往左移动 <span class="number">2</span> 步到达 (<span class="number">1</span>,<span class="number">0</span>) 。</span><br><span class="line">- 你可以往上移动 <span class="number">1</span> 步到达 (<span class="number">0</span>,<span class="number">2</span>) 。</span><br><span class="line">从入口处没法到达 (<span class="number">2</span>,<span class="number">3</span>) 。</span><br><span class="line">所以，最近的出口是 (<span class="number">0</span>,<span class="number">2</span>) ，距离为 <span class="number">1</span> 步。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"+"</span>,<span class="string">"+"</span>,<span class="string">"+"</span>]], entrance = [<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：迷宫中只有 <span class="number">1</span> 个出口，在 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">(<span class="number">1</span>,<span class="number">0</span>) 不算出口，因为它是入口格子。</span><br><span class="line">初始时，你在入口与格子 (<span class="number">1</span>,<span class="number">0</span>) 处。</span><br><span class="line">- 你可以往右移动 <span class="number">2</span> 步到达 (<span class="number">1</span>,<span class="number">2</span>) 处。</span><br><span class="line">所以，最近的出口为 (<span class="number">1</span>,<span class="number">2</span>) ，距离为 <span class="number">2</span> 步。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maze = [[<span class="string">"."</span>,<span class="string">"+"</span>]], entrance = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：这个迷宫中没有出口。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>maze.length == m</code></li><li><code>maze[i].length == n</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>maze[i][j]</code>要么是 ‘.’ ，要么是 ‘+’ 。</li><li><code>entrance.length == 2</code></li><li><code>0 &lt;= entrancerow &lt; m</code></li><li><code>0 &lt;= entrancecol &lt; n</code></li><li><code>entrance</code> 一定是空格子。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze" target="_blank" rel="noopener">https://leetcode-cn.com/problems/nearest-exit-from-entrance-in-maze</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的<code>BFS</code>即可，检测到边缘位置即返回即可。我们主要检测当前位置是否在边缘，判断条件为:<script type="math/tex; mode=display">x == 0 \quad or \quad x == row-1 \\y == 0 \quad or \quad y == col-1</script></li><li>时间复杂度为$O(m<em>n)$,空间复杂度为$O(m</em>n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">nearestExit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; entrance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = maze.size();</span><br><span class="line">        <span class="keyword">int</span> col = maze[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        qu.push(entrance[<span class="number">0</span>]*col + entrance[<span class="number">1</span>]);</span><br><span class="line">        visit[entrance[<span class="number">0</span>]][entrance[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = qu.front()/col;</span><br><span class="line">                <span class="keyword">int</span> y = qu.front()%col;</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="comment">/*check edge*/</span></span><br><span class="line">                <span class="keyword">if</span>(!(x == entrance[<span class="number">0</span>] &amp;&amp; y == entrance[<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x == <span class="number">0</span> || x == row<span class="number">-1</span> || y == <span class="number">0</span> || y == col<span class="number">-1</span>) <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + d[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> ny = y + d[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visit[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(maze[nx][ny] == <span class="string">'+'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.push(nx*col+ny);</span><br><span class="line">                    visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5794-求和游戏"><a href="#5794-求和游戏" class="headerlink" title="5794. 求和游戏"></a>5794. 求和游戏</h2><p><code>Alice</code> 和 <code>Bob</code> 玩一个游戏，两人轮流行动，<code>Alice</code> 先手 。</p><p>给你一个 偶数长度 的字符串 <code>num</code> ，每一个字符为数字字符或者 ‘?’ 。每一次操作中，如果 <code>num</code>中至少有一个 ‘?’ ，那么玩家可以执行以下操作：</p><p>选择一个下标 <code>i</code>满足 <code>num[i] == &#39;?&#39;</code> 。</p><ul><li>将 <code>num[i]</code> 用 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code> 之间的一个数字字符替代。</li><li>当 <code>num</code> 中没有 <code>&#39;?&#39;</code> 时，游戏结束。</li></ul><p><code>Bob</code> 获胜的条件是 <code>num</code> 中前一半数字的和 等于 后一半数字的和。<code>Alice</code> 获胜的条件是前一半的和与后一半的和 不相等 。</p><ul><li>比方说，游戏结束时 <code>num = &quot;243801&quot;</code> ，那么 <code>Bob</code> 获胜，因为 2+4+3 = 8+0+1 。如果游戏结束时 <code>num = &quot;243803&quot;</code> ，那么 Alice 获胜，因为 2+4+3 != 8+0+3 。<br>在 Alice 和 Bob 都采取 最优 策略的前提下，如果 Alice 获胜，请返回 true ，如果 Bob 获胜，请返回 false 。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"5023"</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：num 中没有 <span class="string">'?'</span> ，没法进行任何操作。</span><br><span class="line">前一半的和等于后一半的和：<span class="number">5</span> + <span class="number">0</span> = <span class="number">2</span> + <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"25??"</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：Alice 可以将两个 <span class="string">'?'</span> 中的一个替换为 <span class="string">'9'</span> ，Bob 无论如何都无法使前一半的和等于后一半的和。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">num</span> = <span class="string">"?3295???"</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：Bob 总是能赢。一种可能的结果是：</span><br><span class="line">- Alice 将第一个 <span class="string">'?'</span> 用 <span class="string">'9'</span> 替换。<span class="built_in">num</span> = <span class="string">"93295???"</span> 。</span><br><span class="line">- Bob 将后面一半中的一个 <span class="string">'?'</span> 替换为 <span class="string">'9'</span> 。<span class="built_in">num</span> = <span class="string">"932959??"</span> 。</span><br><span class="line">- Alice 将后面一半中的一个 <span class="string">'?'</span> 替换为 <span class="string">'2'</span> 。<span class="built_in">num</span> = <span class="string">"9329592?"</span> 。</span><br><span class="line">- Bob 将后面一半中最后一个 <span class="string">'?'</span> 替换为 <span class="string">'7'</span> 。<span class="built_in">num</span> = <span class="string">"93295927"</span> 。</span><br><span class="line">Bob 获胜，因为 <span class="number">9</span> + <span class="number">3</span> + <span class="number">2</span> + <span class="number">9</span> = <span class="number">5</span> + <span class="number">9</span> + <span class="number">2</span> + <span class="number">7</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= num.length &lt;= 105</code></li><li><code>num.length</code>是 偶数 。</li><li><code>num</code>只包含数字字符和 <code>&#39;?&#39;</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sum-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sum-game</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 奥数数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们可以知道假如<code>?</code>的个数为奇数，我们可以知道最后的选择权在<code>Alice</code>，则<code>ALICE</code>因为此时可以选择<code>0~9</code>，所以总可以选择一个数使得两端不相等。</li><li>我们知道最优策略，我们假设如果不管一端<code>ALICE</code>在问号中填写任何值，则<code>BOB</code>的最优策略也是在另一侧填入同样的值，在这种情况下，必然两边相等数量的问号会被消掉，我们假设左侧的问号的个数为$s_{1}$,右侧问号的个数为$s_{2}$,此时一共可以消掉$min(s_{2} ,s_{1})$个问号，这时肯定在右侧只剩下$abs(s_{2} - s_{1})$个问号,则此时这些剩余的括号中，每个人会选择替换$\frac{abs(s_{2} - s_{1})}{2}$次,则我们可以知道此时只有在一种情况下，可以保证<code>bob</code>达到的数目，即当<code>alice</code>选择替换为$x$时，则<code>bob</code>则选择替换为$9-x$，此时可以知道替换后增加的总数为$9<em>\frac{abs(s_{2} - s_{1})}{2}$,如果前后的数字和相差刚好为$9</em>\frac{abs(s_{2} - s_{1})}{2}$，此时一定能保证<code>BOB</code>可以赢。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sumGame</span><span class="params">(<span class="built_in">string</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n/<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'?'</span>) s1++;</span><br><span class="line">                <span class="keyword">else</span> sum += num[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[i] == <span class="string">'?'</span>) s2++;</span><br><span class="line">                <span class="keyword">else</span> sum -= num[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((s1 + s2)%<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>( sum == (s2-s1)/<span class="number">2</span>*<span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5795-规定时间内到达终点的最小花费"><a href="#5795-规定时间内到达终点的最小花费" class="headerlink" title="5795. 规定时间内到达终点的最小花费"></a>5795. 规定时间内到达终点的最小花费</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个国家有 <code>n</code>个城市，城市编号为<code>0</code> 到<code>n - 1</code> ，题目保证 所有城市 都由双向道路 连接在一起 。道路由二维整数数组 edges 表示，其中<code>edges[i] = [xi, yi, timei]</code> 表示城市 <code>xi</code> 和 <code>yi</code> 之间有一条双向道路，耗费时间为 timei 分钟。两个城市之间可能会有多条耗费时间不同的道路，但是不会有道路两头连接着同一座城市。</p><p>每次经过一个城市时，你需要付通行费。通行费用一个长度为 n 且下标从 0 开始的整数数组 <code>passingFees</code> 表示，其中 <code>passingFees[j]</code>是你经过城市 <code>j</code> 需要支付的费用。</p><p>一开始，你在城市 0 ，你想要在 <code>maxTime</code>分钟以内 （包含 maxTime 分钟）到达城市 <code>n - 1</code> 。旅行的 费用 为你经过的所有城市 通行费之和 （包括 起点和终点城市的通行费）。</p><p>给你 <code>maxTime</code>，<code>edges</code> 和 <code>passingFees</code>，请你返回完成旅行的 最小费用 ，如果无法在 <code>maxTime</code> 分钟以内完成旅行，请你返回 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">30</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：最优路径为 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> ，总共需要耗费 <span class="number">30</span> 分钟，需要支付 <span class="number">11</span> 的通行费。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">29</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">48</span></span><br><span class="line">解释：最优路径为 <span class="number">0</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span> ，总共需要耗费 <span class="number">26</span> 分钟，需要支付 <span class="number">48</span> 的通行费。</span><br><span class="line">你不能选择路径 <span class="number">0</span> -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">5</span> ，因为这条路径耗费的时间太长。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：maxTime = <span class="number">25</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>],[<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">15</span>]], passingFees = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">20</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：无法在 <span class="number">25</span> 分钟以内从城市 <span class="number">0</span> 到达城市 <span class="number">5</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maxTime &lt;= 1000</code></li><li><code>n == passingFees.length</code></li><li><code>2 &lt;= n &lt;= 1000</code></li><li><code>n - 1 &lt;= edges.length &lt;= 1000</code></li><li><code>0 &lt;= xi, yi &lt;= n - 1</code></li><li><code>1 &lt;= timei &lt;= 1000</code></li><li><code>1 &lt;= passingFees[j] &lt;= 1000</code></li><li>图中两个节点之间可能有多条路径。</li><li>图中不含有自环。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-reach-destination-in-time</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> Dijistra算法，dp。</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的<code>dijistra</code>算法求最短距离，我们设<code>dp[x][y]</code>表示在<code>y</code>时间到大城市<code>x</code>所花费的最小费用。已经知道<code>x</code>的下一跳城市为$nx$,到达$nx$时花费的时间为$dy$,到达城市$nx$的花费为$cost$，所以我们可以很清楚的知道递推关系如下：<script type="math/tex; mode=display">dp[nx][y+dy] = min(dp[nx][y+dy],dp[x][y] + cost)</script></li><li><code>dijistra</code>算法非常简单直接，时间复杂度为$O((N+M)Tlg(NT)$,空间复杂度为$O(N*T + 2M)$。</li><li><code>dp</code>算法，简单的<code>dp</code>算法，非常容易理解，时间复杂度为$O(N+M)T$.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">    Node(<span class="keyword">int</span> city,<span class="keyword">int</span> time,<span class="keyword">int</span> cost)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;city = city;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cost = cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.cost &gt; b.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> n = passingFees.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxTime+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; qu;</span><br><span class="line">        qu.push(Node(<span class="number">0</span>,<span class="number">0</span>,passingFees[<span class="number">0</span>]));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            Node curr = qu.top();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">if</span>(curr.city == n<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.cost;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr.city])&#123;</span><br><span class="line">                    <span class="keyword">int</span> ncity = v.first;</span><br><span class="line">                    <span class="keyword">int</span> ntime = curr.time + v.second;</span><br><span class="line">                    <span class="keyword">int</span> ncost = curr.cost + passingFees[ncity];</span><br><span class="line">                    <span class="keyword">if</span>(ntime &gt; maxTime) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(dp[ncity][ntime] &lt;= ncost) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[ncity][ntime] = ncost;</span><br><span class="line">                    qu.push(Node(ncity,ntime,ncost));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> maxTime, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = edges.size();</span><br><span class="line">        <span class="keyword">int</span> n = passingFees.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxTime+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pii&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].push_back(make_pair(v[<span class="number">1</span>],v[<span class="number">2</span>]));</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(make_pair(v[<span class="number">0</span>],v[<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= maxTime; ++x)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][x] == INT_MAX) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(x + v.second &lt;= maxTime)&#123;</span><br><span class="line">                        dp[v.first][x+v.second] = min(dp[v.first][x+v.second],dp[i][x] + passingFees[v.first]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxTime; ++i)&#123;</span><br><span class="line">            ans = min(ans,dp[n<span class="number">-1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(ans == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2>欢迎关注和打赏，感谢支持！</li></ol><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-56&quot;&gt;&lt;a href=&quot;#leetcode-contest-56&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  56&quot;&gt;&lt;/a&gt;leetcode  contest  56&lt;/h1&gt;&lt;p&gt;今天双周赛的第四题特别简单，就是典型的&lt;code&gt;dijistra&lt;/code&gt;算法求最短距离即可，可惜的是第三题竟然没有做出来，智商捉急。&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/11/4BXACGqyV56jPEW.png&quot; alt&gt;&lt;/p&gt;&lt;h2 id=&quot;5792-统计平方和三元组的数目&quot;&gt;&lt;a href=&quot;#5792-统计平方和三元组的数目&quot; class=&quot;headerlink&quot; title=&quot;5792. 统计平方和三元组的数目&quot;&gt;&lt;/a&gt;5792. 统计平方和三元组的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;一个 平方和三元组 &lt;code&gt;(a,b,c)&lt;/code&gt; 指的是满足 &lt;code&gt;a2 + b2 = c2&lt;/code&gt; 的 整数 三元组 &lt;code&gt;a，b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.9</title>
    <link href="http://yoursite.com/2021/07/07/302/"/>
    <id>http://yoursite.com/2021/07/07/302/</id>
    <published>2021-07-07T01:01:27.805Z</published>
    <updated>2021-07-10T06:17:24.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>这个题目确实非常难，不容易想到解答方法,CF上的原题，确实不容易想到解法。</p><h2 id="Best-Interval-to-Remove"><a href="#Best-Interval-to-Remove" class="headerlink" title="Best Interval to Remove"></a>Best Interval to Remove</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>You are given a list of inclusive intervals that are potentially overlapping.<br>Consider an operation where we remove one interval, merge the remaining intervals and then count the number of intervals left over. Return the maximum number of leftover intervals possible after this removal.</p><a id="more"></a><p>Constraints</p><ul><li><code>n ≤ 100,000</code> where n is the length of intervals<br>Example 1<br>Input<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>ervals = [</span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">    [<span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>Output<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line">Explanation</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">2</span>, <span class="number">5</span>] we <span class="keyword">get</span> [<span class="number">3</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">3</span>, <span class="number">4</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">4</span>, <span class="number">7</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">8</span>] as the merge</span><br><span class="line">If we remove the <span class="built_in">int</span>erval [<span class="number">6</span>, <span class="number">8</span>] we <span class="keyword">get</span> [<span class="number">2</span>, <span class="number">7</span>] as the merge</span><br><span class="line">So removing [<span class="number">4</span>, <span class="number">7</span>] <span class="keyword">is</span> the best</span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/problems/Best-Interval-to-Remove" target="_blank" rel="noopener">https://binarysearch.com/problems/Best-Interval-to-Remove</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数位dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;这个题目确实非常难，不容易想到解答方法,CF上的原题，确实不容易想到解法。&lt;/p&gt;&lt;h2 id=&quot;Best-Interval-to-Remove&quot;&gt;&lt;a href=&quot;#Best-Interval-to-Remove&quot; class=&quot;headerlink&quot; title=&quot;Best Interval to Remove&quot;&gt;&lt;/a&gt;Best Interval to Remove&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;You are given a list of inclusive intervals that are potentially overlapping.&lt;br&gt;Consider an operation where we remove one interval, merge the remaining intervals and then count the number of intervals left over. Return the maximum number of leftover intervals possible after this removal.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.5</title>
    <link href="http://yoursite.com/2021/07/05/301/"/>
    <id>http://yoursite.com/2021/07/05/301/</id>
    <published>2021-07-05T14:25:08.639Z</published>
    <updated>2021-07-07T01:01:16.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>今天的题目为常见的数位<code>dp</code>，实际比较复杂，感觉一般的面试肯定不会出这么难的题目，最后题目解答出来了，但是竟然有些超时，总体的思想肯定没有问题。</p><h2 id="Minimal-Submatrices"><a href="#Minimal-Submatrices" class="headerlink" title="Minimal Submatrices"></a>Minimal Submatrices</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a string s of lowercase letters and an integer k, return the number of strings of equal size as s (only consisting of lowercase letters) that are lexicographically smaller or equal to s and have at most <code>k</code> consecutive equal characters.</p><a id="more"></a><p>Mod the result by <code>10 ** 9 + 7</code>.</p><p>Constraints</p><ul><li><code>n, k ≤ 400</code> where <code>n</code>is the length of <code>s</code>.<br>Example 1<br>Input<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span> = <span class="string">"abb"</span></span><br><span class="line"><span class="attr">k</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>Output<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>Explanation<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">We</span> have the following strings: [<span class="string">"aab"</span>, <span class="string">"aac"</span>, <span class="string">"aad"</span>, <span class="string">"aae"</span>, <span class="string">"aaf"</span>, <span class="string">"aag"</span>, <span class="string">"aah"</span>, <span class="string">"aai"</span>, <span class="string">"aaj"</span>, <span class="string">"aak"</span>, <span class="string">"aal"</span>, <span class="string">"aam"</span>, <span class="string">"aan"</span>, <span class="string">"aao"</span>, <span class="string">"aap"</span>, <span class="string">"aaq"</span>, <span class="string">"aar"</span>, <span class="string">"aas"</span>, <span class="string">"aat"</span>, <span class="string">"aau"</span>, <span class="string">"aav"</span>, <span class="string">"aaw"</span>, <span class="string">"aax"</span>, <span class="string">"aay"</span>, <span class="string">"aaz"</span>, <span class="string">"aba"</span>, <span class="string">"abb"</span>].</span><br></pre></td></tr></table></figure>Note that we didn’t count “aaa” since there can be at most 2 consecutive equal characters.<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/room/Leaning-Tower-of-Hanoi-eQu4VGPJmd" target="_blank" rel="noopener">https://binarysearch.com/room/Leaning-Tower-of-Hanoi-eQu4VGPJmd</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数位dp</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>典型的数位<code>dp</code>的解法，主要是需要知道<code>dp</code>的递推公式，设<code>dp[i][j][c][flag]</code>，其中<code>flag</code>为<code>1</code>表示当前的前<code>i</code>中最后的<code>j</code>位为连续的字符<code>c</code>，且前<code>i</code>位与当前字符串的前<code>i</code>位相等且符合要求的字符的数目；<code>flag</code>为<code>0</code>则表示前<code>i</code>中最后的<code>j</code>位为连续的字符<code>c</code>，且当前的前<code>i</code>位字符的字典序小于原始字符的<code>s</code>的前<code>i</code>的字典序。这个解释比较绕口，感觉解答都不太好解答。但是感觉数位<code>dp</code>这种题目也都是类似的套路，如果熟悉它的话，则认为它比较简单，否则感觉比较复杂和难以理解，多做几道题目肯定会晓得其中的奥妙和递推关系。<br><a href="https://binarysearch.com/problems/Strings-Down-Under/solutions/810226" target="_blank" rel="noopener">解答</a></li><li>算法时间复杂度为$O(n<em>k</em>2*26)$.<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">401</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][maxn][<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="keyword">int</span> curr,<span class="keyword">int</span> cnt,<span class="keyword">char</span> c,<span class="keyword">int</span> flag)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* dp */</span></span><br><span class="line">    <span class="keyword">if</span>(curr &gt;= s.size()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curr == s.size()<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> &amp; tot = dp[curr][cnt][c-<span class="string">'a'</span>][flag];</span><br><span class="line">    <span class="keyword">if</span>(tot &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123; <span class="comment">// lower</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == maxk)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+s1,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">/*upper*/</span></span><br><span class="line">       <span class="keyword">if</span>(cnt == maxk)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[curr+<span class="number">1</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[curr+<span class="number">1</span>] != c)&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,s[curr+<span class="number">1</span>],<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[curr+<span class="number">1</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">              <span class="keyword">if</span>(<span class="string">'a'</span> + i != c)&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">0</span>))%mod;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s[curr+<span class="number">1</span>] != c)&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,<span class="number">1</span>,s[curr+<span class="number">1</span>],<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              tot = (tot + dfs(s,curr+<span class="number">1</span>,cnt+<span class="number">1</span>,c,<span class="number">1</span>))%mod;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">    maxk = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s[<span class="number">0</span>] - <span class="string">'a'</span>; ++i)&#123;</span><br><span class="line">      tot = (tot + dfs(s,<span class="number">0</span>,<span class="number">1</span>,<span class="string">'a'</span> + i,<span class="number">0</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    tot = (tot + dfs(s,<span class="number">0</span>,<span class="number">1</span>,s[<span class="number">0</span>],<span class="number">1</span>))%mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;今天的题目为常见的数位&lt;code&gt;dp&lt;/code&gt;，实际比较复杂，感觉一般的面试肯定不会出这么难的题目，最后题目解答出来了，但是竟然有些超时，总体的思想肯定没有问题。&lt;/p&gt;&lt;h2 id=&quot;Minimal-Submatrices&quot;&gt;&lt;a href=&quot;#Minimal-Submatrices&quot; class=&quot;headerlink&quot; title=&quot;Minimal Submatrices&quot;&gt;&lt;/a&gt;Minimal Submatrices&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a string s of lowercase letters and an integer k, return the number of strings of equal size as s (only consisting of lowercase letters) that are lexicographically smaller or equal to s and have at most &lt;code&gt;k&lt;/code&gt; consecutive equal characters.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 248</title>
    <link href="http://yoursite.com/2021/07/04/300/"/>
    <id>http://yoursite.com/2021/07/04/300/</id>
    <published>2021-07-04T03:59:34.839Z</published>
    <updated>2021-07-04T14:36:40.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-248"><a href="#leetcode-contest-248" class="headerlink" title="leetcode  contest  248"></a>leetcode  contest  248</h1><p>今天周赛前三题基本上都是简单题目，最后一题难度确实很大，不过感觉也是模板题目，最终极的解法还是利用后缀数组来解答。不过常规的用<code>rabin-karp</code>字符串<code>hash</code>算法也可以解决，但是很蛋疼的题目的解法竟然会卡<code>1e9 + 7</code>的取模答案，所以在实际计算时的取模将会是个很大的问题。官方的解答比较有技巧的是用了两个<code>hash</code>来解决碰撞的概率，确实是个非常好的技巧。还是前三题的节奏，感觉非常蛋疼的题目，如果不知道字符串<code>hash</code>或者<code>suffix array</code>的解法，这个题目就不会。最后一题据说是竞赛网站的模板题目，感觉真心蛋疼。</p><a id="more"></a><h2 id="5800-基于排列构建数组"><a href="#5800-基于排列构建数组" class="headerlink" title="5800. 基于排列构建数组"></a>5800. 基于排列构建数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 从 <code>0</code> 开始的排列 <code>nums</code>（下标也从 0 开始）。请你构建一个 同样长度 的数组 <code>ans</code> ，其中，对于每个 <code>i（0 &lt;= i &lt; nums.length</code>），都满足 <code>ans[i] = nums[nums[i]]</code>。返回构建好的数组 ans 。</p><p>从 0 开始的排列 <code>nums</code> 是一个由 0 到 <code>nums.length - 1</code>（0 和<code>nums.length - 1</code> 也包含在内）的不同整数组成的数组。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">解释：数组 ans 构建如下：</span><br><span class="line">ans = [nums[nums[<span class="number">0</span>]], nums[nums[<span class="number">1</span>]], nums[nums[<span class="number">2</span>]], nums[nums[<span class="number">3</span>]], nums[nums[<span class="number">4</span>]], nums[nums[<span class="number">5</span>]]]</span><br><span class="line">    = [nums[<span class="number">0</span>], nums[<span class="number">2</span>], nums[<span class="number">1</span>], nums[<span class="number">5</span>], nums[<span class="number">3</span>], nums[<span class="number">4</span>]]</span><br><span class="line">    = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：数组 ans 构建如下：</span><br><span class="line">ans = [nums[nums[<span class="number">0</span>]], nums[nums[<span class="number">1</span>]], nums[nums[<span class="number">2</span>]], nums[nums[<span class="number">3</span>]], nums[nums[<span class="number">4</span>]], nums[nums[<span class="number">5</span>]]]</span><br><span class="line">    = [nums[<span class="number">5</span>], nums[<span class="number">0</span>], nums[<span class="number">1</span>], nums[<span class="number">2</span>], nums[<span class="number">3</span>], nums[<span class="number">4</span>]]</span><br><span class="line">    = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums<span class="selector-class">.length</span> &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt; nums.length</span><br><span class="line">nums 中的元素 互不相同</span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-array-from-permutation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-from-permutation</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力运算即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[i] = nums[nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5801-消灭怪物的最大数量"><a href="#5801-消灭怪物的最大数量" class="headerlink" title="5801. 消灭怪物的最大数量"></a>5801. 消灭怪物的最大数量</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>你正在玩一款电子游戏，在游戏中你需要保护城市免受怪物侵袭。给你一个 下标从 <code>0</code> 开始 且长度为 <code>n</code> 的整数数组<code>dist</code> ，其中 <code>dist[i]</code> 是第 <code>i</code>个怪物与城市的 初始距离（单位：米）。</p><p>怪物以 恒定 的速度走向城市。给你一个长度为<code>n</code>的整数数组 <code>speed</code>表示每个怪物的速度，其中 <code>speed[i]</code> 是第<code>i</code>个怪物的速度（单位：米/分）。</p><p>怪物从 第 0 分钟 时开始移动。你有一把武器，并可以 选择 在每一分钟的开始时使用，包括第 0 分钟。但是你无法在一分钟的中间使用武器。这种武器威力惊人，一次可以消灭任一还活着的怪物。</p><p>一旦任一怪物到达城市，你就输掉了这场游戏。如果某个怪物 恰 在某一分钟开始时到达城市，这会被视为 输掉 游戏，在你可以使用武器之前，游戏就会结束。</p><p>返回在你输掉游戏前可以消灭的怪物的 最大 数量。如果你可以在所有怪物到达城市前将它们全部消灭，返回  n 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>], speed = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">2</span>,<span class="number">3</span>]，你没有消灭任何怪物。</span><br><span class="line">第 <span class="number">2</span> 分钟开始时，怪物的距离是 [X,<span class="number">1</span>,<span class="number">2</span>]，你消灭了第二个怪物。</span><br><span class="line">第 <span class="number">3</span> 分钟开始时，怪物的距离是 [X,X,<span class="number">1</span>]，你消灭了第三个怪物。</span><br><span class="line">所有 <span class="number">3</span> 个怪物都可以被消灭。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], speed = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]，你输掉了游戏。</span><br><span class="line">你只能消灭 <span class="number">1</span> 个怪物。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：dist = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], speed = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：</span><br><span class="line">第 <span class="number">0</span> 分钟开始时，怪物的距离是 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]，你消灭了第一个怪物。</span><br><span class="line">第 <span class="number">1</span> 分钟开始时，怪物的距离是 [X,<span class="number">0</span>,<span class="number">2</span>]，你输掉了游戏。 </span><br><span class="line">你只能消灭 <span class="number">1</span> 个怪物。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == dist.length == speed.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= dist[i], speed[i] &lt;= 105</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/eliminate-maximum-number-of-monsters</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们按照贪心算法排序即可，依次消灭最快到达城市的怪物即可。</li><li>时间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eliminateMaximum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = dist.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            arr.push_back(make_pair(dist[i],speed[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),[&amp;](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)&#123;</span><br><span class="line">            <span class="keyword">double</span> ta = <span class="keyword">double</span>(a.first)/a.second;</span><br><span class="line">            <span class="keyword">double</span> tb = <span class="keyword">double</span>(b.first)/b.second;</span><br><span class="line">            <span class="keyword">return</span> ta &lt; tb;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span> <span class="keyword">long</span>)arr[i].second*i &gt;= arr[i].first) <span class="keyword">break</span>;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5802-统计好数字的数目"><a href="#5802-统计好数字的数目" class="headerlink" title="5802. 统计好数字的数目"></a>5802. 统计好数字的数目</h2><p>我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。</p><p>比方说，<code>&quot;2582&quot;</code> 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。但 <code>&quot;3245&quot;</code> 不是 好数字，因为 3 在偶数下标处但不是偶数。<br>给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。由于答案可能会很大，请你将它对 <code>109 + 7</code> 取余后返回 。</p><p>一个 数字字符串 是每一位都由 0 到 <code>9</code> 组成的字符串，且可能包含前导 0 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的好数字包括 <span class="string">"0"</span>，<span class="string">"2"</span>，<span class="string">"4"</span>，<span class="string">"6"</span>，<span class="string">"8"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="number">400</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">50</span></span><br><span class="line">输出：<span class="number">564908303</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 1015</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-good-numbers" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-numbers</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目即为非常简单的数学问题，我们可以将两位划分成为一组，如果如果$n$为偶数，则我们可以知道总的数目为$20^{n/2}$,如果$n$为奇数，则我们可以知道总的数目应该为$5*20^{\frac{n-1}{2}}$.</li><li>可以利用<code>fastpow</code>即可在$lgn$的时间复杂度内求出结果。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = y ; i != <span class="number">0</span>; i = i&gt;&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                ans = (ans*curr)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodNumbers</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> fastpow(<span class="number">20</span>,n/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">5</span>*fastpow(<span class="number">20</span>,(n<span class="number">-1</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5803-最长公共子路径"><a href="#5803-最长公共子路径" class="headerlink" title="5803. 最长公共子路径"></a>5803. 最长公共子路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个国家由 <code>n</code>个编号为 0 到 <code>n - 1</code>的城市组成。在这个国家里，每两个 城市之间都有一条道路连接。</p><p>总共有<code>m</code>个编号为 0 到<code>m - 1</code> 的朋友想在这个国家旅游。他们每一个人的路径都会包含一些城市。每条路径都由一个整数数组表示，每个整数数组表示一个朋友按顺序访问过的城市序列。同一个城市在一条路径中可能 重复 出现，但同一个城市在一条路径中不会连续出现。</p><p>给你一个整数 <code>n</code>和二维数组 <code>paths</code> ，其中 <code>paths[i]</code>是一个整数数组，表示第 i 个朋友走过的路径，请你返回 每一个 朋友都走过的 最长公共子路径 的长度，如果不存在公共子路径，请你返回 0 。</p><p>一个 子路径 指的是一条路径中连续的城市序列。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, paths = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">4</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：最长公共子路径为 [<span class="number">2</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, paths = [[<span class="number">0</span>],[<span class="number">1</span>],[<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：三条路径没有公共子路径。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, paths = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">                     [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最长公共子路径为 [<span class="number">0</span>]，[<span class="number">1</span>]，[<span class="number">2</span>]，[<span class="number">3</span>] 和 [<span class="number">4</span>] 。它们长度都为 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 105</code></li><li><code>m == paths.length</code></li><li><code>2 &lt;= m &lt;= 105</code></li><li><code>sum(paths[i].length) &lt;= 105</code></li><li><code>0 &lt;= paths[i][j] &lt; n</code></li><li><code>paths[i]</code>中同一个城市不会连续重复出现。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-common-subpath" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subpath</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> KR hash算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li><code>Rabin-Karp</code>算法，利用字符串的<code>hash</code>算法将字符串的所有字串进行<code>hash</code>表示<code>key</code>，然后在所有的路径中检测是否都存在相同的<code>key</code>即可。</li><li>算法时间复杂为$O(nlgn)$,总的来说算是个好的题目，但是真心不适合面试。关键在于如何处理<code>hash</code>冲突的问题，官方题解中用了两个<code>hash</code>来检测<code>hash</code>冲突的问题，确实是个不错的技巧，值得学习。</li><li>后缀数组的解法就比较难了，还是老实看题解。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll B1 = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll M1 = <span class="number">1e12</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths,<span class="keyword">int</span> len,ll base,ll mod)</span> </span>&#123;</span><br><span class="line">        ll P = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m = paths.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            P = (P*base)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ll, <span class="keyword">int</span>&gt; total;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : paths) &#123;</span><br><span class="line">            ll curr = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;ll&gt; part;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.size(); i++) &#123;</span><br><span class="line">                curr = (curr*base  + p[i])%mod;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len) &#123;</span><br><span class="line">                    curr = (curr - (P*p[i-len])%mod + mod)%mod; </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= len<span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(part.count(curr)) <span class="keyword">continue</span>;</span><br><span class="line">                    part.insert(curr);</span><br><span class="line">                    total[curr]++;</span><br><span class="line">                    <span class="keyword">if</span>(total[curr] == m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubpath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">100000</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; paths.size(); ++i)&#123;</span><br><span class="line">            r = min(r,<span class="keyword">int</span>(paths[i].size()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(paths, mid,B1,M1)) &#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, l<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-248&quot;&gt;&lt;a href=&quot;#leetcode-contest-248&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  248&quot;&gt;&lt;/a&gt;leetcode  contest  248&lt;/h1&gt;&lt;p&gt;今天周赛前三题基本上都是简单题目，最后一题难度确实很大，不过感觉也是模板题目，最终极的解法还是利用后缀数组来解答。不过常规的用&lt;code&gt;rabin-karp&lt;/code&gt;字符串&lt;code&gt;hash&lt;/code&gt;算法也可以解决，但是很蛋疼的题目的解法竟然会卡&lt;code&gt;1e9 + 7&lt;/code&gt;的取模答案，所以在实际计算时的取模将会是个很大的问题。官方的解答比较有技巧的是用了两个&lt;code&gt;hash&lt;/code&gt;来解决碰撞的概率，确实是个非常好的技巧。还是前三题的节奏，感觉非常蛋疼的题目，如果不知道字符串&lt;code&gt;hash&lt;/code&gt;或者&lt;code&gt;suffix array&lt;/code&gt;的解法，这个题目就不会。最后一题据说是竞赛网站的模板题目，感觉真心蛋疼。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Binarysearch】 每日一题 7.3</title>
    <link href="http://yoursite.com/2021/07/03/299/"/>
    <id>http://yoursite.com/2021/07/03/299/</id>
    <published>2021-07-03T14:56:15.048Z</published>
    <updated>2021-07-03T15:09:27.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h1><p>最近开始计划进行每日一道算法题的训练，初步计划以国外的刷题平台<code>binarysearch</code>为主，这个平台上的题目题目质量很高，感觉还是非常值得学习和思考的，计划坚持每日一题的节奏，计划主要坚持刷<code>mid</code>难度以上的题目，题目还是非常经典的，感觉质量要比<code>leetcode</code>的题目质量高很多。但是难度感觉不算很高，感觉也就是面试题目的难度，远远比不上<code>ACM</code>算法题目的难度，但是感觉还是非常值得学习和思考的题目。</p><a id="more"></a><h2 id="Minimal-Submatrices"><a href="#Minimal-Submatrices" class="headerlink" title="Minimal Submatrices"></a>Minimal Submatrices</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a two-dimensional integer matrix and an integer k, return a matrix containing minimum values of all <code>k</code>by <code>k</code>submatrices.</p><p>Constraints</p><ul><li><code>1 ≤ n * m ≤ 100,000</code> where <code>n</code>and<code>m</code>are the number of rows and columns in <code>matrix</code><br>Example 1<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    [<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>]</span><br><span class="line">]</span><br><span class="line">k = <span class="number">2</span></span><br></pre></td></tr></table></figure>Output<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>Explanation<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">The top left submatrix has minimum value of <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line">The top right submatrix has minimum value of <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line">The bottom left submatrix has minimum value of <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line">The bottom right submatrix has minimum value of <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><a href="https://binarysearch.com/problems/Minimal-Submatrices" target="_blank" rel="noopener">https://binarysearch.com/problems/Minimal-Submatrices</a><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>典型的滑动窗口，即求数组中连续的子数组中最小的元素，只不过这里改为二维的矩阵了。如果用常规的有序集合即可解决问题，我们首先求出每一列中的前<code>k</code>个行中对应的最小元素数组<code>arr</code>，然后在<code>arr</code>中求出该列中连续的<code>k</code>个元素的最小元素，本质上与一维时原理基本相同。</li><li>求连续的<code>k</code>个元素的最小值或者最大值的解法有很多，比如常见的有序集合、单调栈、线段树等等常见的解法，如果用有序集合或者线段树的解法，则时间复杂度为$O(nlgn)$,如果用单调栈则时间复杂度为$O(n)$.</li><li>本题我是直接用的有序集合来解答改题目，时间复杂度为$O(m<em>n</em>lgk)$<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; solve(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; curr(col);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row-k+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initial</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">        curr[i].insert(matrix[j][i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= row-k; ++i)&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; min_row(col);</span><br><span class="line">      <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; curr_row;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">        <span class="comment">// insert every element each col</span></span><br><span class="line">        curr[j].insert(matrix[i+k<span class="number">-1</span>][j]);</span><br><span class="line">        <span class="comment">// get every minimum col element</span></span><br><span class="line">        min_row[j] = *curr[j].begin();</span><br><span class="line">        <span class="comment">// remove every minimum row </span></span><br><span class="line">        <span class="keyword">auto</span> it = curr[j].find(matrix[i][j]);</span><br><span class="line">        curr[j].erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k<span class="number">-1</span>; ++j) curr_row.insert(min_row[j]);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = k<span class="number">-1</span>; j &lt; col; ++j)&#123;</span><br><span class="line">        curr_row.insert(min_row[j]);</span><br><span class="line">        ans[i].push_back(*curr_row.begin());</span><br><span class="line">        <span class="keyword">auto</span> it = curr_row.find(min_row[j-k+<span class="number">1</span>]);</span><br><span class="line">        curr_row.erase(it);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;每日一题&quot;&gt;&lt;a href=&quot;#每日一题&quot; class=&quot;headerlink&quot; title=&quot;每日一题&quot;&gt;&lt;/a&gt;每日一题&lt;/h1&gt;&lt;p&gt;最近开始计划进行每日一道算法题的训练，初步计划以国外的刷题平台&lt;code&gt;binarysearch&lt;/code&gt;为主，这个平台上的题目题目质量很高，感觉还是非常值得学习和思考的，计划坚持每日一题的节奏，计划主要坚持刷&lt;code&gt;mid&lt;/code&gt;难度以上的题目，题目还是非常经典的，感觉质量要比&lt;code&gt;leetcode&lt;/code&gt;的题目质量高很多。但是难度感觉不算很高，感觉也就是面试题目的难度，远远比不上&lt;code&gt;ACM&lt;/code&gt;算法题目的难度，但是感觉还是非常值得学习和思考的题目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="binarysearch" scheme="http://yoursite.com/tags/binarysearch/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.S081】 Lab2 Systemcalls</title>
    <link href="http://yoursite.com/2021/06/28/298/"/>
    <id>http://yoursite.com/2021/06/28/298/</id>
    <published>2021-06-28T14:42:20.599Z</published>
    <updated>2021-07-03T01:23:35.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="systemcalls"><a href="#systemcalls" class="headerlink" title="systemcalls"></a>systemcalls</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab2</code>的内容作完了，<code>lab2</code>的难度感觉比<code>lab1</code>小多了，主要是为系统添加两个<code>system call</code>，总体来说难度偏低。</p><ul><li>首先我们可以观察到，所有的系统调用函数都存放在<code>usys.S</code>中，用<code>risc-v</code>的指令完成。在用户空间中调用系统调用函数<code>func</code>，实际内核中对应的就是系统调用对应的<code>id</code>写入到寄存器<code>a7</code>，然后调用<code>ecall</code>指令，即在内核中可调用对应的函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># generated by usys.pl - do not edit</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"kernel/syscall.h"</span></span></span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global wait</span><br><span class="line">wait:</span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global pipe</span><br><span class="line">pipe:</span><br><span class="line"> li a7, SYS_pipe</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global read</span><br><span class="line">read:</span><br><span class="line"> li a7, SYS_read</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global close</span><br><span class="line">close:</span><br><span class="line"> li a7, SYS_close</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global kill</span><br><span class="line">kill:</span><br><span class="line"> li a7, SYS_kill</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exec</span><br><span class="line">exec:</span><br><span class="line"> li a7, SYS_exec</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global open</span><br><span class="line">open:</span><br><span class="line"> li a7, SYS_open</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mknod</span><br><span class="line">mknod:</span><br><span class="line"> li a7, SYS_mknod</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global unlink</span><br><span class="line">unlink:</span><br><span class="line"> li a7, SYS_unlink</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global fstat</span><br><span class="line">fstat:</span><br><span class="line"> li a7, SYS_fstat</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global link</span><br><span class="line">link:</span><br><span class="line"> li a7, SYS_link</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mkdir</span><br><span class="line">mkdir:</span><br><span class="line"> li a7, SYS_mkdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global chdir</span><br><span class="line">chdir:</span><br><span class="line"> li a7, SYS_chdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global dup</span><br><span class="line">dup:</span><br><span class="line"> li a7, SYS_dup</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global getpid</span><br><span class="line">getpid:</span><br><span class="line"> li a7, SYS_getpid</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sbrk</span><br><span class="line">sbrk:</span><br><span class="line"> li a7, SYS_sbrk</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global uptime</span><br><span class="line">uptime:</span><br><span class="line"> li a7, SYS_uptime</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sysinfo</span><br><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure></li><li>在内核中我们可以看到实际的系统调用内核中执行如下:<br>从<code>a7</code>寄存器中取出系统调用号，然后执行对应的内核中的函数,系统调用函数可能会从用户空间中取出传入的参数，然后将执行的返回结果再写回到用户空间中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// system call number</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf("sys call num = %d\n",num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果我们需要添加系统调用，则首先添加系统调用的编号，然后在内核中添加系统调用编号对应的回调函数即可。</li><li>测试结果：<br><img src="https://i.loli.net/2021/07/02/WGBDQaPhdVY54Nk.png" alt></li></ul><a id="more"></a><h2 id="1-trace"><a href="#1-trace" class="headerlink" title="1. trace"></a>1. trace</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will <span class="builtin-name">add</span> a<span class="built_in"> system </span>call tracing feature that may help you when debugging later labs. You’ll create a new trace<span class="built_in"> system </span>call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which<span class="built_in"> system </span>calls <span class="keyword">to</span> trace. <span class="keyword">For</span> example, <span class="keyword">to</span> trace the fork<span class="built_in"> system </span>call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number <span class="keyword">from</span> kernel/syscall.h. You have <span class="keyword">to</span> modify the xv6 kernel <span class="keyword">to</span> <span class="builtin-name">print</span> out a line when each<span class="built_in"> system </span>call is about <span class="keyword">to</span> return, <span class="keyword">if</span> the<span class="built_in"> system </span>call’s number is <span class="builtin-name">set</span> <span class="keyword">in</span> the mask. The line should contain the process id, the name of the<span class="built_in"> system </span>call <span class="keyword">and</span> the return value; you don’t need <span class="keyword">to</span> <span class="builtin-name">print</span> the<span class="built_in"> system </span>call arguments. The trace<span class="built_in"> system </span>call should <span class="builtin-name">enable</span> tracing <span class="keyword">for</span> the process that calls it <span class="keyword">and</span> any children that it subsequently forks, but should <span class="keyword">not</span> affect other processes.</span><br></pre></td></tr></table></figure><p>实现系统调用的<code>trace</code>功能，即打印出进程中每一个在<code>mask</code>掩码中的系统调用，并且子进程会继承父进程的<code>mask</code>.</p><ul><li>代码实现本身不是特别难，主要是需要弄清楚系统的调用的过程。我们首先添加系统调用编号<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure>在用户程序中添加如下:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry(<span class="string">"sleep"</span>);</span><br><span class="line">entry(<span class="string">"uptime"</span>);</span><br><span class="line">entry(<span class="string">"trace"</span>);</span><br><span class="line">entry(<span class="string">"sysinfo"</span>);</span><br></pre></td></tr></table></figure>在进程的结构体中增加<code>tracemask</code>变量，在<code>systemcall</code>函数中需要修改，每次进行系统调用时，则将系统调用号与掩码进行比对，是否存在于掩码的状态中，如果掩码存在，则此时我们打印出系统调用的具体信息。本身不是特别难。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf("sys call num = %d\n",num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d: syscall %s -&gt; %d\n"</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %s: unknown sys call %d\n"</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system trace call, using trace mask to print system call information</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(<span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  p-&gt;tracemask = mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-sysinfo"><a href="#2-sysinfo" class="headerlink" title="2. sysinfo"></a>2. sysinfo</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">In</span> this assignment you will <span class="builtin-name">add</span> a<span class="built_in"> system </span>call, sysinfo, that collects information about the running system. The<span class="built_in"> system </span>call takes one argument: a pointer <span class="keyword">to</span> a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be <span class="builtin-name">set</span> <span class="keyword">to</span> the number of bytes of free memory, <span class="keyword">and</span> the nproc field should be <span class="builtin-name">set</span> <span class="keyword">to</span> the number of processes whose state is <span class="keyword">not</span> UNUSED. We provide a test program sysinfotest; you pass this assignment <span class="keyword">if</span> it prints “sysinfotest: OK”.</span><br></pre></td></tr></table></figure>完成<code>sysinfo</code>系统调用，主要时获取当前<code>heap</code>中的<code>free</code>的总空间，同时获取当前系统中存在多少非空闲的进程个数。这个也比较简单，难点在于学会将内核空间的数据拷贝到用户空间。</li><li>系统调用添加的流程跟<code>trace</code>是一样的，稍微复杂点即是需要在<code>kalloc.c</code>中添加对<code>free memory</code>的统计，以及在<code>proc</code>中添加对空闲进程的统计。</li><li><code>kalloc</code>中我们可以看到所有的<code>memory free</code>是用<code>list</code>表示的，每一块空闲的内存大小为<code>4096 byte</code>，我们只需要遍历<code>freelist</code>统计块的数目即可。</li><li><code>proc</code>中我们可以看到每一个<code>process</code>都有一个状态，我们只需要检测<code>process</code>的状态即可，<code>process</code>列表用数组表示，我们只需要遍历数组即可。</li><li>关键的一点，获取参数以后，需要将所有的参数信息从内核空间拷贝到用户空间即可，这时需要用到<code>copyout</code>函数.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysinfo</span><span class="params">(uint64 addr)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  st.freemem = totalfree();</span><br><span class="line">  st.nproc   = nproc();</span><br><span class="line">  <span class="comment">// printf("total free: %d\n",st.freemem);</span></span><br><span class="line">  <span class="comment">// printf("total proc：%d\n",st.nproc);</span></span><br><span class="line">  <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="keyword">char</span> *)&amp;st, <span class="keyword">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// system information null process number.</span></span><br><span class="line"><span class="function">uint64 <span class="title">nproc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">totalfree</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get totall free memory</span></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    tot += <span class="number">4096</span>;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;systemcalls&quot;&gt;&lt;a href=&quot;#systemcalls&quot; class=&quot;headerlink&quot; title=&quot;systemcalls&quot;&gt;&lt;/a&gt;systemcalls&lt;/h1&gt;&lt;p&gt;最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把&lt;code&gt;lab2&lt;/code&gt;的内容作完了，&lt;code&gt;lab2&lt;/code&gt;的难度感觉比&lt;code&gt;lab1&lt;/code&gt;小多了，主要是为系统添加两个&lt;code&gt;system call&lt;/code&gt;，总体来说难度偏低。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;首先我们可以观察到，所有的系统调用函数都存放在&lt;code&gt;usys.S&lt;/code&gt;中，用&lt;code&gt;risc-v&lt;/code&gt;的指令完成。在用户空间中调用系统调用函数&lt;code&gt;func&lt;/code&gt;，实际内核中对应的就是系统调用对应的&lt;code&gt;id&lt;/code&gt;写入到寄存器&lt;code&gt;a7&lt;/code&gt;，然后调用&lt;code&gt;ecall&lt;/code&gt;指令，即在内核中可调用对应的函数。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;# generated by usys.pl - do not edit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&quot;kernel/syscall.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fork:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_fork&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_exit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global wait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wait:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_wait&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global pipe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pipe:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_pipe&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global read&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;read:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_read&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global write&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;write:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_write&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global close&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;close:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_close&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global kill&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kill:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_kill&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global exec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exec:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_exec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global open&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;open:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_open&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global mknod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mknod:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_mknod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global unlink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unlink:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_unlink&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global fstat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fstat:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_fstat&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;link:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global mkdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mkdir:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_mkdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global chdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;chdir:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_chdir&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global dup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dup:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_dup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global getpid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getpid:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_getpid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sbrk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sbrk:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sbrk&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sleep:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sleep&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global uptime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;uptime:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_uptime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global trace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;trace:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_trace&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.global sysinfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sysinfo:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; li a7, SYS_sysinfo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ecall&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ret&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// System call numbers&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_fork    1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_exit    2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_wait    3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_pipe    4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_read    5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_kill    6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_exec    7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_fstat   8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_chdir   9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_dup    10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_getpid 11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sbrk   12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sleep  13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_uptime 14&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_open   15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_write  16&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_mknod  17&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_unlink 18&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_link   19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_mkdir  20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_close  21&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_trace  22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; SYS_sysinfo 23&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;在内核中我们可以看到实际的系统调用内核中执行如下:&lt;br&gt;从&lt;code&gt;a7&lt;/code&gt;寄存器中取出系统调用号，然后执行对应的内核中的函数,系统调用函数可能会从用户空间中取出传入的参数，然后将执行的返回结果再写回到用户空间中。&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;syscall(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;proc&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;p&lt;/span&gt; = &lt;span class=&quot;title&quot;&gt;myproc&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// system call number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  num = p-&amp;gt;trapframe-&amp;gt;a7;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(num &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; num &amp;lt; NELEM(syscalls) &amp;amp;&amp;amp; syscalls[num]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;a0 = syscalls[num]();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p-&amp;gt;tracemask &amp;amp; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;num))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// printf(&quot;sys call num = %d\n&quot;,num);&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d: syscall %s -&amp;gt; %d\n&quot;&lt;/span&gt;,p-&amp;gt;pid,syscallname[num],p-&amp;gt;trapframe-&amp;gt;a0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d %s: unknown sys call %d\n&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p-&amp;gt;pid, p-&amp;gt;name, num);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    p-&amp;gt;trapframe-&amp;gt;a0 = &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;如果我们需要添加系统调用，则首先添加系统调用的编号，然后在内核中添加系统调用编号对应的回调函数即可。&lt;/li&gt;
&lt;li&gt;测试结果：&lt;br&gt;&lt;img src=&quot;https://i.loli.net/2021/07/02/WGBDQaPhdVY54Nk.png&quot; alt&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="OS" scheme="http://yoursite.com/categories/OS/"/>
    
    
      <category term="operation system" scheme="http://yoursite.com/tags/operation-system/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 Leetcode  Contest 247</title>
    <link href="http://yoursite.com/2021/06/27/297/"/>
    <id>http://yoursite.com/2021/06/27/297/</id>
    <published>2021-06-27T05:29:11.848Z</published>
    <updated>2021-06-27T14:11:53.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-contest-247"><a href="#leetcode-contest-247" class="headerlink" title="leetcode  contest  247"></a>leetcode  contest  247</h1><p>周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。</p><h2 id="5797-两个数对之间的最大乘积差"><a href="#5797-两个数对之间的最大乘积差" class="headerlink" title="5797. 两个数对之间的最大乘积差"></a>5797. 两个数对之间的最大乘积差</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个数对<code>(a, b)</code> 和 <code>(c, d)</code>之间的 乘积差 定义为 <code>(a * b) - (c * d)</code> 。</p><a id="more"></a><ul><li>例如，<code>(5, 6)</code> 和 <code>(2, 7)</code> 之间的乘积差是 <code>(5 * 6) - (2 * 7) = 16</code> 。</li></ul><p>给你一个整数数组 nums ，选出四个 不同的 下标 w、x、y 和 z ，使数对<code>(nums[w], nums[x])</code> 和 <code>(nums[y], nums[z])</code>之间的 乘积差 取到 最大值 。</p><p>返回以这种方式取得的乘积差中的 最大值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">34</span></span><br><span class="line">解释：可以选出下标为 <span class="number">1</span> 和 <span class="number">3</span> 的元素构成第一个数对 (<span class="number">6</span>, <span class="number">7</span>) 以及下标 <span class="number">2</span> 和 <span class="number">4</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">6</span> * <span class="number">7</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">34</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">64</span></span><br><span class="line">解释：可以选出下标为 <span class="number">3</span> 和 <span class="number">6</span> 的元素构成第一个数对 (<span class="number">9</span>, <span class="number">8</span>) 以及下标 <span class="number">1</span> 和 <span class="number">5</span> 构成第二个数对 (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">乘积差是 (<span class="number">9</span> * <span class="number">8</span>) - (<span class="number">2</span> * <span class="number">4</span>) = <span class="number">64</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>4 &lt;= nums.length &lt;= 104</code></li><li><code>1 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-difference-between-two-pairs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的数学问题，我们知道成绩差的最大值肯定为最大的两数之积减去最小的两数之积。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProductDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[n<span class="number">-1</span>]*nums[n<span class="number">-2</span>] - nums[<span class="number">0</span>]*nums[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5798-循环轮转矩阵"><a href="#5798-循环轮转矩阵" class="headerlink" title="5798. 循环轮转矩阵"></a>5798. 循环轮转矩阵</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个大小为 <code>m x n</code>的整数矩阵 <code>grid​​​</code> ，其中 <code>m</code> 和 <code>n</code> 都是 偶数 ；另给你一个整数 k 。</p><p>矩阵由若干层组成，如下图所示，每种颜色代表一层：<br>矩阵的循环轮转是通过分别循环轮转矩阵中的每一层完成的。在对某一层进行一次循环旋转操作时，层中的每一个元素将会取代其 逆时针 方向的相邻元素。轮转示例如下：<br>返回执行 <code>k</code>次循环轮转操作后的矩阵。</p><p>示例 1：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[40,10],[30,20]]</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[[10,20],[40,30]]</span></span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]], k = <span class="number">2</span></span><br><span class="line">输出：[[<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>],[<span class="number">2</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">16</span>],[<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">15</span>],[<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">14</span>]]</span><br><span class="line">解释：上图展示了矩阵在执行循环轮转操作时每一步的状态。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>2 &lt;= m, n &lt;= 50</code></li><li><code>m</code> 和 <code>n</code> 都是 偶数</li><li><code>1 &lt;= grid[i][j] &lt;= 5000</code></li><li><code>1 &lt;= k &lt;= 109</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cyclically-rotating-a-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cyclically-rotating-a-grid</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们按照层次分别进行模拟旋转即可，这个就是找规律。取出每一层的数据，然后进行向左偏移$k$位即可。</li><li>时间复杂度位$O(2*n)$,空间复杂度为$O(n)$.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rotateGrid(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> level = min(row/<span class="number">2</span>,col/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">            <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                arr.push_back(grid[j][col-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[row<span class="number">-1</span>-i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                arr.push_back(grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*rotate*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.size(); ++j)&#123;</span><br><span class="line">                copy.push_back(arr[(j+k)%arr.size()]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">             <span class="comment">/*up*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; col-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*right*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; row-i<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                ans[j][col-i<span class="number">-1</span>] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*bottom*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[row<span class="number">-1</span>-i][j] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*left*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = row<span class="number">-1</span>-i; j &gt; i; --j)&#123;</span><br><span class="line">                ans[j][i] = copy[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5799-最美子字符串的数目"><a href="#5799-最美子字符串的数目" class="headerlink" title="5799. 最美子字符串的数目"></a>5799. 最美子字符串的数目</h2><p>如果某个字符串中 至多一个 字母出现 奇数 次，则称其为 最美 字符串。</p><p>例如，<code>&quot;ccjjc&quot;</code> 和 <code>&quot;abab&quot;</code>都是最美字符串，但 <code>&quot;ab&quot;</code>不是。<br>给你一个字符串 <code>word</code> ，该字符串由前十个小写英文字母组成（’a’ 到 ‘j’）。请你返回 <code>word</code> 中 最美非空子字符串 的数目。如果同样的子字符串在 <code>word</code>中出现多次，那么应当对 每次出现 分别计数。</p><p>子字符串 是字符串中的一个连续字符序列。</p><p>示例 1：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aba"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：<span class="number">4</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aba"</span> -&gt; <span class="string">"aba"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"aabb"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：<span class="number">9</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aa"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aab"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"aabb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"a"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"abb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"bb"</span></span><br><span class="line">- <span class="string">"aabb"</span> -&gt; <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">word</span> = <span class="string">"he"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：<span class="number">2</span> 个最美子字符串如下所示：</span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"h"</span></span><br><span class="line">- <span class="string">"he"</span> -&gt; <span class="string">"e"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= word.length &lt;= 105</code></li><li><code>word</code>由从 <code>&#39;a&#39;</code>到 <code>&#39;j&#39;</code> 的小写英文字母组成<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/number-of-wonderful-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-wonderful-substrings</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 前缀和 + 状态压缩<code>dp</code></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>这个题目出的非常不错，我们设状态二进制<code>mask</code>，如果<code>mask</code>的第<code>i</code>位为<code>1</code>则表示字母<code>&#39;a&#39; + i</code>的数目为奇数，如果<code>mask</code>的第<code>i</code>位为<code>0</code>则表示字母<code>&#39;a&#39; + i</code>的数目为偶数。则我们可以字符统计的前缀和，如果状态<code>mask</code>相等的前缀之间的连续子字符串一定每个字符的个数均为偶数。</li><li>题目还给出另一个要求，至多存在一个字符的数目为奇数，则我们可以知道，如果两个前缀之间的某个字符的奇偶性相反，则这两个前缀之间的连续子字符串的该字符的个数一定为奇数，则我们依次尝试假设每一个字符可能为奇数，进行尝试即可。</li><li>时间复杂度为$O(m*n)$,空间复杂度为$2^{m}$.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">wonderfulSubstrings</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = word.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask = mask^(<span class="number">1</span>&lt;&lt;(word[i] - <span class="string">'a'</span>));</span><br><span class="line">            ans += cnt[mask];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                ans += cnt[mask^(<span class="number">1</span>&lt;&lt;j)];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[mask]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5204-统计为蚁群构筑房间的不同顺序"><a href="#5204-统计为蚁群构筑房间的不同顺序" class="headerlink" title="5204. 统计为蚁群构筑房间的不同顺序"></a>5204. 统计为蚁群构筑房间的不同顺序</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你是一只蚂蚁，负责为蚁群构筑 <code>n</code>间编号从<code>0</code>到 <code>n-1</code>的新房间。给你一个 下标从 <code>0</code>开始 且长度为 n 的整数数组 <code>prevRoom</code>作为扩建计划。其中，<code>prevRoom[i]</code>表示在构筑房间 i 之前，你必须先构筑房间 <code>prevRoom[i]</code>，并且这两个房间必须 直接 相连。房间 0 已经构筑完成，所以 <code>prevRoom[0] = -1</code>。扩建计划中还有一条硬性要求，在完成所有房间的构筑之后，从房间 <code>0</code>可以访问到每个房间。</p><p>你一次只能构筑 一个 房间。你可以在 已经构筑好的 房间之间自由穿行，只要这些房间是 相连的 。如果房间 <code>prevRoom[i]</code> 已经构筑完成，那么你就可以构筑房间 <code>i</code>。</p><p>返回你构筑所有房间的 不同顺序的数目 。由于答案可能很大，请返回对<code>109 + 7</code>取余 的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：仅有一种方案可以完成所有房间的构筑：<span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：prevRoom = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 种不同顺序：</span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">2</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">1</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">1</span> → <span class="number">2</span> → <span class="number">4</span> → <span class="number">3</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">3</span> → <span class="number">4</span></span><br><span class="line"><span class="number">0</span> → <span class="number">2</span> → <span class="number">1</span> → <span class="number">4</span> → <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == prevRoom.length</code></li><li><code>2 &lt;= n &lt;= 105</code></li><li><code>prevRoom[0] == -1</code></li><li>对于所有的 <code>1 &lt;= i &lt; n</code> ，都有 <code>0 &lt;= prevRoom[i] &lt; n</code></li><li>题目保证所有房间都构筑完成后，从房间 <code>0</code>可以访问到每个房间</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-ways-to-build-rooms-in-an-ant-colony</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp ，排列组合，乘法逆元</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目除了乘法逆元的数学知识以外，我觉题目本身不难，即为非常容易理解的排列组合。但是觉得这个题目还是出的很好，质量很高，非常适合拿来面试。题目主要要求，构造的拓扑排序的方案数目，我们按照拓扑排序的方式来构造序列即可。</li><li>需要的基础知识为：</li></ol><ul><li>排列数的基本方式，我们知道有$a_{0}$个物品$0$,$a_{1}$个物品$1$,…,$a_{n}$个物品$n$,如果我们需要将这$n$类物品排成一列，则方案数为：<script type="math/tex; mode=display">\frac{(a_{0} + a_{1} + a_{2} + ... + a_{n})!}{a_{0}!.a_{1}!...a_{n}!}</script></li><li>乘法逆元：<script type="math/tex; mode=display">(\frac{b}{a})\mod m ≡ (b * a^{-1} \mod m) \\a*a^{-1} ≡ (1 \mod m) \\a^{-1} ≡ a^{m-2}</script></li></ul><ol><li>设以<code>x</code>为<code>root</code>节点的子树的节点个数为$cnt[x]$,子数的可能的排序方法数为$dp[x]$，则我们可以知道以<code>q</code>为<code>root</code>的树的孩子节点分别为:$p_{1},p_{2},…,p_{k}$,则我们知道根据排列组合可以知道如下：<script type="math/tex; mode=display">cnt[q] = 1 + \sum_{i=1}^{k}p_{i} \\dp[q] = \frac{(p_{1} + p_{2} + p_{3} + ... + p_{k})!}{p_{1}.!p_{2}!...p_{k}!} * \prod_{i=1}^{k}dp[p_{i}]\\= (p_{1} + p_{2} + p_{3} + ... + p_{k})!\prod_{i=1}^{k}((p_{i}!)^{-1}*dp[pi])</script></li><li>算法时间复杂度为$O(32*n)$,空间复杂度为$O(n)$.</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">using</span> LL = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m,<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> curr = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*curr)%mod;</span><br><span class="line">            curr = (curr*curr)%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">waysToBuildRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prevRoom)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prevRoom.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; fac(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; inv(n+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        fac[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            fac[i] = (fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">            inv[i] = fastpow(fac[i],mod<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            next[prevRoom[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         function&lt;long long(int)&gt; dfs = [&amp;](int u)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ret = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : next[u])&#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> curr = dfs(v);</span><br><span class="line">                ret = ((ret*curr)%mod*inv[cnt[v]])%mod;</span><br><span class="line">                cnt[u] += cnt[v];</span><br><span class="line">            &#125;</span><br><span class="line">            ret = (ret*fac[cnt[u]])%mod;</span><br><span class="line">            cnt[u]++;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id><a href="#" class="headerlink" title="#"></a>#</h2><p>欢迎关注和打赏，感谢支持！</p><ul><li>关注我的博客: <a href="http://mikemeng.org/" target="_blank" rel="noopener">http://mikemeng.org/</a></li><li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu" target="_blank" rel="noopener">https://www.zhihu.com/people/da-hua-niu</a></li><li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;leetcode-contest-247&quot;&gt;&lt;a href=&quot;#leetcode-contest-247&quot; class=&quot;headerlink&quot; title=&quot;leetcode  contest  247&quot;&gt;&lt;/a&gt;leetcode  contest  247&lt;/h1&gt;&lt;p&gt;周赛的题目质量一向非常高，非常喜欢这类难度适中的题目，稍微带点思考，但并不是特别难的题目。不过还是三题的节奏，第三题竟然没有做出来。&lt;/p&gt;&lt;h2 id=&quot;5797-两个数对之间的最大乘积差&quot;&gt;&lt;a href=&quot;#5797-两个数对之间的最大乘积差&quot; class=&quot;headerlink&quot; title=&quot;5797. 两个数对之间的最大乘积差&quot;&gt;&lt;/a&gt;5797. 两个数对之间的最大乘积差&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;两个数对&lt;code&gt;(a, b)&lt;/code&gt; 和 &lt;code&gt;(c, d)&lt;/code&gt;之间的 乘积差 定义为 &lt;code&gt;(a * b) - (c * d)&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
