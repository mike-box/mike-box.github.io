<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>just code for fun</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-18T09:02:52.866Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 189周双周赛</title>
    <link href="http://yoursite.com/2020/05/18/162/"/>
    <id>http://yoursite.com/2020/05/18/162/</id>
    <published>2020-05-18T09:02:46.654Z</published>
    <updated>2020-05-18T09:02:52.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="189周周赛"><a href="#189周周赛" class="headerlink" title="189周周赛"></a>189周周赛</h1><p>还是周赛质量稍微高一些。</p><h2 id="1450-Number-of-Students-Doing-Homework-at-a-Given-Time"><a href="#1450-Number-of-Students-Doing-Homework-at-a-Given-Time" class="headerlink" title="1450. Number of Students Doing Homework at a Given Time"></a>1450. Number of Students Doing Homework at a Given Time</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two integer arrays startTime and endTime and given an integer queryTime.</p><a id="more"></a><p>The ith student started doing their homework at the time startTime[i] and finished it at time <code>endTime[i]</code>.</p><p>Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval <code>[startTime[i], endTime[i]]</code> inclusive.</p><p>Example 1:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], endTime = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: We have <span class="number">3</span> students <span class="keyword">where</span>:</span><br><span class="line">The <span class="keyword">first</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">1</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">second</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">2</span> <span class="keyword">and</span> also wasn't doing anything <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br><span class="line">The <span class="keyword">third</span> student started doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">3</span> <span class="keyword">and</span> finished <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">7</span> <span class="keyword">and</span> was <span class="keyword">the</span> only student doing homework <span class="keyword">at</span> <span class="built_in">time</span> <span class="number">4.</span></span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">4</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The only student was doing their homework at the queryTime.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">4</span>], endTime = [<span class="number">4</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], endTime = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], queryTime = <span class="number">7</span></span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure><br>Example 5:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: startTime = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], endTime = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>], queryTime = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>startTime.length == endTime.length</code></li><li><code>1 &lt;= startTime.length &lt;= 100</code></li><li><code>1 &lt;= startTime[i] &lt;= endTime[i] &lt;= 1000</code></li><li><code>1 &lt;= queryTime &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/" target="_blank" rel="noopener">https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接判断或者二分查找</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的数据量非常小，我们直接判断每个区间是否包含<code>querytime</code>即可，O(n)时间复杂度内即可完成，比较简单。</li><li>另有一种比较方便的算法，可以用来计算多个<code>query</code>，可以在O(1)或者O(lgn)时间复杂度内获取多个<code>query</code>的次数。类似于左右括号匹配的办法。我们将所有的<code>startTime</code>在坐标上以<code>(</code>表示，将所有的<code>endTime</code>以<code>)</code>表示，我们遇到左括号则进行加1操作，遇到右括号则进行减1操作。</li><li>根据2的解法其实很简单，我们将所有的<code>startTime</code>和<code>endTime</code>进行排序，我们查找小于等于<code>querytime</code>的<code>startTime</code>有l个，我们查找小于<code>querytime</code>的<code>endTime</code>有r个，在此区间的则总共有<code>l - r</code>。<br><img src="https://mike-box.github.io/images/163-1.png" alt="1"><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Declare Array of maximum given constraint size to</span></span><br><span class="line">        <span class="comment">// store all the overlapping intervals at any time.</span></span><br><span class="line">        <span class="comment">// Initially no intervals overlap so initialised by 0.</span></span><br><span class="line">        <span class="keyword">int</span> overlap_intervals[<span class="number">1002</span>];</span><br><span class="line">        <span class="built_in">memset</span>(overlap_intervals, <span class="number">0</span>, <span class="keyword">sizeof</span>(overlap_intervals));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// For every index in start time </span></span><br><span class="line">        <span class="comment">// increment the index in array by 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : startTime) </span><br><span class="line">            overlap_intervals[i] += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Since the intervals also contains the ending points so</span></span><br><span class="line">        <span class="comment">// decrement will work at index i+1.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : endTime) </span><br><span class="line">            overlap_intervals[i + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Find the overlaps by using prefix sum technique</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) </span><br><span class="line">            overlap_intervals[i+<span class="number">1</span>] += overlap_intervals[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return the overlaps at the given query time.</span></span><br><span class="line">        <span class="keyword">return</span> overlap_intervals[queryTime];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">busyStudent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; startTime, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; endTime, <span class="keyword">int</span> queryTime)</span> </span>&#123;</span><br><span class="line">        sort(startTime.begin(),startTime.end());</span><br><span class="line">        sort(endTime.begin(),endTime.end());</span><br><span class="line">        <span class="keyword">int</span> l = upper_bound(startTime.begin(),startTime.end(),queryTime) - startTime.begin();</span><br><span class="line">        <span class="keyword">int</span> r = lower_bound(endTime.begin(),endTime.end(),queryTime) - endTime.begin();</span><br><span class="line">        <span class="keyword">return</span> l - r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1451-Rearrange-Words-in-a-Sentence"><a href="#1451-Rearrange-Words-in-a-Sentence" class="headerlink" title="1451. Rearrange Words in a Sentence"></a>1451. Rearrange Words in a Sentence</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a sentence <code>text</code> (A sentence is a string of space-separated words) in the following format:</p><ul><li>First letter is in upper case.</li><li>Each word in <code>text</code> are separated by a single space.</li></ul><p>Your task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.</p><p>Return the new text following the format shown above.</p><p>Example 1:<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="keyword">text</span> = <span class="string">"Leetcode is cool"</span></span><br><span class="line">Output: <span class="string">"Is cool leetcode"</span></span><br><span class="line">Explanation: There are <span class="number">3</span> <span class="keyword">words</span>, <span class="string">"Leetcode"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">8</span>, <span class="string">"is"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">2</span> <span class="keyword">and</span> <span class="string">"cool"</span> <span class="keyword">of</span> <span class="built_in">length</span> <span class="number">4.</span></span><br><span class="line">Output is ordered <span class="keyword">by</span> <span class="built_in">length</span> <span class="keyword">and</span> <span class="keyword">the</span> <span class="built_in">new</span> <span class="keyword">first</span> <span class="built_in">word</span> starts <span class="keyword">with</span> capital letter.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="type">text</span> = <span class="string">"Keep calm and code on"</span></span><br><span class="line">Output: <span class="string">"On and keep calm code"</span></span><br><span class="line">Explanation: Output <span class="literal">is</span> ordered <span class="keyword">as</span> follows:</span><br><span class="line"><span class="string">"On"</span> <span class="number">2</span> letters.</span><br><span class="line"><span class="string">"and"</span> <span class="number">3</span> letters.</span><br><span class="line"><span class="string">"keep"</span> <span class="number">4</span> letters <span class="keyword">in</span> <span class="keyword">case</span> <span class="keyword">of</span> tie <span class="keyword">order</span> <span class="keyword">by</span><span class="built_in"> position</span> <span class="keyword">in</span> original <span class="type">text</span>.</span><br><span class="line"><span class="string">"calm"</span> <span class="number">4</span> letters.</span><br><span class="line"><span class="string">"code"</span> <span class="number">4</span> letters.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = "To <span class="keyword">be</span> <span class="keyword">or</span> <span class="keyword">not</span> to <span class="keyword">be</span>"</span><br><span class="line">Output: "To <span class="keyword">be</span> <span class="keyword">or</span> to <span class="keyword">be</span> <span class="keyword">not</span>"</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li>text begins with a capital letter and then contains lowercase letters and single space between words.</li><li><code>1 &lt;= text.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/rearrange-words-in-a-sentence/" target="_blank" rel="noopener">https://leetcode.com/problems/rearrange-words-in-a-sentence/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这种题目特别无聊，就是直接暴力即可，没有一点技巧可言。</li><li>先分词，然后对所有的单词按照长度进行<code>稳定</code>排序，保证单词的顺序与原来保持一致。</li><li>再重写句子，然后将首字母改成大写。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; sv,<span class="keyword">const</span> <span class="keyword">char</span> flag = <span class="string">' '</span>)</span> </span>&#123;</span><br><span class="line">        sv.clear();</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(iss, temp, flag)) &#123;</span><br><span class="line">            sv.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.size() == b.first.size()) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first.size() &lt; b.first.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">lower</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">upper</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="string">'A'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlpha</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (c &gt;= <span class="string">'a'</span>&amp;&amp; c &lt;= <span class="string">'z'</span>)||(c &gt;= <span class="string">'A'</span>&amp;&amp; c &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">arrangeWords</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        </span><br><span class="line">        text[<span class="number">0</span>] = lower(text[<span class="number">0</span>]);</span><br><span class="line">        split(text,words,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); ++i)&#123;</span><br><span class="line">            arr.push_back(make_pair(words[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end(),cmp);</span><br><span class="line">        res += arr[<span class="number">0</span>].first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">           res += <span class="string">' '</span> + arr[i].first;</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isAlpha(res[<span class="number">0</span>]))&#123;</span><br><span class="line">            res[<span class="number">0</span>] = upper(res[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List"><a href="#1452-People-Whose-List-of-Favorite-Companies-Is-Not-a-Subset-of-Another-List" class="headerlink" title="1452. People Whose List of Favorite Companies Is Not a Subset of Another List"></a>1452. People Whose List of Favorite Companies Is Not a Subset of Another List</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given the array favoriteCompanies where <code>favoriteCompanies[i]</code> is the list of favorites companies for the ith person (indexed from 0).</p><p>Return the indices of people whose list of favorite companies is not a subset of any other list of favorites companies. You must return the indices in increasing order.</p><p>Example 1:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>,<span class="string">"microsoft"</span>],[<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"google"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">2</span> has favoriteCompanies[<span class="number">2</span>]=[<span class="string">"google"</span>,<span class="string">"facebook"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] corresponding to the person with index <span class="number">0.</span> </span><br><span class="line"><span class="symbol">Person</span> with index=<span class="number">3</span> has favoriteCompanies[<span class="number">3</span>]=[<span class="string">"google"</span>] which is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>] and favoriteCompanies[<span class="number">1</span>]=[<span class="string">"google"</span>,<span class="string">"microsoft"</span>]. </span><br><span class="line"><span class="symbol">Other</span> lists of favorite companies are not a subset of another list, therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>,<span class="number">4</span>].</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>],[<span class="string">"leetcode"</span>,<span class="string">"amazon"</span>],[<span class="string">"facebook"</span>,<span class="string">"google"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>] </span><br><span class="line"><span class="symbol">Explanation</span>: <span class="symbol">In</span> this case favoriteCompanies[<span class="number">2</span>]=[<span class="string">"facebook"</span>,<span class="string">"google"</span>] is a subset of favoriteCompanies[<span class="number">0</span>]=[<span class="string">"leetcode"</span>,<span class="string">"google"</span>,<span class="string">"facebook"</span>], therefore, the answer is [<span class="number">0</span>,<span class="number">1</span>].</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Input</span>: favoriteCompanies = [[<span class="string">"leetcode"</span>],[<span class="string">"google"</span>],[<span class="string">"facebook"</span>],[<span class="string">"amazon"</span>]]</span><br><span class="line"><span class="symbol">Output</span>: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= favoriteCompanies.length &lt;= 100</code></li><li><code>1 &lt;= favoriteCompanies[i].length &lt;= 500</code></li><li><code>1 &lt;= favoriteCompanies[i][j].length &lt;= 20</code></li><li>All strings in <code>favoriteCompanies[i]</code> are distinct.</li><li>All lists of favorite companies are distinct, that is, If we sort alphabetically each list then <code>favoriteCompanies[i] != favoriteCompanies[j]</code>.</li><li>All strings consist of lowercase English letters only.</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/" target="_blank" rel="noopener">https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目也是直接暴力即可，稍微用点技巧的是可以将字符串改用hash来存储，直接暴力两层循环即可。</li><li>难点在于如何判断两个<code>list</code>存在包含关系，稍微用点技巧，用hash或者双指针均可，即可在O(m)得时间复杂度完成判别。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; a, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = a.size();</span><br><span class="line">        <span class="keyword">int</span> n = b.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>; i &lt; m &amp;&amp; j &lt; n;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; peopleIndexes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            sort(A[i].begin(),A[i].end());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isContain = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(contain(A[i],A[j]))&#123;</span><br><span class="line">                    isContain = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isContain) res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard"><a href="#1453-Maximum-Number-of-Darts-Inside-of-a-Circular-Dartboard" class="headerlink" title="1453. Maximum Number of Darts Inside of a Circular Dartboard"></a>1453. Maximum Number of Darts Inside of a Circular Dartboard</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>You have a very large square wall and a circular dartboard placed on the wall. You have been challenged to throw darts into the board blindfolded. Darts thrown at the wall are represented as an array of points on a 2D plane.<br>Return the maximum number of points that are within or lie on <code>any</code> circular dartboard of radius r.</p><p>Example 1:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">0</span>) <span class="keyword">and</span> radius = <span class="number">2</span> contain all points.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-3</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">9</span>],[<span class="number">7</span>,<span class="number">8</span>]], r = <span class="number">5</span></span><br><span class="line">Output: <span class="number">5</span></span><br><span class="line">Explanation: Circle dartboard with center <span class="keyword">in</span> (<span class="number">0</span>,<span class="number">4</span>) <span class="keyword">and</span> radius = <span class="number">5</span> contain all points except the point (<span class="number">7</span>,<span class="number">8</span>).</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">-2</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">-2</span>]], r = <span class="number">1</span></span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure><br>Example 4:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">-1</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>]], r = <span class="number">2</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>Constraints:</p><ul><li><code>1 &lt;= points.length &lt;= 100</code></li><li><code>points[i].length == 2</code></li><li><code>-10^4 &lt;= points[i][0], points[i][1] &lt;= 10^4</code></li><li><code>1 &lt;= r &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/" target="_blank" rel="noopener">https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>遇到这种图论或者数学问题果真不会解答，直接参考答案。<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Enumerate all combinations <span class="keyword">of</span> <span class="number">2</span> points,</span><br><span class="line">find <span class="keyword">the</span> circle going <span class="keyword">through</span> them <span class="keyword">with</span> radius = r.</span><br><span class="line"></span><br><span class="line">Use this circumcenter <span class="keyword">as</span> <span class="keyword">the</span> center <span class="keyword">of</span> circle,</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">count</span> how many points inside.</span><br><span class="line"></span><br><span class="line">Also explained <span class="keyword">by</span> Alexandre C:</span><br><span class="line">Basic observations :</span><br><span class="line"></span><br><span class="line">    I assume <span class="keyword">the</span> radius <span class="keyword">is</span> one,</span><br><span class="line">    <span class="keyword">since</span> <span class="keyword">it</span> doesn't change anything.</span><br><span class="line">    <span class="keyword">given</span> any two points,</span><br><span class="line">    there exists <span class="keyword">at</span> most two unit circles <span class="keyword">on</span> which they lie.</span><br><span class="line">    <span class="keyword">given</span> a solution circle <span class="keyword">to</span> your problem,</span><br><span class="line">    you can move <span class="keyword">it</span> <span class="keyword">until</span> <span class="keyword">it</span> <span class="keyword">contains</span> two points <span class="keyword">of</span> your <span class="keyword">set</span></span><br><span class="line">    <span class="keyword">while</span> keeping <span class="keyword">the</span> same <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside <span class="keyword">it</span>.</span><br><span class="line"></span><br><span class="line">The algorithm <span class="keyword">is</span> <span class="keyword">then</span>:</span><br><span class="line"></span><br><span class="line">    For each pair <span class="keyword">of</span> points,</span><br><span class="line">    <span class="keyword">if</span> their distance <span class="keyword">is</span> &lt; <span class="number">2</span>,</span><br><span class="line">    compute <span class="keyword">the</span> two unit circles C1 <span class="keyword">and</span> C2 <span class="keyword">that</span> pass <span class="keyword">through</span> them.</span><br><span class="line">    Compute <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> points <span class="keyword">of</span> your <span class="keyword">set</span> inside C1 <span class="keyword">and</span> C2</span><br><span class="line">    Take <span class="keyword">the</span> max.</span><br></pre></td></tr></table></figure></li><li>涉及到图论中的相关数学知识，还是没有学过。如果一个圆 C 能覆盖点集 S，当S包含两个及以上数量的点时，我们可以将园进行平移移动 C 找到一个 C’，使得 C’ 也能覆盖 S，且至少有两个点在 C’ 上。这个证明就很复杂了，感兴趣的还是看看数学定理吧。<br><img src="https://mike-box.github.io/images/163-2.png" alt="2"></li><li>现在我们已经知道园上两点的坐标和园的半径，求圆心。根据学过的解析几何，很容易将圆心的坐标求出来。实际圆心可能由两种情况，如图所示的A,B两点为可能的圆心。<br><img src="https://mike-box.github.io/images/163-4.png" alt="3"></li><li>又把解析几何稍微复习了一下，上面使一些递推公式，稍微复杂点，大意就是起点坐标加上单位向量乘以长度。推公式还是非常有意思的。<script type="math/tex; mode=display">(x^{'},y^{'}) = (x,y) + (x_{d},y_{d})*h</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1 = points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y1 = points[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> x2 = points[j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> y2 = points[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">double</span> d = <span class="built_in">sqrt</span>((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));</span><br><span class="line">                <span class="keyword">if</span>(d &gt; r*<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> x0 = (x1+x2)/<span class="number">2.0</span> + (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">double</span> y0 = (y1+y2)/<span class="number">2.0</span> - (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                x0 = (x1+x2)/<span class="number">2.0</span> - (y2 - y1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                y0 = (y1+y2)/<span class="number">2.0</span> + (x2 - x1)*<span class="built_in">sqrt</span>(r*r - d*d/<span class="number">4</span>)/d;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = points[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = points[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>((x0-x)*(x0-x) + (y0-y)*(y0-y) &lt;= r*r + <span class="number">0.00001</span>)&#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;189周周赛&quot;&gt;&lt;a href=&quot;#189周周赛&quot; class=&quot;headerlink&quot; title=&quot;189周周赛&quot;&gt;&lt;/a&gt;189周周赛&lt;/h1&gt;&lt;p&gt;还是周赛质量稍微高一些。&lt;/p&gt;&lt;h2 id=&quot;1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot;&gt;&lt;a href=&quot;#1450-Number-of-Students-Doing-Homework-at-a-Given-Time&quot; class=&quot;headerlink&quot; title=&quot;1450. Number of Students Doing Homework at a Given Time&quot;&gt;&lt;/a&gt;1450. Number of Students Doing Homework at a Given Time&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two integer arrays startTime and endTime and given an integer queryTime.&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 26周双周赛</title>
    <link href="http://yoursite.com/2020/05/17/161/"/>
    <id>http://yoursite.com/2020/05/17/161/</id>
    <published>2020-05-16T16:09:54.635Z</published>
    <updated>2020-05-16T16:10:00.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26周双周赛"><a href="#26周双周赛" class="headerlink" title="26周双周赛"></a>26周双周赛</h1><p>前三题非常简单，最后一题稍微复杂点。</p><h2 id="5396-连续字符"><a href="#5396-连续字符" class="headerlink" title="5396. 连续字符"></a>5396. 连续字符</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。</p><p>请你返回字符串的能量。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子字符串 <span class="string">"ee"</span> 长度为 <span class="number">2</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbcccddddeeeeedcba"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：子字符串 <span class="string">"eeeee"</span> 长度为 <span class="number">5</span> ，只包含字符 'e' 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"triplepillooooow"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"hooraaaaaaaaaaay"</span></span><br><span class="line">输出：<span class="number">11</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"tourist"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 只包含小写英文字母。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/consecutive-characters/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接暴力滑动窗口统计相同的字符数目即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPower</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">char</span> curr = s[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == curr)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res = max(res,count);</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">                curr = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res,count);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5397-最简分数"><a href="#5397-最简分数" class="headerlink" title="5397. 最简分数"></a>5397. 最简分数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你返回所有 <code>0</code>到 <code>1</code> 之间（不包括 0 和 1）满足分母小于等于  <code>n</code>的 最简 分数 。分数可以以 任意 顺序返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>]</span><br><span class="line">解释：<span class="string">"1/2"</span> 是唯一一个分母小于等于 <span class="number">2</span> 的最简分数。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"2/3"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"1/2"</span>,<span class="string">"1/3"</span>,<span class="string">"1/4"</span>,<span class="string">"2/3"</span>,<span class="string">"3/4"</span>]</span><br><span class="line">解释：<span class="string">"2/4"</span> 不是最简分数，因为它可以化简为 <span class="string">"1/2"</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="string">[]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/simplified-fractions/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中的<code>n</code>最大只有100，所以根本就不用技巧了，直接暴力求出所有可能的分数，然后化简分数，去掉重复的数即可。</li><li>去重的方法有很多种，我这里用的hash。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; simplifiedFractions(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; count;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> g = __gcd(i,j);</span><br><span class="line">                <span class="keyword">int</span> x = i/g;</span><br><span class="line">                <span class="keyword">int</span> y = j/g;</span><br><span class="line">                <span class="built_in">string</span> s = to_string(x) + <span class="string">"/"</span> + to_string(y);</span><br><span class="line">                count.insert(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : count)&#123;</span><br><span class="line">            res.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5398-统计二叉树中好节点的数目"><a href="#5398-统计二叉树中好节点的数目" class="headerlink" title="5398. 统计二叉树中好节点的数目"></a>5398. 统计二叉树中好节点的数目</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵根为 <code>root</code> 的二叉树，请你返回二叉树中好节点的数目。</p><p>「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：图中蓝色节点为好节点。</span><br><span class="line">根节点 (<span class="number">3</span>) 永远是个好节点。</span><br><span class="line">节点 <span class="number">4</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">5</span> -&gt; (<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) 是路径中的最大值。</span><br><span class="line">节点 <span class="number">3</span> -&gt; (<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>) 是路径中的最大值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">3</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：节点 <span class="number">2</span> -&gt; (<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>) 不是好节点，因为 <span class="string">"3"</span> 比它大。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：根节点是好节点。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>二叉树中节点数目范围是<code>[1, 10^5]</code>。</li><li>每个节点权值的范围是 <code>[-10^4, 10^4]</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/count-good-nodes-in-binary-tree/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目咋一看貌似很复杂，实际一分析非常简单，直接DFS搞定。</li><li>DFS时每次传输从根节点到该节点路劲上的最大值，判断当前的节点的值是否大于等于路径的最大值即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> maxCurr,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt;= maxCurr)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        maxCurr = max(root-&gt;val,maxCurr);</span><br><span class="line">        dfs(root-&gt;left,maxCurr,res);</span><br><span class="line">        dfs(root-&gt;right,maxCurr,res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">goodNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        dfs(root,INT_MIN,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5399-数位成本和为目标值的最大数字"><a href="#5399-数位成本和为目标值的最大数字" class="headerlink" title="5399. 数位成本和为目标值的最大数字"></a>5399. 数位成本和为目标值的最大数字</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>cost</code> 和一个整数 <code>target</code>。请你返回满足如下规则可以得到的 最大 整数：</p><ul><li>给当前结果添加一个数位<code>（i + 1）</code>的成本为 <code>cost[i]</code> （<code>cost</code> 数组下标从 0 开始）。</li><li>总成本必须恰好等于 <code>target</code>。</li><li>添加的数位中没有数字 0 。</li></ul><p>由于答案可能会很大，请你以字符串形式返回。</p><p>如果按照上述要求无法得到任何整数，请你返回 “0” 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">5</span>], target = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"7772"</span></span><br><span class="line">解释：添加数位 '<span class="number">7</span>' 的成本为 <span class="number">2</span> ，添加数位 '<span class="number">2</span>' 的成本为 <span class="number">3</span> 。所以 <span class="string">"7772"</span> 的代价为 <span class="number">2</span>*<span class="number">3</span>+ <span class="number">3</span>*<span class="number">1</span> = <span class="number">9</span> 。 <span class="string">"997"</span> 也是满足要求的数字，但 <span class="string">"7772"</span> 是较大的数字。</span><br><span class="line"> 数字     成本</span><br><span class="line">  <span class="number">1</span>  -&gt;   <span class="number">4</span></span><br><span class="line">  <span class="number">2</span>  -&gt;   <span class="number">3</span></span><br><span class="line">  <span class="number">3</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">4</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">5</span>  -&gt;   <span class="number">6</span></span><br><span class="line">  <span class="number">6</span>  -&gt;   <span class="number">7</span></span><br><span class="line">  <span class="number">7</span>  -&gt;   <span class="number">2</span></span><br><span class="line">  <span class="number">8</span>  -&gt;   <span class="number">5</span></span><br><span class="line">  <span class="number">9</span>  -&gt;   <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">8</span>], target = <span class="number">12</span></span><br><span class="line">输出：<span class="string">"85"</span></span><br><span class="line">解释：添加数位 '<span class="number">8</span>' 的成本是 <span class="number">7</span> ，添加数位 '<span class="number">5</span>' 的成本是 <span class="number">5</span> 。<span class="string">"85"</span> 的成本为 <span class="number">7</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], target = <span class="number">5</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：总成本是 target 的条件下，无法生成任何整数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：cost = [<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>,<span class="number">40</span>], target = <span class="number">47</span></span><br><span class="line">输出：<span class="string">"32211"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>cost.length == 9</code></li><li><code>1 &lt;= cost[i] &lt;= 5000</code></li><li><code>1 &lt;= target &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-26/problems/form-largest-integer-with-digits-that-add-up-to-target/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  0-1背包问题</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的0-1背包问题，给定的重量下，有无数的货物，如何取货物使得背包的价值最大。</li><li>在这里背包的重量即为<code>target</code>,每个货物的重量即为<code>cost</code>,价值即为组成的数。</li><li>稍微复杂点的数如何表示，假设我们直接用字符串来表示已经取得货物的价值时，肯定会出现内存超出或者超时的问题，仔细分析一下，我们用一个数据统计已经取得所有数目<code>1~9</code>的个数。每次进行价值比较时，我们首先比较数字的个数，如果数字的个数相同，则比较数目的大小即可，具体可以参考代码。</li><li>直接dp即可。<script type="math/tex; mode=display">dp[i] = max(dp[i],dp[i-cost[j]] + j)</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cntb = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            cnta += a[i];</span><br><span class="line">            cntb += b[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnta &gt; cntb) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnta &lt; cntb) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; b[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(b[i] &gt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a[i]; ++j)&#123;</span><br><span class="line">                res += to_string(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(target+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>,<span class="number">-1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= <span class="number">9</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;= cost[j<span class="number">-1</span>] &amp;&amp; valid(dp[i-cost[j<span class="number">-1</span>]]))&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev = dp[i-cost[j<span class="number">-1</span>]];</span><br><span class="line">                    prev[j]++;</span><br><span class="line">                    <span class="keyword">if</span>(!valid(dp[i])||compare(prev,dp[i]))&#123;</span><br><span class="line">                        dp[i] = prev;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!valid(dp[target])) <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> generNum(dp[target]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;26周双周赛&quot;&gt;&lt;a href=&quot;#26周双周赛&quot; class=&quot;headerlink&quot; title=&quot;26周双周赛&quot;&gt;&lt;/a&gt;26周双周赛&lt;/h1&gt;&lt;p&gt;前三题非常简单，最后一题稍微复杂点。&lt;/p&gt;&lt;h2 id=&quot;5396-连续字符&quot;&gt;&lt;a href=&quot;#5396-连续字符&quot; class=&quot;headerlink&quot; title=&quot;5396. 连续字符&quot;&gt;&lt;/a&gt;5396. 连续字符&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。&lt;/p&gt;&lt;p&gt;请你返回字符串的能量。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;ee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abbcccddddeeeeedcba&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：子字符串 &lt;span class=&quot;string&quot;&gt;&quot;eeeee&quot;&lt;/span&gt; 长度为 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; ，只包含字符 &#39;e&#39; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;triplepillooooow&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;hooraaaaaaaaaaay&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;tourist&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程《Algorithms on Graphs》</title>
    <link href="http://yoursite.com/2020/05/10/160/"/>
    <id>http://yoursite.com/2020/05/10/160/</id>
    <published>2020-05-10T12:09:15.322Z</published>
    <updated>2020-05-10T12:09:20.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Graphs"><a href="#Algorithmic-Graphs" class="headerlink" title="Algorithmic Graphs"></a>Algorithmic Graphs</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是比较容易的题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6" target="_blank" rel="noopener">Algorithms on Graphs</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs" target="_blank" rel="noopener">source code</a><br>总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。</p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Problem-Finding-an-Exit-from-a-Maze"><a href="#1-Problem-Finding-an-Exit-from-a-Maze" class="headerlink" title="1. Problem: Finding an Exit from a Maze"></a>1. Problem: Finding an Exit from a Maze</h3><p>A maze is a rectangular grid of cells with walls between some of adjacent cells.<br>You would like to check whether there is a path from a given cell to a given<br>exit from a maze where an exit is also a cell that lies on the border of the maze<br>(in the example shown to the right there are two exits: one on the left border<br>and one on the right border). For this, you represent the maze as an undirected<br>graph: vertices of the graph are cells of the maze, two vertices are connected by<br>an undirected edge if they are adjacent and there is no wall between them. Then,<br>to check whether there is a path between two given cells in the maze, it suffices to<br>check that there is a path between the corresponding two vertices in the graph.<br><strong>Task</strong>. Given an undirected graph and two distinct vertices 𝑢 and 𝑣, check if there is a path between 𝑢 and 𝑣.<br><strong>Input Format</strong>. An undirected graph with 𝑛 vertices and 𝑚 edges. The next line contains two vertices 𝑢<br>and 𝑣 of the graph.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 103; 1 ≤ 𝑚 ≤ 103; 1 ≤ 𝑢, 𝑣 ≤ 𝑛; 𝑢 ̸= 𝑣.<br><strong>Output Format</strong>. Output 1 if there is a path between 𝑢 and 𝑣 and 0 otherwise.</p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> BFS</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>最基本的BFS路径搜索<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reach</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">  visit.insert(x);</span><br><span class="line">  qu.push(x);</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line">      <span class="keyword">if</span>(curr == y) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">          qu.push(v);</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> x, y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reach(adj, x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Problem-Adding-Exits-to-a-Maze"><a href="#2-Problem-Adding-Exits-to-a-Maze" class="headerlink" title="2 Problem: Adding Exits to a Maze"></a>2 Problem: Adding Exits to a Maze</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, compute the number of connected components in it.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 103.<br><strong>Output Format</strong>. Output the number of connected components.</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.最基本的查找图的连通单元，用BFS或者并查集实现均可。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(visit.count(i)) <span class="keyword">continue</span>;</span><br><span class="line">      qu.push(i);</span><br><span class="line">      visit.insert(i);</span><br><span class="line">      res++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit.insert(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><p>第一题比较简单</p><h3 id="2-Determining-an-Order-of-Courses"><a href="#2-Determining-an-Order-of-Courses" class="headerlink" title="2. Determining an Order of Courses"></a>2. Determining an Order of Courses</h3><p><strong>Task</strong>. Compute a topological ordering of a given directed acyclic graph (DAG) with 𝑛 vertices and 𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105. The given graph is guaranteed to be acyclic.<br><strong>Output Format</strong>. Output any topological ordering of its vertices. (Many DAGs have more than just one topological ordering. You may output any of them.)</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>很直接的拓扑排序<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;used, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;order, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; toposort(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj) &#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; used(adj.size(), <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(adj.size(),<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">          indegree[adj[i][j]]++;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">          qu.push(i);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">      order.push_back(curr);</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">          indegree[v]--;</span><br><span class="line">          <span class="keyword">if</span>(indegree[v] == <span class="number">0</span>)&#123;</span><br><span class="line">              qu.push(v);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order = toposort(adj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; order.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; order[i] + <span class="number">1</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City"><a href="#3-Advanced-Problem-Checking-Whether-Any-Intersection-in-a-City" class="headerlink" title="3. Advanced Problem: Checking Whether Any Intersection in a City"></a>3. Advanced Problem: Checking Whether Any Intersection in a City</h3><p><strong>Task</strong>. Compute the number of strongly connected components of a given directed graph with 𝑛 vertices and<br>𝑚 edges.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 104, 0 ≤ 𝑚 ≤ 104.<br><strong>Output Format</strong>. Output the number of strongly connected components.</p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>求有向图的连通分量，SCC算法。先用DFS遍历图，并且将图的节点保存到栈中，然后每次从栈中弹出一个元素，DFS遍历遍历逆向图即可，得到SCC分量。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,v,s,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(curr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj,<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[v] = <span class="literal">true</span>;</span><br><span class="line">        dfs2(adj,v,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">number_of_strongly_connected_components</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; adj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; reverseAdj(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit1(n,<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit2(n,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            reverseAdj[adj[i][j]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit1[i]) <span class="keyword">continue</span>;</span><br><span class="line">        visit1[i] = <span class="literal">true</span>;</span><br><span class="line">        dfs1(adj,i,post,visit1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!post.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = post.top();</span><br><span class="line">        post.pop();</span><br><span class="line">        <span class="keyword">if</span>(visit2[curr]) <span class="keyword">continue</span>;</span><br><span class="line">        visit2[curr] = <span class="literal">true</span>;</span><br><span class="line">        result++;</span><br><span class="line">        dfs2(reverseAdj,curr,visit2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; number_of_strongly_connected_components(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week-3-Paths-in-Graphs"><a href="#week-3-Paths-in-Graphs" class="headerlink" title="week 3 Paths in Graphs"></a>week 3 Paths in Graphs</h2><p>dijistra求最短距离</p><h3 id="1-Problem-Computing-the-Minimum-Number-of-Flight-Segments"><a href="#1-Problem-Computing-the-Minimum-Number-of-Flight-Segments" class="headerlink" title="1. Problem: Computing the Minimum Number of Flight Segments"></a>1. Problem: Computing the Minimum Number of Flight Segments</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges and two vertices 𝑢 and 𝑣, compute the length of a shortest path between 𝑢 and 𝑣 (that is, the minimum number of edges in a path from 𝑢 to 𝑣).<br><strong>Input Format</strong>. A graph is given in the standard format. The next line contains two vertices 𝑢 and 𝑣.<br><strong>Constraints</strong>. 2 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105, 𝑢 ̸= 𝑣, 1 ≤ 𝑢, 𝑣 ≤ 𝑛.<br><strong>Output Format</strong>. Output the minimum number of edges in a path from 𝑢 to 𝑣, or −1 if there is no path.</p><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历图，求最短路径。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  qu.push(s);</span><br><span class="line">  visit[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">          qu.pop();</span><br><span class="line">          <span class="keyword">if</span>(curr == t) <span class="keyword">return</span> step;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">              <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">              qu.push(v);</span><br><span class="line">              visit[v] = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      step++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Checking-whether-a-Graph-is-Bipartite"><a href="#2-Problem-Checking-whether-a-Graph-is-Bipartite" class="headerlink" title="2. Problem: Checking whether a Graph is Bipartite"></a>2. Problem: Checking whether a Graph is Bipartite</h3><p><strong>Task</strong>. Given an undirected graph with 𝑛 vertices and 𝑚 edges, check whether it is bipartite.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 105, 0 ≤ 𝑚 ≤ 105.<br><strong>Output Format</strong>. Output 1 if the graph is bipartite and 0 otherwise.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>BFS遍历即可，非常简单，leetcode也有原题。<h5 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> WHITE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BLACK = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  qu.push(make_pair(<span class="number">0</span>,WHITE));</span><br><span class="line">  visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  color[<span class="number">0</span>] = WHITE;</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr.first])&#123;</span><br><span class="line">          <span class="keyword">if</span>(visit[v])&#123;</span><br><span class="line">              <span class="keyword">if</span>(color[curr.first] == color[v]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          qu.push(make_pair(v,!curr.second));</span><br><span class="line">          visit[v] = <span class="literal">true</span>;</span><br><span class="line">          color[v] = !curr.second;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    adj[y - <span class="number">1</span>].push_back(x - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bipartite(adj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Paths-in-Graphs"><a href="#week4-Paths-in-Graphs" class="headerlink" title="week4: Paths in Graphs"></a>week4: Paths in Graphs</h2><p>这章主要是dijistra算法和bellman ford算法</p><h3 id="Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="Problem: Detecting Anomalies in Currency Exchange Rates"></a>Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>直接用dijistra算法求最短距离即可<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code her</span></span><br><span class="line">  <span class="keyword">int</span> n = adj.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,INT_MAX);</span><br><span class="line">  <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line"></span><br><span class="line">  dist[s] = <span class="number">0</span>;</span><br><span class="line">  qu.push(make_pair(s,<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">      pii curr = qu.front();</span><br><span class="line">      qu.pop();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[curr.first].size(); ++i)&#123;</span><br><span class="line">          <span class="keyword">int</span> v = adj[curr.first][i];</span><br><span class="line">          <span class="keyword">int</span> w = cost[curr.first][i];</span><br><span class="line">          <span class="keyword">if</span>((curr.second + w) &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = curr.second + w;</span><br><span class="line">              qu.push(make_pair(v,dist[v]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(dist[t] == INT_MAX) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> s, t;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; t;</span><br><span class="line">  s--, t--;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance(adj, cost, s, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates"><a href="#2-Problem-Detecting-Anomalies-in-Currency-Exchange-Rates" class="headerlink" title="2. Problem: Detecting Anomalies in Currency Exchange Rates"></a>2. Problem: Detecting Anomalies in Currency Exchange Rates</h3><p><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges, check<br>whether it contains a cycle of negative weight.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, edge weights are integers of absolute value at most 103.<br><strong>Output Format</strong>. Output 1 if the graph contains a cycle of negative weight and 0 otherwise.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>求图中是否有和为负的有向环，直接BF算法。先进行<code>v-1</code>次循环对边进行叠加，再进行一次循环进行迭代，经过V次循环后，如果发现仍有边可以迭代，则认为此时该图中存在负的有向环。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">relax</span><span class="params">(Edge &amp; e,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; dist,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; parent)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negative_cycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;cost)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dist(n,<span class="number">1e9</span>+<span class="number">7</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">        <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">        <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;u&lt;&lt;":"&lt;&lt;v&lt;&lt;" ="&lt;&lt;w&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; negative_cycle(adj, cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Advanced-Problem-Exchanging-Money-Optimally"><a href="#3-Advanced-Problem-Exchanging-Money-Optimally" class="headerlink" title="3. Advanced Problem: Exchanging Money Optimally"></a>3. Advanced Problem: Exchanging Money Optimally</h3><strong>Task</strong>. Given an directed graph with possibly negative edge weights and with 𝑛 vertices and 𝑚 edges as well as its vertex 𝑠, compute the length of shortest paths from 𝑠 to all other vertices of the graph.<br><strong>Input Format</strong>. A graph is given in the standard format.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 103, 0 ≤ 𝑚 ≤ 104, 1 ≤ 𝑠 ≤ 𝑛, edge weights are integers of absolute value at most 109.<br><strong>Output Format</strong>. For all vertices 𝑖 from 1 to 𝑛 output the following on a separate line:<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目也比较简单，<code>bellman-ford</code>算法，先进行V次迭代后，将所有还可继续迭代的节点入队列，然后用BFS算法，将所有这些可迭代的点遍历，所有可以达到的点，都认为不存在最小值。<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::priority_queue;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Edge(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> weight)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;u = u;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v = v;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortest_paths</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;adj, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;cost, <span class="keyword">int</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &amp;distance, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;reachable, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;shortest)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//write your code here</span></span><br><span class="line">    <span class="keyword">int</span> n = adj.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dist(n,INT_MAX);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent(n,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check edges*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j)&#123;</span><br><span class="line">            edges.push_back(Edge(i,adj[i][j],cost[i][j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bell-man */</span></span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.size(); ++j)&#123;</span><br><span class="line">          <span class="keyword">int</span> u = edges[j].u;</span><br><span class="line">          <span class="keyword">int</span> v = edges[j].v;</span><br><span class="line">          <span class="keyword">int</span> w = edges[j].weight;</span><br><span class="line">          <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">              dist[v] = w + dist[u];</span><br><span class="line">              parent[v] = u;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check cycle*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> u = edges[i].u;</span><br><span class="line">      <span class="keyword">int</span> v = edges[i].v;</span><br><span class="line">      <span class="keyword">int</span> w = edges[i].weight;</span><br><span class="line">      <span class="comment">// get all relaxed node</span></span><br><span class="line">      <span class="keyword">if</span>(dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])&#123;</span><br><span class="line">          visit.insert(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : visit)&#123;</span><br><span class="line">        qu.push(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">        qu.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : adj[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">            qu.push(v);</span><br><span class="line">            visit.insert(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*check answer*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] == INT_MAX)&#123;</span><br><span class="line">            reachable[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reachable[i] = <span class="number">1</span>;</span><br><span class="line">            distance[i] = dist[i];</span><br><span class="line">            <span class="keyword">if</span>(visit.count(i)) shortest[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; adj(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; cost(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">    adj[x - <span class="number">1</span>].push_back(y - <span class="number">1</span>);</span><br><span class="line">    cost[x - <span class="number">1</span>].push_back(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  s--;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; distance(n, <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;::max());</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reachable(n, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shortest(n, <span class="number">1</span>);</span><br><span class="line">  shortest_paths(adj, cost, s, distance, reachable, shortest);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!reachable[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shortest[i]) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-\n"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; distance[i] &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="Problem-Building-Roads-to-Connect-Cities"><a href="#Problem-Building-Roads-to-Connect-Cities" class="headerlink" title="Problem: Building Roads to Connect Cities"></a>Problem: Building Roads to Connect Cities</h3><p><strong>Task</strong>. Given 𝑛 points on a plane, connect them with segments of minimum total length such that there is a<br>path between any two points. Recall that the length of a segment with endpoints (𝑥1, 𝑦1) and (𝑥2, 𝑦2)<br>is equal to<br>√︀<br>(𝑥1 − 𝑥2)2 + (𝑦1 − 𝑦2)2.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖).<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different, no three<br>points lie on the same line.<br><strong>Output Format</strong>. Output the minimum total length of segments. The absolute value of the difference<br>between the answer of your program and the optimal value should be at most 10−6. To ensure this,<br>output your answer with at least seven digits after the decimal point (otherwise your answer, while<br>being computed correctly, can turn out to be wrong because of rounding issues).</p><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>最小生成树，求最短距离。</li><li>重点考察对并查集的应用，<code>kruskal</code> 算法中常用的求最短距离。<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">int</span> y;</span><br><span class="line">  <span class="keyword">double</span> d;</span><br><span class="line">  Node(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">double</span> d)&#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">      <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">      <span class="keyword">this</span>-&gt;d = d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.d &gt; b.d;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != f[x])&#123;</span><br><span class="line">        x = f[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    <span class="keyword">if</span>(x1 == y1) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimum_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> distance = [&amp;](<span class="keyword">int</span> p1,<span class="keyword">int</span> p2)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[p1]-x[p2],<span class="number">2</span>) + <span class="built_in">pow</span>(y[p1]-y[p2],<span class="number">2</span>));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          pq.push(Node(i,j,distance(i,j)));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(!pq.empty())&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(find(f,x) == find(f,y)) <span class="keyword">continue</span>;</span><br><span class="line">      uni(f,x,y);</span><br><span class="line">      result += curr.d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; minimum_distance(x, y) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p><strong>Task</strong>. Given 𝑛 points on a plane and an integer 𝑘, compute the largest possible value of 𝑑 such that the<br>given points can be partitioned into 𝑘 non-empty subsets in such a way that the distance between any<br>two points from different subsets is at least 𝑑.<br><strong>Input Format</strong>. The first line contains the number 𝑛 of points. Each of the following 𝑛 lines defines a point<br>(𝑥𝑖, 𝑦𝑖). The last line contains the number 𝑘 of clusters.<br><strong>Constraints</strong>. 2 ≤ 𝑘 ≤ 𝑛 ≤ 200; −103 ≤ 𝑥𝑖, 𝑦𝑖 ≤ 103 are integers. All points are pairwise different.<br><strong>Output Format</strong>. Output the largest value of 𝑑. The absolute value of the difference between the answer of<br>your program and the optimal value should be at most 10−6. To ensure this, output your answer with<br>at least seven digits after the decimal point (otherwise your answer, while being computed correctly,<br>can turn out to be wrong because of rounding issues).</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>典型的<code>kruskal</code>算法的变种，求最短距离时进行集合合并。</li><li>当合并的单元到达<code>k</code>时，求出最长满足要求的边即可。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> distance;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    Node(<span class="keyword">double</span> d,<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;distance = d;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=f[x]) x = f[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = find(f,x);</span><br><span class="line">    <span class="keyword">int</span> y1 = find(f,y);</span><br><span class="line">    f[x1] = y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node &amp; a,<span class="keyword">const</span> Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.distance &gt; b.distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCluster</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; f)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.size(); ++i)&#123;</span><br><span class="line">        visit.insert(find(f,i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)visit.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">clustering</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="keyword">int</span> count = n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f(n,<span class="number">0</span>);</span><br><span class="line">  priority_queue&lt;Node,<span class="built_in">vector</span>&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      f[i] = i;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(x[i]-x[j],<span class="number">2</span>) + <span class="built_in">pow</span>(y[i]-y[j],<span class="number">2</span>));</span><br><span class="line">          pq.push(Node(d,i,j));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!pq.empty() &amp;&amp; count &gt;= k)&#123;</span><br><span class="line">      Node curr = pq.top();</span><br><span class="line">      pq.pop();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> x = curr.x;</span><br><span class="line">      <span class="keyword">int</span> y = curr.y;</span><br><span class="line">      <span class="keyword">if</span>(find(f,x) != find(f,y))&#123;</span><br><span class="line">          uni(f,x,y);</span><br><span class="line">          count--;   </span><br><span class="line">      &#125;</span><br><span class="line">      d = max(d,curr.distance);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="keyword">int</span> k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n), y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">10</span>) &lt;&lt; clustering(x, y, k) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Graphs&quot;&gt;&lt;a href=&quot;#Algorithmic-Graphs&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Graphs&quot;&gt;&lt;/a&gt;Algorithmic Graphs&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，已经把第二部分课程《Algorithmic Toolbox》学习完了，图的前5章比较简单，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是比较容易的题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/TS4US3YKWDB6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithms on Graphs&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithms%20on%20graphs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;br&gt;总的来说，这个课程比另外两个课程简单一些，当然还有最后一节图的高级应用，还是稍微复杂一些，目前正在学习中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithms on Graphs》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithms-on-Graphs%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 181周比赛</title>
    <link href="http://yoursite.com/2020/05/10/159/"/>
    <id>http://yoursite.com/2020/05/10/159/</id>
    <published>2020-05-10T09:31:20.124Z</published>
    <updated>2020-05-10T09:31:26.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="181周比赛"><a href="#181周比赛" class="headerlink" title="181周比赛"></a>181周比赛</h1><p>周赛的题目质量果真非常高。</p><h2 id="5404-用栈操作构建数组"><a href="#5404-用栈操作构建数组" class="headerlink" title="5404. 用栈操作构建数组"></a>5404. 用栈操作构建数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个目标数组 <code>target</code>和一个整数 <code>n</code>。每次迭代，需要从  <code>list = {1,2,3..., n}</code> 中依序读取一个数字。</p><p>请使用下述操作来构建目标数组 <code>target</code> ：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Push：从 </span>list 中读取一个新元素， 并将其推入数组中。</span><br><span class="line"><span class="keyword">Pop：删除数组中的最后一个元素。</span></span><br><span class="line"><span class="keyword">如果目标数组构建完成，就停止读取更多元素。</span></span><br></pre></td></tr></table></figure><br>题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。</p><a id="more"></a><p>请返回构建目标数组所用的操作序列。</p><p>题目数据保证答案是唯一的。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释： </span><br><span class="line">读取 <span class="number">1</span> 并自动推入数组 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">2</span> 并自动推入数组，然后删除它 -&gt; [<span class="number">1</span>]</span><br><span class="line">读取 <span class="number">3</span> 并自动推入数组 -&gt; [<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br><span class="line">解释：只需要读取前 <span class="number">2</span> 个数字就可以停止。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span></span><br><span class="line">输出：[<span class="string">"Push"</span>,<span class="string">"Pop"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>,<span class="string">"Push"</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= target.length &lt;= 1001 &lt;= target[i] &lt;= 1001 &lt;= n &lt;= 100target 是严格递增的</code></pre><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-an-array-with-stack-operations" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-an-array-with-stack-operations</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前的最大值，如果发现当前的值小于序列的值，则进行”push”和“pop”双操作。</li><li>如果当前的值等于序列的值，则只进行<code>push</code>操作即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; buildArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(start &lt; target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                res.push_back(<span class="string">"Pop"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(start == target[i])&#123;</span><br><span class="line">                res.push_back(<span class="string">"Push"</span>);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5405-形成两个异或相等数组的三元组数目"><a href="#5405-形成两个异或相等数组的三元组数目" class="headerlink" title="5405. 形成两个异或相等数组的三元组数目"></a>5405. 形成两个异或相等数组的三元组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>arr</code> 。</p><p>现需要从数组中取三个下标 <code>i、j</code>和 k ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p><p><code>a</code>和 <code>b</code>定义如下：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">a</span> = arr[i]<span class="regexp"> ^</span> arr[i + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[j - <span class="number">1</span>]</span><br><span class="line">b = arr[j]<span class="regexp"> ^</span> arr[j + <span class="number">1</span>]<span class="regexp"> ^</span> ...<span class="regexp"> ^</span> arr[k]</span><br></pre></td></tr></table></figure><br>注意：^ 表示 按位异或 操作。</p><p>请返回能够令 <code>a == b</code> 成立的三元组<code>(i, j , k)</code> 的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：满足题意的三元组分别是 (<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>), (<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>), (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) 以及 (<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">17</span>,<span class="number">22</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>&lt;= arr.length &lt;= <span class="number">300</span></span><br><span class="line"><span class="symbol">1 </span>&lt;= arr[i] &lt;= <span class="number">10</span>^<span class="number">8</span></span><br></pre></td></tr></table></figure><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学运算</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们可以数学运算公式如下：<script type="math/tex; mode=display">xor(i,j) = arr[i]\bigoplus arr[i+1]\bigoplus arr[i+2]\bigoplus arr[i+3]\bigoplus arr[i+4]\bigoplus arr[i+5]\bigoplus... arr[j]\bigoplus</script>我们知道假如<script type="math/tex; mode=display">a \bigoplus b = 0</script>则一定是可以得到<strong>a == b</strong>.</li><li>实际过程中，我们可以按照如下将<code>xor(i,j) = 0</code>按照如下来分解：<script type="math/tex; mode=display">xor(i,j) = \left\{\begin{aligned}xor(i,i)\bigoplus xor(i+1,j) = 0 \\xor(i,i+1)\bigoplus xor(i+2,j)  = 0\\xor(i,i+2)\bigoplus xor(i+3,j)  = 0\\...                           \\xor(i,j-2)\bigoplus xor(j-1,j) = 0 \\xor(i,j-1)\bigoplus xor(j,j) = 0 \\\end{aligned}\right.</script>按照我们的推算则应该有如下等式成立：<script type="math/tex; mode=display">\left\{\begin{aligned}xor(i,i) ==  xor(i+1,j) \\xor(i,i+1) ==  xor(i+2,j) \\xor(i,i+2) ==  xor(i+3,j) \\...                           \\xor(i,j-2) == xor(j-1,j)  \\xor(i,j-1) == xor(j,j)  \\\end{aligned}\right.</script>因此总共有<code>j-i</code>种组合满足题目要求。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mask(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            mask[i+<span class="number">1</span>] = mask[i]^arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = arr[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                curr = curr^arr[j];</span><br><span class="line">                <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">                    res += j - i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5406-收集树上所有苹果的最少时间"><a href="#5406-收集树上所有苹果的最少时间" class="headerlink" title="5406. 收集树上所有苹果的最少时间"></a>5406. 收集树上所有苹果的最少时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵有 n 个节点的无向树，节点编号为 0 到 n-1 ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 节点 0 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。</p><p>无向树的边由<code>edges</code> 给出，其中 <code>edges[i] = [fromi, toi]</code>，表示有一条边连接 <code>from</code>和<code>toi</code>。除此以外，还有一个布尔数组 <code>hasApple</code>，其中 <code>hasApple[i] = true</code>代表节点<code>i</code>有一个苹果，否则，节点<code>i</code>没有苹果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">8</span> </span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], hasApple = [<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n-1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt;= n-1</code></li><li><code>fromi &lt; toi</code></li><li><code>hasApple.length == n</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>我们知道每次从根节点下去取孩子节点的苹果时，都会有两步上下操作，因此我们每次判断发现本次的当前节点的孩子节点的子树有苹果存在时，则将路径+2.</li><li>采用DFS即可，我们每次返回子树是否有苹果，如果有苹果存在，则加2.<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; apples,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> hasapple = <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">if</span>(apples[curr]) hasapple = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : tree[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(v,tree,apples,res))&#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                hasapple = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasapple;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; hasApple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree;        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            tree[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>,tree,hasApple,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5407-切披萨的方案数"><a href="#5407-切披萨的方案数" class="headerlink" title="5407. 切披萨的方案数"></a>5407. 切披萨的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>rows x cols</code>大小的矩形披萨和一个整数 k ，矩形包含两种字符：<code>&#39;A&#39;</code>（表示苹果）和 ‘.’ （表示空白格子）。你需要切披萨 <code>k-1</code>次，得到 <code>k</code> 块披萨并送给别人。</p><p>切披萨的每一刀，先要选择是向垂直还是水平方向切，再在矩形的边界上选一个切的位置，将披萨一分为二。如果垂直地切披萨，那么需要把左边的部分送给一个人，如果水平地切，那么需要把上面的部分送给一个人。在切完最后一刀后，需要把剩下来的一块送给最后一个人。</p><p>请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。由于答案可能是个很大的数字，请你返回它对 <code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AAA"</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：上图展示了三种切披萨的方案。注意每一块披萨都至少包含一个苹果。</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"AA."</span>,<span class="string">"..."</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：pizza = [<span class="string">"A.."</span>,<span class="string">"A.."</span>,<span class="string">"..."</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= rows, cols &lt;= <span class="number">50</span></span><br><span class="line">rows == pizza.length</span><br><span class="line">cols == pizza[i].length</span><br><span class="line"><span class="number">1</span> &lt;= k &lt;= <span class="number">10</span></span><br><span class="line">pizza 只包含字符 <span class="string">'A'</span> 和 <span class="string">'.'</span> 。</span><br></pre></td></tr></table></figure></p><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-188/problems/number-of-ways-of-cutting-a-pizza/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设递推公式<code>dp[i][j][k]</code>代表从左上定点<code>(i,j)</code>与右下顶点<code>(m,n)</code>组成的矩形，切分<code>k</code>次的方案数，很容易想到递推公式:<script type="math/tex; mode=display">dp[x][y][k] = \left\{\begin{aligned}\sum_{i=x+1}^{m-1}dp[i][y][k-1] \qquad if(sum[x][y] - sum[i][y] > 0) \\\sum_{j=y+1}^{n-1}dp[x][j][k-1] \qquad if(sum[x][y] - sum[x][j] > 0) \\\end{aligned}\right.</script></li><li><code>sum</code>代表后缀和，<code>sum[i][j]</code>代表从<code>(i,j)</code>到<code>(m,n)</code>组成的矩形中苹果的总数目。<script type="math/tex; mode=display">sum[x][y] = \sum_{i=x}^{m}\sum_{j=y}^{n}matrix[i][j]</script><script type="math/tex; mode=display">sum[x][y] = sum[x][y+1] + sum[x+1][y] - sum[x+1][y+1] + matrix[x][y]</script>题目其实仔细分析下来挺简单的，就是写的时候稍微复杂点。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ways</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; pizza, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = pizza.size();</span><br><span class="line">        <span class="keyword">int</span> n = pizza[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[M][M][k];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*prefix sum*/</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="keyword">sizeof</span>(dp),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                sum[i][j] = sum[i+<span class="number">1</span>][j] + sum[i][j+<span class="number">1</span>] - sum[i+<span class="number">1</span>][j+<span class="number">1</span>] + (pizza[i][j] == <span class="string">'A'</span>?<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span>(sum[i][j] &gt; <span class="number">0</span>) dp[i][j][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; k; ++s)&#123;</span><br><span class="line">                    <span class="comment">/*cut row*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = i+<span class="number">1</span>; t &lt; m; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[t][j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[t][j][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">/*cut col*/</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> t = j+<span class="number">1</span>; t &lt; n; ++t)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum[i][j] - sum[i][t] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j][s] = (dp[i][j][s] + dp[i][t][s<span class="number">-1</span>])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;181周比赛&quot;&gt;&lt;a href=&quot;#181周比赛&quot; class=&quot;headerlink&quot; title=&quot;181周比赛&quot;&gt;&lt;/a&gt;181周比赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真非常高。&lt;/p&gt;&lt;h2 id=&quot;5404-用栈操作构建数组&quot;&gt;&lt;a href=&quot;#5404-用栈操作构建数组&quot; class=&quot;headerlink&quot; title=&quot;5404. 用栈操作构建数组&quot;&gt;&lt;/a&gt;5404. 用栈操作构建数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个目标数组 &lt;code&gt;target&lt;/code&gt;和一个整数 &lt;code&gt;n&lt;/code&gt;。每次迭代，需要从  &lt;code&gt;list = {1,2,3..., n}&lt;/code&gt; 中依序读取一个数字。&lt;/p&gt;&lt;p&gt;请使用下述操作来构建目标数组 &lt;code&gt;target&lt;/code&gt; ：&lt;br&gt;&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Push：从 &lt;/span&gt;list 中读取一个新元素， 并将其推入数组中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;Pop：删除数组中的最后一个元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;如果目标数组构建完成，就停止读取更多元素。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 180周比赛</title>
    <link href="http://yoursite.com/2020/05/03/158/"/>
    <id>http://yoursite.com/2020/05/03/158/</id>
    <published>2020-05-03T06:16:42.499Z</published>
    <updated>2020-05-03T06:16:49.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="180周比赛"><a href="#180周比赛" class="headerlink" title="180周比赛"></a>180周比赛</h1><p>周赛的题目质量果真非常高。</p><h2 id="5384-拥有最多糖果的孩子"><a href="#5384-拥有最多糖果的孩子" class="headerlink" title="5384. 拥有最多糖果的孩子"></a>5384. 拥有最多糖果的孩子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code>表示，其中 <code>paths[i] = [cityAi, cityBi]</code>表示该线路将会从 <code>cityAi</code>直接前往 <code>cityBi</code>。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。</p><a id="more"></a><p>题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点站。</p><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"London"</span>,<span class="string">"New York"</span>],[<span class="string">"New York"</span>,<span class="string">"Lima"</span>],[<span class="string">"Lima"</span>,<span class="string">"Sao Paulo"</span>]]</span><br><span class="line">输出：<span class="string">"Sao Paulo"</span> </span><br><span class="line">解释：从 <span class="string">"London"</span> 出发，最后抵达终点站 <span class="string">"Sao Paulo"</span> 。本次旅行的路线是 <span class="string">"London"</span> -&gt; <span class="string">"New York"</span> -&gt; <span class="string">"Lima"</span> -&gt; <span class="string">"Sao Paulo"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"B"</span>,<span class="string">"C"</span>],[<span class="string">"D"</span>,<span class="string">"B"</span>],[<span class="string">"C"</span>,<span class="string">"A"</span>]]</span><br><span class="line">输出：<span class="string">"A"</span></span><br><span class="line">解释：所有可能的线路是：</span><br><span class="line"><span class="string">"D"</span> -&gt; <span class="string">"B"</span> -&gt; <span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"B"</span> -&gt; <span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"C"</span> -&gt; <span class="string">"A"</span>. </span><br><span class="line"><span class="string">"A"</span>. </span><br><span class="line">显然，旅行终点站是 <span class="string">"A"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：paths = [[<span class="string">"A"</span>,<span class="string">"Z"</span>]]</span><br><span class="line">输出：<span class="string">"Z"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= paths.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `paths[i].length == <span class="number">2</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= cityAi.length, cityBi.length &lt;= <span class="number">10</span>`</span><br><span class="line">+ `cityAi != cityBi`</span><br><span class="line">+ 所有字符串均由大小写英文字母和空格字符组成。</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/destination-city</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  求入度</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 这个题目可以用BFS来解决，但是作为简单题目真心没必要。</span><br><span class="line"><span class="number">2.</span> 我们求出每个节点的入度和出度，求出入度大于<span class="number">0</span>且出度为<span class="number">0</span>的节点即为目标节点。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> destCity(vector&lt;vector&lt;<span class="built_in">string</span>&gt;&gt;&amp; paths) &#123;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="keyword">out</span>;</span><br><span class="line">        unordered_map&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="keyword">in</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> s : paths)&#123;</span><br><span class="line">            <span class="keyword">out</span>[s[<span class="number">0</span>]]++;</span><br><span class="line">            <span class="keyword">in</span>[s[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">auto</span> x : <span class="keyword">in</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">out</span>.count(x.first)) <span class="keyword">return</span> x.first;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5401-是否所有-1-都至少相隔-k-个元素"><a href="#5401-是否所有-1-都至少相隔-k-个元素" class="headerlink" title="5401. 是否所有 1 都至少相隔 k 个元素"></a>5401. 是否所有 1 都至少相隔 k 个元素</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 True ；否则，返回 False 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：每个 <span class="number">1</span> 都至少相隔 <span class="number">2</span> 个元素。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：第二个 <span class="number">1</span> 和第三个 <span class="number">1</span> 之间只隔了 <span class="number">1</span> 个元素。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">0</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">0</span> &lt;= k &lt;= nums.length`</span><br><span class="line">+ ` nums[i] `的值为 <span class="number">0</span> 或 <span class="number">1</span></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/check-if-all-1s-are-at-least-length-k-places-away</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  水题</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 把所有元素值为<span class="number">1</span>的索引求出来，然后查看相邻的元素是否间隔满足条件.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> kLengthApart(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                arr.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] &lt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5402-绝对差不超过限制的最长连续子数组"><a href="#5402-绝对差不超过限制的最长连续子数组" class="headerlink" title="5402. 绝对差不超过限制的最长连续子数组"></a>5402. 绝对差不超过限制的最长连续子数组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。</p><p>如果不存在满足条件的子数组，则返回 0 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>], limit = <span class="number">4</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[<span class="number">8</span>] 最大绝对差 |<span class="number">8</span><span class="number">-8</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span> </span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">8</span><span class="number">-2</span>| = <span class="number">6</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>] 最大绝对差 |<span class="number">2</span><span class="number">-2</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>] 最大绝对差 |<span class="number">2</span><span class="number">-4</span>| = <span class="number">2</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">2</span><span class="number">-7</span>| = <span class="number">5</span> &gt; <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>] 最大绝对差 |<span class="number">4</span><span class="number">-4</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>] 最大绝对差 |<span class="number">4</span><span class="number">-7</span>| = <span class="number">3</span> &lt;= <span class="number">4.</span></span><br><span class="line">[<span class="number">7</span>] 最大绝对差 |<span class="number">7</span><span class="number">-7</span>| = <span class="number">0</span> &lt;= <span class="number">4.</span> </span><br><span class="line">因此，满足题意的最长子数组的长度为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>], limit = <span class="number">5</span></span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：满足题意的最长子数组是 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>]，其最大绝对差 |<span class="number">2</span><span class="number">-7</span>| = <span class="number">5</span> &lt;= <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>], limit = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^9</code></li><li><code>0 &lt;= limit &lt;= 10^9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>保证当前窗口的最大值和最小值之差小于等于<code>limit</code>即可。</li><li>用multiset保存当前位置为终点的最长连续子序列，如果最大值与最小值之差小于等于<code>limit</code>，则该连续子序列肯定可以满足要求。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">        prev.insert(nums[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            prev.insert(nums[i]);</span><br><span class="line">            <span class="keyword">while</span>(curr &lt; i &amp;&amp; <span class="built_in">abs</span>(*prev.rbegin()-*prev.begin()) &gt; limit)&#123;</span><br><span class="line">                prev.erase(nums[curr]);</span><br><span class="line">                curr++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,(<span class="keyword">int</span>)prev.size());</span><br><span class="line">        &#125;</span><br><span class="line">                  </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5403-有序矩阵中的第-k-个最小数组和"><a href="#5403-有序矩阵中的第-k-个最小数组和" class="headerlink" title="5403. 有序矩阵中的第 k 个最小数组和"></a>5403. 有序矩阵中的第 k 个最小数组和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个 <code>m * n</code> 的矩阵 <code>mat</code>，以及一个整数 <code>k</code> ，矩阵中的每一行都以非递减的顺序排列。</p><p>你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第<code>k</code>个 最小 数组和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">4</span>], [<span class="number">3</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">6</span>]。其中第 <span class="number">5</span> 个的和是 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">3</span>,<span class="number">11</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]], k = <span class="number">9</span></span><br><span class="line">输出：<span class="number">17</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>]], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">6</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>]。其中第 <span class="number">7</span> 个的和是 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">10</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">9</span>]], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == mat.length</code></li><li><code>n == mat.length[i]</code></li><li><code>1 &lt;= m, n &lt;= 40</code></li><li><code>1 &lt;= k &lt;= min(200, n ^ m)</code></li><li><code>1 &lt;= mat[i][j] &lt;= 5000</code></li><li><code>mat[i]</code> 是一个非递减数组</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  BFS + 优先级队列</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>想到这到题目需要用优先级队列，但是比赛时没有做出来。</li><li>就是BFS + 优先级队列，由于<code>k</code>的值不超过200，我们直接暴力搜索即可。每次将当前节点的所有后续节点入优先级队列中即可，优先级节点比较所有的列的和。</li><li>我们用每一行的列索引作为节点的状态，定义节点如下：<script type="math/tex; mode=display">curr = (cols[0],cols[1],...,cols[n-1])</script>比如有<code>4*m</code>的矩阵，最开始的节点为<script type="math/tex; mode=display">[0,0,0,0]</script>那么它的后续节点即下一个最小值的可能由列的索引构成,我们将后续的四个可能的节点全部入队列。<script type="math/tex; mode=display">[1,0,0,0] \quad [0,1,0,0] \quad [0,0,1,0] \quad [0,0,0,1]</script>每次从优先级队列中取出最小的值。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; idx(row,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; v)&#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i)&#123;</span><br><span class="line">                res += mat[i][v[i]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        pq.insert(&#123;get(idx),idx&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; ++i)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [val,v] = *pq.begin();</span><br><span class="line">            pq.erase(pq.begin());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                v[j]++;</span><br><span class="line">                <span class="keyword">if</span>(v[j] &lt; col)&#123;</span><br><span class="line">                    pq.insert(&#123;get(v),v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                v[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pq.begin()-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;180周比赛&quot;&gt;&lt;a href=&quot;#180周比赛&quot; class=&quot;headerlink&quot; title=&quot;180周比赛&quot;&gt;&lt;/a&gt;180周比赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量果真非常高。&lt;/p&gt;&lt;h2 id=&quot;5384-拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#5384-拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;5384. 拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;5384. 拥有最多糖果的孩子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一份旅游线路图，该线路图中的旅行线路用数组 &lt;code&gt;paths&lt;/code&gt;表示，其中 &lt;code&gt;paths[i] = [cityAi, cityBi]&lt;/code&gt;表示该线路将会从 &lt;code&gt;cityAi&lt;/code&gt;直接前往 &lt;code&gt;cityBi&lt;/code&gt;。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 25周双周比赛</title>
    <link href="http://yoursite.com/2020/05/03/157/"/>
    <id>http://yoursite.com/2020/05/03/157/</id>
    <published>2020-05-03T02:15:25.433Z</published>
    <updated>2020-05-03T02:15:30.546Z</updated>
    
    <content type="html"><![CDATA[<h1 id="25周比赛"><a href="#25周比赛" class="headerlink" title="25周比赛"></a>25周比赛</h1><p>双周赛的题目难度比周赛稍微差点</p><h2 id="5384-拥有最多糖果的孩子"><a href="#5384-拥有最多糖果的孩子" class="headerlink" title="5384. 拥有最多糖果的孩子"></a>5384. 拥有最多糖果的孩子</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>candies</code>和一个整数 <code>extraCandies</code>，其中 <code>candies[i]</code> 代表第 i 个孩子拥有的糖果数目。</p><p>对每一个孩子，检查是否存在一种方案，将额外的 <code>extraCandies</code>个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>], extraCandies = <span class="number">3</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>] </span><br><span class="line">解释：</span><br><span class="line">孩子 <span class="number">1</span> 有 <span class="number">2</span> 个糖果，如果他得到所有额外的糖果（<span class="number">3</span>个），那么他总共有 <span class="number">5</span> 个糖果，他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">2</span> 有 <span class="number">3</span> 个糖果，如果他得到至少 <span class="number">2</span> 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">3</span> 有 <span class="number">5</span> 个糖果，他已经是拥有最多糖果的孩子。</span><br><span class="line">孩子 <span class="number">4</span> 有 <span class="number">1</span> 个糖果，即使他得到所有额外的糖果，他也只有 <span class="number">4</span> 个糖果，无法成为拥有糖果最多的孩子。</span><br><span class="line">孩子 <span class="number">5</span> 有 <span class="number">3</span> 个糖果，如果他得到至少 <span class="number">2</span> 个额外糖果，那么他将成为拥有最多糖果的孩子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], extraCandies = <span class="number">1</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>] </span><br><span class="line">解释：只有 <span class="number">1</span> 个额外糖果，所以不管额外糖果给谁，只有孩子 <span class="number">1</span> 可以成为拥有糖果最多的孩子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">输入：candies = [<span class="number">12</span>,<span class="number">1</span>,<span class="number">12</span>], extraCandies = <span class="number">10</span></span><br><span class="line">输出：[<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">true</span>]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">2</span> &lt;= candies.length &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= candies[i] &lt;= <span class="number">100</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= extraCandies &lt;= <span class="number">50</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/kids-with-the-greatest-number-of-candies/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  暴力</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 首先找到数组中最大的数`maxval`，遍历数组每个元素，将该元素与`extra`相加比较与`maxval`的大小，如果比`maxval`小则返回`<span class="literal">false</span>`，否则为`<span class="literal">true</span>`.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="built_in">bool</span>&gt; kidsWithCandies(vector&lt;<span class="built_in">int</span>&gt;&amp; candies, <span class="built_in">int</span> extraCandies) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = candies.size();</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; res(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">int</span> maxv = *max_element(candies.begin(),candies.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candies[i] + extraCandies &gt;= maxv)&#123;</span><br><span class="line">                res[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5385-改变一个整数能得到的最大差值"><a href="#5385-改变一个整数能得到的最大差值" class="headerlink" title="5385. 改变一个整数能得到的最大差值"></a>5385. 改变一个整数能得到的最大差值</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 num 。你可以对它进行如下步骤恰好 两次 ：</p><p>选择一个数字 <code>x (0 &lt;= x &lt;= 9)</code>.<br>选择另一个数字<code>y (0 &lt;= y &lt;= 9)</code>。数字 <code>y</code>可以等于<code>x</code> 。<br>将 num 中所有出现 x 的数位都用 y 替换。<br>得到的新的整数 不能 有前导 0 ，得到的新整数也 不能 是 0 。<br>令两次对<code>num</code>的操作得到的结果分别为 <code>a</code>和 <code>b</code>。</p><p>请你返回 <code>a</code> 和<code>b</code>的 最大差值 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">555</span></span><br><span class="line">输出：<span class="number">888</span></span><br><span class="line">解释：第一次选择 x = <span class="number">5</span> 且 y = <span class="number">9</span> ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x = <span class="number">5</span> 且 y = <span class="number">1</span> ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a = <span class="number">999</span> 和 b = <span class="number">111</span> ，最大差值为 <span class="number">888</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">9</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：第一次选择 x = <span class="number">9</span> 且 y = <span class="number">9</span> ，并把得到的新数字保存在 a 中。</span><br><span class="line">第二次选择 x = <span class="number">9</span> 且 y = <span class="number">1</span> ，并把得到的新数字保存在 b 中。</span><br><span class="line">现在，我们有 a = <span class="number">9</span> 和 b = <span class="number">1</span> ，最大差值为 <span class="number">8</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">123456</span></span><br><span class="line">输出：<span class="number">820000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">10000</span></span><br><span class="line">输出：<span class="number">80000</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="number">9288</span></span><br><span class="line">输出：<span class="number">8700</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= num &lt;= <span class="number">10</span>^<span class="number">8</span>`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/max-difference-you-can-get-from-changing-an-integer/</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  数学</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 所谓最大的数即将从左往右第一个小于**<span class="number">9</span>**的数字改为**<span class="number">9</span>**.</span><br><span class="line"><span class="number">2.</span> 所谓最小的数分为两种情况，如果最高位不为`<span class="number">1</span>`,将所有最高位相同的数字改为**<span class="number">1</span>**;如果最高位为`<span class="number">1</span>`,将从左往右第<span class="number">2</span>位开始第一个大于**<span class="number">1</span>**的数字改为**<span class="number">0</span>**.</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> minChange(<span class="built_in">int</span> num)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        char c;</span><br><span class="line">        <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt; <span class="string">'1'</span>)&#123;</span><br><span class="line">                last = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        c = s[last];</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'1'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxChange(<span class="built_in">int</span> num)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(num);</span><br><span class="line">        char c;</span><br><span class="line">        <span class="built_in">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; <span class="string">'9'</span>)&#123;</span><br><span class="line">                last = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(last == <span class="number">-1</span>) <span class="keyword">return</span> num;</span><br><span class="line">        c = s[last];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == c) s[i] = <span class="string">'9'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stoi(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDiff(<span class="built_in">int</span> num) &#123;</span><br><span class="line">        cout&lt;&lt;maxChange(num)&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;minChange(num)&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> maxChange(num) - minChange(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5386-检查一个字符串是否可以打破另一个字符串"><a href="#5386-检查一个字符串是否可以打破另一个字符串" class="headerlink" title="5386. 检查一个字符串是否可以打破另一个字符串"></a>5386. 检查一个字符串是否可以打破另一个字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串<code>s1</code> 和 <code>s2</code>，它们长度相等，请你检查是否存在一个 s1  的排列可以打破 s2 的一个排列，或者是否存在一个 s2 的排列可以打破 s1 的一个排列。</p><p>字符串 x 可以打破字符串 <code>y</code>（两者长度都为 <code>n</code> ）需满足对于所有 i（在 <code>0</code> 到 <code>n - 1</code> 之间）都有<code>x[i] &gt;= y[i]</code>（字典序意义下的顺序）。</p><p>示例 1：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"abc"</span>, <span class="built_in">s2</span> = <span class="string">"xya"</span></span><br><span class="line">输出：true</span><br><span class="line">解释：<span class="string">"ayx"</span> 是 <span class="built_in">s2</span>=<span class="string">"xya"</span> 的一个排列，<span class="string">"abc"</span> 是字符串 <span class="built_in">s1</span>=<span class="string">"abc"</span> 的一个排列，且 <span class="string">"ayx"</span> 可以打破 <span class="string">"abc"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">s1</span> = <span class="string">"abe"</span>, <span class="built_in">s2</span> = <span class="string">"acd"</span></span><br><span class="line">输出：false </span><br><span class="line">解释：<span class="built_in">s1</span>=<span class="string">"abe"</span> 的所有排列包括：<span class="string">"abe"</span>，<span class="string">"aeb"</span>，<span class="string">"bae"</span>，<span class="string">"bea"</span>，<span class="string">"eab"</span> 和 <span class="string">"eba"</span> ，<span class="built_in">s2</span>=<span class="string">"acd"</span> 的所有排列包括：<span class="string">"acd"</span>，<span class="string">"adc"</span>，<span class="string">"cad"</span>，<span class="string">"cda"</span>，<span class="string">"dac"</span> 和 <span class="string">"dca"</span>。然而没有任何 <span class="built_in">s1</span> 的排列可以打破 <span class="built_in">s2</span> 的排列。也没有 <span class="built_in">s2</span> 的排列能打破 <span class="built_in">s1</span> 的排列。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = <span class="string">"leetcodee"</span>, s2 = <span class="string">"interview"</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `s1.length == n`</span><br><span class="line">+ `s2.length == n`</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ 所有字符串都只包含小写英文字母。</span><br><span class="line"></span><br><span class="line"><span class="meta">### 地址</span></span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-25/problems/check-if-a-string-can-break-another-string/</span></span><br><span class="line"><span class="meta">### 题意</span></span><br><span class="line">&gt;  数学问题</span><br><span class="line"><span class="meta">### 思路</span></span><br><span class="line"><span class="number">1.</span> 我们将两个字符串按照字符大小排序。实际也为贪心法，如果字符串`s`存在严格意义上每一位字符都比字符串`t`的每一位都大，或者字符串`t`存在严格意义上每一位字符都比字符串`s`的每一位都大，则一定存在严格意义上的打破排序。</span><br><span class="line"><span class="meta">### 代码</span></span><br><span class="line">```c++</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> checkIfCanBreak(<span class="keyword">string</span> s1, <span class="keyword">string</span> s2) &#123;</span><br><span class="line">        sort(s1.begin(),s1.end());</span><br><span class="line">        sort(s2.begin(),s2.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> ret1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> ret2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &lt; s2[i]) ret1 = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] &gt; s2[i]) ret2 = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret1||ret2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5387-每个人戴不同帽子的方案数"><a href="#5387-每个人戴不同帽子的方案数" class="headerlink" title="5387. 每个人戴不同帽子的方案数"></a>5387. 每个人戴不同帽子的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>总共有 <code>n</code> 个人和 <code>40</code>种不同的帽子，帽子编号从 1 到 40 。</p><p>给你一个整数列表的列表 <code>hats</code> ，其中 <code>hats[i]</code> 是第 i 个人所有喜欢帽子的列表。</p><p>请你给每个人安排一顶他喜欢的帽子，确保每个人戴的帽子跟别人都不一样，并返回方案数。</p><p>由于答案可能很大，请返回它对 <code>10^9 + 7</code>取余后的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：给定条件下只有一种方法选择帽子。</span><br><span class="line">第一个人选择帽子 <span class="number">3</span>，第二个人选择帽子 <span class="number">4</span>，最后一个人选择帽子 <span class="number">5</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">4</span> 种安排帽子的方法：</span><br><span class="line">(<span class="number">3</span>,<span class="number">5</span>)，(<span class="number">5</span>,<span class="number">3</span>)，(<span class="number">1</span>,<span class="number">3</span>) 和 (<span class="number">1</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：每个人都可以从编号为 <span class="number">1</span> 到 <span class="number">4</span> 的帽子中选。</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="number">4</span> 个帽子的排列方案数为 <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：hats = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>],[<span class="number">1</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">7</span>]]</span><br><span class="line">输出：<span class="number">111</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == hats.length</code></li><li><code>1 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= hats[i].length &lt;= 40</code></li><li><code>1 &lt;= hats[i][j] &lt;= 40</code></li><li><code>hats[i]</code> 包含一个数字互不相同的整数列表。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-wear-different-hats-to-each-other</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  状态压缩 + 动态规划</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>对于<code>leetcode</code>上的题目做多了的话，本题一看就知道要用状态压缩dp.本来我以为本题会出一个类似于最大二分图的题目，可以用最大流来解决。这种题目基本上已经非常常见了，这个题目在lc平台上已经出现了很多次。lc平台特别喜欢出这种状态压缩的dp。比如典型的：</li></ol><ul><li><a href="https://leetcode-cn.com/problems/maximum-students-taking-exam/" target="_blank" rel="noopener">1349. 参加考试的最大学生数</a></li><li><a href="https://leetcode-cn.com/problems/find-the-shortest-superstring/" target="_blank" rel="noopener">943. 最短超级串</a></li><li><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid/" target="_blank" rel="noopener">1411. 给 N x 3 网格图涂色的方案数</a></li><li><a href="https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/" target="_blank" rel="noopener">864. 获取所有钥匙的最短路径</a></li></ul><ol><li>稍微复杂点，这次稍微迷惑的是状态定义。常规思路肯定是<code>n</code>个人选<code>m</code>种颜色,<code>m</code>种颜色的选择作为一个状态，但是这个题目给的数据是颜色的种类远大于人的数目，所以按照这种常规思路肯定会出现超时。反过来来看，我们也可以这样看待，<code>m</code>种颜色需要选择<code>n</code>个人进行分配，计算每个人都能分配到一种颜色的方案数目，这样实际等效过程是一样的。</li><li>我们设递推公式位<code>dp[i][state]</code>,代表前<code>i</code>个元素分为给<code>state</code>代表的位图的人数的方案数,我们可以知道当加入第<code>i+1</code>种颜色时，要么该颜色不分配给任何人，要么将该颜色分配给允许该颜色的人<code>p</code>,且前<code>i-1</code>种颜色未分配给<code>p</code>。<script type="math/tex; mode=display">dp[i][state] = dp[i-1][state] + \sum_{j = 1}^{n}dp[i-1][state-(1<<j)] \qquad if \quad valid[i][j] = true</script><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bitTst</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((mask&amp;(<span class="number">1</span>&lt;&lt;n))&gt;&gt;n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitSet</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask|(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bitClr</span><span class="params">(<span class="keyword">int</span> mask,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mask&amp;(~(<span class="number">1</span>&lt;&lt;n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hats.size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">1</span>&lt;&lt;n;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(<span class="number">41</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>&lt;&lt;n,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; valid(<span class="number">41</span>,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hats[i].size(); ++j)&#123;</span><br><span class="line">                valid[hats[i][j]][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">40</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(bitTst(j,k)&amp;&amp;valid[i][k])&#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i<span class="number">-1</span>][bitClr(j,k)])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">40</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;25周比赛&quot;&gt;&lt;a href=&quot;#25周比赛&quot; class=&quot;headerlink&quot; title=&quot;25周比赛&quot;&gt;&lt;/a&gt;25周比赛&lt;/h1&gt;&lt;p&gt;双周赛的题目难度比周赛稍微差点&lt;/p&gt;&lt;h2 id=&quot;5384-拥有最多糖果的孩子&quot;&gt;&lt;a href=&quot;#5384-拥有最多糖果的孩子&quot; class=&quot;headerlink&quot; title=&quot;5384. 拥有最多糖果的孩子&quot;&gt;&lt;/a&gt;5384. 拥有最多糖果的孩子&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;candies&lt;/code&gt;和一个整数 &lt;code&gt;extraCandies&lt;/code&gt;，其中 &lt;code&gt;candies[i]&lt;/code&gt; 代表第 i 个孩子拥有的糖果数目。&lt;/p&gt;&lt;p&gt;对每一个孩子，检查是否存在一种方案，将额外的 &lt;code&gt;extraCandies&lt;/code&gt;个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 算法课程《Algorithmic Toolbox》</title>
    <link href="http://yoursite.com/2020/05/02/156/"/>
    <id>http://yoursite.com/2020/05/02/156/</id>
    <published>2020-05-02T10:23:04.359Z</published>
    <updated>2020-05-02T10:51:58.797Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Toolbox"><a href="#Algorithmic-Toolbox" class="headerlink" title="Algorithmic Toolbox"></a>Algorithmic Toolbox</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是基本题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST" target="_blank" rel="noopener">Algorithmic Toolbox</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Sum-of-Two-Digits"><a href="#1-Sum-of-Two-Digits" class="headerlink" title="1. Sum of Two Digits"></a>1. Sum of Two Digits</h3><p>We start from this ridiculously simple problem to show you the<br>pipeline of reading the problem statement, designing an algorithm, implementing<br>it, testing and debugging your program, and submitting it to<br>the grading system.<br>Input format. Integers a and b on the same line (separated by a space).<br>Output format. The sum of a and b.<br>Constraints. 0  a;b  9.<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample.</span><br><span class="line">Input:</span><br><span class="line"><span class="number">9</span> <span class="number">7</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> 直接相加</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>相加即可<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_of_two_digits</span><span class="params">(<span class="keyword">int</span> first_digit, <span class="keyword">int</span> second_digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first_digit + second_digit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum_of_two_digits(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Maximum-Pairwise-Product"><a href="#2-Maximum-Pairwise-Product" class="headerlink" title="2 Maximum Pairwise Product"></a>2 Maximum Pairwise Product</h3><p>Given a sequence of non-negative integers a1; : : : ;an, compute<br>max<br>1i,jn<br>ai  aj :<br>Note that i and j should be different, though it may be the case that ai = aj .<br>Input format. The first line contains an integer n. The next line contains<br>n non-negative integers a1; : : : ;an (separated by spaces).<br>Output format. The maximum pairwise product.<br>Constraints. 2  n  2  105; 0  a1; : : : ;an  2  105.</p><p>Sample 1.<br>Input:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><br>Output:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.找到二维数组中的最大的两个元素即可，返回他们的乘积，时间复杂度$O(n)$。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MaxPairwiseProduct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &gt; first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = numbers[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] &gt; second)&#123;</span><br><span class="line">            second = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first*second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; MaxPairwiseProduct(numbers) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="Fibonacci-Number"><a href="#Fibonacci-Number" class="headerlink" title="Fibonacci Number"></a>Fibonacci Number</h3><p>Given an integer 𝑛, find the 𝑛th Fibonacci number 𝐹𝑛.</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>非常简单了，找到第<code>n</code>个斐波那契数。<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following code calls a naive algorithm for computing a Fibonacci number.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// What to do:</span></span><br><span class="line"><span class="comment">// 1. Compile the following code and run it on an input "40" to check that it is slow.</span></span><br><span class="line"><span class="comment">//    You may also want to submit it to the grader to ensure that it gets the "time limit exceeded" message.</span></span><br><span class="line"><span class="comment">// 2. Implement the fibonacci_fast procedure.</span></span><br><span class="line"><span class="comment">// 3. Remove the line that prints the result of the naive algorithm, comment the lines reading the input,</span></span><br><span class="line"><span class="comment">//    uncomment the line with a call to test_solution, compile the program, and run it.</span></span><br><span class="line"><span class="comment">//    This will ensure that your efficient algorithm returns the same as the naive one for small values of n.</span></span><br><span class="line"><span class="comment">// 4. If test_solution() reveals a bug in your implementation, debug it, fix it, and repeat step 3.</span></span><br><span class="line"><span class="comment">// 5. Remove the call to test_solution, uncomment the line with a call to fibonacci_fast (and the lines reading the input),</span></span><br><span class="line"><span class="comment">//    and submit it to the grader.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fibonacci_naive(n - <span class="number">1</span>) + fibonacci_naive(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci_fast</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        f3 = f2 + f1;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(fibonacci_fast(<span class="number">3</span>) == <span class="number">2</span>);</span><br><span class="line">    assert(fibonacci_fast(<span class="number">10</span>) == <span class="number">55</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">20</span>; ++n)</span><br><span class="line">        assert(fibonacci_fast(n) == fibonacci_naive(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; fibonacci_naive(n) &lt;&lt; '\n';</span></span><br><span class="line">    <span class="comment">//test_solution();</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci_fast(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Last-Digit-of-a-Large-Fibonacci-Number"><a href="#2-Last-Digit-of-a-Large-Fibonacci-Number" class="headerlink" title="2 Last Digit of a Large Fibonacci Number"></a>2 Last Digit of a Large Fibonacci Number</h3><p>Your goal in this problem is to find the last digit of 𝑛-th Fibonacci number. Recall that Fibonacci numbers<br>grow exponentially fast. For example,<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝐹<span class="number">200</span> = <span class="number">280</span> <span class="number">571</span> <span class="number">172</span> <span class="number">992</span> <span class="number">510</span> <span class="number">140</span> <span class="number">037</span> <span class="number">611</span> <span class="number">932</span> <span class="number">413</span> <span class="number">038</span> <span class="number">677</span> <span class="number">189</span> <span class="number">525</span> .</span><br></pre></td></tr></table></figure></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>找到斐波那契数的个位数。</li><li>我们直接对每一位取模即可。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fibonacci_last_digit_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_previous = previous%<span class="number">10</span>;</span><br><span class="line">        previous = current%<span class="number">10</span>;</span><br><span class="line">        current = (tmp_previous + current)%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> c = get_fibonacci_last_digit_naive(n);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Greatest-Common-Divisor"><a href="#3-Greatest-Common-Divisor" class="headerlink" title="3 Greatest Common Divisor"></a>3 Greatest Common Divisor</h3>The greatest common divisor GCD(𝑎, 𝑏) of two non-negative integers 𝑎 and 𝑏<br>(which are not both equal to 0) is the greatest integer 𝑑 that divides both 𝑎 and 𝑏.<br>Your goal in this problem is to implement the Euclidean algorithm for computing<br>the greatest common divisor.<br>Efficient algorithm for computing the greatest common divisor is an important<br>basic primitive of commonly used cryptographic algorithms like RSA.</li></ol><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>牛顿法找到两个数的最大公约数即可。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_naive(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_naive(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd_naive(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Least-Common-Multiple"><a href="#4-Least-Common-Multiple" class="headerlink" title="4 Least Common Multiple"></a>4 Least Common Multiple</h3><p>Given two integers 𝑎 and 𝑏, find their least common multiple.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>找到两个数的最小公倍数。</li><li>先找两个数的最大公约数，然后乘以他们各自除以最大公约数的结果。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_fast</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_fast(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_fast(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">1</span>; l &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>) a * b; ++l)</span><br><span class="line">    <span class="keyword">if</span> (l % a == <span class="number">0</span> &amp;&amp; l % b == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_fast</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) (a * b)/gcd_fast(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(lcm_fast(<span class="number">6</span>,<span class="number">8</span>) == <span class="number">24</span>);</span><br><span class="line">    assert(lcm_fast(<span class="number">761457</span>,<span class="number">614573</span>) == <span class="number">467970912861</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  test_solution();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcm_fast(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Fibonacci-Number-Again"><a href="#5-Fibonacci-Number-Again" class="headerlink" title="5 Fibonacci Number Again"></a>5 Fibonacci Number Again</h3>In this problem, your goal is to compute 𝐹𝑛 modulo 𝑚, where 𝑛 may be really huge: up to 1014. For such<br>values of 𝑛, an algorithm looping for 𝑛 iterations will not fit into one second for sure. Therefore we need to<br>avoid such a loop.<br>To get an idea how to solve this problem without going through all 𝐹𝑖 for 𝑖 from 0 to 𝑛, let’s see what<br>happens when 𝑚 is small — say, 𝑚 = 2 or 𝑚 = 3.</li></ol><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>用数学方法可以证明斐波那契数列对某个自然数取模后的结果一定存在循环，数学证明方法比较复杂就不展开讲了，知道它肯定会循环，我们需要找到它的循环周期<code>T</code>,则后续处理就非常简单。</li><li>我们只需要找到连续的两个数取模后的结果分别为<code>0,1</code>这即为循环序列的开始，题目稍微有点复杂。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_pisano_period</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; (m*m); ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">        <span class="keyword">if</span>(previous == <span class="number">0</span> &amp;&amp; current == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_fibonacci_huge_naive</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> period = get_pisano_period(m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = n%period;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; mod<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_fibonacci_huge_naive(n, m) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers"><a href="#6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers" class="headerlink" title="6-8 Last Digit of the Sum of Fibonacci Numbers"></a>6-8 Last Digit of the Sum of Fibonacci Numbers</h3><p>The goal in this problem is to find the last digit of a sum of the first 𝑛 Fibonacci numbers.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>如果会解决第5题，后面的三道题目都非常简单，在这里就不贴详细的代码。</li><li>主要是利用斐波那契数列取模后的循环数列的技巧，分别求即可。</li></ol><h2 id="week-3-Greedy-Algorithms"><a href="#week-3-Greedy-Algorithms" class="headerlink" title="week 3 Greedy Algorithms"></a>week 3 Greedy Algorithms</h2><p>贪心算法也是非常常见和应用的算法，前1-5题非常简单。重点需要展开讲述一下6-7题。</p><h3 id="6-Maximum-Number-of-Prizes"><a href="#6-Maximum-Number-of-Prizes" class="headerlink" title="6 Maximum Number of Prizes"></a>6 Maximum Number of Prizes</h3><p>You are organizing a funny competition for children. As a prize fund you have 𝑛<br>candies. You would like to use these candies for top 𝑘 places in a competition<br>with a natural restriction that a higher place gets a larger number of candies.<br>To make as many children happy as possible, you are going to find the largest<br>value of 𝑘 for which it is possible.</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ol><li>我们从<code>1</code>开始顺序的加入自然数即可，直到加入第<code>i-1</code>个数后，剩余的元素应该大于等于<code>i</code>.<script type="math/tex; mode=display">i \le n - (i-1)*i/2</script></li><li>本质也是贪心算法<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; optimal_summands(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> rest = n - (i*(i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(rest &lt;= i)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)&#123;</span><br><span class="line">              summands.push_back(j);</span><br><span class="line">          &#125;</span><br><span class="line">          summands.push_back(n-(i<span class="number">-1</span>)*i/<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> summands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands = optimal_summands(n);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; summands.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Maximum-Salary"><a href="#7-Maximum-Salary" class="headerlink" title="7 Maximum Salary"></a>7 Maximum Salary</h3><strong>Task</strong>. Compose the largest number out of a set of integers.<br><strong>Input Format</strong>. The first line of the input contains an integer 𝑛. The second line contains integers<br>𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 100; 1 ≤ 𝑎𝑖 ≤ 103 for all 1 ≤ 𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. Output the largest number that can be composed out of 𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Sample 1</strong>.<br>Input:<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">21 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>Output:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">221</span></span><br></pre></td></tr></table></figure>Note that in this case the above algorithm also returns an incorrect answer <code>212</code>.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li><li>仔细看下似乎比较麻烦，但是实际上很简单，我们采取贪心的算法，将字典序组合最大的排在前面即可。我们将字符串按照<code>s1,s2</code>如下顺序进行排列：<script type="math/tex; mode=display">(s1 + s2) > (s2 + s1)</script></li><li>我们直接排序然后输出字符串即可，当然了这是<code>leetcode</code>上的原题。<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp; a,<span class="built_in">string</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = a + b;</span><br><span class="line">    <span class="built_in">string</span> s2 = b + a;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largest_number</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ret;</span><br><span class="line">  sort(a.begin(),a.end(),cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    ret &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  ret &gt;&gt; result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; largest_number(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Divide-and-Conquer"><a href="#week4-Divide-and-Conquer" class="headerlink" title="week4: Divide-and-Conquer"></a>week4: Divide-and-Conquer</h2><p>这一章主要是将分治法，主要涉及的内容有二分查找和归并排序的应用。非常非常重要的基础算法应用。题目稍微比较难。前2题比较简单，重点把后4题稍微思考一下。<br>分治法的核心思路也是递归。将一个大的<strong>task</strong>划分成为n个小的<strong>task</strong>即可。然后再对<code>n</code>个<strong>task</strong>进行归并调度即可。</p><h3 id="3-Improving-Quick-Sort"><a href="#3-Improving-Quick-Sort" class="headerlink" title="3 Improving Quick Sort"></a>3 Improving Quick Sort</h3><p>To force the given implementation of the quick sort algorithm to efficiently process sequences with<br>few unique elements, your goal is replace a 2-way partition with a 3-way partition. That is, your new<br>partition procedure should partition the array into three parts: &lt; 𝑥 part, = 𝑥 part, and &gt; 𝑥 part.</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>对快速排序的改进，实际也是所谓的<strong>3-way-partion</strong>，每次将数组划分为3部分，即小于<code>pivot</code>,等于<code>pivot</code>,大于<code>pivot</code>三部分，然后小于<code>pivot</code>和大于<code>pivot</code>的部分进行下一轮划分，等于<code>piovt</code>的保持不变即可。</li><li>这样总的划分效果较好，特别是较少了递归的次数，每次相等的部分位置就固定下来。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = a[l];</span><br><span class="line">  <span class="keyword">int</span> j = l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= x) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a[l], a[j]);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partition3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">int</span> k = l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; x) &#123;</span><br><span class="line">            swap(a[k],a[i]);</span><br><span class="line">            swap(a[k++],a[j++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == x)&#123;</span><br><span class="line">            swap(a[k++],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret.push_back(j);</span><br><span class="line">    ret.push_back(k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threeway_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partion = partition3(a, l, r);</span><br><span class="line">  threeway_quick_sort(a, l, partion[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">  threeway_quick_sort(a, partion[<span class="number">1</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomized_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="keyword">int</span> m = partition2(a, l, r);</span><br><span class="line"></span><br><span class="line">  randomized_quick_sort(a, l, m - <span class="number">1</span>);</span><br><span class="line">  randomized_quick_sort(a, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  threeway_quick_sort(a, <span class="number">0</span>, a.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Number-of-Inversions"><a href="#4-Number-of-Inversions" class="headerlink" title="4 Number of Inversions"></a>4 Number of Inversions</h3><p>An inversion of a sequence 𝑎0, 𝑎1, . . . , 𝑎𝑛−1 is a pair of indices 0 ≤ 𝑖 &lt; 𝑗 &lt; 𝑛 such that 𝑎𝑖 &gt; 𝑎𝑗 . The number of inversions of a sequence in some sense measures how close the sequence is to being sorted. For example, a sorted (in non-descending order) sequence contains no inversions at all, while in a sequence sorted in descending order any two elements constitute an inversion (for a total of 𝑛(𝑛 − 1)/2 inversions).The goal in this problem is to count the number of inversions of a given sequence.</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol><li>这个是<code>leetcode</code>上的原题，本质是归并排序。</li><li>每次我们将数组划分为前半部分后后半部分，并分别对前半部分进行归并排序，并同时判断两个部分的逆序对。</li><li>每次进行归并时，计算前半部分的元素大于后半部分的数的有多少个，然其所有大于的数组之和相加即可。</li><li>我们刚好利用归并时即可，将两个有序的数组进行归并，所以这次归并时在<code>O(n)</code>时间复杂度内完成本次逆序对的计算和排序。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_number_of_inversions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="keyword">size_t</span> left, <span class="keyword">size_t</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> number_of_inversions = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (right &lt;= left + <span class="number">1</span>) <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">  <span class="keyword">size_t</span> ave = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, left, ave);</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, ave, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> l = left;</span><br><span class="line">  <span class="keyword">int</span> r = ave;</span><br><span class="line">  <span class="keyword">int</span> curr = left;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; ave || r &lt; right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave &amp;&amp; r &lt; right)&#123;</span><br><span class="line">          <span class="keyword">if</span>(a[r] &lt; a[l])&#123;</span><br><span class="line">              number_of_inversions += ave - l;</span><br><span class="line">              b[curr++] = a[r++];</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              b[curr++] = a[l++];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave) b[curr++] = a[l++];</span><br><span class="line">      <span class="keyword">if</span>(r &lt; right) b[curr++] = a[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.size());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_number_of_inversions(a, b, <span class="number">0</span>, a.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Organizing-a-Lottery"><a href="#5-Organizing-a-Lottery" class="headerlink" title="5 Organizing a Lottery"></a>5 Organizing a Lottery</h3>You are organizing an online lottery. To participate, a person bets on a single integer. You then draw several ranges of consecutive integers at random.A participant’s payoff then is proportional to the number of ranges that<br>contain the participant’s number minus the number of ranges that does not contain it. You need an efficient algorithm for computing the payoffs for all participants. A naive way to do this is to simply scan, for all participants, the<br>list of all ranges. However, you lottery is very popular: you have thousands of participants and thousands of ranges. For this reason, you cannot afford a slow naive algorithm.<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目非常好，质量很高。其实拿到这个题目我一开始想到的就是<code>segmentTree</code>，结果就是超时了。</li><li>后来思考了好长时间没有想到更简单的做法。然后去论坛找了提示，发现这个解法非常非常的巧妙。</li><li>我们对所有的元素进行标记，我们可以想像把线段的左端点标记为左括号<code>(</code>,线段的右端点标记为右括号<code>(</code>,需要查找的点标记为<code>p</code>,我们实际上就是判断点p能否被几个完成的左右括号同时覆盖<code>()</code>.</li><li>记住上面的关键点的思考。实际我们可能还有许多细节要思考，比如这种线段<code>s:(x,x)</code>,点p为<code>x</code>,则这时点<code>p</code>应该是被线段<code>s</code>包围的,这点所谓的包含思维需要仔细的思考。我们将线段的左端点标记为<code>l</code>，线段的右端点标记为<code>r</code>，将point标记为<code>p</code>，然后将左端点和右端点加在一起排序。我们判断时，每次遇到左括号则进行计数加<code>1</code>,遇到右括号，则将计数减<code>1</code>,到达当前点<code>p</code>时的计数大小即为所有包含点<code>p</code>的线段数。</li><li>另一种方法可能更快一点，我们直接利用二分查找。对于当前点<code>p:x</code>,我们查找有多少个大于<code>x</code>的左端点，个数即为<code>lx</code>,同时查找大于等于<code>x</code>的右端点的个数为<code>rx</code>.包含点<code>p</code>的线段数为<code>rx-lx</code>.<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; fast_count_segments(vector&lt;int&gt; starts, vector&lt;int&gt; ends, vector&lt;int&gt; points) &#123;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; cnt(points.size());</span></span><br><span class="line"><span class="comment">    int n = starts.size();</span></span><br><span class="line"><span class="comment">    int m = points.size();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sort(starts.begin(),starts.end());</span></span><br><span class="line"><span class="comment">    sort(ends.begin(),ends.end());</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; m; ++i)&#123;</span></span><br><span class="line"><span class="comment">        auto it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span></span><br><span class="line"><span class="comment">        auto it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span></span><br><span class="line"><span class="comment">        int x = it1 - starts.begin();</span></span><br><span class="line"><span class="comment">        int y = it2 - ends.begin();</span></span><br><span class="line"><span class="comment">        cnt[i] = x - y;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return cnt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fast_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">    <span class="keyword">int</span> n = starts.size();</span><br><span class="line">    <span class="keyword">int</span> m = points.size();</span><br><span class="line"></span><br><span class="line">    sort(starts.begin(),starts.end());</span><br><span class="line">    sort(ends.begin(),ends.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span><br><span class="line">        <span class="keyword">int</span> x = it1 - starts.begin();</span><br><span class="line">        <span class="keyword">int</span> y = it2 - ends.begin();</span><br><span class="line">        cnt[i] = x - y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; naive_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; starts.size(); j++) &#123;</span><br><span class="line">      cnt[i] += starts[j] &lt;= points[i] &amp;&amp; points[i] &lt;= ends[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts(n), ends(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; starts.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; starts[i] &gt;&gt; ends[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; points[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//use fast_count_segments</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt = fast_count_segments(starts, ends, points);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Closest-Points"><a href="#6-Closest-Points" class="headerlink" title="6 Closest Points"></a>6 Closest Points</h3><p>In this problem, your goal is to find the closest pair of points among the given 𝑛<br>points. This is a basic primitive in computational geometry having applications in,<br>for example, graphics, computer vision, traffic-control systems.</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol><li>题目中的要求求出一堆点的集合中距离最短的两个点的距离。这个题目我按照提示的要求做出来了，但是至今为止还没搞懂原理。</li><li>将点的集合按照横坐标<code>x</code>的大小进行排序，然后将集合按照横坐标的大小划分为左右两部分。递归求出左半部分的最小距离<code>dl</code>,右半部分的最小距离<code>dr</code>.</li><li>令<code>d = min(dl,dr)</code>,令<code>mid = p[(l+r)/2]</code>,求出所有距离线段<code>x = mid</code>的距离小于等于<code>d</code>的点。</li><li>将上述求得所有的点按照纵坐标<code>y</code>的大小进行排序，每次求出连续相邻<code>8</code>个点的最小距离为<code>d&#39;</code>，令<code>d = min(d,d&#39;)</code>,返回<code>d</code>即可。</li><li>代码本身比较简单，但是这个方法确实不容易想到。<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">  Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpX</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpY</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp; arr, <span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> DBL_MAX;</span><br><span class="line">    <span class="keyword">if</span>(r - l == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[l].x-arr[l+<span class="number">1</span>].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[l].y - arr[l+<span class="number">1</span>].y,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sort(arr.begin()+l,arr.begin()+r,cmpX);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> dl = helper(arr,l,mid);</span><br><span class="line">    <span class="keyword">double</span> dr = helper(arr,mid,r);</span><br><span class="line">    <span class="keyword">double</span> d = min(dl,dr);</span><br><span class="line">    <span class="keyword">int</span> ml = l;</span><br><span class="line">    <span class="keyword">int</span> mr = r<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ml &lt; r &amp;&amp; <span class="built_in">abs</span>(arr[ml].x - arr[mid].x) &gt; d) ml++;</span><br><span class="line">    <span class="keyword">while</span>(mr &gt;= l &amp;&amp; <span class="built_in">abs</span>(arr[mr].x - arr[mid].x) &gt; d) mr--;</span><br><span class="line">    sort(arr.begin() + ml,arr.begin() + mr + <span class="number">1</span>,cmpY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mr ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= mr &amp;&amp; j &lt;= i + <span class="number">7</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">double</span> dy = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[i].x-arr[j].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[i].y-arr[j].y,<span class="number">2</span>));</span><br><span class="line">            d = min(d,dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimal_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">    arr.push_back(Point(x[i],y[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> helper(arr,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; minimal_distance(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="5-Longest-Common-Subsequence-of-Three-Sequences"><a href="#5-Longest-Common-Subsequence-of-Three-Sequences" class="headerlink" title="5 Longest Common Subsequence of Three Sequences"></a>5 Longest Common Subsequence of Three Sequences</h3><p>Compute the length of a longest common subsequence of three sequences.</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ol><li>题目是求出三个字符串的最长公共子序列，稍微复杂点。</li><li>本题中有三个字符串<code>a,b,c</code>,我们设递推公式<code>dp[x][y][z]</code>为字符串<code>a</code>的到索引<code>x</code>处，字符串<code>b</code>的到索引<code>y</code>处，字符串<code>c</code>的到索引<code>z</code>处的最长公共子序列数目。</li><li>递推公式如下：<br>如果当<code>a[x] = b[y]</code>且<code>b[y] = c[z]</code>时：<script type="math/tex; mode=display">dp[x][y][z] = dp[x-1][y-1][z-1] \qquad if(a[x] = b[y] = c[z])</script>否则：<script type="math/tex; mode=display">dp[x][y][z] = min\left\{\begin{aligned}dp[x-1][y][z] \\dp[x][y-1][z] \\dp[x][y][z-1] \\\end{aligned}\right.</script></li><li>根据以上的递推公式即可。<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.size();</span><br><span class="line">    <span class="keyword">int</span> n = b.size();</span><br><span class="line">    <span class="keyword">int</span> l = c.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= l; ++k)&#123;</span><br><span class="line">              <span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>] &amp;&amp; b[j<span class="number">-1</span>] == c[k<span class="number">-1</span>])&#123;</span><br><span class="line">                  dp[i][j][k] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i<span class="number">-1</span>][j][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j<span class="number">-1</span>][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n][l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> an;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; an;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(an);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; an; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> bn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; bn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(bn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; bn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> cn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(cn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcs3(a, b, c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-Dynamic-Programming-2"><a href="#6-Dynamic-Programming-2" class="headerlink" title="6:Dynamic Programming 2"></a>6:Dynamic Programming 2</h2><p>最后两道题目稍微有点难度，别的都还好，也是<code>dp</code>的重要应用。<code>dp</code>的思想，最关键的是递推关系的确立。递推关系一般不好思考，这点需要经验。不过一般都是跟元素的大小有关系。</p><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p>You and two of your friends have just returned back home after visiting various countries. Now you would<br>like to evenly split all the souvenirs that all three of you bought.</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ol><li>这个也是动态规划，我们需要找到递推关系还是需要花费一定时间思考的。</li><li>首先思考一下数组本身，如果整个数组的和<code>sum</code>不能被3整除，那么该数组肯定不能划分成为相等的3个非重复的子序列。最终划分为3个子序列，每个子序列的和为$\frac{sum}{3}$.</li><li>我们思考一下，设动态规划递推公式<code>dp[i][x][y]</code>表示前<code>i</code>个元素能否被划分成为3个子序列，其中有两个字序列的和为<code>x,y</code>.实际这三个子序列的和应该分别为：<code>x,y,sum[i]-x-y</code>,则当我们加入第<code>i+1</code>个元素时，第<code>i+1</code>个元素可以分别加入到这三个不同的子序列，我们判断当其加入到这三个不同的子序列中时，等式是否成立.我们设立递推公式为如下：<script type="math/tex; mode=display">dp[i][x][y] = dp[i-1][x][y] \quad or \quad dp[i-1][x-arr[i]][y] \quad or \quad dp[i-1][x][y-arr[i]]</script></li><li>实际我们可以将题目本身的问题转化为n个元素划分为三个子序列，是否有其中两个子序列的和分别为$\frac{sum}{3}$.即<code>dp[n][sum/3][sum/3]</code>是否为成立。<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">        all += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(all%<span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    div = all/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*intiail*/</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= div; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= div; ++k)&#123;</span><br><span class="line">                dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]][k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k-A[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][div][div];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; partition3(A) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Maximum-Value-of-an-Arithmetic-Expression"><a href="#3-Maximum-Value-of-an-Arithmetic-Expression" class="headerlink" title="3 Maximum Value of an Arithmetic Expression"></a>3 Maximum Value of an Arithmetic Expression</h3><p>Find the maximum value of an arithmetic expression by specifying the order of applying its arithmetic<br>operations using additional parentheses.<br>In this problem, your goal is to add parentheses to a given arithmetic<br>expression to maximize its value. max(5−8+7×4−8+9) =?</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目非常类似于括号匹配的最大值，跟<code>leetcode</code>某个题目非常相似。</li><li>题目中由于加入了加法、减法、乘法，实际情况稍微复杂一些。我们首先设立<code>dpmax[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最大值,<code>dpmin[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最小值.我们仔细判断一下，分为以下三种情况,<code>l</code>代表符号左边的值，<code>r</code>代表符号右边的值：</li></ol><ul><li><code>+</code>：当符号为加号时我们肯定希望等式表示左右两边的加数最大。<script type="math/tex; mode=display">max(result) = max(l) + max(r) \qquad min(result) = min(l) + min(r)</script></li><li><code>-</code>：当符号为减号号时我们肯定希望等式表示左边的数最大，右边的数。<script type="math/tex; mode=display">max(result) = max(l) - min(r) \qquadmin(result) = min(l) - max(r)</script></li><li><code>*</code>：当符号为乘号时，情况比较复杂，因为涉及到乘积的符号的问题，但是<script type="math/tex; mode=display">max(result) = max\left\{\begin{aligned}max(l)*max(r)\\min(l)*max(r)\\    max(l)*min(r)\\min(l)*min(r)\\  \end{aligned}\right.</script><script type="math/tex; mode=display">min(result) = min\left\{\begin{aligned}max(l)*max(r)\\min(l)*max(r)\\    max(l)*min(r)\\min(l)*min(r)\\  \end{aligned}\right.</script></li></ul><ol><li>我们接下来我们需要仔细处理等式划分的问题，因为这涉及到括号的问题。<code>dp[i][j]</code>代表从<code>i</code>到<code>j</code>的表达式，我们可以从<code>i+1</code>,<code>i+2</code>,<code>i+3</code>,…,<code>j-1</code>处进行断开。</li><li>我们可以看到如下：</li></ol><script type="math/tex; mode=display">dpmax[i][j]  =  max\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned} \right. \qquad  (i \le k \le j)</script><script type="math/tex; mode=display">dpmin[i][j] = min\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\ eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned}\right. \qquad  (i \le k \le j)</script><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">eval</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="string">'*'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'+'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">'+'</span>|| c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_maximum_value</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n = (<span class="built_in">exp</span>.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp1(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MAX));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp2(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MIN));</span><br><span class="line">  <span class="comment">/*intial*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isDigit(<span class="built_in">exp</span>[i])) nums.push_back(<span class="built_in">exp</span>[i] - <span class="string">'0'</span>);</span><br><span class="line">      <span class="keyword">if</span>(isOp(<span class="built_in">exp</span>[i])) op.push_back(<span class="built_in">exp</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    dp1[i][i] = nums[i];</span><br><span class="line">    dp2[i][i] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt;= j+i; ++k)&#123;</span><br><span class="line">              <span class="comment">/*min expression*/</span></span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*max expression*/</span></span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp2[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_maximum_value(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Toolbox&quot;&gt;&lt;a href=&quot;#Algorithmic-Toolbox&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Toolbox&quot;&gt;&lt;/a&gt;Algorithmic Toolbox&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是基本题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithmic Toolbox
&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithmic Toolbox》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithmic-Toolbox%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第186周比赛</title>
    <link href="http://yoursite.com/2020/04/26/155/"/>
    <id>http://yoursite.com/2020/04/26/155/</id>
    <published>2020-04-26T09:15:42.260Z</published>
    <updated>2020-04-26T09:15:44.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="186周比赛"><a href="#186周比赛" class="headerlink" title="186周比赛"></a>186周比赛</h1><p>本周题目的质量不错。</p><h2 id="5392-分割字符串的最大得分"><a href="#5392-分割字符串的最大得分" class="headerlink" title="5392. 分割字符串的最大得分"></a>5392. 分割字符串的最大得分</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由若干 <code>0</code> 和<code>1</code> 组成的字符串 <code>s</code>，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"011101"</span></span><br><span class="line">输出：<span class="number">5</span> </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 = <span class="string">"0"</span> 且 右子字符串 = <span class="string">"11101"</span>，得分 = <span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span> </span><br><span class="line">左子字符串 = <span class="string">"01"</span> 且 右子字符串 = <span class="string">"1101"</span>，得分 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> </span><br><span class="line">左子字符串 = <span class="string">"011"</span> 且 右子字符串 = <span class="string">"101"</span>，得分 = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> </span><br><span class="line">左子字符串 = <span class="string">"0111"</span> 且 右子字符串 = <span class="string">"01"</span>，得分 = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> </span><br><span class="line">左子字符串 = <span class="string">"01110"</span> 且 右子字符串 = <span class="string">"1"</span>，得分 = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00111"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：当 左子字符串 = <span class="string">"00"</span> 且 右子字符串 = <span class="string">"111"</span> 时，我们得到最大得分 = <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身数据量非常小，我们实际只需暴力匹配即可。非常简单<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCurr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) one++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) zero++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) oneCurr++;</span><br><span class="line">            res = max(res,zero + one - oneCurr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5393-可获得的最大点数"><a href="#5393-可获得的最大点数" class="headerlink" title="5393. 可获得的最大点数"></a>5393. 可获得的最大点数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code>给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组<code>cardPoints</code> 和整数<code>k</code>，请你返回可以获得的最大点数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="number">1</span> + <span class="number">6</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">55</span></span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">1000</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="number">1</span> 。</span><br><span class="line">``` </span><br><span class="line">示例 <span class="number">5</span>：</span><br></pre></td></tr></table></figure><br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints.length &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints[i] &lt;= <span class="number">10</span>^<span class="number">4</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= k &lt;= cardPoints.length`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 数组的前缀和后缀组合，前`i`个前缀和后`k-i`个后缀之和的最大值。</span><br><span class="line">$$</span><br><span class="line">f = max(prefix[i] + suffix[k-i])  \: i \<span class="keyword">in</span>(<span class="number">0</span>,...,k)</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 另一种思路，求滑动窗口，求出剩余的连续`n-k`个元素的最小值，总数减去这个值即可。</span><br><span class="line">$$</span><br><span class="line">f = \sum_&#123;i=<span class="number">1</span>&#125;^&#123;n&#125; p[i] - min(sum(i,i+n-k<span class="number">-1</span>))  \: i \<span class="keyword">in</span>(<span class="number">1</span>,...,k)</span><br><span class="line">$$</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxScore(vector&lt;<span class="built_in">int</span>&gt;&amp; cardPoints, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = cardPoints.size();</span><br><span class="line">        <span class="built_in">int</span> m = n-k;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> remove = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += cardPoints[i];</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m<span class="number">-1</span> &amp;&amp; m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                remove = min(curr,remove);</span><br><span class="line">                curr -= cardPoints[i-m+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(remove == INT_MAX) remove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum - remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5394-对角线遍历-II"><a href="#5394-对角线遍历-II" class="headerlink" title="5394. 对角线遍历 II"></a>5394. 对角线遍历 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个列表 <code>nums</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i].length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i][j] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">nums 中最多有 <span class="number">10</span>^<span class="number">5</span> 个数字。</span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diagonal-traverse-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是蛮有意思。首先对角线打印其实很简单，但是时间复杂度的话 会超时。</li><li>我们应该找规律，想更快的办法，后来仔细分析一下，我们可以对每个元素的下标进行排序，按照<code>rowindex</code>和<code>colindex</code>的和的大小进行顺序排序，如果和相等，再按照<code>rowindex</code>从大到小排序。</li><li>根据索引的排序结果输入所有元素。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sa = a.first + a.second;</span><br><span class="line">        <span class="keyword">int</span> sb = b.first + b.second;</span><br><span class="line">        <span class="keyword">if</span>(sa == sb) <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        <span class="keyword">return</span> sa &lt; sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums[n<span class="number">-1</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); ++j)&#123;</span><br><span class="line">                idx.push_back(make_pair(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(idx.begin(),idx.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx.size(); ++i)&#123;</span><br><span class="line">            res.push_back(nums[idx[i].first][idx[i].second]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5180-带限制的子序列和"><a href="#5180-带限制的子序列和" class="headerlink" title="5180. 带限制的子序列和"></a>5180. 带限制的子序列和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 <code>nums[i]</code> 和 <code>nums[j]</code>，它们在原数组中的下标 i 和 j 满足<code>i &lt; j</code>且 <code>j - i &lt;= k</code>。</p><p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">37</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">-2</span>,<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">-2</span>, <span class="number">-5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/constrained-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/constrained-subset-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本题基本一眼看到就是动态规划。</li><li>仔细思考一下我们设<code>dp[i]</code>为前<code>i</code>个元素的最大子序列和且包含第<code>i</code>个元素。</li><li>按照常规思路<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[0],dp[1],dp[2],...,dp[i-1])+nums[i]);</script></li><li>但是本题中限制了两个元素之间的相隔不超过<code>k</code>则上述递推公式应该变为：<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[i-k],dp[i-k+1],dp[i-k+2],...,dp[i-1])+nums[i]);</script></li><li>我们用滑动窗口即可，我们利用优先级队列，保留前<code>k</code>元素的最大子序列，每次取前<code>k</code>个元素的最大子序列和的最大值。如果队列的元素个数大于<code>k</code>则去掉队首的元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        prev.insert(dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = max(nums[i],*prev.rbegin() + nums[i]);</span><br><span class="line">            prev.insert(dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) prev.erase(dp[i-k]);</span><br><span class="line">            res = max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;186周比赛&quot;&gt;&lt;a href=&quot;#186周比赛&quot; class=&quot;headerlink&quot; title=&quot;186周比赛&quot;&gt;&lt;/a&gt;186周比赛&lt;/h1&gt;&lt;p&gt;本周题目的质量不错。&lt;/p&gt;&lt;h2 id=&quot;5392-分割字符串的最大得分&quot;&gt;&lt;a href=&quot;#5392-分割字符串的最大得分&quot; class=&quot;headerlink&quot; title=&quot;5392. 分割字符串的最大得分&quot;&gt;&lt;/a&gt;5392. 分割字符串的最大得分&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由若干 &lt;code&gt;0&lt;/code&gt; 和&lt;code&gt;1&lt;/code&gt; 组成的字符串 &lt;code&gt;s&lt;/code&gt;，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCP2020</title>
    <link href="http://yoursite.com/2020/04/20/154/"/>
    <id>http://yoursite.com/2020/04/20/154/</id>
    <published>2020-04-20T15:00:58.392Z</published>
    <updated>2020-04-22T09:39:59.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCP2020"><a href="#LCP2020" class="headerlink" title="LCP2020"></a>LCP2020</h1><p>还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。</p><h2 id="LCP-06-拿硬币"><a href="#LCP-06-拿硬币" class="headerlink" title="LCP 06. 拿硬币"></a>LCP 06. 拿硬币</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>桌上有 <code>n</code>堆力扣币，每堆的数量保存在数组 <code>coins</code>中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 <span class="number">2</span> 次，第二堆最少需要拿 <span class="number">1</span> 次，第三堆最少需要拿 <span class="number">1</span> 次，总共 <span class="number">4</span> 次即可拿完。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><br>限制：</p><a id="more"></a><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/na-ying-bi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/na-ying-bi</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单题目直接计算即可。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            res += (c+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a>LCP 07. 传递信息</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小朋友 <code>A</code> 在和<code>ta</code>的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比3. A 可以向 B 传信息，但 B 不能向 A 传信息）。<br> 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 n，以及按 <code>[玩家编号,对应可传递玩家编号]</code>关系组成的二维数组 <code>relation</code>。返回信息从小<code>A</code>(编号 0 ) 经过 <code>k</code>轮传递到编号为<code>n-1</code> 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>]], k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：信息从小 A 编号 <span class="number">0</span> 处开始，经 <span class="number">3</span> 轮传递，到达编号 <span class="number">4</span>。共有 <span class="number">3</span> 种方案，分别是 <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：信息不能从小 A 处经过 <span class="number">2</span> 轮传递到编号 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chuan-di-xin-xi</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><code>dp[i][j]</code>代表从经过<code>i</code>轮传递到<code>j</code>的方案数。<script type="math/tex; mode=display">dp[i][j] = \sum_{v = 1}^{n}dp[i-1][v] \:\:  if(edge[v][j] == true)</script></li><li>非常简单的<code>dp</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : relation)&#123;</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][v] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] += dp[i<span class="number">-1</span>][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[k][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-08-剧情触发时间"><a href="#LCP-08-剧情触发时间" class="headerlink" title="LCP 08. 剧情触发时间"></a>LCP 08. 剧情触发时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 <code>increase</code>来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如<code>[[1,2,1],[3,4,2]]</code>表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。</p><p>所有剧情的触发条件也用一个二维数组<code>requirements</code>表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code>且 <code>H &gt;= h[i]</code>，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]] requirements = [[<span class="number">2</span>,<span class="number">11</span>,<span class="number">3</span>],[<span class="number">15</span>,<span class="number">10</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>],[<span class="number">8</span>,<span class="number">1</span>,<span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">初始时，C = <span class="number">0</span>，R = <span class="number">0</span>，H = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 天，C = <span class="number">2</span>，R = <span class="number">8</span>，H = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">2</span> 天，C = <span class="number">4</span>，R = <span class="number">13</span>，H = <span class="number">4</span>，此时触发剧情 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">3</span> 天，C = <span class="number">14</span>，R = <span class="number">22</span>，H = <span class="number">12</span>，此时触发剧情 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">剧情 <span class="number">1</span> 和 <span class="number">3</span> 无法触发。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>]] requirements = [[<span class="number">12</span>,<span class="number">11</span>,<span class="number">16</span>],[<span class="number">20</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">10</span>,<span class="number">18</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">14</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = <span class="string">[[1,1,1]]</span> requirements = <span class="string">[[0,0,0]]</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>限制：`</p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常典型的二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找，当时竟然很麻烦的用的线段树完成该题的解答。</li><li>我们把所有天数的属性值全部叠加起来组成数组，然后利用二分查找的特性查找满足剧情要求的最小的天数。</li><li>关于二分查找算法，自己掌握的还是不够好，经常对于边界条件处理的不好。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getTriggerTime(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; increase, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requirements) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = increase.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; days;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        days.push_back(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : increase)&#123;</span><br><span class="line">            curr[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">            curr[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">            curr[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">            days.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : requirements)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = days.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(days[mid][<span class="number">0</span>] &lt; v[<span class="number">0</span>] || days[mid][<span class="number">1</span>] &lt; v[<span class="number">1</span>] || days[mid][<span class="number">2</span>] &lt; v[<span class="number">2</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(days[l][<span class="number">0</span>] &gt;= v[<span class="number">0</span>] &amp;&amp; days[l][<span class="number">1</span>] &gt;= v[<span class="number">1</span>] &amp;&amp; days[l][<span class="number">2</span>] &gt;= v[<span class="number">2</span>])&#123;</span><br><span class="line">                res.push_back(l);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-09-最小跳跃次数"><a href="#LCP-09-最小跳跃次数" class="headerlink" title="LCP 09. 最小跳跃次数"></a>LCP 09. 最小跳跃次数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射<code>jump[i]</code>的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 <code>i+jump[i]</code> 的弹簧（若 <code>i+jump[i]&gt;=N</code> ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p><p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：jump = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：小 Z 最少需要按动 <span class="number">3</span> 次弹簧，小球依次到达的顺序为 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">6</span>，最终小球弹出了机器。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= jump.length &lt;= 10^6</code></li><li><code>1 &lt;= jump[i] &lt;= 10000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  BFS或者DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始准备用BFS，第一次写BFS时竟然超时了，后来仔细发现还是部分条件存在重复的问题。</li><li>每次往前跳的时候或者往后跳的时候如果发现部分元素已经访问过时，需要将其剔除掉。</li><li>记录当前步数下所能够跳的最远距离，这时下一布如果选择往回跳时，直接从上一次的最大值开始常识，而不必要从0开始跳起。算法的时间复杂度为<code>O(n)</code>.</li><li>其实这个题目刚开始准备利用<code>set</code>自动排序的特性，每次直接将已经访问的元素直接从<code>set</code>中自动去掉。算法的时间时间复杂度为<code>O(lgn)</code>,因为二叉平衡树每次进行查找时需要<code>lgn</code>的时间复杂度，结果意外的超时，最后一个测试用例无法通过。</li><li>时间仔细计算以下，题目中的数量级为<code>10e6</code>,如果利用二分查找，则时间复杂度的数量级在<code>1e7</code>次方的数量级，这种情况下其实很容易超时。</li><li>仔细想想其实绝大部分问题的最优解法其实都是非常简单的，并且基本上思路都很直接和简单，实际在做题的时候如果把题目想的太复杂的话，很可能时自己的解法应该时错误的，这点必须知道自己的错误点在哪里，思路在哪里。其实目前刷题来说对于应付一般的面试肯定没有什么问题，但是如果正对于竞赛的话，自己的水平其实差的太远太远。</li><li>对于竞赛的话，感觉自己这种老人肯定是远远达不到年轻人的水平。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = jump.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= n) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= mx) qu.push(curr + jump[curr]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = mx; j &lt; curr; ++j) qu.push(j);</span><br><span class="line">                mx = max(mx,curr + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-10-二叉树任务调度"><a href="#LCP-10-二叉树任务调度" class="headerlink" title="LCP 10. 二叉树任务调度"></a>LCP 10. 二叉树任务调度</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。</p><p>通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 <code>root</code> 为根任务，<code>root.left</code> 和 <code>root.right</code> 为他的两个前导任务（可能为空），<code>root.val</code> 为其自身的执行时间。</p><p>在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。</p><p>现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">47</span>, <span class="number">74</span>, <span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">121</span></span><br><span class="line"></span><br><span class="line">解释：根节点的左右节点可以并行执行<span class="number">31</span>分钟，剩下的<span class="number">43</span>+<span class="number">47</span>分钟只能串行执行，因此总体执行时间是<span class="number">121</span>分钟。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">15</span>, <span class="number">21</span>, <span class="literal">null</span>, <span class="number">24</span>, <span class="literal">null</span>, <span class="number">27</span>, <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">87</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">7.5</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= 节点数量 &lt;= 1000</code></li><li><code>1 &lt;= 单节点执行时间 &lt;= 1000</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>当时比赛的时候没有想明白，解题思路可以参考lee215的微信公众号<a href="https://mp.weixin.qq.com/s/rmwVuDpbQlhoK7DcD715bg" target="_blank" rel="noopener">2020力扣杯</a>。</li><li>后来仔细思考了一下，还是非常有意思的，当时比赛时想到了这点，但是如何进一步优化确实没有深入思考，遇到困难就放弃，确实是自己最大的问题。</li><li>根据题目种的思路，实际上对于节点<code>root</code>,它的左右子树的任务是可以进行并行运行的，我们整个的解题思路也是围绕着，如何能够更好的解决左右子树同时并行的任务的最大值的问题。我们<code>dfs</code>时，每次返回<code>root</code>节点下双核并行任务的运行时间和单核任务运行的时间，分别为<code>s</code>,<code>d</code>,如何围绕左右子树的任务进行合并。</li><li>我们假设当前<code>root</code>节点的左子树返回的双核并行时间和单核运行时间分别为<code>d1</code>,<code>s1</code>.右子树返回的双核并行时间和单核运行时间分别为<code>d2</code>,<code>s2</code>.常规思路是我们讲所有的并行时间加起来，再把单核运行的时间中的部分最小值部分进行并行即<code>min(s1,s2)</code>.<br>所以我们可以得到左右子树的总共的并行时间为：<script type="math/tex; mode=display">d = d1 + d2 + min(s1,s2)</script>左右子树的总共的单核运行时间为:<script type="math/tex; mode=display">s = abs(s1-s2)</script>所以完成左右子树的任务的总时间应该为：<script type="math/tex; mode=display">t = d + s = d1 + d2 + min(s1,s2) + abs(s1-s2)\\</script></li><li>上面这样的结果基本上大部分人都能想到，但是实际上这样真的是最小吗？我们能否再增加d的时间，减少s的时间？但是如何再增加并行的时间，可能讨论就非常的复杂。隐隐约约感觉可以进行优化，因为我们知道假设并行的时间d再增减$\Delta t1$,单核运行的时间就可以减少$2\Delta t1$,总的时间也就减少$\Delta t1$, 也即我们想办法如何减少<code>abs(s1-s2)</code>，减少单核运行的时间。<script type="math/tex; mode=display">t = d + \Delta t1 + s - 2\Delta t1 = d + s - \Delta t1\\0 \le \Delta t1 \le \frac{s}{2} \\</script>仔细思考一下，这点稍微有点绕弯。如何进行优化呢？比如<code>s1 &gt; s2</code>,我们能否减少<code>d2</code>的并行时间$\Delta t$,然后<code>s2</code>就增加了$2 \Delta t$的时间内然后<code>s1</code>就能增加$2 \Delta t$与<code>s2</code>进行并行，这样我们就能够增加并行时间，那么总的消耗时间也就减少了。<script type="math/tex; mode=display">d2 = d2 - \Delta t\\s2 = s2 + 2*\Delta t\\t = d + s  \\t = d1 + d2  - \Delta t + min(s1,s2 + 2*\Delta t) + abs(s1-s2-2*\Delta t)</script>也就是我们要从<code>d2</code>中剥离部分时间尽量延长<code>s2</code>的使得<code>abs(s1-s2)</code>最小。只有这样才能得到最小值，实际也是贪心算法。所以当<code>s1 &gt; s2</code>时我们就要想办法提高<code>s2</code>,当<code>s2 &gt; s1</code>时我们就需要想办法提高<code>s1</code>.只有这样才能保证绝对值之差最小。<br>已知如下条件:<script type="math/tex; mode=display">s1 \ge s2 \\s1 \ge s2 - 2*\Delta t\\d2 \ge \Delta t\\d = d1 + d2 + min(s1,s2) = d1 + d2 + s2\\s = abs(s1-s2) = s1 - s2 \\t = d1 + d2 + s1 \\</script>我们对上述表达式进行展开：<script type="math/tex; mode=display">d^{'} = d1 + d2 + s2 + \Delta t \\s^{'} = s1 - s2 - 2*\Delta t \\t^{'} = d1 + d2  - \Delta t + s2 + 2*\Delta t  + (s1-s2-2*\Delta t)  \\t^{'} = d1 + d2 - \Delta t + s1</script>当然最优解的话肯定为：<script type="math/tex; mode=display">\Delta t = \frac{s1-s2}{2}</script>但由于还有下面的限制。<script type="math/tex; mode=display">d2 \ge \Delta t\\</script>所以总结起来：<script type="math/tex; mode=display">\Delta T = min(\frac{s1-s2}{2},d2)</script><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; dfs(TreeNode * root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; l = dfs(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> delta = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(l.first &gt;= r.first)&#123;</span><br><span class="line">            delta = min((l.first-r.first)/<span class="number">2</span>,r.second);</span><br><span class="line">            d = l.second + r.second + r.first + delta;</span><br><span class="line">            s = l.first - r.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            delta = min((r.first-l.first)/<span class="number">2</span>,l.second);</span><br><span class="line">            d = l.second + r.second + l.first + delta;</span><br><span class="line">            s = r.first - l.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">minimalExecTime</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; t = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> t.first + t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCP2020&quot;&gt;&lt;a href=&quot;#LCP2020&quot; class=&quot;headerlink&quot; title=&quot;LCP2020&quot;&gt;&lt;/a&gt;LCP2020&lt;/h1&gt;&lt;p&gt;还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。&lt;/p&gt;&lt;h2 id=&quot;LCP-06-拿硬币&quot;&gt;&lt;a href=&quot;#LCP-06-拿硬币&quot; class=&quot;headerlink&quot; title=&quot;LCP 06. 拿硬币&quot;&gt;&lt;/a&gt;LCP 06. 拿硬币&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;桌上有 &lt;code&gt;n&lt;/code&gt;堆力扣币，每堆的数量保存在数组 &lt;code&gt;coins&lt;/code&gt;中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 次，第二堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，第三堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，总共 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;限制：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第185周比赛</title>
    <link href="http://yoursite.com/2020/04/19/153/"/>
    <id>http://yoursite.com/2020/04/19/153/</id>
    <published>2020-04-19T00:37:17.252Z</published>
    <updated>2020-04-20T15:00:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="185周比赛"><a href="#185周比赛" class="headerlink" title="185周比赛"></a>185周比赛</h1><p>今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。</p><h2 id="5388-重新格式化字符串"><a href="#5388-重新格式化字符串" class="headerlink" title="5388. 重新格式化字符串"></a>5388. 重新格式化字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"a0b1c2"</span></span><br><span class="line">输出：<span class="string">"0a1b2c"</span></span><br><span class="line">解释：<span class="string">"0a1b2c"</span> 中任意两个相邻字符的类型都不同。 <span class="string">"a0b1c2"</span>, <span class="string">"0a1b2c"</span>, <span class="string">"0c2a1b"</span> 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"leetcode"</span> 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1229857369"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"1229857369"</span> 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"covid2019"</span></span><br><span class="line">输出：<span class="string">"c2o0v1i9d"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ab123"</span></span><br><span class="line">输出：<span class="string">"1a2b3"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 仅由小写英文字母和/或数字组成。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reformat-the-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reformat-the-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>字母的数目和数字的数目差的绝对值大于2则不可能产生出相应的字符串。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformat</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(s.size(),<span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) digit++;</span><br><span class="line">            <span class="keyword">else</span> alpha++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(digit-alpha) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> la = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(digit &gt; alpha)&#123;</span><br><span class="line">            ld = <span class="number">0</span>;</span><br><span class="line">            la = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ld = <span class="number">1</span>;</span><br><span class="line">            la = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res[ld] = c;</span><br><span class="line">                ld += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[la] = c;</span><br><span class="line">                la += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5389-点菜展示表"><a href="#5389-点菜展示表" class="headerlink" title="5389. 点菜展示表"></a>5389. 点菜展示表</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code>是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code>是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 <code>“Table”</code> ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Corina"</span>,<span class="string">"10"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Water"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Rous"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Ceviche"</span>,<span class="string">"Fried Chicken"</span>,<span class="string">"Water"</span>],[<span class="string">"3"</span>,<span class="string">"0"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>],[<span class="string">"5"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>],[<span class="string">"10"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>]] </span><br><span class="line">解释：</span><br><span class="line">点菜展示表如下所示：</span><br><span class="line">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class="line"><span class="number">3</span>    ,<span class="number">0</span>           ,<span class="number">2</span>      ,<span class="number">1</span>            ,<span class="number">0</span></span><br><span class="line"><span class="number">5</span>    ,<span class="number">0</span>           ,<span class="number">1</span>      ,<span class="number">0</span>            ,<span class="number">1</span></span><br><span class="line"><span class="number">10</span>   ,<span class="number">1</span>           ,<span class="number">0</span>      ,<span class="number">0</span>            ,<span class="number">0</span></span><br><span class="line">对于餐桌 <span class="number">3</span>：David 点了 <span class="string">"Ceviche"</span> 和 <span class="string">"Fried Chicken"</span>，而 Rous 点了 <span class="string">"Ceviche"</span></span><br><span class="line">而餐桌 <span class="number">5</span>：Carla 点了 <span class="string">"Water"</span> 和 <span class="string">"Ceviche"</span></span><br><span class="line">餐桌 <span class="number">10</span>：Corina 点了 <span class="string">"Beef Burrito"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"James"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Ratesh"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Amadeus"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Adam"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>],[<span class="string">"Brianna"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Canadian Waffles"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"0"</span>],[<span class="string">"12"</span>,<span class="string">"0"</span>,<span class="string">"3"</span>]] </span><br><span class="line">解释：</span><br><span class="line">对于餐桌 <span class="number">1</span>：<span class="symbol">Adam</span> 和 <span class="symbol">Brianna</span> 都点了 <span class="string">"Canadian Waffles"</span></span><br><span class="line">而餐桌 <span class="number">12</span>：<span class="symbol">James</span>, <span class="symbol">Ratesh</span> 和 <span class="symbol">Amadeus</span> 都点了 <span class="string">"Fried Chicken"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"Laura"</span>,<span class="string">"2"</span>,<span class="string">"Bean Burrito"</span>],[<span class="string">"Jhon"</span>,<span class="string">"2"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"Melissa"</span>,<span class="string">"2"</span>,<span class="string">"Soda"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Bean Burrito"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Soda"</span>],[<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li><li><code>orders[i].length == 3</code></li><li><code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li><li><code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 ‘ ‘ 组成。</li><li><code>tableNumberi</code> 是 1 到 500 范围内的整数。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant" target="_blank" rel="noopener">https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 系统设计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>用map保存每桌的点餐的事物和数量。同时<code>set</code>保存所有的菜品。</li><li>每次点餐时在每桌的订单上进行数据叠加。</li><li>最后统计就非常简单了。直接map查询每周每个菜品订单的数量即可。</li><li>用<code>map</code>和<code>set</code>可以直接利用二叉查找树的自动排序功能，避免二次排序。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; displayTable(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; table;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; foods;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; type;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> order : orders)&#123;</span><br><span class="line">            table[stoi(order[<span class="number">1</span>])][order[<span class="number">2</span>]]++;</span><br><span class="line">            foods.insert(order[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        type.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : foods)&#123;</span><br><span class="line">            type.push_back(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*first colum*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        res.push_back(type);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : table)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; col;</span><br><span class="line">            col.push_back(to_string(p.first));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; type.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.second.count(type[i]))&#123;</span><br><span class="line">                    col.push_back(to_string(p.second[type[i]]));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    col.push_back(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5390-数青蛙"><a href="#5390-数青蛙" class="headerlink" title="5390. 数青蛙"></a>5390. 数青蛙</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>&quot;croak&quot;</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code>。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p><p>注意：要想发出蛙鸣 <code>&quot;croak&quot;</code>，青蛙必须 依序 输出<code>‘c’, ’r’, ’o’, ’a’, ’k’</code>这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p><p>如果字符串 <code>croakOfFrogs</code>不是由若干有效的<code>&quot;croak&quot;</code> 字符混合而成，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroak"</span></span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"crcoakroak"</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class="line">第一只青蛙 <span class="string">"crcoakroak"</span></span><br><span class="line">第二只青蛙 <span class="string">"crcoakroak"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcrook"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：给出的字符串不是 <span class="string">"croak"</span> 的有效组合。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroa"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li><li>字符串中的字符只有<code>&#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39;</code>或者 <code>&#39;k&#39;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常有点绕</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>判断是否需要数目加1</code>：遇到字母<code>c</code>时判断当前是否已经有完成呼叫的任务，如果有则直接将其拿过来进行重新呼叫一次，否则再新加进来一只青蛙进行呼叫。</li><li><code>判断当前呼叫是否合法</code>: 判断当前字母的统计数目是否大于前一个字母的数目，如果是则时非法的，表示该次呼叫未按照顺序进行拼写呼叫。全部呼叫完成后，最后判断所有的青蛙是否全部完成呼叫，即所有的字母统计数目相等。</li><li>返回字符的统计数目即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkFrog</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;  p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x != p.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="built_in">string</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"croak"</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; prev;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            prev[s[i]] = s[(i+<span class="number">4</span>)%<span class="number">5</span>];</span><br><span class="line">            cnt[s[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'c'</span> &amp;&amp; checkFrog(cnt))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); ++j) cnt[s[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[A[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(A[i] != <span class="string">'c'</span> &amp;&amp; cnt[A[i]] &gt; cnt[prev[A[i]]]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!checkValid(cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="string">'c'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5391-生成数组"><a href="#5391-生成数组" class="headerlink" title="5391. 生成数组"></a>5391. 生成数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数 <code>n、m 和 k</code>。下图描述的算法用于找出正整数数组中最大的元素。</p><p>请你生成一个具有下述属性的数组 <code>arr</code>：</p><ul><li><code>arr</code>中有 n 个整数。</li><li><code>1 &lt;= arr[i] &lt;= m</code>其中<code>(0 &lt;= i &lt; n)</code> 。</li><li>将上面提到的算法应用于 <code>arr ，search_cost</code>的值等于 k 。</li></ul><p>返回上述条件下生成数组 <code>arr</code>的 方法数 ，由于答案可能会很大，所以 必须 对 <code>10^9 + 7</code>取余。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：可能的数组分别为 [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>] [<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：可能的数组只有 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">50</span>, m = <span class="number">100</span>, k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">34549172</span></span><br><span class="line">解释：不要忘了对 <span class="number">1000000007</span> 取余</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">37</span>, m = <span class="number">17</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">418930126</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设<code>dp[i][j][k]</code>代表数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>的数组的方案数目。</li><li>我们假设当前数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>。则当数组长度为<code>i+1</code>时，如果第<code>i+1</code>个数大于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该为为<code>k+1</code>,则这时第<code>i+1</code>个数的取值范围为<code>j+1~m</code>;如果第<code>i+1</code>个数小于等于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该仍然为<code>k</code>,则这时第<code>i+1</code>个数应该取值范围为<code>1~j</code>。因此我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][j][k] = dp[i-1][j][k]*j + \sum_{x=1}^{j-1}dp[i-1][x][k-1]</script></li><li>最后我们可以得到得分为<code>k</code>的总的方案数目:<script type="math/tex; mode=display">total = \sum_{i=1}^{m}dp[n][i][k]</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">51</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[N][M][K];</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">2</span>; a &lt;= n; ++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= m; ++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= k &amp;&amp; c &lt;= b &amp;&amp; c &lt;= a; ++c)&#123;</span><br><span class="line">                    dp[a][b][c] = (b*dp[a<span class="number">-1</span>][b][c])%mod;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> mx = <span class="number">1</span>; mx &lt; b; ++mx)&#123;</span><br><span class="line">                        dp[a][b][c] = (dp[a][b][c] + dp[a<span class="number">-1</span>][mx][c<span class="number">-1</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            total = (total + dp[n][i][k])%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;185周比赛&quot;&gt;&lt;a href=&quot;#185周比赛&quot; class=&quot;headerlink&quot; title=&quot;185周比赛&quot;&gt;&lt;/a&gt;185周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。&lt;/p&gt;&lt;h2 id=&quot;5388-重新格式化字符串&quot;&gt;&lt;a href=&quot;#5388-重新格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;5388. 重新格式化字符串&quot;&gt;&lt;/a&gt;5388. 重新格式化字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。&lt;/p&gt;&lt;p&gt;请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。&lt;/p&gt;&lt;p&gt;请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第24场双周比赛</title>
    <link href="http://yoursite.com/2020/04/18/152/"/>
    <id>http://yoursite.com/2020/04/18/152/</id>
    <published>2020-04-18T10:19:10.180Z</published>
    <updated>2020-04-19T12:19:12.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24周双周比赛"><a href="#24周双周比赛" class="headerlink" title="24周双周比赛"></a>24周双周比赛</h1><p>今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部<code>AC</code>，不过跟那些大神不能比，10分钟<code>AC</code>四道题的那种。</p><h2 id="5372-逐步求和得到正数的最小值"><a href="#5372-逐步求和得到正数的最小值" class="headerlink" title="5372. 逐步求和得到正数的最小值"></a>5372. 逐步求和得到正数的最小值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 正数 <code>startValue</code> 作为初始值。</p><p>你需要从左到右遍历<code>nums</code> 数组，并将 <code>startValue</code> 依次累加上<code>nums</code>数组中的值。</p><a id="more"></a><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 <code>startValue</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：如果你选择 startValue = <span class="number">4</span>，在第三次累加时，和小于 <span class="number">1</span> 。</span><br><span class="line">                累加求和</span><br><span class="line">                startValue = <span class="number">4</span> | startValue = <span class="number">5</span> | nums</span><br><span class="line">                  (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>  | (<span class="number">5</span> <span class="number">-3</span> ) = <span class="number">2</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">1</span> +<span class="number">2</span> ) = <span class="number">3</span>  | (<span class="number">2</span> +<span class="number">2</span> ) = <span class="number">4</span>    |   <span class="number">2</span></span><br><span class="line">                  (<span class="number">3</span> <span class="number">-3</span> ) = <span class="number">0</span>  | (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">0</span> +<span class="number">4</span> ) = <span class="number">4</span>  | (<span class="number">1</span> +<span class="number">4</span> ) = <span class="number">5</span>    |   <span class="number">4</span></span><br><span class="line">                  (<span class="number">4</span> +<span class="number">2</span> ) = <span class="number">6</span>  | (<span class="number">5</span> +<span class="number">2</span> ) = <span class="number">7</span>    |   <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最小的 startValue 需要是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求前<code>n</code>项和的最小值。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们最低需要满足前<code>n</code>项和的最小值与这个数相加大于等于<code>1</code>即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res = max(res,<span class="number">1</span>-sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5373-和为-K-的最少斐波那契数字数目"><a href="#5373-和为-K-的最少斐波那契数字数目" class="headerlink" title="5373. 和为 K 的最少斐波那契数字数目"></a>5373. 和为 K 的最少斐波那契数字数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你数字 <code>k</code>，请你返回和为<code>k</code>的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><ul><li><code>F1 = 1</code></li><li><code>F2 = 1</code></li><li><code>Fn = Fn-1 + Fn-2</code> ， 其中 n &gt; 2 。</li></ul><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：斐波那契数字为：<span class="number">1</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">8</span>，<span class="number">13</span>，……</span><br><span class="line">对于 k = <span class="number">7</span> ，我们可以得到 <span class="number">2</span> + <span class="number">5</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：对于 k = <span class="number">10</span> ，我们可以得到 <span class="number">2</span> + <span class="number">8</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">19</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：对于 k = <span class="number">19</span> ，我们可以得到 <span class="number">1</span> + <span class="number">5</span> + <span class="number">13</span> = <span class="number">19</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似很简单，但当时卡壳了好久。后来仔细研究了一下，发现了规律。</li><li>我们找出所有不大于<code>k</code>的斐波那契数列，如果k在数列中，我们直接返回1.</li><li>否则我们找到最大且最接近<code>k</code>的斐波那契数<code>m</code>, 然后再递归求<code>k-m</code>最少需要多少个费不纳妾数组合。<code>fib(k)</code>表示最大的小于等于<code>K</code>的斐波那契数。<script type="math/tex; mode=display">F(k) = 1 + F(k-fib(k))</script></li><li>贴了一下证明过程，用数学归纳法证明比较有意思：</li></ol><ul><li>对于$k=1$是显然成立.</li><li>假设$k=1…N$都成立,则当$k=N+1$时，如果$k$本身是斐波那契数，自然成立，否则一定存在<code>m</code>,使得下述不等式成立：<script type="math/tex; mode=display">Fib_{m}<k<Fib_{m+1}</script></li><li>根据上述不等式可以化为：<script type="math/tex; mode=display">0<k−Fib_{m}<Fib_{m+1}−Fib_{m}=Fib_{m−1} \\k = Fib_{m} + (k-Fib_{m})</script></li><li>按照题目中的归纳条件，根据斐波那契数列数列递增的特性$Fib_{m} \le Fib_{m+1}$,显然我们可以得出<script type="math/tex; mode=display">1\le Fib_{m} \le N \\1\le (k-Fib_{m}) \le N \\k - Fib_{m} \le Fib_{m} \\</script></li><li>按照归纳条件$k−Fib_{m}$可以表示为不同的斐波那契数之和，这些斐波那契数里面显然不包括$Fib_{m}$.所以$k=N+1$也可以表示为不同的斐波那契数之和.且序列中每个数都不相等，而且必须是不连续的斐波那契数之和.因为存在以下等式：<script type="math/tex; mode=display">Fib_{m} + Fib_{m} = Fib_{m+1} \:\:\:  (m == 1) \\Fib_{m} + Fib_{m} = Fib_{m-1} + Fib_{m-2} + Fib{m}  = Fib_{m-2} + Fib_{m+1} \:\:\: (m \neq 1) \\\\Fib_{m} + Fib_{m+1} = Fib_{m+2} \\</script></li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line">        cnt.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  f3 &lt; k ; ++i)&#123;</span><br><span class="line">            f3 = f1+f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">            cnt.insert(f3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(k))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.lower_bound(k);</span><br><span class="line">            it--;</span><br><span class="line">            k -= *it;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5374-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#5374-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="5374. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个 「开心字符串」定义为：</p><ul><li>仅包含小写字母 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li><li>对所有在 1 到 <code>s.length - 1</code>之间的 i ，满足<code>s[i] != s[i + 1]</code>（字符串的下标从 1 开始）。</li></ul><p>比方说，字符串 <code>&quot;abc&quot;</code>，<code>&quot;ac&quot;，&quot;b&quot;</code>和 <code>&quot;abcbabcbcb&quot;</code> 都是开心字符串，但是<code>&quot;aa&quot;，&quot;baa&quot;</code>和<code>&quot;ababbc&quot;</code>都不是开心字符串。</p><p>给你两个整数 <code>n</code> 和 <code>k</code>，你需要将长度为 <code>n</code>的所有开心字符串按字典序排序。</p><p>请你返回排序后的第 <code>k</code> 个开心字符串，如果长度为 <code>n</code>的开心字符串少于 <code>k</code>个，那么请你返回 空字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"c"</span></span><br><span class="line">解释：列表 [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] 包含了所有长度为 <span class="number">1</span> 的开心字符串。按照字典序排序后第三个字符串为 <span class="string">"c"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的开心字符串只有 <span class="number">3</span> 个。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"cab"</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的开心字符串总共有 <span class="number">12</span> 个 [<span class="string">"aba"</span>, <span class="string">"abc"</span>, <span class="string">"aca"</span>, <span class="string">"acb"</span>, <span class="string">"bab"</span>, <span class="string">"bac"</span>, <span class="string">"bca"</span>, <span class="string">"bcb"</span>, <span class="string">"cab"</span>, <span class="string">"cac"</span>, <span class="string">"cba"</span>, <span class="string">"cbc"</span>] 。第 <span class="number">9</span> 个字符串为 <span class="string">"cab"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, k = <span class="number">100</span></span><br><span class="line">输出：<span class="string">"abacbabacb"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= n &lt;= 101 &lt;= k &lt;= 100</code></pre><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接DFS暴力匹配</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量非常小，也没啥好优化的，直接DFS搞起。</li><li>因为题目中是求得是第<code>k</code>个字符串，所以不太好弄，直接DFS模拟求出第k个即可。如果求数量得话，直接<code>DP</code>搞定。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; curr,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &gt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.back() == <span class="string">'a'</span> + i) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span> + i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span>+i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.size() != k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5375-恢复数组"><a href="#5375-恢复数组" class="headerlink" title="5375. 恢复数组"></a>5375. 恢复数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 ·<code>[1, k]</code>之间，且数组中的数字都没有前导 0 。</p><p>给你字符串 <code>s</code> 和整数<code>k</code> 。可能会有多种不同的数组恢复结果。</p><p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p><p>由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一一种可能的数组方案是 [<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在任何数组方案满足所有整数都 &gt;= <span class="number">1</span> 且 &lt;= <span class="number">10</span> 同时输出结果为 s 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1317"</span>, k = <span class="number">2000</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可行的数组方案为 [<span class="number">1317</span>]，[<span class="number">131</span>,<span class="number">7</span>]，[<span class="number">13</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">317</span>]，[<span class="number">13</span>,<span class="number">1</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">31</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"2020"</span>, k = <span class="number">30</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一可能的数组方案是 [<span class="number">20</span>,<span class="number">20</span>] 。 [<span class="number">2020</span>] 不是可行的数组方案，原因是 <span class="number">2020</span> &gt; <span class="number">30</span> 。 [<span class="number">2</span>,<span class="number">020</span>] 也不是可行的数组方案，因为 <span class="number">020</span> 含有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1234567890"</span>, k = <span class="number">90</span></span><br><span class="line">输出：<span class="number">34</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code>.</li><li><code>s 只包含数字且不包含前导 0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code>.<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/restore-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-the-array</a><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本题基本一眼看到就是动态规划。</li><li><code>dp[i]</code>代表前数组前<code>i</code>个数的组合数目，则递推公式为：<script type="math/tex; mode=display">dp[i] = \sum_{j=1}^{i} dp[i-j] \: \: if(num(i-j+1,i) \le k)</script></li><li>因为题目中给定的<code>k</code>的最大长度为<code>10</code>，所以非常简单，我们只需要判断从<code>i</code>往前数<code>i-10</code>组成的字串是否为合法的数目，且其是否大于给定的数目<code>k</code>.</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArrays</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = to_string(k).size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i-j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(stoll(s.substr(i-j,j)) &lt;= k)&#123;</span><br><span class="line">                    dp[i] = (dp[i] + dp[i-j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;24周双周比赛&quot;&gt;&lt;a href=&quot;#24周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;24周双周比赛&quot;&gt;&lt;/a&gt;24周双周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部&lt;code&gt;AC&lt;/code&gt;，不过跟那些大神不能比，10分钟&lt;code&gt;AC&lt;/code&gt;四道题的那种。&lt;/p&gt;&lt;h2 id=&quot;5372-逐步求和得到正数的最小值&quot;&gt;&lt;a href=&quot;#5372-逐步求和得到正数的最小值&quot; class=&quot;headerlink&quot; title=&quot;5372. 逐步求和得到正数的最小值&quot;&gt;&lt;/a&gt;5372. 逐步求和得到正数的最小值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。你可以选定任意的 正数 &lt;code&gt;startValue&lt;/code&gt; 作为初始值。&lt;/p&gt;&lt;p&gt;你需要从左到右遍历&lt;code&gt;nums&lt;/code&gt; 数组，并将 &lt;code&gt;startValue&lt;/code&gt; 依次累加上&lt;code&gt;nums&lt;/code&gt;数组中的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】</title>
    <link href="http://yoursite.com/2020/04/17/151/"/>
    <id>http://yoursite.com/2020/04/17/151/</id>
    <published>2020-04-17T04:25:14.114Z</published>
    <updated>2020-04-21T15:50:33.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACautomation的DFA的写法"><a href="#ACautomation的DFA的写法" class="headerlink" title="ACautomation的DFA的写法"></a>ACautomation的DFA的写法</h1><p>最近学习了字符串的相关算法，特别是对<code>kmp</code>和 <code>DFA</code>以及正则表达式的<code>NFA</code>的匹配。特别是<code>kmp</code>这种字符串匹配算法，其实本质也是贪心算法得一种，每次匹配前一个字符为结尾的最长后缀的下一个字母。后来仔细研究了下<code>Aho-Corasick automation</code>,它的算法本质其实也是和<code>kmp</code>一样，如果当前字符<code>s[i]</code>不能匹配，则匹配上一个字符<code>s[i-1]</code>为结尾的最长后缀的下一个字符。</p><a id="more"></a><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>我们假设<code>s[i]</code>的最长后缀为<code>prefix[i-1] = k</code>,一旦遇到<code>s[i]</code>不能匹配当前字符串时，则我们就将<code>s[i]</code>与<code>s[prefix[i-1]+1]</code>进行匹配。<br>同时学习Princeton的算法课程时，看到了课件上的<code>kmp</code>的<code>dfa</code>写法，其实非常非常的简单。强烈建议学习一下这个<code>dfa</code>的写法。<br><img src="https://mike-box.github.io/images/148-1.png" alt="kmp"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><code>dfa</code>则为确定的状态机，当前状态接受输入后的下一个状态只有一个，是可预测的，所以称之为确定状态机。<code>nfa</code>为不确定状态机，当前状态接受下一个字符后，后续状态可以有多个，因此下一个状态不确定，所以我们称之为不确定状态机。</li><li>对于单个字符串的匹配，我们可以用<code>dfa</code>来进行匹配。<code>dfa</code>的建立的原理可以参考Princeton的算法课程，老爷爷讲的特别清楚。当前正确的匹配状态从<code>0~n-1</code>开始匹配，失败的匹配状态从<code>1~n</code>开始匹配。比如字符串<code>ababac</code>.<br><code>dfa</code>正确的匹配状态如下。<script type="math/tex; mode=display">0\stackrel{a}{\longrightarrow}1\stackrel{b}{\longrightarrow}2\stackrel{a}{\longrightarrow}3\stackrel{b}{\longrightarrow}4\stackrel{a}{\longrightarrow}5\stackrel{c}{\longrightarrow}6</script>则我们知道正确的匹配状态如下<script type="math/tex; mode=display">dfa(0,a) = 1 \\dfa(1,b) = 2  \\dfa(2,a) = 3  \\dfa(3,b) = 4  \\dfa(4,a) = 5  \\dfa(5,c) = 6  \\</script></li><li>我们可以知道当处于状态<code>0</code>时，则不正确的匹配状态为<script type="math/tex; mode=display">dfa(0,b) = 0 \\dfa(0,c) = 0 \\</script>我们设置另一个<code>fail</code>状态的匹配从<code>1~n-1</code>开始匹配字符串<code>babac</code>。<br>设置状态<code>1</code>匹配失败的状态<script type="math/tex; mode=display">fail = 0 \\dfa(1,b) = dfa(fail,b) \\dfa(1,c) = dfa(fail,c) \\</script>设置状态<code>2</code>匹配失败的状态<script type="math/tex; mode=display">fail = dfa(fail,b) = 0 \\dfa(2,a) = dfa(fail,b) \\dfa(2,c) = dfa(fail,c) \\</script>剩余的状态计算匹配依次按照上述规律即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; pat,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; dfa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = pat.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">           dfa.push_back(state);</span><br><span class="line">           dfa[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       dfa[pat[<span class="number">0</span>]-<span class="string">'a'</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       prefix[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; n; ++i )&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">               dfa[j][i] = dfa[j][x];</span><br><span class="line">           &#125;</span><br><span class="line">           dfa[pat[i]-<span class="string">'a'</span>][i] = i+<span class="number">1</span>;</span><br><span class="line">           x = dfa[pat[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           prefix[i] = x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> end = dfa[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">           x = dfa[str[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           <span class="keyword">if</span>(x == end) <span class="keyword">return</span> i-x+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="匹配原理"><a href="#匹配原理" class="headerlink" title="匹配原理"></a>匹配原理</h3></li><li>我们知道KMP的匹配状态如此，那么AC automation的状态匹配也应该如此，其实本来AC匹配属于多字符串匹配，应该用<code>NFA</code>来实现的，比如我们常见的正则表达式的<code>|</code>操作即可匹配多个字符串。但是实际过程中我们也可以用模拟DFA的操作来完成这个状态转移。<br>只不过每次设置DFA的时候需要设置第<code>i</code>个字符串的前<code>j</code>个字符的最长匹配后缀。代码写的比较复杂，但是实际运行效果还是可以的。我们对所有字符串组成<code>trie</code>树，对每个非空节点进行编码和定义状态。实际也是搜索过程也是在这些状态种跳转。</li><li>我们按层对<code>trie</code>树进行遍历，每次记住上层的<code>fail</code>状态,然后计算本层的匹配失败后的跳转状态。但是它与<code>kmp</code>有点区别的是，需要对最终结束的节点的下一个状态进行计算，对于单个字符串的<code>kmp</code>匹配算法来说，我们只需匹配到结束状态即可，计算出相应的匹配位置即可，但是多个字符串匹配时可能情况会比较复杂，有可能匹配某个字符串<code>s</code>结束状态时，实际还需要进行匹配下一个字符串<code>t</code>。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    TrieNode * next[<span class="number">26</span>];</span><br><span class="line">    TrieNode(<span class="keyword">int</span> idx)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;TrieNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">acAutomation</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    acAutomation()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> TrieNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodes.push_back(root);</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildAc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        buildTrie(words);</span><br><span class="line">        buildFail(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; word : words)&#123;</span><br><span class="line">            insertTrie(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildFail</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">int</span> m = nodes.size();        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;dfa = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;fail = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = words[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            dfa[<span class="number">0</span>][c] = <span class="keyword">this</span>-&gt;nodes[<span class="number">0</span>]-&gt;next[c]-&gt;idx;</span><br><span class="line">            curr[i] = dfa[<span class="number">0</span>][c];</span><br><span class="line">            prev[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fail[curr[i]] = prev[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;width; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[j].size() &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                    dfa[curr[j]][k] = dfa[prev[j]][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = words[j][i] - <span class="string">'a'</span>;</span><br><span class="line">                dfa[curr[j]][c] = <span class="keyword">this</span>-&gt;nodes[curr[j]]-&gt;next[c]-&gt;idx;</span><br><span class="line">                curr[j] = dfa[curr[j]][c];</span><br><span class="line">                prev[j] = dfa[prev[j]][c];</span><br><span class="line">                fail[curr[j]] = prev[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*linked the complate state*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes[i]-&gt;isWord)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nodes[i]-&gt;next[j] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        dfa[i][j] = dfa[fail[i]][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> &amp; content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : content)&#123;</span><br><span class="line">            curr = dfa[curr][c-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> state = curr;</span><br><span class="line">            <span class="keyword">while</span>(state != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[state]-&gt;isWord)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;nodes[state]-&gt;word&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                state = fail[state];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%4c"</span>,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c "</span>,<span class="string">'a'</span> + i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes.size(); ++j)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%4d"</span>,dfa[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,fail[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertTrie</span><span class="params">(<span class="built_in">string</span> &amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode * curr = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!curr-&gt;next[c-<span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;nodes.push_back(<span class="keyword">new</span> TrieNode(nodes.size()));</span><br><span class="line">                curr-&gt;next[c-<span class="string">'a'</span>] = <span class="keyword">this</span>-&gt;nodes.back();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        curr-&gt;word = word;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = max(<span class="keyword">this</span>-&gt;width,<span class="keyword">int</span>(word.size()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode * root;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode *&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"bcde"</span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">string</span> s4 = <span class="string">"bc"</span>;</span><br><span class="line">    <span class="built_in">string</span> s5 = <span class="string">"c"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">    words.push_back(s1);</span><br><span class="line">    words.push_back(s2);</span><br><span class="line">    words.push_back(s3);</span><br><span class="line">    words.push_back(s4);</span><br><span class="line">    words.push_back(s5);</span><br><span class="line">    acAutomation * ac = <span class="keyword">new</span> acAutomation();</span><br><span class="line">    ac-&gt;buildAc(words);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> content = <span class="string">"abcdefabcd"</span>;</span><br><span class="line">    ac-&gt;search(content);</span><br><span class="line">    ac-&gt;debug();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ACautomation的DFA的写法&quot;&gt;&lt;a href=&quot;#ACautomation的DFA的写法&quot; class=&quot;headerlink&quot; title=&quot;ACautomation的DFA的写法&quot;&gt;&lt;/a&gt;ACautomation的DFA的写法&lt;/h1&gt;&lt;p&gt;最近学习了字符串的相关算法，特别是对&lt;code&gt;kmp&lt;/code&gt;和 &lt;code&gt;DFA&lt;/code&gt;以及正则表达式的&lt;code&gt;NFA&lt;/code&gt;的匹配。特别是&lt;code&gt;kmp&lt;/code&gt;这种字符串匹配算法，其实本质也是贪心算法得一种，每次匹配前一个字符为结尾的最长后缀的下一个字母。后来仔细研究了下&lt;code&gt;Aho-Corasick automation&lt;/code&gt;,它的算法本质其实也是和&lt;code&gt;kmp&lt;/code&gt;一样，如果当前字符&lt;code&gt;s[i]&lt;/code&gt;不能匹配，则匹配上一个字符&lt;code&gt;s[i-1]&lt;/code&gt;为结尾的最长后缀的下一个字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="AC" scheme="http://yoursite.com/tags/AC/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】 AtCoder Beginner Contest 162</title>
    <link href="http://yoursite.com/2020/04/15/150/"/>
    <id>http://yoursite.com/2020/04/15/150/</id>
    <published>2020-04-15T04:39:48.065Z</published>
    <updated>2020-04-15T07:30:22.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AtCoder-Beginner-Contest-162"><a href="#AtCoder-Beginner-Contest-162" class="headerlink" title="AtCoder Beginner Contest 162"></a>AtCoder Beginner Contest 162</h1><p><code>atcoder</code>题目比<code>leetcode</code>题目质量高多了。非常有意思。</p><h2 id="A-Lucky-7"><a href="#A-Lucky-7" class="headerlink" title="A - Lucky 7"></a>A - Lucky 7</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB</p><p>Score : 100</p><p>points</p><h4 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Given is a three-digit integer N<br>. Does N contain the digit 7</p><a id="more"></a><p>If so, print Yes; otherwise, print No.</p><h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>100≤N≤999</code></li></ul><p>Input<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span> is given <span class="meta">from</span> Standard <span class="meta">Input</span> <span class="meta">in</span> the following <span class="meta">format</span>:</span><br><span class="line"></span><br><span class="line">N</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> N</span><br><span class="line">contains the digit 7</span><br><span class="line"></span><br><span class="line">, <span class="builtin-name">print</span> <span class="literal">Yes</span>; otherwise, <span class="builtin-name">print</span> <span class="literal">No</span>.</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code>仅包含小写英文字母。</li><li>题目数据 保证 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_a" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_a</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力破解即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身题目比较简单，直接取出数据的每位即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">10</span> == <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="B-FizzBuzz-Sum"><a href="#B-FizzBuzz-Sum" class="headerlink" title="B - FizzBuzz Sum /"></a>B - FizzBuzz Sum /</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB</p><p>Score : 200<br>points</p><h4 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Let us define the FizzBuzz sequence a1,a2,…</p><p>as follows:</p><ul><li>If both 3 and 5 divides i, ai=FizzBuzz</li><li>If the above does not hold but 3 divides i, ai=Fizz</li><li>If none of the above holds but 5 divides i, ai=Buzz</li><li>If none of the above holds, ai=i</li></ul><p>Find the sum of all numbers among the first N<br>terms of the FizzBuzz sequence.</p><h4 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>1≤N≤1e9</code></li></ul><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span> is given <span class="meta">from</span> Standard <span class="meta">Input</span> <span class="meta">in</span> the following <span class="meta">format</span>:</span><br><span class="line"></span><br><span class="line">N</span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print <span class="keyword">the</span> <span class="built_in">sum</span> <span class="keyword">of</span> all numbers <span class="keyword">among</span> <span class="keyword">the</span> <span class="keyword">first</span> N</span><br></pre></td></tr></table></figure><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_b" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_b</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接暴力即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接计算能被3整出的和能被5整出的，然后加上能被15整出的。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f = n/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = n/<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fb = n/<span class="number">15</span>;</span><br><span class="line">    sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    sum = sum - <span class="number">3</span>*(f*(f+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    sum = sum - <span class="number">5</span>*(b*(b+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    sum = sum + <span class="number">15</span>*(fb*(fb+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="C-Sum-of-gcd-of-Tuples-Easy"><a href="#C-Sum-of-gcd-of-Tuples-Easy" class="headerlink" title="C - Sum of gcd of Tuples (Easy) /"></a>C - Sum of gcd of Tuples (Easy) /</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 300<br>points</p><h4 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Find</p><script type="math/tex; mode=display">\sum_{a=1}^{K}\sum_{b=1}^{K}\sum_{c=1}^{K}gcd(a,b,c)</script><p>Here gcd(a,b,c) denotes the greatest common divisor of a, b, and c.</p><h4 id="Constraints-2"><a href="#Constraints-2" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>1≤ K ≤ 200</code></li><li><code>K is an integer.</code><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4>Input is given from Standard Input in the following format:<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">K</span></span><br></pre></td></tr></table></figure><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4>Print the value of:<script type="math/tex; mode=display">\sum_{a=1}^{K}\sum_{b=1}^{K}\sum_{c=1}^{K}gcd(a,b,c)</script><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://atcoder.jp/contests/abc162/tasks/abc162_c" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_c</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数据量非常小，直接暴力</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>数据量非常小，基本上就是直接暴力匹配。</li><li>我们直接三个<code>for</code>循环即可以解决这个问题，数据量非常小。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                sum += __gcd(i,__gcd(j,k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="D-RGB-Triplets"><a href="#D-RGB-Triplets" class="headerlink" title="D - RGB Triplets"></a>D - RGB Triplets</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 400<br>points</p><h4 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>We have a string S of length N<br>consisting of R, G, and B.<br>Find the number of triples <code>(i, j, k) (1≤i&lt;j&lt;k≤N)</code><br>that satisfy both of the following conditions:</p><ul><li><code>Si≠Sj</code></li><li><code>Si≠Sk, and Sj≠Sk</code></li><li><code>j−i≠k−j</code><h4 id="Constraints-3"><a href="#Constraints-3" class="headerlink" title="Constraints"></a>Constraints</h4></li><li><code>1≤N≤4000</code></li><li><code>N</code>is a string of length N consisting of R, G, and B.<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4>Input is given from Standard Input in the following format:<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">N</span></span><br><span class="line"><span class="attribute">S</span></span><br></pre></td></tr></table></figure><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4>Print the number of triplets in question.<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><a href="https://atcoder.jp/contests/abc162/tasks/abc162_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_d</a><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排列组合</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>其实本质是数学组合。首先我们计算所有3种颜色组合的数目。</li><li>去除掉三种颜色组合中存在等差数列的数目。</li><li>本质是个小技巧即可，时间复杂度即可控制在<code>O(n^2)</code>。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rcopy;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gcopy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            rcopy.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'G'</span>)&#123;</span><br><span class="line">            g++;</span><br><span class="line">            gcopy.push_back(i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'B'</span>)&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">0</span> || g == <span class="number">0</span> || b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = r*g*b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rcopy.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; gcopy.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">abs</span>(rcopy[i] - gcopy[j]);</span><br><span class="line">            <span class="keyword">int</span> l = min(rcopy[i],gcopy[j]) - d;</span><br><span class="line">            <span class="keyword">int</span> r = max(rcopy[i],gcopy[j]) + d;</span><br><span class="line">            <span class="keyword">int</span> m = (rcopy[i] + gcopy[j])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= <span class="number">0</span> &amp;&amp; s[l] == <span class="string">'B'</span>) res--;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; n &amp;&amp; s[r] == <span class="string">'B'</span>) res--;</span><br><span class="line">            <span class="keyword">if</span>( d%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; s[m] == <span class="string">'B'</span>) res--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    slove(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="E-Sum-of-gcd-of-Tuples-Hard"><a href="#E-Sum-of-gcd-of-Tuples-Hard" class="headerlink" title="E - Sum of gcd of Tuples (Hard)"></a>E - Sum of gcd of Tuples (Hard)</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 500<br>points</p><h4 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Consider sequences {A1,…,AN} of length N consisting of integers between 1 and K</p><p>(inclusive).</p><p>There are KN<br>such sequences. Find the sum of gcd(A1,…,AN)</p><p>over all of them.</p><p>Since this sum can be enormous, print the value modulo (109+7)</p><p>.<br>Here gcd(A1,…,AN)<br>denotes the greatest common divisor of A1,…,AN.</p><h4 id="Constraints-4"><a href="#Constraints-4" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>2 ≤ N ≤ 105</code></li><li><code>1 ≤ K ≤ 105</code></li><li>All values in input are integers.</li></ul><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><p>Print the sum of <code>gcd(A1,...,AN)</code> over all KN sequences, modulo <code>(109+7)</code>.</p><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><p>Print the number of triplets in question.</p><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_d</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>转化为数学问题，思路确实不容易想到。</li><li>我们知道:<code>gcd(a1,a2,a3,a4,...,ak)</code>,一共用<code>1~k</code>种取值的可能，我们只需要找到每种取值<code>i</code>的个数<code>f(i)</code>,最终的结果为$\sum_{i=1}^{k}f(i)$.</li><li>递推关系为：<script type="math/tex; mode=display">f[i] = [\frac{K}{i}]^{N} - \sum_{j>i,i|j}f[j]</script><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=<span class="number">1L</span>L*ans*x%MD;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%MD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x+=y;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=MD) x-=MD;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">        f[i]=quick_pow(k/i,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=k;j+=i) &#123;</span><br><span class="line">            add(f[i],-f[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">        add(ans,<span class="number">1L</span>L*f[i]*i%MD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="F-Select-Half"><a href="#F-Select-Half" class="headerlink" title="F - Select Half"></a>F - Select Half</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 600<br>points</p><h4 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Given is an integer sequence A1,…,AN of length N.</p><p>We will choose exactly <code>⌊N2⌋</code></p><p>elements from this sequence so that no two adjacent elements are chosen.</p><p>Find the maximum possible sum of the chosen elements.</p><p>Here <code>⌊x⌋</code><br>denotes the greatest integer not greater than x.</p><h4 id="Constraints-5"><a href="#Constraints-5" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>2≤N≤2×105</code></li><li><code>|Ai|≤109</code></li><li>All values in input are integers.</li></ul><h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><p>Input is given from Standard Input in the following format:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line"><span class="function"><span class="title">A1</span></span>...AN</span><br></pre></td></tr></table></figure></p><h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h4><p>Print the maximum possible sum of the chosen elements.</p><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_f</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常有意思。非常典型的竞赛题目，很有技巧；</li><li>我们设<code>dp[i]</code>代表从前i个元素中选去最多[i/2]个元素和的最大值,我们分为两种情况来讨论。</li><li>如果前i个元素共有偶数个元素，也即i位偶数。则这时从<code>i</code>个元素中选取$[\frac{i}{2}]$个元素，则这时最多只有两种选择，要么是等差从<code>0</code>开始选择<code>{a[0],a[2],a[4],a[6],...,a[i]}</code>,要么是等差数列从<code>1</code>开始选择<code>{a[1],a[3],a[5],...,a[i-1]}</code>。所以我们当i位偶数时，推出递推公式为：<script type="math/tex; mode=display">dp[i] = max(\sum_{k=0}^{\frac{i}{2}}a[2*i+1],\sum_{k=0}^{\frac{i}{2}}a[2*i])</script></li><li>如果前i个元素共有奇数个元素，也即i位奇数。则这时情况稍微比较复杂，如果i为奇数，则我们需要选择$\frac{i-1}{2}$个元素,我们要么从前<code>i-1</code>个元素选择，要么加上元素<code>i</code>。则我们可以推出递推公式为：<script type="math/tex; mode=display">dp[i] = max(d[i-1],dp[i-2] + a[i])</script></li><li>这个题目质量很高，出的很好，我觉得<code>leetcode</code> 质量高多了。</li></ol></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*0 1 2 3 4 5 6 7*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dp[i] 代表从前i个元素中选去最多[i/2]个元素和的最大值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + arr[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">            left += arr[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + arr[i],left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AtCoder-Beginner-Contest-162&quot;&gt;&lt;a href=&quot;#AtCoder-Beginner-Contest-162&quot; class=&quot;headerlink&quot; title=&quot;AtCoder Beginner Contest 162&quot;&gt;&lt;/a&gt;AtCoder Beginner Contest 162&lt;/h1&gt;&lt;p&gt;&lt;code&gt;atcoder&lt;/code&gt;题目比&lt;code&gt;leetcode&lt;/code&gt;题目质量高多了。非常有意思。&lt;/p&gt;&lt;h2 id=&quot;A-Lucky-7&quot;&gt;&lt;a href=&quot;#A-Lucky-7&quot; class=&quot;headerlink&quot; title=&quot;A - Lucky 7&quot;&gt;&lt;/a&gt;A - Lucky 7&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Time Limit: 2 sec / Memory Limit: 1024 MB&lt;/p&gt;&lt;p&gt;Score : 100&lt;/p&gt;&lt;p&gt;points&lt;/p&gt;&lt;h4 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h4&gt;&lt;p&gt;Given is a three-digit integer N&lt;br&gt;. Does N contain the digit 7&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="atcoder" scheme="http://yoursite.com/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第184周比赛</title>
    <link href="http://yoursite.com/2020/04/13/149/"/>
    <id>http://yoursite.com/2020/04/13/149/</id>
    <published>2020-04-12T16:27:19.040Z</published>
    <updated>2020-04-12T16:27:24.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="184周比赛"><a href="#184周比赛" class="headerlink" title="184周比赛"></a>184周比赛</h1><p>感觉题目越来越水了啊，质量不够高。</p><h2 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a>5380. 数组中的字符串匹配</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回<code>words</code>中是其他单词的子字符串的所有单词。</p><p>如果你可以删除<code>words[j]</code> 最左侧和/或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code>就是 <code>words[j]</code>的一个子字符串。</p><a id="more"></a><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"mass"</span>,<span class="string">"as"</span>,<span class="string">"hero"</span>,<span class="string">"superhero"</span>]</span><br><span class="line">输出：[<span class="string">"as"</span>,<span class="string">"hero"</span>]</span><br><span class="line">解释：<span class="string">"as"</span> 是 <span class="string">"mass"</span> 的子字符串，<span class="string">"hero"</span> 是 <span class="string">"superhero"</span> 的子字符串。</span><br><span class="line">[<span class="string">"hero"</span>,<span class="string">"as"</span>] 也是有效的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"leetcode"</span>,<span class="string">"et"</span>,<span class="string">"code"</span>]</span><br><span class="line">输出：[<span class="string">"et"</span>,<span class="string">"code"</span>]</span><br><span class="line">解释：<span class="string">"et"</span> 和 <span class="string">"code"</span> 都是 <span class="string">"leetcode"</span> 的子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"blue"</span>,<span class="string">"green"</span>,<span class="string">"bu"</span>]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code>仅包含小写英文字母。</li><li>题目数据 保证 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/string-matching-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-matching-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力匹配</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身数据量非常小，我们实际只需暴力匹配即可。</li><li>对字符串按照长度长短进行排序，然后每次直接用<code>find</code>进行暴力匹配，其实find的本质也是字符串字串匹配的问题。</li><li>本质是非常简单的解法。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp; a,<span class="built_in">string</span> &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringMatching(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        sort(words.begin(),words.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; words[j].size() &gt; words[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[j].find(words[i]) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    res.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a>5381. 查询带键的排列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个待查数组<code>queries</code>，数组中的元素为 <code>1</code>到<code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code>到 <code>i=queries.length-1</code>）：</p><ul><li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li><li>对于当前的 i ，请你找出待查项 <code>queries[i]</code>在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列<code>P</code>的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 <code>queries[i]</code>的查询结果。</li></ul><p>请你以数组形式返回待查数组 <code>queries</code>的查询结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], m = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br><span class="line">解释：待查数组 queries 处理如下：</span><br><span class="line">对于 i=<span class="number">0</span>: queries[i]=<span class="number">3</span>, P=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span> 在 P 中的位置是 <span class="number">2</span>，接着我们把 <span class="number">3</span> 移动到 P 的起始位置，得到 P=[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">对于 i=<span class="number">1</span>: queries[i]=<span class="number">1</span>, P=[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">1</span> 在 P 中的位置是 <span class="number">1</span>，接着我们把 <span class="number">1</span> 移动到 P 的起始位置，得到 P=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>] 。 </span><br><span class="line">对于 i=<span class="number">2</span>: queries[i]=<span class="number">2</span>, P=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">2</span> 在 P 中的位置是 <span class="number">2</span>，接着我们把 <span class="number">2</span> 移动到 P 的起始位置，得到 P=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">对于 i=<span class="number">3</span>: queries[i]=<span class="number">1</span>, P=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">1</span> 在 P 中的位置是 <span class="number">1</span>，接着我们把 <span class="number">1</span> 移动到 P 的起始位置，得到 P=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。 </span><br><span class="line">因此，返回的结果数组为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], m = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>], m = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 10^3</code></li><li><code>1 &lt;= queries.length &lt;= m</code></li><li><code>1 &lt;= queries[i] &lt;= m</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/queries-on-a-permutation-with-key" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queries-on-a-permutation-with-key</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中给的数据量只有<code>1o^3</code>的数量级，怎么做都可以出来。</li><li>题目中采用的移位的办法，我们记录每个数在序列中的排序位置。每次需要移动时，我们将所有小于该位置的数的位置全部向后移动一位，然后将数本身再移动到第0位处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; processQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(m,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) order[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res.push_back(order[queries[i]<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(order[j] &lt; order[queries[i]<span class="number">-1</span>]) order[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            order[queries[i]<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a>1410. HTML 实体解析器</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p><code>HTML</code>里这些特殊字符和它们对应的字符实体包括：</p><ul><li>双引号：字符实体为 &quot; ，对应的字符是 “ 。</li><li>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。</li><li>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。</li><li>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。</li><li>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。</li><li>斜线号：字符实体为 &frasl; ，对应的字符是 / 。</li></ul><p>给你输入字符串<code>text</code> ，请你实现一个 <code>HTML</code> 实体解析器，返回解析器解析后的结果。</p><p>示例 1：<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text = "&amp;amp; <span class="keyword">is</span> an HTML entity but &amp;ambassador; <span class="keyword">is</span> <span class="keyword">not</span>."</span><br><span class="line">输出："&amp; <span class="keyword">is</span> an HTML entity but &amp;ambassador; <span class="keyword">is</span> <span class="keyword">not</span>."</span><br><span class="line">解释：解析器把字符实体 &amp;amp; 用 &amp; 替换</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="string">"and I quote: &amp;quot;...&amp;quot;"</span></span><br><span class="line">输出：<span class="string">"and I quote: <span class="subst">\"</span>...<span class="subst">\"</span>"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"Stay home! Practice on Leetcode :)"</span></span><br><span class="line">输出：<span class="string">"Stay home! Practice on Leetcode :)"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false"</span></span><br><span class="line">输出：<span class="string">"x &gt; y &amp;&amp; x &lt; y is always false"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leetcode.com&amp;frasl;problemset&amp;frasl;all"</span></span><br><span class="line">输出：<span class="string">"leetcode.com/problemset/all"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 10^5</code></li><li>字符串可能包含<code>256</code>个<code>ASCII</code> 字符中的任意字符。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/html-entity-parser" target="_blank" rel="noopener">https://leetcode-cn.com/problems/html-entity-parser</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接暴力匹配</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量非常小，基本上就是直接暴力匹配。</li><li>当然看了别人的解答，每次匹配连续的<code>&amp;</code>与<code>;</code>，将之间的字符串进行查找和替换。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = text.size();</span><br><span class="line">        <span class="built_in">string</span> keys[<span class="number">6</span>] = &#123;<span class="string">"&amp;quot;"</span>,<span class="string">"&amp;apos;"</span>,<span class="string">"&amp;amp;"</span>,<span class="string">"&amp;gt;"</span>,<span class="string">"&amp;lt;"</span>,<span class="string">"&amp;frasl;"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> rep[<span class="number">6</span>] = &#123;<span class="string">'"'</span>,<span class="string">'\''</span>,<span class="string">'&amp;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'/'</span>&#125;;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == <span class="string">'&amp;'</span>)&#123;</span><br><span class="line">                <span class="keyword">bool</span> isMatch = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n-i &gt;= keys[j].size() &amp;&amp; text.substr(i,keys[j].size()) == keys[j])&#123;</span><br><span class="line">                        res.push_back(rep[j]);</span><br><span class="line">                        i += keys[j].size();</span><br><span class="line">                        isMatch = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!isMatch) res.push_back(text[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(text[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a>5383. 给 N x 3 网格图涂色的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>你有一个 <code>n x 3</code>的网格图 <code>grid</code> ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p><p>给你网格图的行数 n 。</p><p>请你返回给<code>grid</code>涂色的方案数。由于答案可能会非常大，请你返回答案对<code>10^9 + 7</code> 取余的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：总共有 <span class="number">12</span> 种可行的方法：</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">54</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">246</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">106494</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5000</span></span><br><span class="line">输出：<span class="number">30228214</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == grid.length</code></li><li><code>grid[i].length == 3</code></li><li><code>1 &lt;= n &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>本题基本一眼看到就是动态规划，状态压缩的dp。</li><li>我们定义符合行要求的放置的颜色组合一共有12种，而第<code>i</code>行的可以放置的颜色也仅仅与第<code>i-1</code>行的颜色有关，采用动态规划。</li><li>记录<code>dp[i-1]</code>的每种组合的方案数，<code>dp[i]</code>在这12种组合方案中进行遍历，同时记录符合条件的组合方案数。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp1[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp2[<span class="number">12</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">string</span> state[<span class="number">12</span>] = &#123;<span class="string">"123"</span>,<span class="string">"121"</span>,<span class="string">"131"</span>,<span class="string">"132"</span>, \</span><br><span class="line">                            <span class="string">"212"</span>,<span class="string">"213"</span>,<span class="string">"232"</span>,<span class="string">"231"</span>, \</span><br><span class="line">                            <span class="string">"313"</span>,<span class="string">"312"</span>,<span class="string">"321"</span>,<span class="string">"323"</span> &#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; dict;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) dict[state[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> s1 = state[i][<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> s2 = state[i][<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> s3 = state[i][<span class="number">2</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l1 = <span class="number">1</span>; l1 &lt;= <span class="number">3</span>; ++l1)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l2 = <span class="number">1</span>; l2 &lt;= <span class="number">3</span>; ++l2)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l3 = <span class="number">1</span>; l3 &lt;= <span class="number">3</span>; ++l3)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(l1 == l2 || l2 == l3) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(l1 == s1 || l2 == s2 || l3 == s3) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">string</span> x = to_string(l1) + to_string(l2) + to_string(l3);</span><br><span class="line">                        <span class="keyword">int</span> id = dict[x];</span><br><span class="line">                        next[i].push_back(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp1,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp1));</span><br><span class="line">        <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) dp1[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp2));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp1[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; next[j].size(); ++k) dp2[next[j][k]] = (dp2[next[j][k]] + dp1[j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; ++j) dp1[j] = dp2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)&#123;</span><br><span class="line">            res = (res + dp1[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;184周比赛&quot;&gt;&lt;a href=&quot;#184周比赛&quot; class=&quot;headerlink&quot; title=&quot;184周比赛&quot;&gt;&lt;/a&gt;184周比赛&lt;/h1&gt;&lt;p&gt;感觉题目越来越水了啊，质量不够高。&lt;/p&gt;&lt;h2 id=&quot;5380-数组中的字符串匹配&quot;&gt;&lt;a href=&quot;#5380-数组中的字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;5380. 数组中的字符串匹配&quot;&gt;&lt;/a&gt;5380. 数组中的字符串匹配&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;words&lt;/code&gt; ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回&lt;code&gt;words&lt;/code&gt;中是其他单词的子字符串的所有单词。&lt;/p&gt;&lt;p&gt;如果你可以删除&lt;code&gt;words[j]&lt;/code&gt; 最左侧和/或最右侧的若干字符得到 &lt;code&gt;word[i]&lt;/code&gt; ，那么字符串 &lt;code&gt;words[i]&lt;/code&gt;就是 &lt;code&gt;words[j]&lt;/code&gt;的一个子字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yoursite.com/2020/04/10/148/"/>
    <id>http://yoursite.com/2020/04/10/148/</id>
    <published>2020-04-10T04:27:14.175Z</published>
    <updated>2020-04-14T05:22:35.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><p>字符串作为一个非常重要的应用，。对所有字符串算法的总结，包括字符串的排序与字符串的匹配，在实际的程序中是非常非常重要的两块应用，其中的算法又非常的复杂。光把这几个研究透就非常需要耗费精力和时间。</p><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><h5 id="count-index"><a href="#count-index" class="headerlink" title="count index"></a><code>count index</code></h5><p><code>count index</code>作为一种快速的排序算法，可以在O(n+m)的时间复杂度内即可完成字符串的排序。本质是基数排序，实际应用中这个排序算法效率非常高，基本上可以在线性时间内完成对字符串的排序。空间复杂度为O(m+n).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">countIndex</span><span class="params">(<span class="keyword">char</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">257</span>];</span><br><span class="line">    <span class="keyword">int</span> [] aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length; ++i)&#123;</span><br><span class="line">        count[str[i]+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        aux[count[a[i]++]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        a[i] = aux[i];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="LSD"><a href="#LSD" class="headerlink" title="LSD"></a><code>LSD</code></h4><p>基数排序的重要应用，按照字母的先后顺序进行排序，从后往前进行排列,这种算法只适合等长度得数据值，实际应用范围较窄。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = W<span class="number">-1</span>; d &gt;= <span class="number">0</span>; d--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            count[a[i].charAt(d) + <span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)</span><br><span class="line">            count[r+<span class="number">1</span>] += count[r];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            a[i] = aux[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="MSD"><a href="#MSD" class="headerlink" title="MSD"></a><code>MSD</code></h4><p>基数排序的重要应用，按照字母的先后顺序进行排序，从前往后进行排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> String[a.length];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, String[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        count[charAt(a[i], d) + <span class="number">2</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R+<span class="number">1</span>; r++)</span><br><span class="line">        count[r+<span class="number">1</span>] += count[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        aux[count[charAt(a[i], d) + <span class="number">1</span>]++] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        a[i] = aux[i - lo];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)</span><br><span class="line">        sort(a, aux, lo + count[r], lo + count[r+<span class="number">1</span>] - <span class="number">1</span>, d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-way-quick-sort"><a href="#3-way-quick-sort" class="headerlink" title="3-way quick sort"></a><code>3-way quick sort</code></h4><p>这是类似于<code>quicksort</code>的基数排序方法，其实排序的速度非常快，需要经常应用的一个算法。每次读取字符串的第一个字符，并根据第一个字符的比较大小，对字符串数组分为三类，第一个字符小于<code>target</code>的字符串，第一个字符等于<code>target</code>的字符串，第一个字符大于于<code>target</code>的字符串，然后再依次对这三种分类递归进行下次排序划分。比如字符串数组如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bac</span></span><br><span class="line"><span class="keyword">aab</span></span><br><span class="line"><span class="keyword">cba</span></span><br><span class="line"><span class="keyword">aac</span></span><br><span class="line"><span class="keyword">bda</span></span><br></pre></td></tr></table></figure><br>第一次比较则划分，我们选去<code>b</code>作为关键字进行比较：</p><ul><li>第一类：首字符比<code>b</code>小<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">aab</span></span><br><span class="line"><span class="attribute">aac</span></span><br></pre></td></tr></table></figure></li><li>第二类：首字符与<code>b</code>相等<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bac</span></span><br><span class="line"><span class="keyword">bda</span></span><br></pre></td></tr></table></figure></li><li>第三类：首字符比<code>b</code>大<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cba</span></span><br></pre></td></tr></table></figure>然后再对这三类字符分别进行划分和排序，第一类字符串再从第1个字符开始比较和交换，第二类字符串从第2个字符开始比较和划分，第三类字符串从第1个字符串比较和划分。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">    <span class="keyword">int</span> v = charAt(a[lo], d);</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = charAt(a[i], d);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; v) exch(a, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v) exch(a, i, gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, lo, lt<span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) sort(a, lt, gt, d+<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>suffix array</code><br>后缀数组排序算法，刚开始看到这个算法感觉像天书一样，不太晓得是什么意思，后来学了算法涉及课程之后，就知道后缀数组的大概的原理了，知道了大概的原理之后就对倍增的原理到底是怎么来的了解的多了，非常<code>clever</code>的一种算法，当然细节太过于繁琐。我把原理图贴在这里大概就晓得倍增到底是怎么一回事了。不过后缀数组得写法实在太难记了，我觉得还是知道原理就可以了，因为除了竞赛或者写论文外，很少会遇到这么难写的算法，就跟红黑树一样，大家都知道是一种二叉平衡树，但是说实话应该知道就可以了，大可不必花太多时间浪费在细节上。<br><img src="https://mike-box.github.io/images/148-2.png" alt="suffixarray"><br>后缀数组可以解决以下问题：</li></ol><ul><li>给定一个字符串，询问某两个后缀的最长公共前缀。</li><li>给定一个字符串，求最长重复子串，这两个子串可以重叠</li><li><p>给定一个字符串，求最长重复子串，这两个子串不能重叠</p></li><li><p>给定一个字符串，求至少出现k 次的最长重复子串，这k 个子串可以重叠</p></li><li><p>给定一个字符串，求不相同的子串的个数</p></li><li><p>给定一个字符串，求最长回文子串</p></li><li><p>给定一个字符串L，已知这个字符串是由某个字符串S 重复R 次而得到的，求R 的最大值</p></li><li><p>给定一个字符串，求重复次数最多的连续重复子</p></li><li><p>给定两个字符串A 和B，求最长公共子串。</p></li><li><p>给定两个字符串A 和B，求长度不小于k 的公共子串的个数（可以相同）</p></li><li><p>给定n 个字符串，求出现在不小于k 个字符串中的最长子串。</p></li><li><p>给定n 个字符串，求在每个字符串中至少出现两次且不重叠的最长子串</p></li><li><p>给定n 个字符串，求出现或反转后出现在每个字符串中的最长子串。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x)/3+((x)%3==1?0:tb))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)</span></span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c0</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+<span class="number">1</span>]==r[b+<span class="number">1</span>]&amp;&amp;r[a+<span class="number">2</span>]==r[b+<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c12</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">2</span>) <span class="keyword">return</span> r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(<span class="number">1</span>,r,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+<span class="number">1</span>]&lt;wv[b+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=r[a[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) b[--ws[wv[i]]]=a[i];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc3</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,*rn=r+n,*san=sa+n,ta=<span class="number">0</span>,tb=(n+<span class="number">1</span>)/<span class="number">3</span>,tbc=<span class="number">0</span>,p;</span><br><span class="line">r[n]=r[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i%<span class="number">3</span>!=<span class="number">0</span>) wa[tbc++]=i;</span><br><span class="line">sort(r+<span class="number">2</span>,wa,wb,tbc,m);</span><br><span class="line">sort(r+<span class="number">1</span>,wb,wa,tbc,m);</span><br><span class="line">sort(r,wa,wb,tbc,m);</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>,rn[F(wb[<span class="number">0</span>])]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;tbc;i++)</span><br><span class="line">rn[F(wb[i])]=c0(r,wb[i<span class="number">-1</span>],wb[i])?p<span class="number">-1</span>:p++;</span><br><span class="line"><span class="keyword">if</span>(p&lt;tbc) dc3(rn,san,tbc,p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) san[rn[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) <span class="keyword">if</span>(san[i]&lt;tb) wb[ta++]=san[i]*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>) wb[ta++]=n<span class="number">-1</span>;</span><br><span class="line">sort(r,wb,wa,ta,m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) wv[wb[i]=G(san[i])]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>,p=<span class="number">0</span>;i&lt;ta &amp;&amp; j&lt;tbc;p++)</span><br><span class="line">sa[p]=c12(wb[j]%<span class="number">3</span>,r,wa[i],wb[j])?wa[i++]:wb[j++];</span><br><span class="line"><span class="keyword">for</span>(;i&lt;ta;p++) sa[p]=wa[i++];</span><br><span class="line"><span class="keyword">for</span>(;j&lt;tbc;p++) sa[p]=wb[j++];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h4><h5 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a><code>kmp</code></h5><p>题目中直接给的是<code>KMP</code>的<code>DFA</code>的解法，其实非常容易理解。也非常的好写，主要是涉及到匹配时的移位操作。强烈建议看看<code>Princeton</code>的老教授讲的<code>KMP</code>的原理，非常非常的简单。<br>确定状态机的构造原理很简单，当前状态接受当前字符，然后跳到下一个状态:</p><script type="math/tex; mode=display">output_{next} = Fuction(input_{curr})</script><p>比如我们定义初始匹配字符串的初始状态为<code>0</code>，需要接受匹配的字符串为<code>ababaab</code>,则我们需要定义<code>n+1</code>个状态,共可接受<code>n</code>个输入，初始的状态机如下：</p><script type="math/tex; mode=display">0\stackrel{a}{\longrightarrow}1\stackrel{b}{\longrightarrow}2\stackrel{a}{\longrightarrow}3\stackrel{b}{\longrightarrow}4\stackrel{a}{\longrightarrow}5\stackrel{a}{\longrightarrow}6\stackrel{b}{\longrightarrow}7</script><p>我们可以看到初始状态为0，可接受的终止状态为<code>7</code>.这是最初的状态机。我们先计算玩<code>ababaab</code>的作为输入，然后再左移一位，计算<code>babaab</code>作为状态机的输入,且从状态1开始输入。即可计算出整个<code>kmp</code>的DFA状态机。以下为状态机构建与搜索：<br>比如我们可以看到正确的匹配和状态如下：<br>|输入|0|1|2|3|4|5|6|7|<br>|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|<br>|-|a|b|a|b|a|a|b|-|<br>|a|1|-|3|-|5|6|-|-|<br>|b|0|2|-|4|-|-|7|-|<br>|*|0|0|0|0|0|0|0|-|<br>DFA状态机的建立也非常有意思。我们保留另一个状态从字符串第<code>2</code>位开始遍历,当前的状态为x,每次拷贝状态<code>x</code>的指向即可。实际上x的状态即为当前匹配的最长后缀长度。<br>|输入|0|1|2|3|4|5|6|7|<br>|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|<br>|-|a|b|a|b|a|a|b|-|<br>|a|1|1|3|1|5|6|1|-|<br>|b|0|2|0|4|0|4|7|-|<br>|状态x|0|0|1|2|3|1|2|-|</p><p><img src="https://mike-box.github.io/images/148-1.png" alt="kmp"></p><ol><li><code>KMP DFA</code>的搜索<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; pat,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = pat.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">           dfa.push_back(state);</span><br><span class="line">           dfa[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       dfa[pat[<span class="number">0</span>]-<span class="string">'a'</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; n; ++i )&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">               dfa[j][i] = dfa[j][x];</span><br><span class="line">           &#125;</span><br><span class="line">           dfa[pat[i]-<span class="string">'a'</span>][i] = i+<span class="number">1</span>;</span><br><span class="line">           x = dfa[pat[i]-<span class="string">'a'</span>][x];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> end = dfa[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">           x = dfa[str[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           <span class="keyword">if</span>(x == end) <span class="keyword">return</span> i-x+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>KMP next<br>这个时之前教科书上的next数组的表示法，确实有一些比较<code>tricky</code>的地方，计算每个前缀的最长匹配后缀长度，这个稍微需要一点点技巧，特别时用到递归的思想，只需要计算出最长匹配后，后面的就非常简单。<br>比如字符串<code>ababaababd</code>,他所有的前缀字符串为：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">前缀</th><th style="text-align:center">匹配的最长后缀</th><th style="text-align:center">最长匹配后缀长度</th><th style="text-align:center">递推</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ab</td><td style="text-align:center">‘’</td><td style="text-align:center">0</td><td style="text-align:center">prefix(1) = 0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">aba</td><td style="text-align:center">a</td><td style="text-align:center">1</td><td style="text-align:center">prefix(1) = 1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">abab</td><td style="text-align:center">ab</td><td style="text-align:center">2</td><td style="text-align:center">prefix(1) = 2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">ababa</td><td style="text-align:center">aba</td><td style="text-align:center">3</td><td style="text-align:center">prefix(4) = 3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ababaa</td><td style="text-align:center">a</td><td style="text-align:center">1</td><td style="text-align:center">prefix(5) = prefix(prefix(4))</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ababaab</td><td style="text-align:center">ab</td><td style="text-align:center">2</td><td style="text-align:center">prefix(6) = 2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ababaaba</td><td style="text-align:center">aba</td><td style="text-align:center">3</td><td style="text-align:center">prefix(7) = 3</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">ababaabab</td><td style="text-align:center">abab</td><td style="text-align:center">4</td><td style="text-align:center">prefix(8) = 4</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ababaababd</td><td style="text-align:center">‘’</td><td style="text-align:center">0</td><td style="text-align:center">prefix(9) = 0</td></tr></tbody></table></div><p>我们看到kmp的本质就是当前位置索引<code>i</code>去匹配前缀<code>prefix(i-1)</code>的下一个字母，如果能够匹配则相等，否则则匹配下一个更短的后缀。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kmp(<span class="built_in">string</span> str)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(; k &gt; <span class="number">0</span> &amp;&amp; str[k] != str[i]; k = prefix[k<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span>(str[k] == str[i])  prefix[i++] = ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) prefix[i] = prefix[i<span class="number">-1</span>];</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> need)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = kmp(need);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; j &lt; need.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == str[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="built_in">strlen</span>(need)) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h5><ol><li>bm算法的特点为字符串比较时从右向左比较，因此非常快的跳跃过去。</li><li>如果发现当前可能匹配的字符串中不存在模式中的字符，直接跳到当前字符的下一个字符进行比较。</li><li>尽可能的向右移动，本质就是贪心算法，每次计算移动位置。<br><img src="https://mike-box.github.io/images/148-3.png" alt="bm"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bm_search</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> m = str.size();</span><br><span class="line">       <span class="keyword">int</span> n = needle.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">-1</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; needle.size(); ++i)&#123;</span><br><span class="line">           right[needle[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> skip = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-n; i += skip)&#123;</span><br><span class="line">           skip = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(str[i+j] != needle[j])&#123;</span><br><span class="line">                   skip = max(<span class="number">1</span>,j-right[str[i+j]-<span class="string">'a'</span>]);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(skip == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="KR"><a href="#KR" class="headerlink" title="KR"></a>KR</h5><ol><li><code>KR</code>算法的本质<br><img src="https://mike-box.github.io/images/148-4.png" alt="kr"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> patHash; <span class="comment">// pattern hash value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">// pattern length</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> Q; <span class="comment">// modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R; <span class="comment">// radix</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> RM; <span class="comment">// R^(M-1) % Q</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        M = pat.length();</span><br><span class="line">        R = <span class="number">256</span>;</span><br><span class="line">        Q = longRandomPrime();</span><br><span class="line">        RM = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M-<span class="number">1</span>; i++)</span><br><span class="line">            RM = (R * RM) % Q;</span><br><span class="line">        patHash = hash(pat, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* as before */</span> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="keyword">int</span> txtHash = hash(txt, M);</span><br><span class="line">        <span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;</span><br><span class="line">            txtHash = (txtHash*R + txt.charAt(i)) % Q;</span><br><span class="line">            <span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="AC-automation"><a href="#AC-automation" class="headerlink" title="AC automation"></a>AC automation</h4><p>匹配单字符串时我们可以用快速的匹配算法<code>KMP</code>,但是实际程序中我们可能需要进行多个字符串的匹配，这时我们就需要新的算法。AC自动机作为匹配多字符串的算法，其也有非常重要的应用，比如<code>DPI</code>,互联网上的报文搜索。AC自动机的本质也是避免所谓的<code>backup</code>，也是类似于<code>KMP</code>所谓的指当前能够匹配的最长后缀, 关键点在于设置节点的<code>fail</code>指针。知乎上有相关解释，其实ac自动机的本质即为 <code>kmp + trie</code>的组合，原理其实非常简单，也是找到当前字符位置的最长匹配的后缀。<code>trie</code>树作为一个最基本的应用应该需要掌握的基础。<br><a href="https://zhuanlan.zhihu.com/p/80325757" target="_blank" rel="noopener">AC自动机</a><br><img src="https://mike-box.github.io/images/148-8.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-9.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-10.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-11.png" alt="ac"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    TrieNode * next[<span class="number">26</span>];</span><br><span class="line">    TrieNode * fail;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isword = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bulidTrie</span><span class="params">(TrieNode * root,<span class="built_in">string</span> &amp; word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[c-<span class="string">'a'</span>]) node-&gt;next[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        node = node-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildFail</span><span class="params">(TrieNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; w : words)&#123;</span><br><span class="line">        insertTrie(root,w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TrieNode *&gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TrieNode * curr = qu.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            TrieNode * next = curr-&gt;next[i];</span><br><span class="line">            <span class="keyword">if</span>(!next) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr == root)&#123;</span><br><span class="line">                next-&gt;fail = curr;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TrieNode * fail = curr-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span>(fail)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fail-&gt;next[i])&#123;</span><br><span class="line">                        next-&gt;fail = fail-&gt;next[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fail = fail-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!fail) next-&gt;fail = root;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            qu.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieNode * <span class="title">buildAcAutomation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">    TrieNode * root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    bulidTrie(root,words);</span><br><span class="line">    buildFail(root,words);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(TrieNode * root,<span class="built_in">string</span> content)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    TrieNode * curr = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : content)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!curr-&gt;next[c-<span class="string">'a'</span>] &amp;&amp; curr != root)&#123;</span><br><span class="line">            curr = curr-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = curr-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(!curr) curr = root;</span><br><span class="line">        TrieNode * t = curr;</span><br><span class="line">        <span class="keyword">while</span>(t != root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;isWord == <span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;t-&gt;word&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            t = t-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NFA状态机"><a href="#NFA状态机" class="headerlink" title="NFA状态机"></a>NFA状态机</h4><p><code>NFA</code>状态机的构造理论也是非常复杂的一个问题，感觉不是一两句话就能说清楚，特别是<code>nfa</code>的建造，实际上非常又技巧的一个巧妙的算法。另一个是关于<code>nfa</code>的搜索，如果不进行优化的话，就是实际的<code>DFS</code>查找。以下的代码是参考<code>princeton</code>的例子简单的写了一个<code>NFA</code>的模式匹配算法，支持<code>(),|,+,*,</code>的匹配，写的非常简单，但是对于理解基本的<code>nfa</code>原理来说肯定够用了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nfa</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Nfa()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;regexpr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> re)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = re.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;regexpr = re;</span><br><span class="line">        <span class="keyword">this</span>-&gt;graph.clear();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> lp = i;</span><br><span class="line">            <span class="keyword">if</span>(re[i] == <span class="string">'('</span>||re[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                ops.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(re[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ops.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(re[ops.top()] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                    <span class="keyword">while</span>(!ops.empty()&amp;&amp;re[ops.top()] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                        curr.push(ops.top());</span><br><span class="line">                        ops.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ops.empty()||re[ops.top()] != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    lp = ops.top();</span><br><span class="line">                    ops.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(!curr.empty())&#123;</span><br><span class="line">                        <span class="keyword">this</span>-&gt;addEdge(lp,curr.top()+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;addEdge(curr.top(),i);</span><br><span class="line">                        curr.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(re[ops.top()] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    lp = ops.top();</span><br><span class="line">                    ops.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; <span class="keyword">this</span>-&gt;m &amp;&amp; re[i+<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i+<span class="number">1</span>,lp);</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(lp,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; <span class="keyword">this</span>-&gt;m &amp;&amp; re[i+<span class="number">1</span>] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i+<span class="number">1</span>,lp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re[i] == <span class="string">'('</span> || re[i] == <span class="string">'*'</span> || </span><br><span class="line">               re[i] == <span class="string">')'</span> || re[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!ops.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>-&gt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;graph.count(i))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : <span class="keyword">this</span>-&gt;graph[i])&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> target)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; marked;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pc;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,marked);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : marked)&#123;</span><br><span class="line">            pc.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : pc)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v == <span class="keyword">this</span>-&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;this-&gt;regexpr[v]&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;regexpr[v] == target[i] || <span class="keyword">this</span>-&gt;regexpr[v] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    matched.push_back(v+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            marked.clear();</span><br><span class="line">            pc.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : matched)&#123;</span><br><span class="line">                dfs(v,marked);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : marked)&#123;</span><br><span class="line">                pc.push_back(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : pc)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="keyword">this</span>-&gt;m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; marked)</span></span>&#123;</span><br><span class="line">        marked.insert(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(marked.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v,marked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;graph[v].push_back(w);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> regexpr;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> regexpr = <span class="string">"(a|b)*cd"</span>;</span><br><span class="line">    <span class="built_in">string</span> target1 = <span class="string">"ABD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target2 = <span class="string">"ADD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target3 = <span class="string">"ABD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target4 = <span class="string">"CBBD"</span>;</span><br><span class="line">    Nfa nfa;</span><br><span class="line">    nfa.build(regexpr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target4)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><code>NFA</code>转<code>DFA</code>的算法实现<br>这个算法也是我一直像学的，但是一直没有时间来好好思考这个问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="number">3.</span> 正则表达式引擎编写</span><br><span class="line">```c++</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串算法&quot;&gt;&lt;a href=&quot;#字符串算法&quot; class=&quot;headerlink&quot; title=&quot;字符串算法&quot;&gt;&lt;/a&gt;字符串算法&lt;/h3&gt;&lt;p&gt;字符串作为一个非常重要的应用，。对所有字符串算法的总结，包括字符串的排序与字符串的匹配，在实际的程序中是非常非常重要的两块应用，其中的算法又非常的复杂。光把这几个研究透就非常需要耗费精力和时间。&lt;/p&gt;&lt;h4 id=&quot;字符串排序&quot;&gt;&lt;a href=&quot;#字符串排序&quot; class=&quot;headerlink&quot; title=&quot;字符串排序&quot;&gt;&lt;/a&gt;字符串排序&lt;/h4&gt;&lt;h5 id=&quot;count-index&quot;&gt;&lt;a href=&quot;#count-index&quot; class=&quot;headerlink&quot; title=&quot;count index&quot;&gt;&lt;/a&gt;&lt;code&gt;count index&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;count index&lt;/code&gt;作为一种快速的排序算法，可以在O(n+m)的时间复杂度内即可完成字符串的排序。本质是基数排序，实际应用中这个排序算法效率非常高，基本上可以在线性时间内完成对字符串的排序。空间复杂度为O(m+n).&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countIndex&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; [] a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [] count = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;257&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [] aux = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[a.length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; str.length; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count[str[i]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] += count[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        aux[count[a[i]++]] = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i] = aux[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Priceton 算法课程学习</title>
    <link href="http://yoursite.com/2020/04/09/147/"/>
    <id>http://yoursite.com/2020/04/09/147/</id>
    <published>2020-04-09T15:34:46.798Z</published>
    <updated>2020-04-10T01:58:42.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法课程总结"><a href="#算法课程总结" class="headerlink" title="算法课程总结"></a>算法课程总结</h2><p>在疫情的两个月内已经把相关材料全部学习完成了，特别是把几个project全部做了一遍，感觉<code>project</code>全部做了一遍，总的感觉是课程的质量非常非常的高，难得见到这么高质量的课程。我是全程把课程资料和project全部下下来了，总共10个<code>project</code>全部做了一遍，感慨一下算法的强大，虽然自己也仅仅只是学到了皮毛，但是对于已经过了中年还坚持学习的自己感到很满意。“学无止境”，我想这永远是对自己的一种激励和鞭策。中国古人言，“求其上者，得其中，求其中者，得其下”，我想保持一颗永远学习进去得心，在哪里都会有自己得空间。<br>其实我最想点赞得是10个<code>project</code>得难度都很棒，还记得从刚开始得<code>java</code>的语法都搞不清楚，到后面基本上<code>java</code>的一般语法问题难不倒我。其实学完了这些课程以后，其实很羡慕那些能够去世界名校学习的学生们，你们始终是幸运儿。再想想10年前我所经历的大学，很少有这样的顶级学习资源和老师。虽然时光已逝，这些年经历了许多，经历了亲人的去世，也经历了两个小宝贝的诞生，让我逐渐成熟了许多，越来越知道自己想要追求什么，到底喜欢什么样的生活，我想说的是人需要为了理想而努力，虽然我出身低微贫穷，但是这些年来一直也没有放弃自己对美好生活和理想的追求。以下是 <code>github</code>上的地址连接：<br><a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1" target="_blank" rel="noopener">algorithms-part1</a><br><a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2" target="_blank" rel="noopener">algorithms-part2</a><br>从最开始连题目都看不懂，等到后面几个<code>project</code>基本上都能得到满分，还是非常欣慰的能看到自己的进步。强烈建议学习算法的同学们能够把这个课程坚持学习完整。<br>我觉得这个课程的<code>project</code> 非常有特色，需要提交的代码不仅仅是求出结果，还会对代码的输入检查、异常抛出、代码的风格、变量的定义以及运行时间和运行</p><a id="more"></a><h3 id="algorithms-part1"><a href="#algorithms-part1" class="headerlink" title="algorithms-part1"></a>algorithms-part1</h3><h4 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week1" target="_blank" rel="noopener">percolation</a><br>本次的<code>project</code>是关于<code>union-set</code>，<code>tricky</code>的地方查找集合中的元素同时存在上下边缘的元素。我们可以为每个集合定义两个变量表示该集合是否同时存在上下边缘的元素。<br><img src="https://mike-box.github.io/images/147-1.png" alt="percolation"></p><h4 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week2" target="_blank" rel="noopener">queues</a><br>本次的<code>project</code>是关于<code>queue</code>，这个project比较简单，<code>tricky</code>的地方randomQueue和Dequue。<br><img src="https://mike-box.github.io/images/147-2.png" alt="queues"></p><h4 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week3" target="_blank" rel="noopener">collinear</a><br>本次的<code>project</code>是关于线段合并，这个project稍微比较难，难点在于需要对所有的点的斜率进行排序，然后取斜率相等，<code>tricky</code>的地方在于如何去重，需要一点技巧，要按照元素的大小进行排序。<br><img src="https://mike-box.github.io/images/147-3.png" alt="collinear"></p><h4 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week4" target="_blank" rel="noopener">8puzzle</a><br>本次的<code>project</code>是关于优先级队列，这个project稍微比较难，首先题目非常不容易理解，再次对优先级的定义涉及到<code>mahanton</code>距离的计算。<code>tricky</code>的地方在于如何如何涉及优先级队列。<br>关于优先级队列中另有一个<code>project</code>我觉得非常有意思，<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week4/CollisionSystem" target="_blank" rel="noopener">CollisionSystem</a>.我用<code>python</code>重新写了一个碰撞模拟的系统，感觉非常有意思，如果感兴趣的同学非常建议把这个<code>project</code>学习以下，强烈的推荐。<br><img src="https://mike-box.github.io/images/147-4.png" alt="collinear"></p><h4 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week5" target="_blank" rel="noopener">kdtree</a><br>本次的<code>project</code>是关于<code>kdtree</code>，本质上是二分搜索树，非常经典的一个问题，通过这个project详细的了解了<code>kdtree</code>的原理，其实这个算法非常的有用，在<code>LBS</code>应用算法中非常有用。这个project稍微难，难点在于如何对<code>kdtree</code>进行查找，如何在<code>lgn</code>时间内对树进行搜索和查找。<code>tricky</code>的地方在写查找函数还是非常需要一定的技巧，当然对于经历过竞赛的同学，这个题目肯定非常简单。<br><img src="https://mike-box.github.io/images/147-6.png" alt="kdtree"></p><h3 id="algorithms-part2"><a href="#algorithms-part2" class="headerlink" title="algorithms-part2"></a>algorithms-part2</h3><h4 id="week1-1"><a href="#week1-1" class="headerlink" title="week1"></a>week1</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week1" target="_blank" rel="noopener">wordnet</a><br>本次的<code>project</code>是关于<code>图的搜索</code>，本质上是<code>BFS</code>，这个<code>project</code>比较简单，本质就是图的遍历。<code>tricky</code>的地方在在树中查找求最短距离之和。<br><img src="https://mike-box.github.io/images/147-7.png" alt="wordnet"></p><h4 id="week2-1"><a href="#week2-1" class="headerlink" title="week2"></a>week2</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week2" target="_blank" rel="noopener">seam</a><br>本次的<code>project</code>是关于<code>dp</code>，这个<code>project</code>比较有意思，用<code>DP</code>解决了这个问题，性能比给的参考答案性能还快几倍，这个project稍微比较简单，关键点在于找到能量最低的那条线，每次去掉能量最低的一条线的元素。<br><img src="https://mike-box.github.io/images/147-8.png" alt="seam"></p><h4 id="week3-1"><a href="#week3-1" class="headerlink" title="week3"></a>week3</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week3" target="_blank" rel="noopener">baseball</a><br>本次的<code>project</code>是关于<code>maxflow</code>，由于以前一直对<code>maxflow</code>这个算法不太了解，其中那几天想了好长时间才想明白这个算法的道理。如果明白了<code>maxflow</code>算法的原理，这个<code>project</code>非常简单，就是把图的边的对应关系要建立起来。<code>tricky</code>的地方在于对这个题目好多地方不太明白，看清楚图中每条边的<code>capbility</code>的是如何约束的，了解清楚就非常简单。<br><img src="https://mike-box.github.io/images/147-9.png" alt="baseball"></p><h4 id="week4-1"><a href="#week4-1" class="headerlink" title="week4"></a>week4</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week4" target="_blank" rel="noopener">boggle</a><br>本次的<code>project</code>是关于<code>trie</code>，题目很简单，在<code>leetcode</code>上有基本上类似的题目，早就对这个题目相当明白了。只要知道<code>trie</code>的搜索，这个题目时非常简单的。<br><img src="https://mike-box.github.io/images/147-9.png" alt="boggle"></p><h4 id="week5-1"><a href="#week5-1" class="headerlink" title="week5"></a>week5</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week5" target="_blank" rel="noopener">burrows</a><br>本次的<code>project</code>是关于<code>compress</code>算法，题目比较难，主要是压缩算法转换时对性能要求非常高，性能方面比较容易丢分要拿到满分不容易，最后性能跟题目中的参考答案差了一倍。<code>tricky</code>的地方在于如何理解题目，题目部分地方非常不好理解，另一方面性能如何优化是一个挑战。<br><img src="https://mike-box.github.io/images/147-10.png" alt="burrows"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法课程总结&quot;&gt;&lt;a href=&quot;#算法课程总结&quot; class=&quot;headerlink&quot; title=&quot;算法课程总结&quot;&gt;&lt;/a&gt;算法课程总结&lt;/h2&gt;&lt;p&gt;在疫情的两个月内已经把相关材料全部学习完成了，特别是把几个project全部做了一遍，感觉&lt;code&gt;project&lt;/code&gt;全部做了一遍，总的感觉是课程的质量非常非常的高，难得见到这么高质量的课程。我是全程把课程资料和project全部下下来了，总共10个&lt;code&gt;project&lt;/code&gt;全部做了一遍，感慨一下算法的强大，虽然自己也仅仅只是学到了皮毛，但是对于已经过了中年还坚持学习的自己感到很满意。“学无止境”，我想这永远是对自己的一种激励和鞭策。中国古人言，“求其上者，得其中，求其中者，得其下”，我想保持一颗永远学习进去得心，在哪里都会有自己得空间。&lt;br&gt;其实我最想点赞得是10个&lt;code&gt;project&lt;/code&gt;得难度都很棒，还记得从刚开始得&lt;code&gt;java&lt;/code&gt;的语法都搞不清楚，到后面基本上&lt;code&gt;java&lt;/code&gt;的一般语法问题难不倒我。其实学完了这些课程以后，其实很羡慕那些能够去世界名校学习的学生们，你们始终是幸运儿。再想想10年前我所经历的大学，很少有这样的顶级学习资源和老师。虽然时光已逝，这些年经历了许多，经历了亲人的去世，也经历了两个小宝贝的诞生，让我逐渐成熟了许多，越来越知道自己想要追求什么，到底喜欢什么样的生活，我想说的是人需要为了理想而努力，虽然我出身低微贫穷，但是这些年来一直也没有放弃自己对美好生活和理想的追求。以下是 &lt;code&gt;github&lt;/code&gt;上的地址连接：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/algorithms-part1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;algorithms-part1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/algorithms-part2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;algorithms-part2&lt;/a&gt;&lt;br&gt;从最开始连题目都看不懂，等到后面几个&lt;code&gt;project&lt;/code&gt;基本上都能得到满分，还是非常欣慰的能看到自己的进步。强烈建议学习算法的同学们能够把这个课程坚持学习完整。&lt;br&gt;我觉得这个课程的&lt;code&gt;project&lt;/code&gt; 非常有特色，需要提交的代码不仅仅是求出结果，还会对代码的输入检查、异常抛出、代码的风格、变量的定义以及运行时间和运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LFU</title>
    <link href="http://yoursite.com/2020/04/06/146/"/>
    <id>http://yoursite.com/2020/04/06/146/</id>
    <published>2020-04-06T15:12:08.192Z</published>
    <updated>2020-04-07T02:26:44.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h1><p>题目比较简单，都做出来了。</p><h2 id="460-LFU缓存"><a href="#460-LFU缓存" class="headerlink" title="460. LFU缓存"></a>460. LFU缓存</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请你为 最不经常使用<code>（LFU）</code>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p><ul><li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li><li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。</li></ul><a id="more"></a><p>「项的使用次数」就是自插入该项以来对其调用 <code>get</code>和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。`</p><p>进阶：<br>你是否可以在<code>O(1)</code> 时间复杂度内执行两项操作？<br>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LFUCache cache = new LFUCache( <span class="number">2</span> <span class="comment">/* capacity (缓存容量) */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 去除 key 2</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到key 2)</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">3</span>);       <span class="comment">// 返回 3</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 去除 key 1</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到 key 1)</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">3</span>);       <span class="comment">// 返回 3</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">4</span>);       <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure><br>归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/lfu-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> LFU算法  hash + 双链表</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>对所有的key按照使用频次大小和使用时间的先后进行排列，即我们将最少使用次数，且最长时间未用的节点放在链表队列的首部，每次队列满时直接从队列的头部取出元素进行淘汰。</li><li>我们将用将key映射到链表的节点的指针，所以我们可以在O(1)的时间复杂度内即可以访问到链表的节点，然后将链表的节点中存储的freq进行加一，并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).</li><li><code>get</code>操作时，直接查找hash表，查找该值是否存在映射的链表的节点。将链表的节点中存储的freq进行加一，并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).</li><li><code>put</code>操作时，直接查找hash表，查找该值是否存在映射的链表的节点。如果该节点存在，则改变存储的value的值，同时将存储的freq进行加1操作，然后移动链表。并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).如果该节点不存在，则有两种情况需要讨论。一是队列已经满，则这时只需要将双链表队列的头部元素去掉，然后再添加新的头节点到队列中，然后进行比较移动操作。如果队列未满，则直接再双链表队列的头部添加新的元素，然后进行频次比较移位操作。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    CacheNode(<span class="keyword">int</span> k, <span class="keyword">int</span> v):freq(<span class="number">1</span>), key(k), val(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> CacheNode&amp; a, <span class="keyword">const</span> CacheNode&amp; b)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.freq &lt; b.freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        size = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = cacheMap.find(key);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || it == cacheMap.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        CacheNode temp = *(it-&gt;second);</span><br><span class="line">        temp.freq++;</span><br><span class="line">        cacheSet.erase(it-&gt;second);</span><br><span class="line">        cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cacheMap.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == cacheMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheMap.size() == size)&#123;</span><br><span class="line">                cacheMap.erase((cacheSet.begin())-&gt;key);</span><br><span class="line">                cacheSet.erase(cacheSet.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            CacheNode temp = CacheNode(key, value);</span><br><span class="line">            cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheNode temp = *(it-&gt;second);</span><br><span class="line">        temp.freq++;</span><br><span class="line">        temp.val = value;</span><br><span class="line">        cacheSet.erase(it-&gt;second);</span><br><span class="line">        cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;CacheNode, Compare&gt; cacheSet;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;CacheNode, Compare&gt;::iterator&gt; cacheMap;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    Node * next;</span><br><span class="line">    Node * prev;</span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;freq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> currSize;</span><br><span class="line">    Node * head;</span><br><span class="line">    Queue(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxSize = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;currSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu || qu-&gt;currSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> qu-&gt;currSize &gt;= qu-&gt;maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">shiftQueue</span><span class="params">(Queue * qu,Node * curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu || !curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(qu)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*shift every node if freq is less or equal than curr*/</span></span><br><span class="line">    <span class="keyword">bool</span> replace = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(Node * node = curr-&gt;next; node ; node = curr-&gt;next)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"swap :"&lt;&lt;curr-&gt;val &lt;&lt;" "&lt;&lt; node-&gt;val &lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">/*swap node*/</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;freq &lt;= curr-&gt;freq)&#123;</span><br><span class="line">            curr-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;prev = curr-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;prev) curr-&gt;prev-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next) node-&gt;next-&gt;prev = curr;</span><br><span class="line">            curr-&gt;prev = node;</span><br><span class="line">            node-&gt;next = curr;</span><br><span class="line">            <span class="keyword">if</span>(qu-&gt;head == curr &amp;&amp; !replace)&#123;</span><br><span class="line">                qu-&gt;head = node;</span><br><span class="line">                replace = <span class="literal">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushFront</span><span class="params">(Queue * qu, Node * node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu||!node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(qu))&#123;</span><br><span class="line">        qu-&gt;head = node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node-&gt;next = qu-&gt;head;</span><br><span class="line">        qu-&gt;head-&gt;prev = node;</span><br><span class="line">        qu-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;currSize++;</span><br><span class="line">    shiftQueue(qu,node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popFront</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;currSize == <span class="number">0</span> || !qu-&gt;head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Node * e = qu-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> ret = e-&gt;key;</span><br><span class="line">    qu-&gt;head = qu-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;head) qu-&gt;head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    qu-&gt;currSize--;</span><br><span class="line">    e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    e-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">debugQueue</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"curr size = "</span>&lt;&lt;qu-&gt;currSize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(Node * node = qu-&gt;head; node; node = node-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"key:"</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="string">" value:"</span>&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" freq:"</span>&lt;&lt;node-&gt;freq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;qu = <span class="keyword">new</span> Queue(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;hash.count(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">        curr-&gt;freq++;</span><br><span class="line">        <span class="keyword">int</span> ret = curr-&gt;val;</span><br><span class="line">        shiftQueue(<span class="keyword">this</span>-&gt;qu,curr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.count(key))&#123;</span><br><span class="line">             Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">             curr-&gt;val = value;</span><br><span class="line">             curr-&gt;freq++;</span><br><span class="line">             shiftQueue(<span class="keyword">this</span>-&gt;qu,curr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/* buffer is full*/</span></span><br><span class="line">            <span class="keyword">if</span>(isFull(qu))&#123;</span><br><span class="line">                <span class="keyword">if</span>(qu-&gt;head)&#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;hash.erase(qu-&gt;head-&gt;key);</span><br><span class="line">                    popFront(qu);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isFull(qu))&#123;</span><br><span class="line">                Node * node = <span class="keyword">new</span> Node();</span><br><span class="line">                node-&gt;key = key;</span><br><span class="line">                node-&gt;val = value;</span><br><span class="line">                node-&gt;freq = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;hash[key] = node;</span><br><span class="line">                pushFront(<span class="keyword">this</span>-&gt;qu,node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node *&gt; hash;</span><br><span class="line">    Queue *qu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    Node(<span class="keyword">int</span> key,<span class="keyword">int</span> val,<span class="keyword">int</span> freq,<span class="keyword">int</span> time)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;freq = freq;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node * x,<span class="keyword">const</span> Node * y)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;freq == y-&gt;freq) <span class="keyword">return</span> x-&gt;time &lt; y-&gt;time;</span><br><span class="line">        <span class="keyword">return</span> x-&gt;freq &lt; y-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxSize = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash.count(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node * curr = hash[key];</span><br><span class="line">        buffer.erase(curr);</span><br><span class="line">        <span class="keyword">int</span> ret = curr-&gt;val;</span><br><span class="line">        curr-&gt;freq++;</span><br><span class="line">        curr-&gt;time = <span class="keyword">this</span>-&gt;timer;</span><br><span class="line">        buffer.insert(curr);</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;maxSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(hash.count(key))&#123;</span><br><span class="line">            Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">            buffer.erase(curr);</span><br><span class="line">            curr-&gt;val = value;</span><br><span class="line">            curr-&gt;freq++;</span><br><span class="line">            curr-&gt;time = <span class="keyword">this</span>-&gt;timer;</span><br><span class="line">            buffer.insert(curr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer.size() &gt;= <span class="keyword">this</span>-&gt;maxSize)&#123;</span><br><span class="line">                Node * curr = *buffer.begin();</span><br><span class="line">                <span class="keyword">this</span>-&gt;hash.erase(curr-&gt;key);</span><br><span class="line">                buffer.erase(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            Node * node = <span class="keyword">new</span> Node(key,value,<span class="number">1</span>,<span class="keyword">this</span>-&gt;timer);</span><br><span class="line">            <span class="keyword">this</span>-&gt;hash[key] = node;</span><br><span class="line">            buffer.insert(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node *&gt; hash;</span><br><span class="line">    <span class="built_in">set</span>&lt;Node*,cmp&gt; buffer;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LFU&quot;&gt;&lt;a href=&quot;#LFU&quot; class=&quot;headerlink&quot; title=&quot;LFU&quot;&gt;&lt;/a&gt;LFU&lt;/h1&gt;&lt;p&gt;题目比较简单，都做出来了。&lt;/p&gt;&lt;h2 id=&quot;460-LFU缓存&quot;&gt;&lt;a href=&quot;#460-LFU缓存&quot; class=&quot;headerlink&quot; title=&quot;460. LFU缓存&quot;&gt;&lt;/a&gt;460. LFU缓存&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请你为 最不经常使用&lt;code&gt;（LFU）&lt;/code&gt;缓存算法设计并实现数据结构。它应该支持以下操作：&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get(key)&lt;/code&gt; - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put(key, value)&lt;/code&gt; - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 23周双周比赛</title>
    <link href="http://yoursite.com/2020/04/05/145/"/>
    <id>http://yoursite.com/2020/04/05/145/</id>
    <published>2020-04-05T15:07:04.024Z</published>
    <updated>2020-04-05T15:07:10.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23周比赛"><a href="#23周比赛" class="headerlink" title="23周比赛"></a>23周比赛</h1><p>题目比较简单，都做出来了。</p><h2 id="5360-统计最大组的数目"><a href="#5360-统计最大组的数目" class="headerlink" title="5360. 统计最大组的数目"></a>5360. 统计最大组的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p><p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">9</span> 个组，将 <span class="number">1</span> 到 <span class="number">13</span> 按数位求和后这些组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">10</span>]，[<span class="number">2</span>,<span class="number">11</span>]，[<span class="number">3</span>,<span class="number">12</span>]，[<span class="number">4</span>,<span class="number">13</span>]，[<span class="number">5</span>]，[<span class="number">6</span>]，[<span class="number">7</span>]，[<span class="number">8</span>]，[<span class="number">9</span>]。总共有 <span class="number">4</span> 个组拥有的数字并列最多。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个大小为 <span class="number">1</span> 的组 [<span class="number">1</span>]，[<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">15</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">24</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：`</p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-largest-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-largest-group</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序之后，暴力即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += (n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            cnt[sum(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">            maxFreq = max(x.second,maxFreq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second == maxFreq) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5362-构造-K-个回文字符串"><a href="#5362-构造-K-个回文字符串" class="headerlink" title="5362. 构造 K 个回文字符串"></a>5362. 构造 K 个回文字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。</p><p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 <code>True</code>，否则返回 <code>False</code>。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"annabelle"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以用 s 中所有字符构造 <span class="number">2</span> 个回文字符串。</span><br><span class="line">一些可行的构造方案包括：<span class="string">"anna"</span> + <span class="string">"elble"</span>，<span class="string">"anbna"</span> + <span class="string">"elle"</span>，<span class="string">"anellena"</span> + <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span>, <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法用 s 中所有字符构造 <span class="number">3</span> 个回文串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"true"</span>, <span class="attr">k</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"yzyzyzyzyzyzyzy"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"cr"</span>, <span class="attr">k</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：我们没有足够的字符去构造 <span class="number">7</span> 个回文串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 10^5</li><li>s 中所有字符都是小写英文字母。</li><li>1 &lt;= k &lt;= 10^5</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-k-palindrome-strings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 判定不符合条件</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>只需要统计字符的个数即可。对于偶数的字符，我们可以知道它可以拆成一个或者两个或者零个回文字符串都可以。比如 “aaaaa”:<br>我们可以把该字符串本身串联都其他的回文字符串，或者将其当作一个单独的字符串，或者拆成两个字符串。</li><li>但是对于字符数目为奇数的字符我们最少都需要占用一个回文字符串，因为它有一个奇数的字符没法拆分。</li><li>此题实际上转换为求偶数数目的字符的个数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            cnt[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]%<span class="number">2</span>) odd++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(odd &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5361-圆和矩形是否有重叠"><a href="#5361-圆和矩形是否有重叠" class="headerlink" title="5361. 圆和矩形是否有重叠"></a>5361. 圆和矩形是否有重叠</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个以 <code>(radius, x_center, y_center)</code> 表示的圆和一个与坐标轴平行的矩形 <code>(x1, y1, x2, y2)</code>，其中 <code>(x1, y1)</code> 是矩形左下角的坐标，<code>(x2, y2)</code>是右上角的坐标。</p><p>如果圆和矩形有重叠的部分，请你返回 <code>True</code>，否则返回 <code>False</code> 。</p><p>换句话说，请你检测是否 存在 点 <code>(xi, yi)</code>，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">0</span>, y_center = <span class="number">0</span>, x1 = <span class="number">1</span>, y1 = <span class="number">-1</span>, x2 = <span class="number">3</span>, y2 = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：圆和矩形有公共点 (<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">0</span>, y_center = <span class="number">0</span>, x1 = <span class="number">-1</span>, y1 = <span class="number">0</span>, x2 = <span class="number">0</span>, y2 = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">1</span>, y_center = <span class="number">1</span>, x1 = <span class="number">-3</span>, y1 = <span class="number">-3</span>, x2 = <span class="number">3</span>, y2 = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">1</span>, y_center = <span class="number">1</span>, x1 = <span class="number">1</span>, y1 = <span class="number">-3</span>, x2 = <span class="number">2</span>, y2 = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= radius &lt;= 2000</code></li><li><code>-10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4</code></li><li><code>x1 &lt; x2</code></li><li><code>y1 &lt; y2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping" target="_blank" rel="noopener">https://leetcode-cn.com/problems/circle-and-rectangle-overlapping</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>圆心如果在矩形内肯定存在交集。</li><li>矩形的边缘如果在园内，则肯定存在交集。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*inside */</span></span><br><span class="line">        <span class="keyword">if</span>(x_center &gt;= x1 &amp;&amp; x_center &lt;= x2 &amp;&amp; y_center &gt;= y1 &amp;&amp; y_center &lt;= y2) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*left and right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y1; i &lt;= y2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(x1-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(i-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(x2-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(i-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*top and buttom*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x1; i &lt;= x2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(i-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(y1-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(i-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(y2-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5363-做菜顺序"><a href="#5363-做菜顺序" class="headerlink" title="5363. 做菜顺序"></a>5363. 做菜顺序</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>一个厨师收集了他 n 道菜的满意程度<code>satisfaction</code>，这个厨师做出每道菜的时间都是 1 单位时间。<br>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]*satisfaction[i]</code> 。<br>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。<br>你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-1</span>,<span class="number">-8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (<span class="number">-1</span>*<span class="number">1</span> + <span class="number">0</span>*<span class="number">2</span> + <span class="number">5</span>*<span class="number">3</span> = <span class="number">14</span>) 。每道菜都需要花费 <span class="number">1</span> 单位时间完成。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：按照原来顺序相反的时间做菜 (<span class="number">2</span>*<span class="number">1</span> + <span class="number">3</span>*<span class="number">2</span> + <span class="number">4</span>*<span class="number">3</span> = <span class="number">20</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-1</span>,<span class="number">-4</span>,<span class="number">-5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">35</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == satisfaction.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-10^3 &lt;= satisfaction[i] &lt;= 10^3</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reducing-dishes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reducing-dishes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划  </p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>本题还是比较常见的DP，首先对菜单进行从小到大排序。</li><li>二维dp，<code>dp[i][j]</code>代表从前<code>i</code>道菜品中选择<code>j</code>道菜品所获得最大满意度。</li><li>递推公式为：<script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] + satisfaction[i]*j)</script></li><li>简单的二维DP，很容易就得到结果。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> dp[M][M];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = satisfaction.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        sort(satisfaction.begin(),satisfaction.end());</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + satisfaction[i<span class="number">-1</span>]*j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + satisfaction[i<span class="number">-1</span>]*j);</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;23周比赛&quot;&gt;&lt;a href=&quot;#23周比赛&quot; class=&quot;headerlink&quot; title=&quot;23周比赛&quot;&gt;&lt;/a&gt;23周比赛&lt;/h1&gt;&lt;p&gt;题目比较简单，都做出来了。&lt;/p&gt;&lt;h2 id=&quot;5360-统计最大组的数目&quot;&gt;&lt;a href=&quot;#5360-统计最大组的数目&quot; class=&quot;headerlink&quot; title=&quot;5360. 统计最大组的数目&quot;&gt;&lt;/a&gt;5360. 统计最大组的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。&lt;/p&gt;&lt;p&gt;请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：总共有 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 个组，将 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; 按数位求和后这些组分别是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]。总共有 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 个组拥有的数字并列最多。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：总共有 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个大小为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的组 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 183周比赛</title>
    <link href="http://yoursite.com/2020/04/05/144/"/>
    <id>http://yoursite.com/2020/04/05/144/</id>
    <published>2020-04-05T11:03:32.352Z</published>
    <updated>2020-04-05T11:03:38.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="183周比赛"><a href="#183周比赛" class="headerlink" title="183周比赛"></a>183周比赛</h1><p>题目都比较简单，除了第三题稍微有点绕弯以外，其余的都比较简单。</p><h2 id="5376-非递增顺序的最小子序列"><a href="#5376-非递增顺序的最小子序列" class="headerlink" title="5376. 非递增顺序的最小子序列"></a>5376. 非递增顺序的最小子序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。<br>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。<br>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。<br>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">9</span>] </span><br><span class="line">解释：子序列 [<span class="number">10</span>,<span class="number">9</span>] 和 [<span class="number">10</span>,<span class="number">8</span>] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [<span class="number">10</span>,<span class="number">9</span>] 的元素之和最大。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>] </span><br><span class="line">解释：子序列 [<span class="number">7</span>,<span class="number">7</span>] 的和为 <span class="number">14</span> ，不严格大于剩下的其他元素之和（<span class="number">14</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">6</span>）。因此，[<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[6]</span></span><br><span class="line">输出：<span class="string">[6]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序之后，暴力即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minSubsequence(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum += x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; sum - curr)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5377-将二进制表示减到-1-的步骤数"><a href="#5377-将二进制表示减到-1-的步骤数" class="headerlink" title="5377. 将二进制表示减到 1 的步骤数"></a>5377. 将二进制表示减到 1 的步骤数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：<br>如果当前数字为偶数，则将其除以 2 。<br>如果当前数字为奇数，则将其加上 1 。<br>题目保证你总是可以按上述规则将测试用例变为 1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1101"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">"1101"</span> 表示十进制数 <span class="number">13</span> 。</span><br><span class="line">Step <span class="number">1</span>) <span class="number">13</span> 是奇数，加 <span class="number">1</span> 得到 <span class="number">14</span> </span><br><span class="line">Step <span class="number">2</span>) <span class="number">14</span> 是偶数，除 <span class="number">2</span> 得到 <span class="number">7</span></span><br><span class="line">Step <span class="number">3</span>) <span class="number">7</span>  是奇数，加 <span class="number">1</span> 得到 <span class="number">8</span></span><br><span class="line">Step <span class="number">4</span>) <span class="number">8</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">4</span>  </span><br><span class="line">Step <span class="number">5</span>) <span class="number">4</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">2</span> </span><br><span class="line">Step <span class="number">6</span>) <span class="number">2</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">"10"</span> 表示十进制数 <span class="number">2</span> 。</span><br><span class="line">Step <span class="number">1</span>) <span class="number">2</span> 是偶数，除 <span class="number">2</span> 得到 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s 由字符 &#39;0&#39; 或 &#39;1&#39; 组成</code></li><li><code>s[0] == &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟计算即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>由于本身的二进制长度很长，可能大于200.</li><li><code>python</code>或者<code>java</code>支持超长数目，所以可以直接计算即可。</li><li><code>c/c++</code>由于没有不支持超长整形，所以我们直接对二进制字符串本身进行模拟加法或者减法即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">increment</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span> &amp;&amp; carry == <span class="number">1</span>)&#123;</span><br><span class="line">                s[i] = <span class="string">'0'</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[i] = s[i] + carry;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> carry == <span class="number">1</span>?(<span class="string">'1'</span>+ s):(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decrement</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substr(<span class="number">0</span>,s.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s != <span class="string">"1"</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(s.back() == <span class="string">'1'</span>) s = increment(s);</span><br><span class="line">            <span class="keyword">else</span> s = decrement(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5195-最长快乐字符串"><a href="#5195-最长快乐字符串" class="headerlink" title="5195. 最长快乐字符串"></a>5195. 最长快乐字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>如果字符串中不含有任何 <code>&#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39;</code>这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p><p>给你三个整数 <code>a，b ，c，</code>请你返回 任意一个 满足下列全部条件的字符串 s：</p><ul><li><code>s</code>是一个尽可能长的快乐字符串。</li><li><code>s</code>中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。</li><li><code>s</code>中只含有 ‘a’、’b’ 、’c’ 三种字母。</li></ul><p>如果不存在这样的字符串<code>s</code>，请返回一个空字符串 “”。<br>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">1</span>, <span class="selector-tag">b</span> = <span class="number">1</span>, c = <span class="number">7</span></span><br><span class="line">输出：<span class="string">"ccaccbcc"</span></span><br><span class="line">解释：<span class="string">"ccbccacc"</span> 也是一种正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">2</span>, <span class="selector-tag">b</span> = <span class="number">2</span>, c = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"aabbc"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">7</span>, <span class="selector-tag">b</span> = <span class="number">1</span>, c = <span class="number">0</span></span><br><span class="line">输出：<span class="string">"aabaa"</span></span><br><span class="line">解释：这是该测试用例的唯一正确答案。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>0 &lt;= a, b, c &lt;= 100</code></li><li><code>a + b + c &gt; 0</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-happy-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-happy-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次优先取长度最长的那个字符，如果该字符之前已经出现了两次，则我们选择次等长度的。</li><li>但是这个题目确实出的不够好，因为实际也并没有对字符的数目进行限制。比较混乱。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>((a+b+c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = res.size();</span><br><span class="line">            <span class="keyword">int</span> x = max(a,max(b,c));</span><br><span class="line">            <span class="keyword">if</span>(x == a)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"aa"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'a'</span>;</span><br><span class="line">                    a--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(b,c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b == max(b,c))&#123;</span><br><span class="line">                        res += <span class="string">'b'</span>;</span><br><span class="line">                        b--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'c'</span>;</span><br><span class="line">                        c--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"bb"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'b'</span>;</span><br><span class="line">                    b--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(a,c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a == max(a,c))&#123;</span><br><span class="line">                        res += <span class="string">'a'</span>;</span><br><span class="line">                        a--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'c'</span>;</span><br><span class="line">                        c--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"cc"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'c'</span>;</span><br><span class="line">                    c--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(a,b) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a == max(a,b))&#123;</span><br><span class="line">                        res += <span class="string">'a'</span>;</span><br><span class="line">                        a--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'b'</span>;</span><br><span class="line">                        b--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5379-石子游戏-III"><a href="#5379-石子游戏-III" class="headerlink" title="5379. 石子游戏 III"></a>5379. 石子游戏 III</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。</p><p>Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。</p><p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p><p>假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。</p><p>示例 1：</p><p>输入：values = [1,2,3,7]<br>输出：”Bob”<br>解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。</p><p>示例 2：</p><p>输入：values = [1,2,3,-9]<br>输出：”Alice”<br>解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。<br>如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。<br>如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。<br>注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。</p><p>示例 3：</p><p>输入：values = [1,2,3,6]<br>输出：”Tie”<br>解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。</p><p>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">"Alice"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="string">"Tie"</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= values.length &lt;= 50000</code></li><li><code>-1000 &lt;= values[i] &lt;= 1000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-iii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划  </p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>比较传统的题目，我们设立dp动态规划。<code>dp[i]</code>代表从<code>i</code>处进行游戏时，在最优策略下直到游戏结束时，自己所能取到的最多的石子的数目。<code>sum[i]</code>代表从i到n的石子的总的数目；</li><li>递推公式为：<script type="math/tex; mode=display">dp[i] = max\left\{\begin{aligned}\sum_{k = 0}^{0}stones[i+k] + sum[i+1] - dp[i+1] \\\sum_{k = 0}^{1}stones[i+k] + sum[i+2] - dp[i+2] \\\sum_{k = 0}^{2}stones[i+k] + sum[i+3] - dp[i+3] \\\end{aligned}\right.</script></li><li>我们倒序从最后的元素开始计算，设dp[n] = 0;我们在O(N)的时间复杂度内既可以求出结果。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">stoneGameIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,INT_MIN);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) sum[i] = sum[i+<span class="number">1</span>] + stoneValue[i];</span><br><span class="line">      </span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n &amp;&amp; j &lt;= i + <span class="number">2</span>; j++)&#123;</span><br><span class="line">                curr += stoneValue[j];</span><br><span class="line">                dp[i] = max(dp[i],curr+sum[j+<span class="number">1</span>]-dp[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>] == sum[<span class="number">0</span>] - dp[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">"Tie"</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>] &gt; sum[<span class="number">0</span>] - dp[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;183周比赛&quot;&gt;&lt;a href=&quot;#183周比赛&quot; class=&quot;headerlink&quot; title=&quot;183周比赛&quot;&gt;&lt;/a&gt;183周比赛&lt;/h1&gt;&lt;p&gt;题目都比较简单，除了第三题稍微有点绕弯以外，其余的都比较简单。&lt;/p&gt;&lt;h2 id=&quot;5376-非递增顺序的最小子序列&quot;&gt;&lt;a href=&quot;#5376-非递增顺序的最小子序列&quot; class=&quot;headerlink&quot; title=&quot;5376. 非递增顺序的最小子序列&quot;&gt;&lt;/a&gt;5376. 非递增顺序的最小子序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。&lt;br&gt;如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。&lt;br&gt;与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。&lt;br&gt;注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>读书感想</title>
    <link href="http://yoursite.com/2020/04/01/143/"/>
    <id>http://yoursite.com/2020/04/01/143/</id>
    <published>2020-04-01T05:19:38.278Z</published>
    <updated>2020-04-01T05:19:48.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="少有人走的路"><a href="#少有人走的路" class="headerlink" title="少有人走的路"></a>少有人走的路</h3><p>最近自己一直在看关于心理方面和社会方面的书，越来越感慨好自己以往的过失与浪费生命。越来越想针对自身的错误来分析自身。<br>总结一下自己所犯的错误的原因如下：</p><h4 id="1-缺乏目标"><a href="#1-缺乏目标" class="headerlink" title="1.缺乏目标"></a>1.缺乏目标</h4><p>感慨自身缺乏目标的有内在的原因也有外在的原因。正是因为却反目标得人生导致了现在被动得自己，自己正所谓得随波逐流，本质上就是昏昏耗耗，其实许多周围人也不见得在这个问题上比自己做的更好，因为毕竟“现世太辛苦和匆忙”，能有时间和精力把健康、家庭、工作都兼顾好都已经非常不容易了，哪里还顾得上更远大得追求，所谓得人生活着得意义这种虚无缥缈得问题，更是少有人去思考。当然人类在进化过程中，进喜欢深度思考和做决策，毕竟深度思考和做决策都需要耗费极大的精力，承担极大的责任，冒着极大的风险，这是本身就是人类进化的结果导致，毕竟现世生活中越操心的人老的越快，反而那些什么都不思考的人活得最长寿。人类进化过程中少部分精英能够有极大的耐心，从内部打破这种依赖，深度去思考世界，思考社会。</p><a id="more"></a><ul><li>内在的原因是因为对自身不够自信，很少独立的去做自己的决定，做决定前害怕做错决定，殊不知人生中哪有会不做错误的决定，究其原因也是从小养成的习惯，从童年开始自己就是一个没有目标的人，做事情只想着做到最好，但没有明确的目标。包括高考，找工作，考研，结婚，买房。感觉人生中的几年大事似乎都是糊里糊涂的就过去了，从来没有认真的思考，这些工作，这些东西是否有过遵从自己的内心。当然了，虽然自己取得一定的成就，从偏远的农村出来，能够在大城市安身立命本身就是非常的不容易。但是时常回顾过往的三十几年，回想起来很多事情其实都过得糊里糊涂，虽然自我评价智商可以，但是很多更长远得目标并没有去实施。我想存在以上这些问题可能本身得出身有关，出身不易，大部分时间只顾的”眼前得苟且“，哪里还有时间去思考”远方得田野“。当然目标是生活稍微安定了以后，物质条件满足了以后，才有很多得闲暇时间来思考人生，来思考活着意义，来思考个人追求得价值观，正所谓得“饱暖思淫欲”吧，人的欲望总是随着周围得环境在不断放大。</li><li>外在得原因是没有进入一个更好的环境。周围人也绝大部分昏昏耗耗，找到志同道合得人已经非常难得，大毕竟大部分人都是普通人，哪有心思去思考人生的追求和意义。在这样物欲横流的社会，大部分都去谁随经济收入、房子、车子、名誉、地位了。有时候跟一些朋友探讨一些问题或者现象时，很少有人对这些话题感兴趣，毕竟大家都是俗人，吃饱饭、住大房子、开豪车、追求权力和地位，这才是最现实的需求。可能我自己觉得自身还是层次太低了，接触的真正的有目标有行动力的人群太少了，大都只能通过网上交流和认识一些网友。从自身来说，一直想跳出体制内这个圈子，不喜欢体制内这种氛围，大部分人都没啥追求的动力，都是安安稳稳的过日子，没有目标没有追求。当然，体制内对于普通人来说绝对时最好的选择，基本上一辈子不会有太大的风险，也不用费劲自己做决定和努力，只需要安安稳稳的过日子即可，一辈子虽不能大富大贵，但是大部分人身体健康，也没有失业的风险，但是自身的成就感太差，绝大分基层很少感受到自身存在的价值。在这种氛围下，时间长了人也会变得非常没有上进心，只想安安稳稳的混日子。所以非常需要一个良好的外部坏境来刺激自己进入到正循环。</li><li>解决办法：</li></ul><ol><li>每年定好自己的目标，每月定时公布自己的进度与进展。不要随意更改自己的目标。疫情过去了，终于可以正常上班了，计划用excel或者表格，定时在网上公布自己每天的进展和进度总结。只有日继月累才有成效。</li><li>今年要主动去寻求改变，改变自身和外部，希望能够跳出体制，找到一个更加让人上进的环境去奋斗。</li></ol><h4 id="2-缺乏自律"><a href="#2-缺乏自律" class="headerlink" title="2.缺乏自律"></a>2.缺乏自律</h4><p>只有自律的人生，才能有所成就和收获。现实社会中，能够真正做到自律的少之又少，我现在回想起来，自己真正进步最快的那段时光，第一段时间是在初二的时候，依稀还记得当时刚开始学习三角几何，那是一段让人充实而又难忘得自学时光。每天自己提前预习课本，每天自己定时自己得进度，每天回顾自身，回想起来那段时间也是自己进度最快得时候，完全凭借着自己得兴趣和热情，然而工作以来，很少再有这种冲动了。另外一段时光是自己考研的时候，每天自己安排生活，自己定好进度和目标，隔一天复习，那时候的自己是简单而又充实的，虽然物质生活过得很苦，但是精神上却非常满足。如今的社会中，诱惑太多，毕竟当自己</p><ul><li>自身的原因。还是对目标不够坚定，没有追求导致。只有心中有非常坚定的目标，才能坚持不懈的努力和追求。我想实际上真正投入后，工作带来的乐趣远大于游戏和娱乐的乐趣，因为工作带来的成就感会持久很长一段，而娱乐带来的快感只有一小段时间，而且长时间的娱乐和放松反而会给人带来浪费时间的愧疚感。</li><li>外界的原因。当前社会的诱惑太多，许多年轻人，包括我自己对于电子游戏、互联网媒体沉迷，长时间陷入不能自拔。这时一个很重要的问题所在，在所有容易收到诱惑的地方浪费了太多宝贵的时间，本来应该利用这些时间来锻炼身体，学习，陪伴关心家人，却都被自身浪费在了一些无所事事的社交媒体上，特别是疫情期间又无法外出，大家都憋在家中无所事事，只能通过社交媒体发泄自己的情绪和不满。每天尽量少看手机和微信，除工作必须以外，将手机使用时间控制在1个小时以内。这是非常重要的一个原因。</li><li>身体的原因。由于疫情期间不能正常外出作息，每天憋在家里，运动量严重不足，时间长了难免心里压抑，并且饮食结构严重不健康。希望快点能够恢复正常，恢复正常的活力，将身体养好。晚上睡觉前坚决不带手机到卧室，这样可以有效的改善自己晚睡的坏习惯。其实本来在武汉的疫情到来以前，晚睡的坏习惯早就改善了，可惜因为疫情的到来，严重的影响了自身的身体健康和作息习惯，要快速的调整过来。只有身心健康，一个人的心情才好，只有心情好，才能拥有事业的进步，才能拥有人生的选择权。</li><li>解决办法：</li></ul><ol><li>坚持锻炼身体。我想只有健康的体魄才是解决问题的根源。按照医学的统计，运动会促进体内的多巴胺的分泌，多巴胺会导致神经兴奋，这也是大多数人运动后心情愉快的根本原因。目前健身房还是没有开门，计划健身房开门后，还是坚持每周3-4次的游泳，每次半个小时。这点一定一定要坚持。</li><li>杜绝一切干扰自身的因素。坚持早上12点前，除非有重要事情，坚持不刷手机。退出所有不必要的微信群，QQ群。除了工作群和校友群以外，全部退出。因为绝大多数的群到了后期都是灌水，很少有真正有营养的东西值得自己去学习和交流，删除电脑上所有的电子游戏。所有不必要的微信公众号全部不再关注。晚上睡觉前坚决不带手机到卧室。</li><li>晚上10点30准时上床休息或看书，养成早睡早起的好习惯。</li><li>每天坚持早上到办公室做好一天的工作计划和安排。<h4 id="3-缺乏自信"><a href="#3-缺乏自信" class="headerlink" title="3.缺乏自信"></a>3.缺乏自信</h4>缺乏自信这个问题，我想跟自身的原生家庭有很大的影响，小时候形成的价值观太难改变了。从小父母给自己的感觉是父亲是个沉默寡言的老实人，顺从不会反抗。父亲做个好榜样其实对自身的影响非常大，很少做过让我们觉得骄傲的事情，依稀还记得小时候的自己又瘦又小，在整个村里面家庭条件都非常差，整天感觉家里面逆来顺受，很少因为这个家庭而感到骄傲。母亲那时候身体不好，时常生病，父亲总是唉声叹气，却很少主动想办法去解决问题，那时候给自己幼小的自己带来很多生活上的阴影。有时候回忆起来，感觉小时候家庭的负面影响太大了，有时候觉得自己读书读研，进入体制内能够到大城市定居真心不容易，历经的挫折和艰辛只有自己知道，这些从来很少跟父亲提到过一路走来的艰辛和不易，别人只看到你表面的光鲜，没看到你背后的努力和受到的委屈。</li></ol><ul><li>现在自己也当了父母了，时刻回忆起来自己小时候受到的挫折和鄙视。怎样给自己的下一代塑造一个健康和正面的心里非常重要，所以现在很少用负面消息去贬低自己的孩子，希望能够给他们正面的形象，让他们的童年能够真正的快乐和健康。每天晚上看着儿子和女儿两个小家伙开心的在床上蹦蹦跳跳的，觉得很知足。希望下一代能够不要再经历我们这一代的不幸。一代总比一代好。他们有着这么好的资源和生活条件，远比我们小时候幸福的多。</li></ul><h4 id="4-遵从自己得内心"><a href="#4-遵从自己得内心" class="headerlink" title="4. 遵从自己得内心"></a>4. 遵从自己得内心</h4><p>人到中年，就会越发感慨，见了许多的离别与生死。身边许多小时候的亲人一个接一个的走掉，人难免都会到达终点，开始思考人生的意义。人活着到底为了什么，怎么样活才能不白活一辈子。难得世上走一回，我觉得更应该要遵从自己的内心，活给自己看，自己活得开心才是最重要，整日的带着面具活着才是最没有意义的。所以以后对自己小孩的要求是千万不要从政，在体制内很少能够活出自己本来的面目，从上到小可能都需要带着面具活着。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;少有人走的路&quot;&gt;&lt;a href=&quot;#少有人走的路&quot; class=&quot;headerlink&quot; title=&quot;少有人走的路&quot;&gt;&lt;/a&gt;少有人走的路&lt;/h3&gt;&lt;p&gt;最近自己一直在看关于心理方面和社会方面的书，越来越感慨好自己以往的过失与浪费生命。越来越想针对自身的错误来分析自身。&lt;br&gt;总结一下自己所犯的错误的原因如下：&lt;/p&gt;&lt;h4 id=&quot;1-缺乏目标&quot;&gt;&lt;a href=&quot;#1-缺乏目标&quot; class=&quot;headerlink&quot; title=&quot;1.缺乏目标&quot;&gt;&lt;/a&gt;1.缺乏目标&lt;/h4&gt;&lt;p&gt;感慨自身缺乏目标的有内在的原因也有外在的原因。正是因为却反目标得人生导致了现在被动得自己，自己正所谓得随波逐流，本质上就是昏昏耗耗，其实许多周围人也不见得在这个问题上比自己做的更好，因为毕竟“现世太辛苦和匆忙”，能有时间和精力把健康、家庭、工作都兼顾好都已经非常不容易了，哪里还顾得上更远大得追求，所谓得人生活着得意义这种虚无缥缈得问题，更是少有人去思考。当然人类在进化过程中，进喜欢深度思考和做决策，毕竟深度思考和做决策都需要耗费极大的精力，承担极大的责任，冒着极大的风险，这是本身就是人类进化的结果导致，毕竟现世生活中越操心的人老的越快，反而那些什么都不思考的人活得最长寿。人类进化过程中少部分精英能够有极大的耐心，从内部打破这种依赖，深度去思考世界，思考社会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生感悟" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="《少有人走得路》" scheme="http://yoursite.com/tags/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E5%BE%97%E8%B7%AF%E3%80%8B/"/>
    
  </entry>
  
</feed>
