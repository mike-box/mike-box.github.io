<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>no one will be your god, your god is just yourself!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-30T06:48:16.264Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Leetcode】 204周周赛</title>
    <link href="http://yoursite.com/2020/08/30/196/"/>
    <id>http://yoursite.com/2020/08/30/196/</id>
    <published>2020-08-30T06:48:11.630Z</published>
    <updated>2020-08-30T06:48:16.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="204场周赛"><a href="#204场周赛" class="headerlink" title="204场周赛"></a>204场周赛</h1><p>周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png" alt="1"></p><h2 id="5499-重复至少-K-次且长度为-M-的模式"><a href="#5499-重复至少-K-次且长度为-M-的模式" class="headerlink" title="5499. 重复至少 K 次且长度为 M 的模式"></a>5499. 重复至少 K 次且长度为 M 的模式</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个正整数数组 <code>arr</code>，请你找出一个长度为<code>m</code>且在数组中至少重复<code>k</code>次的模式。</p><a id="more"></a><p>模式 是由一个或多个值组成的子数组（连续的子序列），连续 重复多次但 不重叠 。 模式由其长度和重复次数定义。</p><p>如果数组中存在至少重复 <code>k</code> 次且长度为<code>m</code>的模式，则返回 <code>true</code>，否则返回  <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>], m = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">4</span>) 的长度为 <span class="number">1</span> ，且连续重复 <span class="number">4</span> 次。注意，模式可以重复 k 次或更多次，但不能少于 k 次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，且连续重复 <span class="number">2</span> 次。另一个符合题意的模式是 (<span class="number">2</span>,<span class="number">1</span>) ，同样重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 长度为 <span class="number">2</span> ，但是只连续重复 <span class="number">2</span> 次。不存在长度为 <span class="number">2</span> 且至少重复 <span class="number">3</span> 次的模式。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：模式 (<span class="number">1</span>,<span class="number">2</span>) 出现 <span class="number">2</span> 次但并不连续，所以不能算作连续重复 <span class="number">2</span> 次。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：长度为 <span class="number">2</span> 的模式只有 (<span class="number">2</span>,<span class="number">2</span>) ，但是只连续重复 <span class="number">2</span> 次。注意，不能计算重叠的重复次数。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 100</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>2 &lt;= k &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目比较坑，直接暴力三重循环搞定，就是太容易出错了。第一题就搞了20分钟，意外的蛋疼。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsPattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span> &amp;&amp; m &lt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+m*k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+m; j &lt; i+m*k; j = j + m)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j + m; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[k] != arr[i+k-j])&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!valid) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5500-乘积为正数的最长子数组长度"><a href="#5500-乘积为正数的最长子数组长度" class="headerlink" title="5500. 乘积为正数的最长子数组长度"></a>5500. 乘积为正数的最长子数组长度</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你求出乘积为正数的最长子数组的长度。</p><p>一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。</p><p>请你返回乘积为正数的最长子数组长度。</p><p>示例  1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：数组本身乘积就是正数，值为 <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：最长乘积为正数的子数组为 [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>] ，乘积为 <span class="number">6</span> 。</span><br><span class="line">注意，我们不能把 <span class="number">0</span> 也包括到子数组中，因为这样乘积为 <span class="number">0</span> ，不是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：乘积为正数的最长子数组是 [<span class="number">-1</span>,<span class="number">-2</span>] 或者 [<span class="number">-2</span>,<span class="number">-3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">-6</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学数学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>记录当前整数和负数的统计个数和第一次出现负数的位置，<code>posnum</code>和<code>negnum</code>。遇到整数是<code>posnum+1</code>,遇到负数时<code>negnum+1</code>.</li><li>假设当前的数不为<code>0</code>,如果当前统计负数的个数为偶数，以当前数为结尾的最长长度为$posnum+negnum$;如果当前统计负数的个数为奇数，则我们应当从第一个负数后面开始计算长度，以当前数为结尾的最长长度为$i-firstneg$。</li><li>如果当前的数为<code>0</code>，则我们将<code>posnum</code>和<code>negnum</code>、<code>firstneg</code>全部置为初始状态。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMaxLen</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> neg = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> first_neg = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                pos += nums[i] &gt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                neg += nums[i] &lt; <span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(neg%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,pos + neg);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(first_neg &gt;= <span class="number">0</span>) ans = max(ans,i-first_neg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(first_neg &lt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) first_neg = i;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                pos  = <span class="number">0</span>;</span><br><span class="line">                neg  = <span class="number">0</span>;</span><br><span class="line">                first_neg = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5501-使陆地分离的最少天数"><a href="#5501-使陆地分离的最少天数" class="headerlink" title="5501. 使陆地分离的最少天数"></a>5501. 使陆地分离的最少天数</h2><p>给你一个由若干 <code>0</code> 和 <code>1</code>组成的二维网格 <code>grid</code>，其中 <code>0</code>表示水，而<code>1</code>表示陆地。岛屿由水平方向或竖直方向上相邻的 <code>1</code> （陆地）连接形成。</p><p>如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。</p><p>一天内，可以将任何单个陆地单元<code>（1）</code>更改为水单元<code>（0）</code>。</p><p>返回使陆地分离的最少天数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/1926_island.png" alt="2"><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少需要 2 天才能得到分离的陆地。</span><br><span class="line">将陆地 grid[<span class="string">1</span>][<span class="symbol">1</span>] 和 grid[<span class="string">0</span>][<span class="symbol">2</span>] 更改为水，得到两个分离的岛屿。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果网格中都是水，也认为是分离的 (<span class="string">[[1,1]]</span> -&gt; <span class="string">[[0,0]]</span>)，<span class="number">0</span> 岛屿。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 30</code></li><li><code>grid[i][j]</code>为 <code>0</code>或 <code>1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这题在比赛的时候没有做出来，最后看了答案感觉好简单，还是思路不对。</li><li>首先如果题目中的岛屿的数目不为<code>1</code>，则直接返回<code>0</code>即可。其次按照实际的情况下，我们最多只需要去掉<code>2</code>个单元，一定能够使得岛屿进行分离。我们查看岛屿是否存在关键节点，如果存在关键节点，如果存在关键节点，则只需要去掉一个单元即可。</li><li>检查关键节点的方法有很多，比如可以使用<code>tarjan</code>查找强连通分量或者直接暴力即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirx[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> diry[] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; copy;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(copy[i][j] == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">        copy[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + dirx[k] &gt;= <span class="number">0</span> &amp;&amp; i + dirx[k] &lt; n &amp;&amp;  j + diry[k] &gt;= <span class="number">0</span> &amp;&amp; j + diry[k] &lt; m)&#123;</span><br><span class="line">                dfs(i + dirx[k],j + diry[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        copy = grid;</span><br><span class="line">        <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(copy[i][j] != <span class="number">0</span>) ct++,dfs(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ct &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                copy = grid;</span><br><span class="line">                copy[i][j] = <span class="number">0</span>;</span><br><span class="line">                ct = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;m;l++)&#123;</span><br><span class="line">                         <span class="keyword">if</span>(copy[k][l] != <span class="number">0</span>) ct++,dfs(k,l);                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ct &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p, sz, dfn, low;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++idx;</span><br><span class="line">        <span class="keyword">int</span> children = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : adj[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                children++;</span><br><span class="line">                tarjan(v, u);</span><br><span class="line">                low[u] = min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">-1</span> &amp;&amp; children &gt;= <span class="number">2</span>)</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dfn[u])</span><br><span class="line">                    found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (v != p)</span><br><span class="line">                low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[u] == u ? u : p[u] = find(p[u]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pu = find(u), pv = find(v);</span><br><span class="line">        <span class="keyword">if</span> (pu == pv)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sz[pu] &gt;= sz[pv]) &#123;</span><br><span class="line">            p[pv] = pu;</span><br><span class="line">            sz[pu] += sz[pv];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p[pu] = pv;</span><br><span class="line">            sz[pv] += sz[pu];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> N = n * m;</span><br><span class="line">        p = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">-1</span>);</span><br><span class="line">        sz = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> ans = N;</span><br><span class="line">        adj = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!grid[i][j])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> u = i * m + j;</span><br><span class="line">                <span class="keyword">if</span> (p[u] == <span class="number">-1</span>)</span><br><span class="line">                    p[u] = u;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> ni = i + dy[k], nj = j + dx[k];</span><br><span class="line">                    <span class="keyword">if</span> (ni &lt; <span class="number">0</span> || ni &gt;= n || nj &lt; <span class="number">0</span> || nj &gt;= m || !grid[ni][nj])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = ni * m + nj;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (p[v] == <span class="number">-1</span>)</span><br><span class="line">                        p[v] = v;</span><br><span class="line">                    connect(u, v);</span><br><span class="line">                    adj[u].emplace_back(v);</span><br><span class="line">                    adj[v].emplace_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">                ans = min(ans, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> components = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span> &amp;&amp; i == find(i))</span><br><span class="line">                components++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (components &gt;= <span class="number">2</span> || components == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                dfn = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                low = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N);</span><br><span class="line">                tarjan(i, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> found ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5502-将子数组重新排序得到同一个二叉查找树的方案数"><a href="#5502-将子数组重新排序得到同一个二叉查找树的方案数" class="headerlink" title="5502. 将子数组重新排序得到同一个二叉查找树的方案数"></a>5502. 将子数组重新排序得到同一个二叉查找树的方案数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组<code>nums</code>表示 <code>1</code> 到 <code>n</code>的一个排列。我们按照元素在 <code>nums</code>中的顺序依次插入一个初始为空的二叉查找树（<code>BST</code>）。请你统计将 <code>nums</code> 重新排序后，统计满足如下条件的方案数：重排后得到的二叉查找树与 <code>nums</code> 原本数字顺序得到的二叉查找树相同。</p><p>比方说，给你 <code>nums = [2,1,3]</code>，我们得到一棵 <code>2</code>为根，<code>1</code> 为左孩子，<code>3</code> 为右孩子的树。数组 <code>[2,3,1]</code> 也能得到相同的 <code>BST</code>，但<code>[3,2,1]</code>会得到一棵不同的 <code>BST</code> 。</p><p>请你返回重排<code>nums</code> 后，与原数组 <code>nums</code>得到相同二叉查找树的方案数。</p><p>由于答案可能会很大，请将结果对 <code>10^9 + 7</code>取余数。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/bb.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：我们将 nums 重排， [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>] 能得到相同的 BST 。没有其他得到相同 BST 的方案了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex1.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：下面 <span class="number">5</span> 个数组会得到相同的 BST：</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/ex4.png" alt="4"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有别的排列顺序能得到相同的 BST 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/30/abc.png" alt="5"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">19</span></span><br></pre></td></tr></table></figure><br>示例  5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">14</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">18</span>]</span><br><span class="line">输出：<span class="number">216212978</span></span><br><span class="line">解释：得到相同 BST 的方案数是 <span class="number">3216212999</span>。将它对 <span class="number">10</span>^<span class="number">9</span> + <span class="number">7</span> 取余后得到 <span class="number">216212978</span>。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>1 &lt;= nums[i] &lt;= nums.length</code></li><li><code>nums</code> 中所有数 互不相同 。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-reorder-array-to-get-same-bst</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>排列组合加递归</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目出的相当好，难度适中，有一定的思考技巧，并且特别有意思。考察基本的数学知识。</li><li>首先我们发现题意的本身要对<code>BST</code>的基本知识要有所了解，对于<code>BST</code>的插入操作时，即每次比根节点大，则插入到节点的右子树，如果比根节点小则插入到节点的左子树。我们知道如果保持根节点不变，且保证左右子树的相对前后顺序，右子树的相对顺序即比根节点大的元素的插入排序是相对固定的，左子树的相对顺序即比根节点小的元素的插入排序是相对固定的，并且保证根节点的值不变，在保证这三个条件的前提下，不同的插入序列一定保证能够得到相同的<code>BST</code>.我们设左子树的节点个数为<code>left</code>,右子树的节点个数为<code>right</code>，即为基本的排列组合，从<code>left+right</code>个位置中选出<code>left</code>个位置放置左子树的节点，则相应的总的排序个数按照排列组合应该为:<script type="math/tex; mode=display">num = C_{left+right}^{left}</script></li><li>我们知道<code>2</code>的基本理论后，下面的推论就很方便。我们仔细思考下，左右子树是否存在相同的情况？左子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合，右子树的节点也保证其根节点不变，也利用<code>2</code>的理论其插入排序也应该有很多种排列组合。根据<code>3</code>的推论，则我们总的节点的排序数应该为:<script type="math/tex; mode=display">F(tree) = C_{left+right}^{left}*F(leftTree)*F(rightTree)</script></li><li>我们用<code>DFS</code>递归，按照<code>3</code>的排列组合理论，很快就可以求出来总的个数，最后将总的个数减去<code>1</code>即为所求。最终的解法总是非常的简洁和优美，如果自己写代码写的很复杂，可能是自己思考错了。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> C[<span class="number">1002</span>][<span class="number">1002</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">                left.push_back(nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right.push_back(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = left.size();</span><br><span class="line">        <span class="keyword">int</span> r = right.size();</span><br><span class="line">        <span class="keyword">return</span> ((C[l+r][r]*dfs(left))%mod*dfs(right))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">memset</span>(C,<span class="number">0</span>,<span class="keyword">sizeof</span>(C));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            C[j][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = j+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>)</span><br><span class="line">                   C[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                   C[i][j] = (C[i<span class="number">-1</span>][j<span class="number">-1</span>] + C[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">            &#125; <span class="comment">// 计算Cmn</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(nums) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;204场周赛&quot;&gt;&lt;a href=&quot;#204场周赛&quot; class=&quot;headerlink&quot; title=&quot;204场周赛&quot;&gt;&lt;/a&gt;204场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，本周的周赛题目还是挺难的。特别时最蛋疼的第一题，花了20分钟才把细节搞定。最后一题还是稍微有点坑，第三题毫无思路，直接放弃了，最终排名竟然意外的200名以内。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200830134750.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5499-重复至少-K-次且长度为-M-的模式&quot;&gt;&lt;a href=&quot;#5499-重复至少-K-次且长度为-M-的模式&quot; class=&quot;headerlink&quot; title=&quot;5499. 重复至少 K 次且长度为 M 的模式&quot;&gt;&lt;/a&gt;5499. 重复至少 K 次且长度为 M 的模式&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个正整数数组 &lt;code&gt;arr&lt;/code&gt;，请你找出一个长度为&lt;code&gt;m&lt;/code&gt;且在数组中至少重复&lt;code&gt;k&lt;/code&gt;次的模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Google Kickstart】 2020 roundE</title>
    <link href="http://yoursite.com/2020/08/27/195/"/>
    <id>http://yoursite.com/2020/08/27/195/</id>
    <published>2020-08-27T05:52:13.942Z</published>
    <updated>2020-08-27T05:52:20.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="google-kickstart-2020-roundE"><a href="#google-kickstart-2020-roundE" class="headerlink" title="google kickstart 2020 roundE"></a>google kickstart 2020 roundE</h1><p>类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。<code>google kickstart</code>的比赛界面不是特别友好，不如<code>leetcode</code>那么人性化，但是题目质量非常高。</p><a id="more"></a><h2 id="Longest-Arithmetic"><a href="#Longest-Arithmetic" class="headerlink" title="Longest Arithmetic"></a>Longest Arithmetic</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>An arithmetic array is an array that contains at least two integers and the differences between consecutive integers are equal. For example, [9, 10], [3, 3, 3], and [9, 7, 5, 3] are arithmetic arrays, while [1, 3, 3, 7], [2, 1, 2], and [1, 2, 4] are not arithmetic arrays.</p><p>Sarasvati has an array of N non-negative integers. The i-th integer of the array is Ai. She wants to choose a contiguous arithmetic subarray from her array that has the maximum length. Please help her to determine the length of the longest contiguous arithmetic subarray.</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. The second line contains N integers. The i-th integer is Ai.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the length of the longest contiguous arithmetic subarray.</p><p><strong>Limits</strong></p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li><p>0 ≤ Ai ≤ 109.</p></li><li><p>Test Set 1<br>2 ≤ N ≤ 2000.</p></li><li><p>Test Set 2<br>2 ≤ N ≤ 2 × 105 for at most 10 test cases.<br>For the remaining cases, 2 ≤ N ≤ 2000.</p></li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Input </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Output</span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">4</span></span><br><span class="line">Case #<span class="number">3</span>: <span class="number">3</span></span><br><span class="line">Case #<span class="number">4</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed" target="_blank" rel="noopener">https://codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bf4ed</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求连续子数组为等差数列的最长长度。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>求连续子数组为等差数列的最长长度。这个题目基本上<code>leetcode</code> easy级别的水平题目。差不多10行代码搞定。</li><li>主要判断以下条件即可<script type="math/tex; mode=display">arr[i] - arr[i-1] == arr[i-1] - arr[i-2]</script>如果满足以上条件则便是当前元素可以和前两个元素构成等差序列。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        arr.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) == (arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="High-Buildings"><a href="#High-Buildings" class="headerlink" title="High Buildings"></a>High Buildings</h3><p><strong>Problem</strong><br>in an unspecified country, Google has an office campus consisting of N office buildings in a line, numbered from 1 to N from left to right. When represented in meters, the height of each building is an integer between 1 to N, inclusive.</p><p>Andre and Sule are two Google employees working in this campus. On their lunch break, they wanted to see the skyline of the campus they are working in. Therefore, Andre went to the leftmost point of the campus (to the left of building 1), looking towards the rightmost point of the campus (to the right of building N). Similarly, Sule went to the rightmost point of the campus, looking towards the leftmost point of the campus.</p><p>To Andre, a building x is visible if and only if there is no building to the left of building x that is strictly higher than building x. Similarly, to Sule, a building x is visible if and only if there is no building to the right of building x that is strictly higher than building x.</p><p>Andre learned that there are A buildings that are visible to him, while Sule learned that there are B buildings that are visible to him. After they regrouped and exchanged information, they also learned that there are C buildings that are visible to both of them.</p><p>They are wondering about the height of each building. They are giving you the value of N, A, B, and C for your information. As their friend, you would like to construct a possible height for each building such that the information learned on the previous paragraph is correct, or indicate that there is no possible height construction that matches the information learned (thus at least one of them must have been mistaken).</p><p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each consists of a single line with four integers N, A, B, and C: the information given by Andre and Sule.</p><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is IMPOSSIBLE if there is no possible height for each building according to the above information, or N space-separated integers otherwise. The i-th integer in y must be the height of the i-th building (in meters) between 1 to N.</p><p>Limits</p><ul><li>Time limit: 20 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ C ≤ N.</li><li>C ≤ A ≤ N.</li><li><p>C ≤ B ≤ N.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 5.</li><li>Test Set 2</li><li>1 ≤ N ≤ 100.</li></ul><p>Sample<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">4</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line">Case #<span class="number">2</span>: IMPOSSIBLE</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">5</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学奥数问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂实际是非常简单的一道类似于小学奥数的题目。<code>Andre</code>在最左侧只能看到严格非递减的楼栋，<code>Sule</code>只能在最右侧看到严格非递减的楼栋，<code>Andre</code>看到的的楼栋的数目为A,<code>Sule</code>看到的建筑的数目为<code>B</code>,两人共同看到的建筑数目为<code>C</code>.题目要求给出符合条件的<code>n</code>个建筑的高度。</li><li>首先我们检测有哪些不符合的情况，整个建筑的数目为<code>n</code>.两人共同看到的数目<code>c</code>肯定为<code>n</code>个建筑中最高的建筑。因此我们首先判断这种情况不可能:<script type="math/tex; mode=display">A + B - C > N</script>因为<code>Andre</code>看到了A个建筑其中包括了<code>C</code>个最高的建筑，同样<code>Sule</code>也看到了<code>B</code>个建筑，也包括了<code>C</code>个最高的建筑。<br>另一种情况，也需要讨论，当<code>A == C</code>且<code>B == C</code>时，这时表示Andre和Sule都只看到了最高的建筑数目<code>C</code>,表示有<code>C</code>个相同高度且最高的建筑。假如当<code>N</code>为<code>1</code>时，则此时C == 1符合条件。假如<code>N &gt; 2</code>时，则此时必须满足第<code>1</code>个建筑和第<code>N</code>个建筑都为最高高度才可以，否则则不可能出现<code>A == C</code>且<code>B == C</code>，因为肯定会有次矮的建筑被看到。</li></ol></blockquote><ol><li>我们再来构建即可，我们直接<code>Andre</code>看到了A个建筑，其中包含C个建筑为最高高度<code>x</code>，次高的建筑数目为<code>A-C</code>个；我们知道<code>Sule</code>看到了B个建筑，其中包含C个建筑为最高高度，次高的建筑数目为<code>B-C</code>个；剩余<code>Andre</code>和<code>Sule</code>未看到的建筑数目为<code>N-A-B+C</code>.我们直接令建筑的组成如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200826174654.png" alt="1"></li><li>我们仔细思考一下3的解法，实际有问题，当<code>A == C或者B == C</code>或者 <code>N == 2</code>时上面的建筑的高度分布就有问题，需要重新思考排列方式。因此我们应该分为几种情况来排列即可。</li></ol><ul><li>当<code>A == C 或者 C &gt;= 2</code>时，则我们优先在左侧放置最高高度的建筑。我们优先放置高度为<code>1</code>的建筑可能会被看到。</li><li>当<code>C == 1 或者 B == C</code>时，则我们优先在右侧放置最高高度的建筑。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">bool</span> isPossible = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;t&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">    <span class="keyword">if</span>(a+b-c&gt;n || a &lt; c || b &lt; c)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == c &amp;&amp; b == c &amp;&amp; c &lt; min(n,<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"IMPOSSIBLE"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d = n - a - b + c;</span><br><span class="line">    <span class="keyword">if</span>(c &gt;= <span class="number">2</span> || a == c)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;<span class="comment">//left</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b-c; ++i)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        slove(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Toys"><a href="#Toys" class="headerlink" title="Toys"></a>Toys</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><strong>Problem</strong><br>Little Axel has N toys numbered from 1 to N. Each toy has two properties:</p><ul><li><strong>Ei—enjoyment</strong>, which is the number of minutes Axel can play with toy number i without getting bored with it;</li><li><strong>Ri—remembrance</strong>, which is the number of minutes it takes Axel to forget toy number i after having played with it.<br>The toys are arranged in a circle, from 1 to N clockwise. Axel plays with them one by one.</li></ul><p>When Axel reaches toy i which he has not played with yet, or which he has already forgotten about, he plays with it for Ei minutes and then immediately moves to the next one (clockwise).</p><p>If he reaches a toy that he has not forgotten yet (if less than Ri minutes have passed since the last time he finished playing with it), he will stop and cry.</p><p>We can define the time Axel spent playing as the sum of Ei of every toy Axel played with before stopping. If Axel played with a toy several times, it should be counted that many times.</p><p>Given the description of the toys, remove the smallest possible number of them in order to make Axel play either an indefinitely long time, or (if that is not possible) as long as possible before he stops.</p><p>Note:</p><ul><li>Axel has never played with these toys before;</li><li>he cannot be left without toys;</li><li>he always starts with the toy that has the smallest number;</li><li>after finishing playing with the toy that has the largest number, he + will move to the toy that has the smallest number.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow. Each test case begins with a line containing the integer N. Next N lines contain 2 integers each: Ei and Ri. The i-th line is describing the toy number i.</li></ul><p><strong>Output</strong><br>For each test case, output one line containing Case #x: y z, where:</p><p>x is the test case number (starting from 1);<br>y is the minimal number of toys to remove so that Axel could play with the rest of them either indefinitely or as long as possible;<br>z is the longest time Axel will play in minutes or “INDEFINITELY” (without quotes) if he will play indefinitely long time.<br><strong>Limits</strong></p><ul><li>Time limit: 30 seconds per test set.</li><li>Memory limit: 1GB.</li><li>1 ≤ T ≤ 100.</li><li>1 ≤ Ei ≤ 109.</li><li><p>1 ≤ Ri ≤ 109.</p></li><li><p>Test Set 1</p></li><li>1 ≤ N ≤ 12.</li><li>Test Set 2</li><li>1 ≤ N ≤ 105.</li></ul><p>Sample<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line"> </span><br><span class="line">Output</span><br><span class="line"> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">30</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">Case #<span class="number">1</span>: <span class="number">0</span> <span class="number">5</span></span><br><span class="line">Case #<span class="number">2</span>: <span class="number">0</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">3</span>: <span class="number">1</span> INDEFINITELY</span><br><span class="line">Case #<span class="number">4</span>: <span class="number">0</span> <span class="number">25</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//codingcompetitions.withgoogle.com/kickstart/round/000000000019ff47/00000000003bede9</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   优先级队列</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 一圈玩具，题目给出了每个玩具的把玩时间和冷却时间，冷却时间即为下一次玩耍该玩具时必须等待的时间，题目要求可以移走部分玩具，求最长可以玩耍游戏的时间是多少。</span><br><span class="line"><span class="number">2.</span> 我们首先分析一下，假设只有`<span class="number">1</span>`个玩具，该玩具的$E_&#123;i&#125; &gt;= R_&#123;i&#125;$,则表示`Axel`可以一直玩该玩具，否则他最多只能玩一次该玩具后，必须等待冷却时间才可以。</span><br><span class="line">由此，我们首先求出第$n (n&gt; <span class="number">1</span>)$次玩第`i`个玩具的等待时间为：</span><br><span class="line">$$W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125;$$</span><br><span class="line">我们必须满足它的等待时间刚好大于或者等于它的冷却时间，则它刚好可以接着玩该玩具。</span><br><span class="line">$$</span><br><span class="line">W_&#123;i&#125; = \sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; - E_&#123;i&#125; \ge R_&#123;i&#125; \\</span><br><span class="line">\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;</span><br><span class="line">$$</span><br><span class="line">即该玩具的冷却时间和玩耍时间之和必须小于等于所有玩具的玩耍时间之和，首先需要把这类玩具去掉。</span><br><span class="line"><span class="number">3.</span> 我们不断更新，如果出现剩余的所有的玩具都满足</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125; $$</span><br><span class="line">则这时表示剩下的玩具可以无限玩，直接返回`INDEFINITELY`即可。</span><br><span class="line"><span class="number">4.</span> 如果不能满足出现`INDEFINITELY`，则我们求出剩余的去除部分玩具的可玩的最大时间。首先我们可以肯定所有的玩具都不会被玩三次，如果该玩具被连续玩了三次，则表示 所有的玩具都被玩了两次，则该部分玩具可以被无限的玩`n`次。</span><br><span class="line"><span class="number">5.</span> 首先我们看到假如一个玩具都不会被删除，则在第一次时，所有的玩具都会被玩一次，在第二圈时，可能部分玩具能够被再玩耍一次。</span><br><span class="line"><span class="number">6.</span> 我们首先将所有的玩具按照顺序，依次加入到可玩的优先级序列中，如果发现有玩具`i`出现条件：g</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \le R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">则这时我们认为第`i`个玩具肯定不能加入到队列中，次吃我们将所有玩具的等待时间减去$E_&#123;i&#125;$,此时我们更新队列,同时判断队列中的元素是否都符合可以玩第二次的条件。</span><br><span class="line">$$\sum_&#123;k=<span class="number">1</span>&#125;^&#123;n&#125;E_&#123;k&#125; \ge R_&#123;i&#125; + E_&#123;i&#125;$$</span><br><span class="line">如果发现不符合，则将其从队列中剔除掉。如果第`i`个玩具符合条件，则将其加入到待选队列中。</span><br><span class="line"><span class="number">7.</span>总的来说该题目还是非常经典。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> cmp(pii &amp; a, pii &amp; b)&#123;</span><br><span class="line">    <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct cmp1&#123;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>()(pii &amp; a,pii &amp;b)&#123;</span><br><span class="line">        <span class="built_in">if</span>(a.first == b.first) </span><br><span class="line">            <span class="built_in">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="built_in">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> slove()&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; enjoy;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; remembrance;</span><br><span class="line">    vector&lt;pii&gt; arr;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> e,r;</span><br><span class="line">        cin&gt;&gt;e&gt;&gt;r;</span><br><span class="line">        enjoy.emplace_back(e);</span><br><span class="line">        remembrance.emplace_back(r);</span><br><span class="line">        arr.emplace_back(make_pair(e+r,i));</span><br><span class="line">        total += e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*count the array*/</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = total;</span><br><span class="line">    sort(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(arr[i].first &gt; sum)&#123;</span><br><span class="line">            sum -= enjoy[arr[i].second];</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;n-i<span class="number">-1</span>&lt;&lt;<span class="string">" INDEFINITELY"</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;pii,vector&lt;pii&gt;,cmp1&gt; pq;</span><br><span class="line">    sum = total;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_val = total;</span><br><span class="line">    <span class="keyword">int</span> min_del = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cdel = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cval = total;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">if</span>(enjoy[i] + remembrance[i] &lt;= sum)&#123;</span><br><span class="line">            pq.push(make_pair(enjoy[i] + remembrance[i],i));</span><br><span class="line">            cval += enjoy[i];</span><br><span class="line">            <span class="built_in">if</span>(cval &gt; max_val)&#123;</span><br><span class="line">                max_val = cval;</span><br><span class="line">                min_del = cdel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="built_in">else</span>&#123;</span><br><span class="line">           sum -= enjoy[i];</span><br><span class="line">           cval -= enjoy[i];</span><br><span class="line">           cdel++;</span><br><span class="line">           <span class="built_in">while</span>(!pq.empty() &amp;&amp; pq.top().first &gt; sum)&#123;</span><br><span class="line">               <span class="keyword">int</span> x = pq.top().second;</span><br><span class="line">               pq.pop();</span><br><span class="line">               sum -= enjoy[x];</span><br><span class="line">               cval -= <span class="number">2</span>*enjoy[x];</span><br><span class="line">               cdel--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;min_del&lt;&lt;<span class="string">" "</span>&lt;&lt;max_val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="built_in">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">"Case #"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">": "</span>;</span><br><span class="line">        slove();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;google-kickstart-2020-roundE&quot;&gt;&lt;a href=&quot;#google-kickstart-2020-roundE&quot; class=&quot;headerlink&quot; title=&quot;google kickstart 2020 roundE&quot;&gt;&lt;/a&gt;google kickstart 2020 roundE&lt;/h1&gt;&lt;p&gt;类似于google的在线笔试题目，题目难度还是非常不错的，前三题似乎都不是特别难，最后一题确实有难度。也就现在的水平还能勉强做出来前三题，以前的自己肯定水的一比，放在6年前估计一题都做不出来。经常做算法题还是有好处的，至少思考能力能够提升到一定水平。&lt;code&gt;google kickstart&lt;/code&gt;的比赛界面不是特别友好，不如&lt;code&gt;leetcode&lt;/code&gt;那么人性化，但是题目质量非常高。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="google kickstart" scheme="http://yoursite.com/tags/google-kickstart/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 203周周赛</title>
    <link href="http://yoursite.com/2020/08/23/194/"/>
    <id>http://yoursite.com/2020/08/23/194/</id>
    <published>2020-08-23T09:00:11.295Z</published>
    <updated>2020-08-23T09:36:44.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="203场周赛"><a href="#203场周赛" class="headerlink" title="203场周赛"></a>203场周赛</h1><p>周赛的题目质量确实要高一些，双周赛的题目简单太多了。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png" alt="1"></p><h2 id="5495-圆形赛道上经过次数最多的扇区"><a href="#5495-圆形赛道上经过次数最多的扇区" class="headerlink" title="5495. 圆形赛道上经过次数最多的扇区"></a>5495. 圆形赛道上经过次数最多的扇区</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code> 和一个整数数组 <code>rounds</code> 。有一条圆形赛道由 <code>n</code>个扇区组成，扇区编号从 <code>1</code> 到 <code>n</code> 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 <code>m</code>个阶段组成。其中，第 i 个阶段将会从扇区 <code>rounds[i - 1]</code> 开始，到扇区 <code>rounds[i]</code>结束。举例来说，第 1 阶段从 <code>rounds[0]</code> 开始，到<code>rounds[1]</code>结束。</p><a id="more"></a><p>请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 升序 排列。</p><p>注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。</p><p>示例 1：</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823154505.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">解释：本场马拉松比赛从扇区 <span class="number">1</span> 开始。经过各个扇区的次序如下所示：</span><br><span class="line"><span class="number">1</span> --&gt; <span class="number">2</span> --&gt; <span class="number">3</span>（阶段 <span class="number">1</span> 结束）--&gt; <span class="number">4</span> --&gt; <span class="number">1</span>（阶段 <span class="number">2</span> 结束）--&gt; <span class="number">2</span>（阶段 <span class="number">3</span> 结束，即本场马拉松结束）</span><br><span class="line">其中，扇区 <span class="number">1</span> 和 <span class="number">2</span> 都经过了两次，它们是经过次数最多的两个扇区。扇区 <span class="number">3</span> 和 <span class="number">4</span> 都只经过了一次。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, rounds = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, rounds = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 100</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>rounds.length == m + 1</code></li><li><code>1 &lt;= rounds[i] &lt;= n</code></li><li><code>rounds[i] != rounds[i + 1] ，其中 0 &lt;= i &lt; m.</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track" target="_blank" rel="noopener">https://leetcode-cn.com/problems/most-visited-sector-in-a-circular-track</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力循环</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>题目描述过于复杂，但实际非常简单，主要是循环数组的处理。</li><li>循环统计每个扇区的通过次数，然后取统计次数的最大值即可。题目可以再增加难度，比如赛道通过的圈数可以为<code>n</code>圈，这样的加法处理又稍微复杂点。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mostVisited(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rounds) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> maxV = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size(); ++i)&#123;</span><br><span class="line">            rounds[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rounds.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rounds[i]; j != rounds[i+<span class="number">1</span>] ; j = (j + <span class="number">1</span>)%n)&#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[rounds.back()]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            maxV = max(cnt[i],maxV);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] == maxV) ans.push_back(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5496-你可以获得的最大硬币数目"><a href="#5496-你可以获得的最大硬币数目" class="headerlink" title="5496. 你可以获得的最大硬币数目"></a>5496. 你可以获得的最大硬币数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有 3n 堆数目不一的硬币，你和你的朋友们打算按以下方式分硬币：</p><p>每一轮中，你将会选出 任意<code>3</code> 堆硬币（不一定连续）。<br><code>Alice</code> 将会取走硬币数量最多的那一堆。<br>你将会取走硬币数量第二多的那一堆。<br>Bob 将会取走最后一堆。<br>重复这个过程，直到没有更多硬币。<br>给你一个整数数组 <code>piles</code>，其中 <code>piles[i]</code>是第 <code>i</code>堆中硬币的数目。</p><p>返回你可以获得的最大硬币数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：选出 (<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>) ，Alice 取走 <span class="number">8</span> 枚硬币的那堆，你取走 <span class="number">7</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">选出 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>) , Alice 取走 <span class="number">4</span> 枚硬币的那堆，你取走 <span class="number">2</span> 枚硬币的那堆，Bob 取走最后一堆。</span><br><span class="line">你可以获得的最大硬币数目：<span class="number">7</span> + <span class="number">2</span> = <span class="number">9.</span></span><br><span class="line">考虑另外一种情况，如果选出的是 (<span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>) 和 (<span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>) ，你就只能得到 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span> 枚硬币，这不是最优解。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= piles.length &lt;= 10^5</code></li><li><code>piles.length % 3 == 0</code></li><li><code>1 &lt;= piles[i] &lt;= 10^4</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-coins-you-can-get</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>如何取最大值，本质是数学问题，我们应当保证尽可能的取到最大值。首先想到的是我们对数组按照从小到大进行排列。</li><li>设数组的长度为<code>3n</code>,则每次取得索引数为$(piles[i],piles[n+2<em>i-1],piles[n+2</em>i])$,则这时</li></ol><ul><li><code>Alice</code>取得得硬币为：<br>$piles[n+2],piles[n+4],…,piles[3n]$</li><li><code>Bob</code>取得得硬币为：<br>$piles[1],piles[2],…,piles[n]$</li><li>自己取得的硬币为：<br>$piles[n+1],piles[n+3],…,piles[3n-1]$</li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="keyword">int</span> x = n/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        sort(piles.begin(),piles.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt; n; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">            ans += piles[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5497-查找大小为-M-的最新分组"><a href="#5497-查找大小为-M-的最新分组" class="headerlink" title="5497. 查找大小为 M 的最新分组"></a>5497. 查找大小为 M 的最新分组</h2><p>给你一个数组 <code>arr</code>，该数组表示一个从 <code>1</code> 到 <code>n</code>的数字排列。有一个长度为 n 的二进制字符串，该字符串上的所有位最初都设置为 0 。</p><p>在从 1 到<code>n</code> 的每个步骤 i 中（假设二进制字符串和 arr 都是从 1 开始索引的情况下），二进制字符串上位于位置<code>arr[i]</code>的位将会设为 1 。</p><p>给你一个整数<code>m</code>，请你找出二进制字符串上存在长度为 <code>m</code>的一组 1 的最后步骤。一组 1 是一个连续的、由 1 组成的子串，且左右两边不再有可以延伸的 1 。</p><p>返回存在长度 恰好 为 <code>m</code>的 一组 <code>1</code>  的最后步骤。如果不存在这样的步骤，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"00101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"11101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"111"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">存在长度为 <span class="number">1</span> 的一组 <span class="number">1</span> 的最后步骤是步骤 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：</span><br><span class="line">步骤 <span class="number">1</span>：<span class="string">"00100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">2</span>：<span class="string">"10100"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">3</span>：<span class="string">"10101"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"1"</span>, <span class="string">"1"</span>]</span><br><span class="line">步骤 <span class="number">4</span>：<span class="string">"10111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"1"</span>, <span class="string">"111"</span>]</span><br><span class="line">步骤 <span class="number">5</span>：<span class="string">"11111"</span>，由 <span class="number">1</span> 构成的组：[<span class="string">"11111"</span>]</span><br><span class="line">不管是哪一步骤都无法形成长度为 <span class="number">2</span> 的一组 <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>], m = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == arr.length</code></li><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= n</code></li><li><code>arr</code> 中的所有整数 互不相同</li><li><code>1 &lt;= m &lt;= arr.length</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-latest-group-of-size-m" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-latest-group-of-size-m</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>left[x]</code>代表从索引<code>x</code>处开始向左连续的最长<code>1</code>的数目，<code>right[x]</code>代表从索引<code>x</code>处开始向右连续的最长<code>1</code>的数目。<code>count[l]</code>代表当前状态中连续<code>1</code>的长度为<code>l</code>的统计数目。</li><li>每次将<code>x</code>位置为<code>1</code>时，则我们进行左右的连续的<code>1</code>的序列合并，这时合并的总长度为: $l = left[x-1] + 1 + right[x+1]$<br>则我们同时将该区间<code>l</code>的两端的left与right进行更新。同时将连续长度为<code>left[x-1],right[x+1]</code>的统计数目减<code>1</code>,将连续长度为<code>l</code>的统计数目加<code>1</code>.</li><li>每次更新完长度的统计数目后，如果发现长度为<code>m</code>的统计数目大于<code>0</code>，则我们认为此时存在大小为<code>m</code>的最新分组。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823171258.png" alt="3"></li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLatestStep</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = arr[i];</span><br><span class="line">            <span class="keyword">int</span> l = left[x<span class="number">-1</span>] + <span class="number">1</span> + right[x+<span class="number">1</span>];</span><br><span class="line">            left[x + right[x+<span class="number">1</span>]] = l;</span><br><span class="line">            right[x - left[x<span class="number">-1</span>]] = l;</span><br><span class="line">            count[left[x<span class="number">-1</span>]]--;</span><br><span class="line">            count[right[x+<span class="number">1</span>]]--;</span><br><span class="line">            count[l]++;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span>(count[m] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5498-石子游戏-V"><a href="#5498-石子游戏-V" class="headerlink" title="5498. 石子游戏 V"></a>5498. 石子游戏 V</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 <code>stoneValue</code> 给出。</p><p>游戏中的每一轮：<code>Alice</code> 会将这行石子分成两个 非空行（即，左侧行和右侧行）；<code>Bob</code> 负责计算每一行的值，即此行中所有石子的值的总和。<code>Bob</code>会丢弃值最大的行，<code>Alice</code>的得分为剩下那行的值（每轮累加）。如果两行的值相等，<code>Bob</code> 让 <code>Alice</code>决定丢弃哪一行。下一轮从剩下的那一行开始。</p><p>只 剩下一块石子 时，游戏结束。<code>Alice</code>的分数最初为 0 。</p><p>返回 <code>Alice</code>能够获得的最大分数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">18</span></span><br><span class="line">解释：在第一轮中，Alice 将行划分为 [<span class="number">6</span>，<span class="number">2</span>，<span class="number">3</span>]，[<span class="number">4</span>，<span class="number">5</span>，<span class="number">5</span>] 。左行的值是 <span class="number">11</span> ，右行的值是 <span class="number">14</span> 。Bob 丢弃了右行，Alice 的分数现在是 <span class="number">11</span> 。</span><br><span class="line">在第二轮中，Alice 将行分成 [<span class="number">6</span>]，[<span class="number">2</span>，<span class="number">3</span>] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 <span class="number">16</span>（<span class="number">11</span> + <span class="number">5</span>）。</span><br><span class="line">最后一轮 Alice 只能将行分成 [<span class="number">2</span>]，[<span class="number">3</span>] 。Bob 扔掉右行，Alice 的分数现在是 <span class="number">18</span>（<span class="number">16</span> + <span class="number">2</span>）。游戏结束，因为这行只剩下一块石头了。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">28</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：stoneValue = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= stoneValue.length &lt;= 500</code></li><li><code>1 &lt;= stoneValue[i] &lt;= 10^6</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-v" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-v</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs记忆化搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题其实比较简单，不过刚开始自己考虑太复杂了，首先知道是要用<code>dp</code>。但是直接推导<code>dp</code>发现时间复杂度为<code>o(n^3)</code>不太好推，后来想想干脆不如用记忆化搜索。</li><li>首先看到题目中要求数组分组并求数组的左右分组的和，这时肯定想到是要用数组的前缀和，因为利用数组的前缀和可以在<code>o(1)</code>时间复杂度内求出数组的区间的和。</li><li>我们通过<code>dfs</code>搜索区间数组<code>[l,r]</code>时，<code>Alice</code>能取得的最大值。则每次我们从<code>x</code>处断开，分别可以求得数组从<code>l</code>到<code>x</code>的和为<code>sum[l][x]</code>,数组从<code>x+1</code>到<code>r</code>的和为<code>sum[x+1][r]</code>,我们判断其大小，然后根据题意进行下一次迭代即可。</li></ol><ul><li>如果：<code>sum[l][x] &gt; sum[x+1][r]</code>,则<script type="math/tex; mode=display">dp[l][r] = max(dp[l][r],sum[x+1][r] + dp[x+1][r])</script></li><li>如过<code>sum[l][x] &lt; sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x])</script>.</li><li>如过<code>sum[l][x] = sum[x+1][r]</code>,则<br><script type="math/tex">dp[l][r] = max(dp[l][r],sum[l][x] + dp[l][x],sum[x+1][r] + dp[x+1][r])</script>.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[<span class="number">550</span>][<span class="number">550</span>];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; sum,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l][r] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">            dp[l][r] = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> lsum = sum[i] - sum[l<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> rsum = sum[r] - sum[i];</span><br><span class="line">                <span class="keyword">if</span>(lsum &gt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lsum &lt; rsum)&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[l][r] = max(dp[l][r],rsum + dfs(sum,i+<span class="number">1</span>,r));</span><br><span class="line">                    dp[l][r] = max(dp[l][r],lsum + dfs(sum,l,i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[l][r];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">stoneGameV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += stoneValue[i];</span><br><span class="line">            sum[i+<span class="number">1</span>] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dfs(sum,<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;203场周赛&quot;&gt;&lt;a href=&quot;#203场周赛&quot; class=&quot;headerlink&quot; title=&quot;203场周赛&quot;&gt;&lt;/a&gt;203场周赛&lt;/h1&gt;&lt;p&gt;周赛的题目质量确实要高一些，双周赛的题目简单太多了。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823154253.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5495-圆形赛道上经过次数最多的扇区&quot;&gt;&lt;a href=&quot;#5495-圆形赛道上经过次数最多的扇区&quot; class=&quot;headerlink&quot; title=&quot;5495. 圆形赛道上经过次数最多的扇区&quot;&gt;&lt;/a&gt;5495. 圆形赛道上经过次数最多的扇区&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; 和一个整数数组 &lt;code&gt;rounds&lt;/code&gt; 。有一条圆形赛道由 &lt;code&gt;n&lt;/code&gt;个扇区组成，扇区编号从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 &lt;code&gt;m&lt;/code&gt;个阶段组成。其中，第 i 个阶段将会从扇区 &lt;code&gt;rounds[i - 1]&lt;/code&gt; 开始，到扇区 &lt;code&gt;rounds[i]&lt;/code&gt;结束。举例来说，第 1 阶段从 &lt;code&gt;rounds[0]&lt;/code&gt; 开始，到&lt;code&gt;rounds[1]&lt;/code&gt;结束。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 33周双周赛</title>
    <link href="http://yoursite.com/2020/08/23/193/"/>
    <id>http://yoursite.com/2020/08/23/193/</id>
    <published>2020-08-23T00:40:24.315Z</published>
    <updated>2020-08-23T00:40:31.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="33场双周赛"><a href="#33场双周赛" class="headerlink" title="33场双周赛"></a>33场双周赛</h1><p>双周赛的题目都好简单，第三题卡壳了好长时间。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png" alt="1"></p><h2 id="5479-千位分隔数"><a href="#5479-千位分隔数" class="headerlink" title="5479. 千位分隔数"></a>5479. 千位分隔数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。</p><p>示例 1：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">987</span></span><br><span class="line">输出：<span class="string">"987"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">1234</span></span><br><span class="line">输出：<span class="string">"1.234"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">123456789</span></span><br><span class="line">输出："<span class="number">123.456</span>.<span class="number">789</span>"</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">0</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">0</span> &lt;= n &lt; <span class="number">2</span>^<span class="number">31</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/thousand-separator</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;   暴力</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 暴力循环即可</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> thousandSeparator(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            ans = to_string(n%<span class="number">10</span>) + ans;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; curr%<span class="number">3</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = <span class="string">"."</span> + ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="5480-可以到达所有点的最少点数目"><a href="#5480-可以到达所有点的最少点数目" class="headerlink" title="5480. 可以到达所有点的最少点数目"></a>5480. 可以到达所有点的最少点数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个 有向无环图 ， <code>n</code>个节点编号为 <code>0</code>到 <code>n-1</code> ，以及一个边数组 <code>edges</code> ，其中 <code>edges[i] = [fromi, toi]</code> 表示一条从点  <code>fromi</code>到点 <code>toi</code>的有向边。</p><p>找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。</p><p>你可以以任意顺序返回这些节点编号。</p><p>示例 1：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">3</span>]</span><br><span class="line">解释：从单个节点出发无法到达所有节点。从 <span class="number">0</span> 出发我们可以到达 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>] 。从 <span class="number">3</span> 出发我们可以到达 [<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] 。所以我们输出 [<span class="number">0</span>,<span class="number">3</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e2.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">解释：注意到节点 <span class="number">0</span>，<span class="number">3</span> 和 <span class="number">2</span> 无法从其他节点到达，所以我们必须将它们包含在结果点集中，这些点都能到达节点 <span class="number">1</span> 和 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>1 &lt;= edges.length &lt;= min(10^5, n * (n - 1) / 2)</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= fromi, toi &lt; n</code></li><li>所有点对 <code>(fromi, toi)</code> 互不相同。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本质就是找到图的入度为<code>0</code>的节点即可，这个题目应该更难点为好。太过于简单了。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findSmallestSetOfVertices(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : edges)&#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                ans.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5481-得到目标数组的最少函数调用次数"><a href="#5481-得到目标数组的最少函数调用次数" class="headerlink" title="5481. 得到目标数组的最少函数调用次数"></a>5481. 得到目标数组的最少函数调用次数</h2><p>给你一个与 nums 大小相同且初始值全为 <code>0</code>的数组 <code>arr</code> ，请你调用以上函数得到整数数组 <code>nums</code>。<br>请你返回将 <code>arr</code>变成 <code>nums</code> 的最少函数调用次数。<br>答案保证在 <code>32</code> 位有符号整数以内。<br><img src="https://assets.leetcode.com/uploads/2020/07/10/sample_2_1887.png" alt="3"></p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：给第二个数加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] 变成 [<span class="number">0</span>, <span class="number">1</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ：[<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">0</span>, <span class="number">2</span>] -&gt; [<span class="number">0</span>, <span class="number">4</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">4</span>] -&gt; [<span class="number">1</span>, <span class="number">5</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">总操作次数为：<span class="number">1</span> + <span class="number">2</span> + <span class="number">2</span> = <span class="number">5</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：给两个数字都加 <span class="number">1</span> ：[<span class="number">0</span>, <span class="number">0</span>] -&gt; [<span class="number">0</span>, <span class="number">1</span>] -&gt; [<span class="number">1</span>, <span class="number">1</span>] （<span class="number">2</span> 次操作）。</span><br><span class="line">将所有数字乘以 <span class="number">2</span> ： [<span class="number">1</span>, <span class="number">1</span>] -&gt; [<span class="number">2</span>, <span class="number">2</span>] （<span class="number">1</span> 次操作）。</span><br><span class="line">总操作次数为： <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：（初始）[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>] -&gt; [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>] （nums 数组）。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>]</span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-numbers-of-function-calls-to-make-target-array</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>对于数目乘以<code>2</code>的次数与数组中最大的数相关，所以乘以<code>2</code>的次数就等于max取<code>log</code>。</li><li>其余剩下的操作次数即为所有元素取2的模为1的次数。</li><li>这种类型的题目非常好，带有数学问题，并且带有一定的难度。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> lg = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(v &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v%<span class="number">2</span>)&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    --v;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ++t;</span><br><span class="line">                    v /= <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lg = max(lg,t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ans += lg;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5482-二维网格图中探测环"><a href="#5482-二维网格图中探测环" class="headerlink" title="5482. 二维网格图中探测环"></a>5482. 二维网格图中探测环</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个二维字符网格数组 <code>grid</code> ，大小为<code>m x n</code> ，你需要检查 <code>grid</code> 中是否存在 相同值 形成的环。</p><p>一个环是一条开始和结束于同一个格子的长度 大于等于 <code>4</code> 的路径。对于一个给定的格子，你可以移动到它上、下、左、右四个方向相邻的格子之一，可以移动的前提是这两个格子有 相同的值 。</p><p>同时，你也不能回到上一次移动时所在的格子。比方说，环 <code>(1, 1) -&gt; (1, 2) -&gt; (1, 1)</code>是不合法的，因为从 <code>(1, 2)</code> 移动到 <code>(1, 1)</code> 回到了上一次移动时的格子。</p><p>如果 grid 中有相同值形成的环，请你返回 <code>true</code>，否则返回 <code>false</code> 。</p><p>示例 1：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e1.png" alt="5"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e11.png" alt="6"><br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"b"</span>,<span class="comment">"b"</span>,<span class="comment">"a"</span>],[<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>,<span class="comment">"a"</span>]]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：如下图所示，有 <span class="number">2</span> 个用不同颜色标出来的环：</span><br></pre></td></tr></table></figure><br>示例 2：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e2.png" alt="7"><br><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e22.png" alt="8"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"a"</span>],[<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>],[<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"e"</span>,<span class="string">"c"</span>],[<span class="string">"f"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>,<span class="string">"c"</span>]]</span><br><span class="line">输出：true</span><br><span class="line">解释：如下图所示，只有高亮所示的一个合法环：</span><br></pre></td></tr></table></figure><br>示例 3：</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5482e3.png" alt="9"><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"z"</span>,<span class="string">"b"</span>],[<span class="string">"b"</span>,<span class="string">"b"</span>,<span class="string">"a"</span>]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m &lt;= 500</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>grid</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/detect-cycles-in-2d-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/detect-cycles-in-2d-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs或者BFS</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>该题非常简单，就是简单的BFS或者DFS即可。判断是否有环即可。不晓得为什么是<code>hard</code>难度。</li><li>最后一题都 <code>AC</code>600+了说明非常简单。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    Node(<span class="keyword">int</span> _x,<span class="keyword">int</span> _y,<span class="keyword">int</span> _d)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = _x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = _y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;d = _d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFrom</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">0</span> &amp;&amp; y == <span class="number">1</span>)||(x == <span class="number">1</span> &amp;&amp; y == <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((x == <span class="number">2</span> &amp;&amp; y == <span class="number">3</span>)||(x == <span class="number">3</span> &amp;&amp; y == <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsCycle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">if</span>(row &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(visit[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">char</span> c = grid[i][j];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">int</span> d = k;</span><br><span class="line">                    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                        qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                        visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">                    Node curr = qu.front();</span><br><span class="line">                    qu.pop();</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(isFrom(k,curr.d)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">int</span> x = curr.x + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = curr.y + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">int</span> d = k;</span><br><span class="line">                        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col &amp;&amp; grid[x][y] == c)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                            qu.push(&#123;x,y,d&#125;);</span><br><span class="line">                            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;33场双周赛&quot;&gt;&lt;a href=&quot;#33场双周赛&quot; class=&quot;headerlink&quot; title=&quot;33场双周赛&quot;&gt;&lt;/a&gt;33场双周赛&lt;/h1&gt;&lt;p&gt;双周赛的题目都好简单，第三题卡壳了好长时间。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200823075219.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5479-千位分隔数&quot;&gt;&lt;a href=&quot;#5479-千位分隔数&quot; class=&quot;headerlink&quot; title=&quot;5479. 千位分隔数&quot;&gt;&lt;/a&gt;5479. 千位分隔数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你每隔三位添加点（即 “.” 符号）作为千位分隔符，并将结果以字符串格式返回。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;987&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;987&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：&lt;span class=&quot;built_in&quot;&gt;n&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1234&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;1.234&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight dns&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;123456789&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&quot;&lt;span class=&quot;number&quot;&gt;123.456&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;789&lt;/span&gt;&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;``` &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ `&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;lt;= n &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;^&lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https:&lt;span class=&quot;comment&quot;&gt;//leetcode-cn.com/problems/thousand-separator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 题意&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;   暴力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 思路&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt; 暴力循环即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;```c++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; thousandSeparator(&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt; curr = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(n != &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            curr++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ans = to_string(n%&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;) + ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            n = n/&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(n &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; curr%&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                ans = &lt;span class=&quot;string&quot;&gt;&quot;.&quot;&lt;/span&gt; + ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>火与烬</title>
    <link href="http://yoursite.com/2020/08/17/192/"/>
    <id>http://yoursite.com/2020/08/17/192/</id>
    <published>2020-08-17T04:29:41.217Z</published>
    <updated>2020-08-17T04:32:27.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="火与烬"><a href="#火与烬" class="headerlink" title="火与烬"></a>火与烬</h1><p>断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。</p><ul><li>为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。</li><li>国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。</li><li>国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。</li><li>文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。</li></ul><a id="more"></a><h2 id="作者背景"><a href="#作者背景" class="headerlink" title="作者背景"></a>作者背景</h2><p>作者英文名迈克尔·伊格纳季耶夫（Michael Ignatieff），中文名叶礼庭,出身在加拿大的一个政治世家，祖父是莎皇时代的教育部长, 在 1917年俄国红色十月革命后逃往满地可, 父亲是加拿大外交官, 他的舅父是 著名 政治哲学家George Grant, 他的姨祖母Alice Massey是前加拿大总督 Vincent Massey的妻子. 家族显赫。他在多伦 多大学历史系毕业，1979年在哈佛大学取得历史博士学，曾在剑桥大学和哈佛大学任教，可以称之为西方世界的精英实至名归。作者在加拿大自由党派的领导人的劝说下，从美国返回到加拿大，后来成为加拿大自由党的党魁，而后又被党内推选为加拿大总理的候选人，参加2008年的加拿大总理竞选，而后又失败</p><h2 id="蹈火（初入政治）"><a href="#蹈火（初入政治）" class="headerlink" title="蹈火（初入政治）"></a>蹈火（初入政治）</h2><p>作者因为家族背景的原因，也是因为自身影响力的原理，从哈佛任教转回加拿大，涉入政坛。由于背景的加持，在党内快速上升，很快就成为加拿大自由党党领袖的候选人，然后第一次党内选举中落败，后来又成为党内的副领袖。200年的经济危机中，由于自由党在竞选中落败，党领袖下台，而他又以外的被推举为自由党的党魁，而又作为在野党的议员，参与行政议政，在议政过程中描写了部分与执政党的有分歧事情和他通过部分事件描述执政党总理的部分观点和看法。从他描述的部分参政议政的过程中，从而对国外的议会制的立法和行政过程有所了解。</p><h2 id="烬余（竞选中期）"><a href="#烬余（竞选中期）" class="headerlink" title="烬余（竞选中期）"></a>烬余（竞选中期）</h2><p>在竞选初期，作者作为自由党的党魁而被党内一致推举为竞选总理的候选人，但反对党借机利用媒体就作者的身份进行大肆宣传，故意丑化作者，“他来自美国，只是一个过客”，这样深入人心的标语，有意丑化候选人，很快就让叶礼庭在大选前的民调中的支持率大幅下降。而竞选过程中并没有我们从前想的那么伟大神圣，保守党主要精力放在恶意丑化对方，能够故意让对方阻挡于“竞选”之外，而并没有去刻意去向选民宣传自己得竞选理念，去争取更多得投标人得支持。自由党作为在野党弱势的一方，作者本身极为辛苦的进行全国巡演，用传统的竞选方式去宣传自己的参政纲领和理念，去与民众亲近，去各地演讲从而寻得全国各地的选民的支持，然而最终竞选结果出来后竞选失败，令作者感到难受，开始反思自己在竞选中所犯的各种错误。</p><h2 id="竞选落败回忆"><a href="#竞选落败回忆" class="headerlink" title="竞选落败回忆"></a>竞选落败回忆</h2><p>作者有句很鲜明的理论，所有的著名的政治学理论都是政治失败者所撰写的，我想只有作者这种亲身参与这样极为重要的政治活动才得出来得理论总结，作者列举了许多著名得政治理论著作，都是由一些落魄得政治失败者反思后所总结撰写得理论，“要么在台上，要么回去教书”，多么形象的比喻。作者总结出，政治这个游戏对参与者的素质要求太高，门槛太高，并不是一般的人能够玩转的。<br>他反思，理论家的独特天分在于，“不计成败的率直、缜密、意志力，以及对独创性的敏锐探寻”，但往往缺乏政界人物需要的谨慎、掩饰、党性、对时势变化的敏锐、灵活的身段、阿谀奉承的口才。尽管叶礼庭自认远远无法与西塞罗、托克维尔这些思想大师并肩，但他的长处依然是在理论研究而非政治实务上，六年从政之路虽然不后悔，但政坛确实不是他真正擅长的地方。<br>“我追求权力的火焰，看到希望逐渐减少为灰烬。”缓慢走出败选阴影的叶礼庭，终于又拿起了笔，唤回那个作为作家的自己。在《火与烬》这本书中，他平和、真诚地讲述自己经历的点点滴滴，毫不留情地分析自己的稚嫩和错误，节制地表达幻灭的痛苦，给我们留下了一份丰富而不失优雅的心灵记录。<br>不得不说，透过本书的描述，让我们对政治生活更有一份客观而又正确的看待，在政治活动中，并没有所谓的绝对的“对与错”，妥协与隐藏是政治活动中的常态，劝诫从政活动中更重要的是要坚守内心的信仰，而不是固守所有的道德准则。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;火与烬&quot;&gt;&lt;a href=&quot;#火与烬&quot; class=&quot;headerlink&quot; title=&quot;火与烬&quot;&gt;&lt;/a&gt;火与烬&lt;/h1&gt;&lt;p&gt;断断续续的才看完了这本所谓的《火与烬》这本书，最初被这本书吸引的是本书的内容的描写，相关主要内容主要描述的是哈佛的著名学者叶礼庭回到自己的故乡加拿大参加竞选总理并最终落选的历程，文中详细的描述了作者参选的过程和落选失败后得感受和历程。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;为什么当初要选这种书籍来阅读，因为在国内的一党专政的体制下，许多人对国外的民主投票政治非常向往，或者说过度神话。但是通过此书详细的描写了国外的选票政治的历程，从中可以窥见一斑，了解国外的民主政治运作方式，是一种直观的方式，虽然没有亲身过西方的选举制度，但通过本书详细的描述了加拿大竞选总理的历程，了解国外选举制度的基本知识，了解国外议会立法的基本运作方式，了解国外的行政的基本运作方式，最直观的感受，就是没有了之前那种“非黑即白”的简单是否观念。&lt;/li&gt;
&lt;li&gt;国外的民主选举制度并不是万能的，国内的一党独裁制度也并不是全部的邪恶的，两者都又它的优点和缺点，更应该客观来看，评论政治体制时，更应该客观的看待，政治制度是否与国内自身的政治背景基础匹配，是否兼顾了公平与效率？民主选举制度更注重过程的公平，而缺少对效率和结果的公平，本身也又其缺点。&lt;/li&gt;
&lt;li&gt;国内的政治制度也有其好的一面，在看到国外的选举过程中，两党之间的政治斗争也时充满腥风血雨，对于党员也要求忠诚第一，稍微不注意，党员也可能在政治斗阵中失败，而被淘汰出局，所谓书中描写的完美制度与家园，本质上也并不存在的。国外的政党也面临着在某些重大利益的事情上无所作为的情况，政治本身也时残酷的，而政治家们也并没有书中描述的那么英明俊朗，政治层面以下也有许多见不得光的利益勾兑和妥协，当然不管在哪国的政治家们想要生存，做一个清白且公正无私的“海瑞”，本就不现实的。这些让我想到了国内体制内流行的一句话，“能做事”跟“做成事”两者之间存在的巨大的鸿沟，政治圈里“做成事”这个问题首先就不可能从书本上找到理论，更需要的实践与智慧，就像为什么现在所谓的“专家”和“学者”很多，但是实际成功的“企业家”和“政客”总是稀缺的。培养几个“工程师”很容易，但是培养一个成功的“CEO”很难，因为很多成功的职业生涯根本就没有一个正确的理论来作为指导的，只能通过当事人的自己摸索和临场发挥。&lt;/li&gt;
&lt;li&gt;文中描述的作者参与“总理”选举的五年历程，其中经历的艰辛、曲折，耗费的精力和金钱，面对的困难和挫折，不是一般的人能够承受的，我们作为台下的观众，总是很容易的帮其分析原因，指责他所范的错误，但实际我们亲身并没有参与这些，我们更应该为作者点赞，佩服作者能够参与平常人几乎没有机会能够参与的一种生活体验。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="读书" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 202周赛</title>
    <link href="http://yoursite.com/2020/08/16/191/"/>
    <id>http://yoursite.com/2020/08/16/191/</id>
    <published>2020-08-16T05:25:21.003Z</published>
    <updated>2020-08-16T05:25:30.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="202场周赛"><a href="#202场周赛" class="headerlink" title="202场周赛"></a>202场周赛</h1><p>本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。</p><h2 id="5185-存在连续三个奇数的数组"><a href="#5185-存在连续三个奇数的数组" class="headerlink" title="5185. 存在连续三个奇数的数组"></a>5185. 存在连续三个奇数的数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code>，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 <code>true</code>；否则，返回 <code>false</code>。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：不存在连续三个元素都是奇数的情况。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：存在连续三个元素都是奇数的情况，即 [<span class="number">5</span>,<span class="number">7</span>,<span class="number">23</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/three-consecutive-odds" target="_blank" rel="noopener">https://leetcode-cn.com/problems/three-consecutive-odds</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力循环即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">threeConsecutiveOdds</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-2</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i<span class="number">-1</span>]%<span class="number">2</span> == <span class="number">1</span> &amp;&amp; arr[i]%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5488-使数组中所有元素相等的最小操作数"><a href="#5488-使数组中所有元素相等的最小操作数" class="headerlink" title="5488. 使数组中所有元素相等的最小操作数"></a>5488. 使数组中所有元素相等的最小操作数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>存在一个长度为 <code>n</code>的数组 <code>arr</code>，其中 <code>arr[i] = (2 * i) + 1 （ 0 &lt;= i &lt; n ）</code>。</p><p>一次操作中，你可以选出两个下标，记作 <code>x</code>和 <code>y （ 0 &lt;= x, y &lt; n ）</code>并使 <code>arr[x]</code> 减去 1 、<code>arr[y]</code>加上 1 （即 <code>arr[x] -=1</code>且 <code>arr[y] += 1</code>）。最终的目标是使数组中的所有元素都 相等 。题目测试用例将会 保证 ：在执行若干步操作后，数组中的所有元素最终可以全部相等。</p><p>给你一个整数 <code>n</code>，即数组的长度。请你返回使数组 <code>arr</code> 中所有元素相等所需的 最小操作数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">第一次操作选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，使数组变为 [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">第二次操作继续选出 x = <span class="number">2</span> 和 y = <span class="number">0</span>，数组将会变成 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-operations-to-make-array-equal</a><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本质就是个数学问题，弄清楚等差数列的元素和长度，即可很快的求出来。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minOperations</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (n*n)/<span class="number">4</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (n<span class="number">-1</span>)*(n+<span class="number">1</span>)/<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5489-两球之间的磁力"><a href="#5489-两球之间的磁力" class="headerlink" title="5489. 两球之间的磁力"></a>5489. 两球之间的磁力</h2><p>在代号为 <code>C-137</code>的地球上，<code>Rick</code> 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。<code>Rick</code> 有 <code>n</code> 个空的篮子，第 <code>i</code> 个篮子的位置在 <code>position[i]</code> ，<code>Morty</code>想把 <code>m</code> 个球放到这些篮子里，使得任意两球间 最小磁力 最大。</p><p>已知两个球如果分别位于<code>x</code>和<code>y</code>，那么它们之间的磁力为<code>|x - y|</code>。</p><p>给你一个整数数组 <code>position</code>和一个整数<code>m</code>，请你返回最大化的最小磁力。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], m = <span class="number">3</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：将 <span class="number">3</span> 个球分别放入位于 <span class="number">1</span>，<span class="number">4</span> 和 <span class="number">7</span> 的三个篮子，两球间的磁力分别为 [<span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>]。最小磁力为 <span class="number">3</span> 。我们没办法让最小磁力大于 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">输入：position = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1000000000</span>], m = <span class="number">2</span></span><br><span class="line">输出：<span class="number">999999999</span></span><br><span class="line">解释：我们使用位于 <span class="number">1</span> 和 <span class="number">1000000000</span> 的篮子时最小磁力最大。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `n == position.length`</span><br><span class="line">+ `<span class="number">2</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= position[i] &lt;= <span class="number">10</span>^<span class="number">9</span>`</span><br><span class="line">+ 所有` position `中的整数 互不相同 。</span><br><span class="line">+ `<span class="number">2</span> &lt;= m &lt;= position.length`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/magnetic-force-between-two-balls</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  二分查找</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 典型的二分查找解法。与之前的类似的题目切巧克力基本上一样的题目，一看基本就直到解法。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> check(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m,<span class="built_in">int</span> distance)&#123;</span><br><span class="line">        m--;</span><br><span class="line">        <span class="built_in">int</span> curr = position[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; position.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(position[i] - curr &gt;= distance)&#123;</span><br><span class="line">                curr = position[i];</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">int</span> maxDistance(vector&lt;<span class="built_in">int</span>&gt;&amp; position, <span class="built_in">int</span> m) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = position.size();</span><br><span class="line">        long long l = <span class="number">1</span>;</span><br><span class="line">        long long r = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        sort(position.begin(),position.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(position,m,mid))&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5490-吃掉-N-个橘子的最少天数"><a href="#5490-吃掉-N-个橘子的最少天数" class="headerlink" title="5490. 吃掉 N 个橘子的最少天数"></a>5490. 吃掉 N 个橘子的最少天数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>厨房里总共有 <code>n</code> 个橘子，你决定每一天选择如下方式之一吃这些橘子：</p><p>吃掉一个橘子。<br>如果剩余橘子数 <code>n</code> 能被 2 整除，那么你可以吃掉 n/2 个橘子。<br>如果剩余橘子数 <code>n</code>能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。<br>每天你只能从以上 3 种方案中选择一种方案。</p><p>请你返回吃掉所有 <code>n</code>个橘子的最少天数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：你总共有 <span class="number">10</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">10</span> - <span class="number">1</span> = <span class="number">9</span>。</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">6</span> 个橘子，剩余橘子数 <span class="number">9</span> - <span class="number">2</span>*(<span class="number">9</span>/<span class="number">3</span>) = <span class="number">9</span> - <span class="number">6</span> = <span class="number">3</span>。（<span class="number">9</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。</span><br><span class="line">第 <span class="number">4</span> 天：吃掉最后 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你需要至少 <span class="number">4</span> 天吃掉 <span class="number">10</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：你总共有 <span class="number">6</span> 个橘子。</span><br><span class="line">第 <span class="number">1</span> 天：吃 <span class="number">3</span> 个橘子，剩余橘子数 <span class="number">6</span> - <span class="number">6</span>/<span class="number">2</span> = <span class="number">6</span> - <span class="number">3</span> = <span class="number">3</span>。（<span class="number">6</span> 可以被 <span class="number">2</span> 整除）</span><br><span class="line">第 <span class="number">2</span> 天：吃 <span class="number">2</span> 个橘子，剩余橘子数 <span class="number">3</span> - <span class="number">2</span>*(<span class="number">3</span>/<span class="number">3</span>) = <span class="number">3</span> - <span class="number">2</span> = <span class="number">1</span>。（<span class="number">3</span> 可以被 <span class="number">3</span> 整除）</span><br><span class="line">第 <span class="number">3</span> 天：吃掉剩余 <span class="number">1</span> 个橘子，剩余橘子数 <span class="number">1</span> - <span class="number">1</span> = <span class="number">0</span>。</span><br><span class="line">你至少需要 <span class="number">3</span> 天吃掉 <span class="number">6</span> 个橘子。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">56</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 2*10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dfs + 记忆式搜索</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>本质是典型的记忆式搜素，题目非常简单。</li><li>或者简单的BFS快速搜素即可，也没什么好讨论的。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(cnt.count(n)) <span class="keyword">return</span> cnt[n];</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">2</span>) + n%<span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        ans = min(ans,dfs(n/<span class="number">3</span>) + n%<span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        cnt[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">minDays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">        que.push(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = que.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">auto</span> q = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">3</span>);</span><br><span class="line">                    s.insert(q / <span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; s.count(q / <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q / <span class="number">2</span>);</span><br><span class="line">                    s.insert(q / <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s.count(q - <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    que.push(q - <span class="number">1</span>);</span><br><span class="line">                    s.insert(q - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;202场周赛&quot;&gt;&lt;a href=&quot;#202场周赛&quot; class=&quot;headerlink&quot; title=&quot;202场周赛&quot;&gt;&lt;/a&gt;202场周赛&lt;/h1&gt;&lt;p&gt;本周的题目都好简单，除了最后一题稍微有点数学知识即可解答出来，其余的题目都非常简单。&lt;/p&gt;&lt;h2 id=&quot;5185-存在连续三个奇数的数组&quot;&gt;&lt;a href=&quot;#5185-存在连续三个奇数的数组&quot; class=&quot;headerlink&quot; title=&quot;5185. 存在连续三个奇数的数组&quot;&gt;&lt;/a&gt;5185. 存在连续三个奇数的数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：不存在连续三个元素都是奇数的情况。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;34&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：存在连续三个元素都是奇数的情况，即 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;23&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 201周周赛</title>
    <link href="http://yoursite.com/2020/08/09/190/"/>
    <id>http://yoursite.com/2020/08/09/190/</id>
    <published>2020-08-09T08:21:04.153Z</published>
    <updated>2020-08-09T09:26:54.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="201周周赛"><a href="#201周周赛" class="headerlink" title="201周周赛"></a>201周周赛</h1><p>本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png" alt="1"><br>不过整体来说，感觉题目质量非常高，leetcode出题还是用心。</p><h2 id="5483-整理字符串"><a href="#5483-整理字符串" class="headerlink" title="5483. 整理字符串"></a>5483. 整理字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由大小写英文字母组成的字符串 <code>s</code> 。</p><p>一个整理好的字符串中，两个相邻字符 <code>s[i]</code>和 <code>s[i + 1]</code>不会同时满足下述条件：</p><a id="more"></a><ul><li><code>0 &lt;= i &lt;= s.length - 2</code></li><li><code>s[i]</code> 是小写字符，但 <code>s[i + 1]</code> 是相同的大写字符；反之亦然 。<br>请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。<br>请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。<br>注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。</li></ul><p>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leEeetcode"</span></span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：无论你第一次选的是 <span class="selector-tag">i</span> = <span class="number">1</span> 还是 <span class="selector-tag">i</span> = <span class="number">2</span>，都会使 <span class="string">"leEeetcode"</span> 缩减为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abBAcC"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：</span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"aAcC"</span> --&gt; <span class="string">"cC"</span> --&gt; <span class="string">""</span></span><br><span class="line"><span class="string">"abBAcC"</span> --&gt; <span class="string">"abBA"</span> --&gt; <span class="string">"aA"</span> --&gt; <span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"s"</span></span><br><span class="line">输出：<span class="string">"s"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 只包含小写和大写英文字母</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/make-the-string-great" target="_blank" rel="noopener">https://leetcode-cn.com/problems/make-the-string-great</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  堆栈</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题感觉比较坑，简单的题目估计卡住不少人，感觉可以到达mid难度。</li><li>模拟堆栈即可，遍历字符串，如果当前字符串中的元素与栈顶的元素的绝对值之差为<code>32</code>，则出栈即可。最后返回栈中剩余的元素即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">makeGood</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isgood = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        res.push_back(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.empty())&#123;</span><br><span class="line">                res.push_back(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(res.back()-s[i]) == <span class="number">32</span>)&#123;</span><br><span class="line">                    res.pop_back();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res.push_back(s[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5484-找出第-N-个二进制字符串中的第-K-位"><a href="#5484-找出第-N-个二进制字符串中的第-K-位" class="headerlink" title="5484. 找出第 N 个二进制字符串中的第 K 位"></a>5484. 找出第 N 个二进制字符串中的第 K 位</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个正整数 <code>n</code> 和 <code>k</code>，二进制字符串  <code>Sn</code> 的形成规则如下：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li>当 <code>i &gt; 1</code> 时，<code>Si = Si-1 + &quot;1&quot; + reverse(invert(Si-1))</code><br>其中 + 表示串联操作，<code>reverse(x)</code> 返回反转 <code>x</code> 后得到的字符串，而 <code>invert(x)</code> 则会翻转<code>x</code>中的每一位（<code>0</code>变为 <code>1</code>，而 <code>1</code> 变为 <code>0</code>）</li></ul><p>例如，符合上述描述的序列的前 4 个字符串依次是：</p><ul><li><code>S1 = &quot;0&quot;</code></li><li><code>S2 = &quot;011&quot;</code></li><li><code>S3 = &quot;0111001&quot;</code></li><li><code>S4 = &quot;011100110110001&quot;</code><br>请你返回  Sn 的 第 k 位字符 ，题目数据保证 k 一定在 Sn 长度范围以内。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br><span class="line">解释：S3 为 <span class="string">"0111001"</span>，其第 <span class="number">1</span> 位为 <span class="string">"0"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">11</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br><span class="line">解释：S4 为 <span class="string">"011100110110001"</span>，其第 <span class="number">11</span> 位为 <span class="string">"1"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"0"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"1"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 20</code></li><li><code>1 &lt;= k &lt;= 2n - 1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-kth-bit-in-nth-binary-string</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题 + 找规律</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>先找到规律，刚拿到题目感觉没法下手，直接去求解的话，感觉很难。</li><li>仔细发现一下找到规律即可，实际我们直到$S_{n}$与$S_{n+1}$之间的递推关系，实际我们就可以用递归求解即可。我们可以讲字符串滑下来。</li><li>我们可以举例<code>S4</code>：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809165248.png" alt="1">。<br>首先我们可以直到$S_{n}$的长度$len(S_{n}) = 2^{n}-1$.假如<code>k</code>刚好在当前字符串中间的话，则直接返回<code>1</code>,因为我们直到除<code>S1</code>以外的字符串，最中间的字符都为<code>1</code>,最中间的位置刚好为：$2^{n-1}$<br>所以我们分为三种情况来讨论：</li></ol><ul><li>当$K &lt; 2^{n-1}$时：则此时$S_{n}[k] = S_{n-1}[k]$</li><li>当$K = 2^{n-1}$时：则此时$S_{n}[K] = 1$</li><li>当$K &gt; 2^{n-1}$时：则此时稍微麻烦点，由于后半部分是$reverse(invert(S_{n-1}))$,则$S_{n}[K] = inverse(S_{n-1}[2^{n}-k])$.</li><li>当$n = 0$时，则返回<code>0</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findKthBit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span> &amp;&amp; k == <span class="number">1</span>) <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(k &lt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="built_in">pow</span>(<span class="number">2</span>,n<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> findKthBit(n<span class="number">-1</span>,<span class="built_in">pow</span>(<span class="number">2</span>,n)-k) == <span class="string">'0'</span>?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="5471-和为目标值的最大数目不重叠非空子数组数目"><a href="#5471-和为目标值的最大数目不重叠非空子数组数目" class="headerlink" title="5471. 和为目标值的最大数目不重叠非空子数组数目"></a>5471. 和为目标值的最大数目不重叠非空子数组数目</h2><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], target = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个不重叠子数组（加粗数字表示） [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] ，它们的和为目标值 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>], target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">3</span> 个子数组和为 <span class="number">6</span> 。</span><br><span class="line">([<span class="number">5</span>,<span class="number">1</span>], [<span class="number">4</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">-9</span>]) 但只有前 <span class="number">2</span> 个是不重叠的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>], target = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>0 &lt;= target &lt;= 10^6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目有点意思，我们设<code>dp[i]</code>代表前<code>i</code>个元素中含有最多的非连续符合条件且不重合的子数组的数目。</li><li>我们每次从在索引<code>i</code>初找到由元素<code>a[i]</code>作为符合条件的子数组的最后一个元素。我们利用前缀和，每次找到<code>prefixsum[i]-tagret</code>的索引<code>j</code>处。则可以得到以下递推公式.<script type="math/tex; mode=display">ans = max(ans,dp[j] + 1)</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            curr += nums[i<span class="number">-1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt.count(curr-target))&#123;</span><br><span class="line">                <span class="keyword">int</span> x = cnt[curr-target];</span><br><span class="line">                dp[i] = max(dp[i],dp[x] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(ans,dp[i]);</span><br><span class="line">            cnt[curr] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5486-切棍子的最小成本"><a href="#5486-切棍子的最小成本" class="headerlink" title="5486. 切棍子的最小成本"></a>5486. 切棍子的最小成本</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>有一根长度为<code>n</code> 个单位的木棍，棍上从 <code>0</code> 到 <code>n</code> 标记了若干位置。例如，长度为 <code>6</code> 的棍子可以标记如下：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171755.png" alt="1"><br>给你一个整数数组 <code>cuts</code> ，其中 <code>cuts[i]</code> 表示你需要将棍子切开的位置。<br>你可以按顺序完成切割，也可以根据需要更改切割的顺序。</p><p>每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和。对棍子进行切割将会把一根木棍分成两根较小的木棍（这两根木棍的长度和就是切割前木棍的长度）。请参阅第一个示例以获得更直观的解释。</p><p>返回切棍子的 最小总成本 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, cuts = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：按 [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] 的顺序切割的情况如下所示：</span><br><span class="line"></span><br><span class="line">第一次切割长度为 <span class="number">7</span> 的棍子，成本为 <span class="number">7</span> 。第二次切割长度为 <span class="number">6</span> 的棍子（即第一次切割得到的第二根棍子），第三次切割为长度 <span class="number">4</span> 的棍子，最后切割长度为 <span class="number">3</span> 的棍子。总成本为 <span class="number">7</span> + <span class="number">6</span> + <span class="number">4</span> + <span class="number">3</span> = <span class="number">20</span> 。</span><br><span class="line">而将切割顺序重新排列为 [<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>] 后，总成本 = <span class="number">16</span>（如示例图中 <span class="number">7</span> + <span class="number">4</span> + <span class="number">3</span> + <span class="number">2</span> = <span class="number">16</span>）。</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200809171815.png" alt="2"><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, cuts = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">22</span></span><br><span class="line">解释：如果按给定的顺序切割，则总成本为 <span class="number">25</span> 。总成本 &lt;= <span class="number">25</span> 的切割顺序很多，例如，[<span class="number">4</span>，<span class="number">6</span>，<span class="number">5</span>，<span class="number">2</span>，<span class="number">1</span>] 的总成本 = <span class="number">22</span>，是所有可能方案中成本最小的。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^6</code></li><li><code>1 &lt;= cuts.length &lt;= min(n - 1, 100)</code></li><li><code>1 &lt;= cuts[i] &lt;= n - 1</code></li><li><code>cuts</code> 数组中的所有整数都 互不相同</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-cost-to-cut-a-stick</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，这种类型的题目已经见了很多了。</li><li>为了方便计算，我们首先讲头和尾加入<code>cuts</code>.我们用<code>dp[i][j]</code>代表<code>cuts[i]</code>到<code>cuts[j]</code>之间的切割最小成本。我们可以直到<code>dp[i][i] = 0</code>和 <code>dp[i][i+1]</code>，因为不需要切割。</li><li>我们很容易得出递推公式：<script type="math/tex; mode=display">dp[i][j] = min(dp[i][j],dp[i][k] + dp[k][j] + cuts[j] - cuts[i]) \qquad ( i \le k \le j</script><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cuts)</span> </span>&#123;        </span><br><span class="line">        cuts.push_back(<span class="number">0</span>);</span><br><span class="line">        cuts.push_back(n);</span><br><span class="line">        <span class="keyword">int</span> m = cuts.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0x3f3f3f3f</span>));</span><br><span class="line">        </span><br><span class="line">        sort(cuts.begin(),cuts.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            dp[i][i] = <span class="number">0</span>;</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[m<span class="number">-1</span>][m<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j+i &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; j+i; ++k)&#123;</span><br><span class="line">                    dp[j][j+i] = min(dp[j][j+i],dp[j][k] + dp[k][j+i] + cuts[j+i] - cuts[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;201周周赛&quot;&gt;&lt;a href=&quot;#201周周赛&quot; class=&quot;headerlink&quot; title=&quot;201周周赛&quot;&gt;&lt;/a&gt;201周周赛&lt;/h1&gt;&lt;p&gt;本周的周赛题目都比较简单，40分钟搞定前三道题目，后面有事就中途退场。回来后，最后一题5分钟搞定，好简单。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/20200809162635.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;不过整体来说，感觉题目质量非常高，leetcode出题还是用心。&lt;/p&gt;&lt;h2 id=&quot;5483-整理字符串&quot;&gt;&lt;a href=&quot;#5483-整理字符串&quot; class=&quot;headerlink&quot; title=&quot;5483. 整理字符串&quot;&gt;&lt;/a&gt;5483. 整理字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由大小写英文字母组成的字符串 &lt;code&gt;s&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;一个整理好的字符串中，两个相邻字符 &lt;code&gt;s[i]&lt;/code&gt;和 &lt;code&gt;s[i + 1]&lt;/code&gt;不会同时满足下述条件：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 32周双周赛</title>
    <link href="http://yoursite.com/2020/08/09/189/"/>
    <id>http://yoursite.com/2020/08/09/189/</id>
    <published>2020-08-09T02:13:37.052Z</published>
    <updated>2020-08-09T14:45:51.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32周双周赛"><a href="#32周双周赛" class="headerlink" title="32周双周赛"></a>32周双周赛</h1><p>本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。</p><h2 id="5468-第-k-个缺失的正整数"><a href="#5468-第-k-个缺失的正整数" class="headerlink" title="5468. 第 k 个缺失的正整数"></a>5468. 第 k 个缺失的正整数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个 严格升序排列 的正整数数组<code>arr</code>和一个整数 <code>k</code>。</p><p>请你找到这个数组里第 <code>k</code> 个缺失的正整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">11</span>], k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">13</span>,...] 。第 <span class="number">5</span> 个缺失的正整数为 <span class="number">9</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：缺失的正整数包括 [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,...] 。第 <span class="number">2</span> 个缺失的正整数为 <span class="number">6</span> 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>1 &lt;= arr[i] &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li>对于所有 <code>1 &lt;= i &lt; j &lt;= arr.length</code>的 <code>i</code>和 <code>j</code>满足 <code>arr[i] &lt; arr[j]</code>.</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/kth-missing-positive-number" target="_blank" rel="noopener">https://leetcode-cn.com/problems/kth-missing-positive-number</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力计数即可，如果发现当前的计数出现在数组中，则k不变，否则k进行减一操作。</li><li>当<code>k</code>为0时返回当前计数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            curr++;</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; arr.size() &amp;&amp; curr == arr[idx])&#123;</span><br><span class="line">                idx++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5469-K-次操作转变字符串"><a href="#5469-K-次操作转变字符串" class="headerlink" title="5469. K 次操作转变字符串"></a>5469. K 次操作转变字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你两个字符串 <code>s</code> 和 <code>t</code> ，你的目标是在<code>k</code>次操作以内把字符串 <code>s</code> 转变成 <code>t</code>。</p><p>在第 <code>i</code>次操作时<code>（1 &lt;= i &lt;= k）</code>，你可以选择进行如下操作：</p><p>选择字符串 <code>s</code> 中满足 <code>1 &lt;= j &lt;= s.length</code> 且之前未被选过的任意下标 <code>j</code>（下标从<code>1</code>开始），并将此位置的字符切换 <code>i</code>次。<br>不进行任何操作。<br>切换 <code>1</code> 次字符的意思是用字母表中该字母的下一个字母替换它（字母表环状接起来，所以 ‘z’ 切换后会变成 ‘a’）。</p><p>请记住任意一个下标<code>j</code> 最多只能被操作 <code>1</code> 次。</p><p>如果在不超过 <code>k</code> 次操作内可以把字符串 <code>s</code>转变成<code>t</code> ，那么请你返回 <code>true</code> ，否则请你返回 <code>false</code> 。</p><p>示例 1：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"input"</span>, t = <span class="string">"ouput"</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">6</span> 次操作时，我们将 <span class="string">'i'</span> 切换 <span class="number">6</span> 次得到 <span class="string">'o'</span> 。第 <span class="number">7</span> 次操作时，我们将 <span class="string">'n'</span> 切换 <span class="number">7</span> 次得到 <span class="string">'u'</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, t = <span class="string">"bcd"</span>, k = <span class="number">10</span></span><br><span class="line">输出：false</span><br><span class="line">解释：我们需要将每个字符切换 <span class="number">1</span> 次才能得到 t 。我们可以在第 <span class="number">1</span> 次操作时将 'a' 切换成 'b' ，但另外 <span class="number">2</span> 个字母在剩余操作中无法再转变为 t 中对应字母。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aab"</span>, t = <span class="string">"bbb"</span>, k = <span class="number">27</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：第 <span class="number">1</span> 次操作时，我们将第一个 <span class="string">'a'</span> 切换 <span class="number">1</span> 次得到 <span class="string">'b'</span> 。在第 <span class="number">27</span> 次操作时，我们将第二个字母 <span class="string">'a'</span> 切换 <span class="number">27</span> 次得到 <span class="string">'b'</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><p>1 &lt;= s.length, t.length &lt;= 10^5<br>0 &lt;= k &lt;= 10^9<br>s 和 t 只包含小写英文字母。</p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-convert-string-in-k-moves</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5470-平衡括号字符串的最少插入次数"><a href="#5470-平衡括号字符串的最少插入次数" class="headerlink" title="5470. 平衡括号字符串的最少插入次数"></a>5470. 平衡括号字符串的最少插入次数</h2><p>给你一个括号字符串 <code>s</code> ，它只包含字符 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。一个括号字符串被称为平衡的当它满足：</p><ul><li>任何左括号 ‘(‘ 必须对应两个连续的右括号 ‘))’ 。</li><li>左括号 ‘(‘ 必须在对应的连续两个右括号 ‘))’ 之前。<br>比方说 “())”， “())(())))” 和 “(())())))” 都是平衡的， “)()”， “()))” 和 “(()))” 都是不平衡的。</li></ul><p>你可以在任意位置插入字符 ‘(‘ 和 ‘)’ 使字符串平衡。</p><p>请你返回让 s 平衡的最少插入次数。</p><p>示例 1：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(()))"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 <span class="string">"(())))"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"())"</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：字符串已经平衡了。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"))())("</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"(((((("</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：添加 <span class="number">12</span> 个 ')' 得到平衡字符串。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">")))))))"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：在字符串开头添加 <span class="number">4</span> 个 '(' 并在结尾添加 <span class="number">1</span> 个 ')' ，字符串变成平衡字符串 <span class="string">"(((())))))))"</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含 <code>&#39;(&#39;</code> 和<code>&#39;)&#39;</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目真心是好题，看似简单，实则需要思考的深度很多，不容易作对，并且做到最简单的方法夜不容易。</li><li>第一种思路，首先补齐右括号<code>)</code>，我们将所有的连续的右括号全部填充成偶数个，然后再将两个右括号<code>))</code>换成单个右括号<code>)</code>,然后再进行匹配，找出最少需要多少个右括号和左括号才能能完成匹配即可。这样做的是思路非常简单容易理解，不容易出错。</li><li>第二种思路，遇到左括号则我们进行计数加<code>1</code>,如果遇到连续的两个右括号，我们将指针指针移动两位，如果遇到<code>1</code>个右括号，我们则将其补齐，这时再看是否有左括号是否能够匹配，如果有左括号可以匹配，我们将左括号计数减一，否则我们补齐一个左括号，最后将剩余的计数的左括号全部补齐匹配即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minInsertions</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'('</span>)&#123;</span><br><span class="line">                curr.push(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i+<span class="number">1</span> &lt; s.size() &amp;&amp; s[i+<span class="number">1</span>] == <span class="string">')'</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(!curr.empty())&#123;</span><br><span class="line">                    curr.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans + curr.size()*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5485-找出最长的超赞子字符串"><a href="#5485-找出最长的超赞子字符串" class="headerlink" title="5485. 找出最长的超赞子字符串"></a>5485. 找出最长的超赞子字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>s</code>。请返回<code>s</code> 中最长的 超赞子字符串 的长度。</p><p>「超赞子字符串」需满足满足下述两个条件：</p><p>该字符串是 <code>s</code> 的一个非空子字符串<br>进行任意次数的字符交换重新排序后，该字符串可以变成一个回文字符串</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"3242415"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：<span class="string">"24241"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"24142"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"12345678"</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"213123"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">"213123"</span> 是最长的超赞子字符串，交换其中的字符后，可以得到回文 <span class="string">"231132"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 仅由数字组成</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-longest-awesome-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-longest-awesome-substring</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>这个题目跟之前的<code>1317</code>题目很像，不过这个题目是求得连续子数组为回文串得最长长度。</li><li>题目还是非常有技巧的，首先我们要分析以下，什么样的字串可以通过无数次变化后变为回文字符串：</li></ol><ul><li>2.1字符串中所有字符的统计个数都为偶数。</li><li>2.2字符串中所有字符的统计个数只有一个字符的统计个数为奇数，其余的都为偶数。</li></ul><ol><li>看到上述描述后，由于题目中的字符串只有好友<code>0-9</code>的数字，因此最多只有10种字符，因此我们最多用10位即可表示10种字符的奇偶状态。比如：</li></ol><ul><li><code>0000000000</code>:代表字符<code>0~9</code>的统计个数都为偶数。</li><li><code>1000000000</code>:代表字符<code>1~9</code>的统计个数都为偶数，字符<code>0</code>的统计个数为奇数。</li><li><code>0110000000</code>:代表字符<code>0,3,4,5,6,7,8,9</code>的统计个数都为偶数,字符<code>1,2</code>的统计个数为奇数。</li></ul><ol><li>所以总共有<code>1024</code>种状态，我们获取当前字符索引<code>i</code>的奇偶状态<code>state[i]</code>，同时获取与<code>state[i]</code>相同的最小前缀<code>j</code>，可以得到以当前字符结束的且符合<code>2.1</code>条件的最长字串;当同时依次反转某个字符的奇偶状态得到<code>inverse_state[i]</code>，同时获取与<code>inverse_state[i]</code>相同的最小前缀<code>j</code>,可以得到以当前字符结束的且符合<code>2.2</code>条件的最长字串长度。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestAwesome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(<span class="number">1</span>&lt;&lt;<span class="number">10</span>,<span class="number">-1</span>);</span><br><span class="line">        prev[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> ch = s[i<span class="number">-1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            mask ^= (<span class="number">1</span>&lt;&lt;ch);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">int</span> next = mask^(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">                <span class="keyword">if</span>(prev[next] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = max(ans,i-prev[next]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(prev[mask] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                ans = max(ans,i-prev[mask]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev[mask] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;32周双周赛&quot;&gt;&lt;a href=&quot;#32周双周赛&quot; class=&quot;headerlink&quot; title=&quot;32周双周赛&quot;&gt;&lt;/a&gt;32周双周赛&lt;/h1&gt;&lt;p&gt;本周的题目难度确实不小，四道题都不是一眼就可以做出来的，基本上都需要思考5到10分钟。&lt;/p&gt;&lt;h2 id=&quot;5468-第-k-个缺失的正整数&quot;&gt;&lt;a href=&quot;#5468-第-k-个缺失的正整数&quot; class=&quot;headerlink&quot; title=&quot;5468. 第 k 个缺失的正整数&quot;&gt;&lt;/a&gt;5468. 第 k 个缺失的正整数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个 严格升序排列 的正整数数组&lt;code&gt;arr&lt;/code&gt;和一个整数 &lt;code&gt;k&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;请你找到这个数组里第 &lt;code&gt;k&lt;/code&gt; 个缺失的正整数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], k = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：缺失的正整数包括 [&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,...] 。第 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个缺失的正整数为 &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Coursera】 Programming Languages</title>
    <link href="http://yoursite.com/2020/08/05/188/"/>
    <id>http://yoursite.com/2020/08/05/188/</id>
    <published>2020-08-05T04:11:55.607Z</published>
    <updated>2020-08-05T04:12:00.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Programming-languages"><a href="#Programming-languages" class="headerlink" title="Programming languages"></a>Programming languages</h1><p>一直听说<code>coursera</code>上<code>UW</code>的<code>Programming languages</code>的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了<code>part A</code>和<code>part B</code>部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的<code>皮毛</code>,对所谓的<code>lambda</code>表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看<code>python</code>的好多特性都可以在这几门课中找到，特别是<code>yeild,lambda,@,stream</code>等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用<code>rackets</code>编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。<code>PL</code>领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。</p><a id="more"></a><ul><li><code>dynamic type</code>： 最大的好处写起来很爽，非常容易扩展和迁移，但是如果用这种动态语言来做大型工程项目来说，我感觉就是噩梦，因为没有强制的类型和规则，意味着处处都有可能产生<code>bug</code>，因为参数和返回值的类型由运行时决定，意外的产生<code>bug</code>会非常难以调试.并且动态类型语言的效率还是个非常大的问题，因为从语言的实现角度来看，如果真要实现动态类型，实际是需要加许多<code>tag</code>的附加信息来标记类型。</li><li><code>static type</code>:最大的好处是有强制的类型和规则校验，编译器会自动做类型检查，帮程序员发现不必要的类型匹配错误，并静态类型语言很容易编译成机器码，效率会很高，占用的内存会较小。非常适合于大型的工程项目。<br>所以的<code>homework project source code</code>都放在<code>github</code>上。实际还是非常花功夫来完成这些<code>project</code>，又熬了好多次夜才完成这些<code>homework</code>,作为二胎的父亲刷网课不易。</li></ul><p><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages" target="_blank" rel="noopener">programming languages</a></p><h2 id="Part-A"><a href="#Part-A" class="headerlink" title="Part A"></a>Part A</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111309.png" alt="1"><br><code>part A</code>部分主要讲述了<code>ML</code>语言，其实是一门学术上研究的语言，实际上很少人会用<code>ML</code>语言来开发项目，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。<br>partA 主要学习了不少概念性的东西：</p><ul><li>hw1:主要学习了递归，<code>list</code>和函数的基本概念，以及类型的基本概念，还是颠覆了原来的认知，函数式编程最大的特点就是各种递归操作。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week1" target="_blank" rel="noopener">hw1</a></li><li>hw2:主要学习了<code>pair,tuple</code>以及<code>option</code>,<code>datatype</code>的各种基本概念。非常绕口的概念，跟过程式编程的体会完全不一样。过程式编程主要考虑程序的顺序执行，函数式编程考虑的怎样函数套函数。<a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week2" target="_blank" rel="noopener">hw2</a></li><li>hw3:学习了基本的<code>curry</code>的概念，感觉印象深刻，其实本质概念，一个函数接受了一个函数作为参数，返回了另一个函数，相当于可以根据参数类型，动态生成一个函数。学到了更高级的<code>map</code>和<code>filter</code>的函数的写法，感觉10行的代码实现了<code>c</code>语言几百行的工作量，非常的优雅，写起来很爽。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week3" target="_blank" rel="noopener">hw3</a></li><li>hw4: 学习了<code>ml</code>基本的模块的概念，如何编写模块和访问控制权限，类似<code>C++</code>中类的基本概念。</li></ul><h2 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h2><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200805111406.png" alt="2"><br><code>part B</code>部分主要讲述了<code>racket</code>语言，其实是一门学术上研究的语言，是由<code>lisp</code>语言发展来的分支，因为感觉写起来太蛋疼了，实话实说函数式编程语言颠覆了以前的认知，跟传统的<code>c\c++</code>和<code>java</code>的编程思想完全不一样，在函数式编程语言里面，认为所有的都式类型，包括函数也只是一种类型而已。</p><ul><li>hw5:学习了<code>racket</code>语言的基本语法和概念，学习了<code>stream</code>和<code>marco</code>的基本使用，毫无疑问的来说<code>stream</code>是个强大的工具，相当于函数本身返回一个函数，然后可以再反复调用这个函数。内部的实现原理其实很简单。<code>racket</code>据说有非常强的<code>marco</code>,不过在这一章里面只写了一个非常简单的皮毛而已。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week5" target="_blank" rel="noopener">hw5</a></li><li>hw6:这章里面主要的就是如何写一个简单的脚本解释器，利用<code>struct</code>创造类型出来，然后各种非常骚的操作写脚本解释器，还有一个很重要的<code>clouser</code>的概念。这章的<code>homework</code>还是比较有意思。<br><a href="https://github.com/mike-box/coursera/tree/master/Programming%20Languages/week6" target="_blank" rel="noopener">hw6</a><br>虽然每次的<code>homework</code>代码量不大，但是需要思考的很多，很多其实非常有意思，如果把这么课理解透了，对于理解函数的<code>闭包</code>这种概念就会非常的深刻。</li></ul><h2 id="Part-C"><a href="#Part-C" class="headerlink" title="Part C"></a>Part C</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Programming-languages&quot;&gt;&lt;a href=&quot;#Programming-languages&quot; class=&quot;headerlink&quot; title=&quot;Programming languages&quot;&gt;&lt;/a&gt;Programming languages&lt;/h1&gt;&lt;p&gt;一直听说&lt;code&gt;coursera&lt;/code&gt;上&lt;code&gt;UW&lt;/code&gt;的&lt;code&gt;Programming languages&lt;/code&gt;的课程为神课，所以终于在6月份的时候排期开始学习这么这么苦逼的神奇课程，目前已经完成了&lt;code&gt;part A&lt;/code&gt;和&lt;code&gt;part B&lt;/code&gt;部分，不得不说从来没有关注过这个领域，学了两次课程，真心颠覆了我对编程语言的认知，终于了解到函数式编程的&lt;code&gt;皮毛&lt;/code&gt;,对所谓的&lt;code&gt;lambda&lt;/code&gt;表达式有了更清晰的认知，特别是学往这几门课程之后，再回过头来看看&lt;code&gt;python&lt;/code&gt;的好多特性都可以在这几门课中找到，特别是&lt;code&gt;yeild,lambda,@,stream&lt;/code&gt;等等中文翻译过来很神奇的概念，已经动态类型语言、静态类型语言，运行时检查等等最基本的语言特性在函数式编程中都可以见到，已经亲自动手实现某些特性，比如用&lt;code&gt;rackets&lt;/code&gt;编写一个简单的脚本解释器等等，感慨收获很多。这门课程可能会比较虚，因为不会讲一些实用的工业界的技能，但是许多观点和视角确实非常不一样，让人耳目一新的收获。&lt;code&gt;PL&lt;/code&gt;领域发展这么多年，一直不温不火，当然很多语言的特性在实际的工程中可能用处不大，但是确实是非常艺术的角度来看待许多语言的细节问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PL" scheme="http://yoursite.com/categories/PL/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【算法】 Brainfuck编译器</title>
    <link href="http://yoursite.com/2020/08/04/187/"/>
    <id>http://yoursite.com/2020/08/04/187/</id>
    <published>2020-08-04T02:34:26.152Z</published>
    <updated>2020-08-04T02:34:32.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Brain-fuck语言"><a href="#Brain-fuck语言" class="headerlink" title="Brain fuck语言"></a>Brain fuck语言</h1><p>第一次听到<code>brain fuck</code>语言是在提交<code>spoj</code>第二道题目时，竟然用<code>brain fuck</code>语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。</p><ul><li>背景：<code>Brainfuck</code>是一种极小化的计算机语言，它是由<code>Urban Müller</code>在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段<code>brain fuck</code>代码：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/111.png" alt="1"><br>这段奇怪的符号实际为<code>100</code>行的<code>Brainfuck</code>虚拟机，实际代码非常晦涩难懂。</li><li>现状：实际上<code>brain fuck</code>只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。</li></ul><a id="more"></a><h2 id="语言规则"><a href="#语言规则" class="headerlink" title="语言规则"></a>语言规则</h2><p>实际上<code>brain fuck</code>只规定了8种基本的机器操作，分别为：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。每个操作用一个符号来替代。下表为实际的操作说明。</p><div class="table-container"><table><thead><tr><th>字符</th><th>含义</th><th>C语言实现</th></tr></thead><tbody><tr><td>&gt;</td><td>当前的地址加1</td><td>ptr++</td></tr><tr><td>&lt;</td><td>当前的地址加1</td><td>ptr—</td></tr><tr><td>+</td><td>指针指向的字节的值加一</td><td>++*ptr;</td></tr><tr><td>-</td><td>指针指向的字节的值减一</td><td>—*ptr;</td></tr><tr><td>.</td><td>输出指针指向的单元内容（ASCII码）</td><td>putchar(*ptr);</td></tr><tr><td>,</td><td>输入内容到指针指向的单元（ASCII码）</td><td>*ptr =getchar();</td></tr><tr><td>[</td><td>如果当前指针指向的单元值为零，向后跳转到对应的<code>]</code>指令的次一指令处</td><td>while (*ptr){</td></tr><tr><td>]</td><td>如果当前指针指向的单元值不为零，向前跳转到对应的<code>[</code>指令的次一指令处</td><td>}</td></tr></tbody></table></div><p>实际用<code>brain fuck</code>语言来写程序的话，非常锻炼你的机器思维。</p><ul><li><p>在屏幕上打印<code>hello word!</code>:</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="literal">+</span><span class="string">.</span>&lt;&lt;<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure></li><li><p>目前位置归零,我们可以看到当执行到<code>[</code>时，如果当前指针值不等于<code>0</code>则顺序执行<code>-</code>,否则跳到下一个<code>]</code>的后一条指令，当执行到<code>]</code>时，如果当前指针值不等于<code>0</code>则跳转到<code>-</code>，一直循环直到当前指针的位置为<code>0</code>.</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name"><span class="builtin-name">-</span></span>]</span><br></pre></td></tr></table></figure></li><li><p>字符I/O,从键盘中读取一个字符，然后打印出来。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,.</span><br></pre></td></tr></table></figure></li><li><p>简单的循环读取键盘字符,直到输入字符<code>\0</code>结束。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">,<span class="string">[.,]</span></span><br></pre></td></tr></table></figure></li><li><p>将所有的输入的字符全部保存到内存中。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;,<span class="string">[.&gt;,]</span></span><br></pre></td></tr></table></figure></li><li><p>加法,这个比较有趣，每次将当前的位置元素减<code>1</code>,同时将下一个指针的元素的元素加<code>1</code>,直到当前元素的元素为<code>0</code>.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;+&lt;]</span><br></pre></td></tr></table></figure></li><li><p>条件指令.这个程序会把从键盘读来的小写字符转换成大写。按回车键退出程序,每次读取大写字符<code>x</code>,然后将其减去<code>34</code>即可，如果读到回车键，则它的<code>ascii</code>码为<code>10</code>,刚好<code>10</code>的时候，程序会退出。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">[</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span><span class="string">,</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="title">]</span></span><br></pre></td></tr></table></figure></li><li><p>加法器 <code>add(summand, addend, *sum)</code></p><figure class="highlight cal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&lt;&lt;&lt; // clear cell <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">[-&gt;&gt;+&gt;+&lt;&lt;&lt;] // transfer cell <span class="string">#0</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#0</span></span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // transfer cell <span class="string">#1</span> <span class="keyword">to</span> <span class="string">#2</span> <span class="keyword">and</span> <span class="string">#3</span></span><br><span class="line">&gt;&gt;[-&lt;&lt;+&gt;&gt;]&lt;&lt; // transfer cell <span class="string">#3</span> <span class="keyword">to</span> <span class="string">#1</span></span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure><p>该代码以 cell #3 作为临时变量，将保存在 cell #0 和 cell #1 中的两个整数相加，<br>结果保存在 cell #2；同时维持原来的两个存储单元数值不变，方便以后使用。<br>代码运行前，设定指针指向 cell #0，<br>第一步，先将 cell #2 和 cell #3 清空，确保不会有脏数据影响运算结果；<br>第二步，将 cell #0 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #0 的值；<br>第三步，将 cell #1 的数值转移到 cell #2 和 cell #3，随后利用 cell #3 这个来恢复 cell #1 的值；<br>最后，指针归位（回到初始位置，即指向 cell #0），方便后续运算。</p></li><li><p>乘法器 <code>multiply(multiplicand, multiplier, *product)</code></p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;[-]&gt;[-]&gt;[-]&lt;&lt;&lt;&lt; // clear cell <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span> <span class="keyword">and</span> <span class="symbol">#4</span></span><br><span class="line">[-&gt;</span><br><span class="line">[-&gt;+&gt;+&lt;&lt;] // <span class="keyword">add</span> cell <span class="symbol">#1</span> <span class="keyword">to</span> <span class="symbol">#2</span> <span class="keyword">and</span> <span class="symbol">#3</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">[-&lt;&lt;+&gt;&gt;] // move cell <span class="symbol">#3</span> back <span class="keyword">to</span> <span class="symbol">#1</span></span><br><span class="line">&gt;+&lt; // copy cell <span class="symbol">#0</span> <span class="keyword">to</span> <span class="symbol">#4</span></span><br><span class="line">&lt;&lt;</span><br><span class="line">&lt;]</span><br><span class="line">&gt;&gt;&gt;&gt;[-&lt;&lt;&lt;&lt;+&gt;&gt;&gt;&gt;]&lt;&lt;&lt;&lt; // move cell <span class="symbol">#4</span> back <span class="keyword">to</span> <span class="symbol">#0</span></span><br></pre></td></tr></table></figure><p>跟上面的“加法器”类似，这个“乘法器”将保存在 cell #0 和 cell #1 的两个整数相乘，结果保存在 cell</p><h1 id="2；同时维持原来的两个存储单元数值不变，方便以后使用。"><a href="#2；同时维持原来的两个存储单元数值不变，方便以后使用。" class="headerlink" title="2；同时维持原来的两个存储单元数值不变，方便以后使用。"></a>2；同时维持原来的两个存储单元数值不变，方便以后使用。</h1></li></ul><p>从以上几个例子，我们可以看出实际上<code>brain fuck</code>实际还是非常有意思的，非常锻炼逻辑思维能力，但是实际工业界和学术界肯定不会用这么低效的语言来开发实际程序。</p><h2 id="brainfuck-解释器"><a href="#brainfuck-解释器" class="headerlink" title="brainfuck 解释器"></a>brainfuck 解释器</h2><p>由于<code>brain fuck</code>语言的功能很简单，只有8个指令，实际上我们可以C语言大概<code>100</code>行左右就可以实现该语言的解释器。</p><ul><li>直接翻译为C语言：这个就比较简单,我们直接翻译即可，转换为C语言。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"brainfuck_out.c"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    out&lt;&lt;<span class="string">"#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"int main()&#123;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char arr[1000000];\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  char *ptr = arr;\n"</span>;</span><br><span class="line">    out&lt;&lt;<span class="string">"  memset(arr,0,sizeof(arr));\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: out&lt;&lt;<span class="string">"    ++ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: out&lt;&lt;<span class="string">"    --ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: out&lt;&lt;<span class="string">"    ++*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: out&lt;&lt;<span class="string">"    --*ptr;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: out&lt;&lt;<span class="string">"    putchar(*ptr);\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: out&lt;&lt;<span class="string">"    *ptr =getchar();\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: out&lt;&lt;<span class="string">"    while (*ptr) &#123;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: out&lt;&lt;<span class="string">"    &#125;\n"</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out&lt;&lt;<span class="string">"&#125;\n"</span>;</span><br><span class="line">    out.close();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>直接源程序文件，进行解析。稍微复杂点的是需要找到左括号<code>[</code>最近的右括号，同时需要找到右括号<code>]</code>最近的左括号，我们用<code>skip_table</code>存放跳转指令即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[MAX_SIZE];</span><br><span class="line">    <span class="built_in">string</span> code;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> ((c=getchar())!=EOF) &#123;</span><br><span class="line">       code.push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* check '[]'*/</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; skip_table;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; code.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(code[i] == <span class="string">'['</span>)&#123;</span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code[i] == <span class="string">']'</span>)&#123;</span><br><span class="line">            assert(!st.empty());</span><br><span class="line">            skip_table[i] = st.top();</span><br><span class="line">            <span class="keyword">if</span>(!skip_table.count(st.top()))&#123;</span><br><span class="line">                skip_table[st.top()] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ip = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = arr;</span><br><span class="line">    <span class="keyword">while</span>(ip &lt; code.size())&#123;</span><br><span class="line">        c = code[ip];</span><br><span class="line">        <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&gt;'</span>: &#123;assert(ptr &lt; (arr+MAX_SIZE<span class="number">-1</span>)); ptr++;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'&lt;'</span>: &#123;assert(ptr &gt; arr); ptr--;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>: &#123;++*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: &#123;--*ptr;&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>: &#123;<span class="built_in">putchar</span>(*ptr);&#125;  <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">','</span>: &#123;*ptr = getchar();&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'['</span>: <span class="keyword">if</span>(*ptr == <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">']'</span>: <span class="keyword">if</span>(*ptr != <span class="string">'\0'</span>)&#123;ip = skip_table[ip];&#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ip++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h2><ul><li>将当前字节减去<code>100</code>，当然我们可以书写成连续<code>100</code>个<code>-</code>,但是这明显太长了。我们可以用<code>10</code>个循环减去<code>10</code>来完成。</li></ul><ol><li>首先将下一个字节作为计数器，首先对下一个字节清零，然后直接加上10;</li><li>我们对上一个字节减去<code>10</code>，然后对下一个字节减去<code>1</code>;</li><li>直到下一个字节为<code>0</code>即可。<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="string">[-]</span>++++++++++<span class="string">[&lt;----------&gt;-]</span>&lt;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><code>Brainfuck</code>总的来说还是非常烧脑的程序，用来写非常普通的计算程序会非常麻烦，但是我们需要这样的练习。对于负数或者浮点数感觉非常的复杂，应为<code>ieee754</code>浮点数的标准解析浮点数是非常蛋疼的一件事。目前只看到部分非常蛋疼的<code>OJ</code>上有要求用<code>brainfuck</code>代码来解题。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Brain-fuck语言&quot;&gt;&lt;a href=&quot;#Brain-fuck语言&quot; class=&quot;headerlink&quot; title=&quot;Brain fuck语言&quot;&gt;&lt;/a&gt;Brain fuck语言&lt;/h1&gt;&lt;p&gt;第一次听到&lt;code&gt;brain fuck&lt;/code&gt;语言是在提交&lt;code&gt;spoj&lt;/code&gt;第二道题目时，竟然用&lt;code&gt;brain fuck&lt;/code&gt;语言来提交题目解答，后来便自己感兴趣，去查阅了相关资料，原来还有这样一门语言，以前真的是孤陋寡闻，计算机界真有不少奇葩。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;背景：&lt;code&gt;Brainfuck&lt;/code&gt;是一种极小化的计算机语言，它是由&lt;code&gt;Urban Müller&lt;/code&gt;在1993年创建的。由于它具备图灵完整性，则意味着其实可以用这门语言实现其他编程语言实现的任何事情。先来一段&lt;code&gt;brain fuck&lt;/code&gt;代码：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/111.png&quot; alt=&quot;1&quot;&gt;&lt;br&gt;这段奇怪的符号实际为&lt;code&gt;100&lt;/code&gt;行的&lt;code&gt;Brainfuck&lt;/code&gt;虚拟机，实际代码非常晦涩难懂。&lt;/li&gt;
&lt;li&gt;现状：实际上&lt;code&gt;brain fuck&lt;/code&gt;只规定了8种简单的操作即可完成所有的操作，符合图灵完全思想的编程语言。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="语言" scheme="http://yoursite.com/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 200周赛</title>
    <link href="http://yoursite.com/2020/08/02/186/"/>
    <id>http://yoursite.com/2020/08/02/186/</id>
    <published>2020-08-02T07:53:24.458Z</published>
    <updated>2020-08-02T07:53:57.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="200场周赛"><a href="#200场周赛" class="headerlink" title="200场周赛"></a>200场周赛</h1><p>本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的<code>dp</code>即可做出来，四道题全部AC，周赛排名<code>150</code>。</p><p><img src="https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png" alt="image-20200802145522515"></p><h2 id="5475-统计好三元组"><a href="#5475-统计好三元组" class="headerlink" title="5475. 统计好三元组"></a>5475. 统计好三元组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> ，以及 <code>a、b 、c</code>三个整数。请你统计其中好三元组的数量。</p><p>如果三元组 <code>(arr[i], arr[j], arr[k])</code> 满足下列全部条件，则认为它是一个 好三元组 。</p><a id="more"></a><ul><li><code>0 &lt;= i &lt; j &lt; k &lt; arr.length</code></li><li><code>|arr[i] - arr[j]| &lt;= a</code></li><li><code>|arr[j] - arr[k]| &lt;= b</code></li><li><code>|arr[i] - arr[k]| &lt;= c</code><br>其中 <code>|x|</code> 表示 <code>x</code>的绝对值。</li></ul><p>返回 好三元组的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>], a = <span class="number">7</span>, b = <span class="number">2</span>, c = <span class="number">3</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：一共有 <span class="number">4</span> 个好三元组：[(<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>), (<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在满足所有条件的三元组。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>3 &lt;= arr.length &lt;= 100</code></li><li><code>0 &lt;= arr[i] &lt;= 1000</code></li><li><code>0 &lt;= a, b, c &lt;= 1000</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-good-triplets" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-good-triplets</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力三重循环即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countGoodTriplets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-arr[j]) &lt;= a &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[j]-arr[k]) &lt;= b &amp;&amp; </span><br><span class="line">                       <span class="built_in">abs</span>(arr[i]-arr[k]) &lt;= c)&#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5476-找出数组游戏的赢家"><a href="#5476-找出数组游戏的赢家" class="headerlink" title="5476. 找出数组游戏的赢家"></a>5476. 找出数组游戏的赢家</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个由 不同 整数组成的整数数组 <code>arr</code>和一个整数 <code>k</code>。</p><p>每回合游戏都在数组的前两个元素（即<code>arr[0]</code>和 <code>arr[1]</code> ）之间进行。比较 <code>arr[0]</code>与 <code>arr[1]</code> 的大小，较大的整数将会取得这一回合的胜利并保留在位置 <code>0</code>，较小的整数移至数组的末尾。当一个整数赢得 <code>k</code>个连续回合时，游戏结束，该整数就是比赛的 赢家 。</p><p>返回赢得比赛的整数。</p><p>题目数据 保证 游戏存在赢家。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：一起看一下本场游戏每回合的情况：</span><br><span class="line"></span><br><span class="line">因此将进行 <span class="number">4</span> 回合比赛，其中 <span class="number">5</span> 是赢家，因为它连胜 <span class="number">2</span> 回合。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 将会在前 <span class="number">10</span> 个回合中连续获胜。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">9</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>], k = <span class="number">1000000000</span></span><br><span class="line">输出：<span class="number">99</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>arr</code> 所含的整数 各不相同 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-winner-of-an-array-game</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>我们直到这样交换的下去的结果是最大的值一定处在 <code>0</code>位置处。</li><li>每次出现比首元素更大的值则进行交换。我们直接模拟这个过程即可，如果发现某个元素<code>A[i]</code>连续比后续的$A[i+1],A[i+1],A[i+1],…,A[i+k]$大时，则我们返回该元素<code>A[i]</code>,到最后一定是最大的元素被放置到<code>A[0]</code>处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWinner</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> curr = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; curr)&#123;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                curr = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5477-排布二进制网格的最少交换次数"><a href="#5477-排布二进制网格的最少交换次数" class="headerlink" title="5477. 排布二进制网格的最少交换次数"></a>5477. 排布二进制网格的最少交换次数</h2><p>给你一个<code>n x n</code>的二进制网格 <code>grid</code>，每一次操作中，你可以选择网格的 相邻两行 进行交换。</p><p>一个符合要求的网格需要满足主对角线以上的格子全部都是 <code>0</code>。</p><p>请你返回使网格满足要求的最少操作次数，如果无法使网格符合要求，请你返回 <code>-1</code> 。</p><p>主对角线指的是从 <code>(1, 1)</code>到 <code>(n, n)</code> 的这些格子。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152236.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152257.png" alt="2"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：所有行都是一样的，交换相邻行无法使网格符合要求。</span><br></pre></td></tr></table></figure><br>示例 3：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802152310.png" alt="3"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>grid[i][j]</code>要么是 <code>0</code>要么是 <code>1</code>。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-swaps-to-arrange-a-binary-grid</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>首先取出所有行的末尾0的个数。</li><li>如果按照条件要求满足第<code>i</code>行末尾<code>0</code>的个数必须要大于等于<code>n-1-i</code>,如果不存在满足要求的行则认为该矩阵无法变换成满足要求，否则则找到一个满足要求的行<code>j</code>,与第<code>i</code>行进行交换，然后第<code>i</code>行至第<code>j-1</code>行全部往后移动一行即可。</li><li>依次循环下一行，典型的贪心算法，找到第一个满足要求的行，然后交换。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwaps</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero(row,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) zero[i]++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*mini swap*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(zero[i] &gt;= (row<span class="number">-1</span>-i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(zero[j] &gt;= (row<span class="number">-1</span>-i))&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t<span class="number">-1</span>; j &gt;= i; --j)&#123;</span><br><span class="line">                swap(zero[j],zero[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += (t-i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5478-最大得分"><a href="#5478-最大得分" class="headerlink" title="5478. 最大得分"></a>5478. 最大得分</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>你有两个 有序 且数组内元素互不相同的数组 <code>nums1</code>和 <code>nums2</code>。</p><p>一条 合法路径 定义如下：</p><p>选择数组 <code>nums1</code> 或者 <code>nums2</code>开始遍历（从下标 <code>0</code>处开始）。<br>从左到右遍历当前数组。<br>如果你遇到了<code>nums1</code> 和 <code>nums2</code> 中都存在的值，那么你可以切换路径到另一个数组对应数字处继续遍历（但在合法路径中重复数字只会被统计一次）。<br>得分定义为合法路径中不同数字的和。</p><p>请你返回所有可能合法路径中的最大得分。</p><p>由于答案可能很大，请你将它对 <code>10^9 + 7</code>取余后返回。</p><p>示例 1：<br><img src="https://raw.githubusercontent.com/mike-box/picbed/master/20200802155350.png" alt="1"><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], nums2 = [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出：<span class="number">30</span></span><br><span class="line">解释：合法路径包括：</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>],（从 nums1 开始遍历）</span><br><span class="line">[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">10</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]  （从 nums2 开始遍历）</span><br><span class="line">最大得分为上图中的绿色路径 [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>], nums2 = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>]</span><br><span class="line">输出：<span class="number">109</span></span><br><span class="line">解释：最大得分由路径 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">100</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], nums2 = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line">输出：<span class="number">40</span></span><br><span class="line">解释：nums1 和 nums2 之间无相同数字。</span><br><span class="line">最大得分由路径 [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>] 得到。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">19</span>], nums2 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">输出：<span class="number">61</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums1.length &lt;= 10^5</code></li><li><code>1 &lt;= nums2.length &lt;= 10^5</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^7</code></li><li><code>nums1</code> 和 <code>nums2</code> 都是严格递增的数组。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/get-the-maximum-score" target="_blank" rel="noopener">https://leetcode-cn.com/problems/get-the-maximum-score</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>典型的dp，跟以前的某个题目很想，即两个数组中取最大的路径。</li><li>本身题目一眼看到就直到怎么做，所以肯定可以做出来，直接copy排名第一的代码。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">10000001</span>;</span><br><span class="line">        boolean[] a = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        boolean[] b = <span class="keyword">new</span> boolean[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums1)a[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : nums2)b[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">long</span> da = <span class="number">0</span>, db = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i])da += i;</span><br><span class="line">        <span class="keyword">if</span>(b[i])db += i;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &amp;&amp; b[i])&#123;</span><br><span class="line">        da = Math.max(da, db);</span><br><span class="line">        db = da;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = (<span class="keyword">int</span>)(Math.max(da, db)%<span class="number">1000000007</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;200场周赛&quot;&gt;&lt;a href=&quot;#200场周赛&quot; class=&quot;headerlink&quot; title=&quot;200场周赛&quot;&gt;&lt;/a&gt;200场周赛&lt;/h1&gt;&lt;p&gt;本周的题目比较简单，四道题目都不是特别难，特别是最后一题用简单的&lt;code&gt;dp&lt;/code&gt;即可做出来，四道题全部AC，周赛排名&lt;code&gt;150&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/mike-box/picbed/master/image-20200802145522515.png&quot; alt=&quot;image-20200802145522515&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5475-统计好三元组&quot;&gt;&lt;a href=&quot;#5475-统计好三元组&quot; class=&quot;headerlink&quot; title=&quot;5475. 统计好三元组&quot;&gt;&lt;/a&gt;5475. 统计好三元组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt; ，以及 &lt;code&gt;a、b 、c&lt;/code&gt;三个整数。请你统计其中好三元组的数量。&lt;/p&gt;&lt;p&gt;如果三元组 &lt;code&gt;(arr[i], arr[j], arr[k])&lt;/code&gt; 满足下列全部条件，则认为它是一个 好三元组 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 199周赛</title>
    <link href="http://yoursite.com/2020/07/26/185/"/>
    <id>http://yoursite.com/2020/07/26/185/</id>
    <published>2020-07-26T10:17:23.607Z</published>
    <updated>2020-08-02T07:58:45.733Z</updated>
    
    <content type="html"><![CDATA[<h1 id="199场周赛"><a href="#199场周赛" class="headerlink" title="199场周赛"></a>199场周赛</h1><p>稳定的三道选手，最后一题<code>hard</code>难度不会。</p><h2 id="5472-重新排列字符串"><a href="#5472-重新排列字符串" class="headerlink" title="5472. 重新排列字符串"></a>5472. 重新排列字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个 长度相同 的整数数组 <code>indices</code> 。</p><p>请你重新排列字符串 s ，其中第 i 个字符需要移动到<code>indices[i]</code>指示的位置。</p><p>返回重新排列后的字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"codeleet"</span>, indices = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="string">"leetcode"</span></span><br><span class="line">解释：如图所示，<span class="string">"codeleet"</span> 重新排列后变为 <span class="string">"leetcode"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abc"</span>, indices = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"abc"</span></span><br><span class="line">解释：重新排列后，每个字符都还留在原来的位置上。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aiohn"</span>, indices = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="string">"nihao"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaiougrt"</span>, indices = [<span class="number">4</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="string">"arigatou"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"art"</span>, indices = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="string">"rat"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/shuffle-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shuffle-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">restoreString</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; indices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">ans</span><span class="params">(n,<span class="string">'a'</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            ans[indices[i]] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5473-灯泡开关-IV"><a href="#5473-灯泡开关-IV" class="headerlink" title="5473. 灯泡开关 IV"></a>5473. 灯泡开关 IV</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>房间中有 n 个灯泡，编号从 <code>0</code>到 <code>n-1</code> ，自左向右排成一行。最开始的时候，所有的灯泡都是 关 着的。</p><p>请你设法使得灯泡的开关状态和 <code>target</code>描述的状态一致，其中 <code>target[i]</code>等于 <code>1</code>第 <code>i</code>个灯泡是开着的，等于 0 意味着第 <code>i</code>个灯是关着的。</p><p>有一个开关可以用于翻转灯泡的状态，翻转操作定义如下：</p><p>选择当前配置下的任意一个灯泡（下标为 i ）<br>翻转下标从<code>i</code>到 <code>n-1</code> 的每个灯泡<br>翻转时，如果灯泡的状态为 0 就变为 1，为 1 就变为 0 。</p><p>返回达成 <code>target</code>描述的状态所需的 最少 翻转次数。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"10111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：初始配置 <span class="string">"00000"</span>.</span><br><span class="line">从第 <span class="number">3</span> 个灯泡（下标为 <span class="number">2</span>）开始翻转 <span class="string">"00000"</span> -&gt; <span class="string">"00111"</span></span><br><span class="line">从第 <span class="number">1</span> 个灯泡（下标为 <span class="number">0</span>）开始翻转 <span class="string">"00111"</span> -&gt; <span class="string">"11000"</span></span><br><span class="line">从第 <span class="number">2</span> 个灯泡（下标为 <span class="number">1</span>）开始翻转 <span class="string">"11000"</span> -&gt; <span class="string">"10111"</span></span><br><span class="line">至少需要翻转 <span class="number">3</span> 次才能达成 target 描述的状态</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="string">"000"</span> -&gt; <span class="string">"111"</span> -&gt; <span class="string">"100"</span> -&gt; <span class="string">"101"</span>.</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"00000"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="keyword">target</span> = <span class="string">"001011101"</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>target[i] == &#39;0&#39; 或者 target[i] == &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iv" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iv</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目还是稍微有点<code>corner</code>,最终就是统计连续的<code>1</code>和<code>0</code>即可。</li><li>需要仔细思考一下，实际上我们可以将数目划分成初始状态相同的连续段即可，每一段作为整体翻转即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minFlips</span><span class="params">(<span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> curr = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c != curr)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                curr = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5474-好叶子节点对的数量"><a href="#5474-好叶子节点对的数量" class="headerlink" title="5474. 好叶子节点对的数量"></a>5474. 好叶子节点对的数量</h2><p>给你二叉树的根节点<code>root</code> 和一个整数 <code>distance</code>。</p><p>如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 <code>distance</code>，那它们就可以构成一组 好叶子节点对 。</p><p>返回树中 好叶子节点对的数量 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：树的叶节点是 <span class="number">3</span> 和 <span class="number">4</span> ，它们之间的最短路径的长度是 <span class="number">3</span> 。这是唯一的好叶子节点对。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：好叶子节点对为 [<span class="number">4</span>,<span class="number">5</span>] 和 [<span class="number">6</span>,<span class="number">7</span>] ，最短路径长度都是 <span class="number">2</span> 。但是叶子节点对 [<span class="number">4</span>,<span class="number">6</span>] 不满足要求，因为它们之间的最短路径长度为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">7</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="literal">null</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">2</span>], distance = <span class="number">3</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一的好叶子节点对是 [<span class="number">2</span>,<span class="number">5</span>] 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">100</span>], distance = <span class="number">1</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], distance = <span class="number">2</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>tree</code> 的节点数在<code>[1, 2^10]</code> 范围内。</li><li>每个节点的值都在 <code>[1, 100]</code>之间。</li><li><code>1 &lt;= distance &lt;= 10</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 标准的dfs</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>标准的DFS，每次统计当前节点下，所有叶子节点到该根节点的距离。</li><li>每次DFS时，先计算左子树和右子树下的所有叶子节点到子树根节点的距离。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dfs(TreeNode * root,<span class="keyword">int</span> distance,<span class="keyword">int</span> &amp; res)&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right)&#123;</span><br><span class="line">            ans[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            left = dfs(root-&gt;left,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[lv.first + <span class="number">1</span>] += lv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            right = dfs(root-&gt;right,distance,res);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv : right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rv.first + <span class="number">1</span> &lt; distance)&#123;</span><br><span class="line">                    ans[rv.first+<span class="number">1</span>] += rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> lv : left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> rv: right)&#123;</span><br><span class="line">                <span class="keyword">if</span>((lv.first + rv.first + <span class="number">2</span>) &lt;= distance)&#123;</span><br><span class="line">                    res += lv.second*rv.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        dfs(root,distance,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5462-压缩字符串-II"><a href="#5462-压缩字符串-II" class="headerlink" title="5462. 压缩字符串 II"></a>5462. 压缩字符串 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>行程长度编码 是一种常用的字符串压缩方法，它将连续的相同字符（重复 2 次或更多次）替换为字符和表示字符计数的数字（行程长度）。例如，用此方法压缩字符串 <code>&quot;aabccc&quot;</code>，将 “aa” 替换为 “a2” ，”ccc” 替换为<code>&quot;c3&quot;</code>。因此压缩后的字符串变为 <code>&quot;a2bc3&quot;</code>。</p><p>注意，本问题中，压缩时没有在单个字符后附加计数 ‘1’ 。</p><p>给你一个字符串 s 和一个整数 k 。你需要从字符串 s 中删除最多 k 个字符，以使 s 的行程长度编码长度最小。</p><p>请你返回删除最多 <code>k</code>个字符后，s 行程长度编码的最小长度 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaabcccd"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：在不删除任何内容的情况下，压缩后的字符串是 <span class="string">"a3bc3d"</span> ，长度为 <span class="number">6</span> 。最优的方案是删除 'b' 和 'd'，这样一来，压缩后的字符串为 <span class="string">"a3c3"</span> ，长度是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aabbaa"</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：如果删去两个 'b' 字符，那么压缩后的字符串是长度为 <span class="number">2</span> 的 <span class="string">"a4"</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaaaaaaaa"</span>, k = <span class="number">0</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：由于 k 等于 <span class="number">0</span> ，不能删去任何字符。压缩后的字符串是 <span class="string">"a11"</span> ，长度为 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>0 &lt;= k &lt;= s.length</code></li><li><code>s</code> 仅包含小写英文字母</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/string-compression-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-compression-ii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>dp</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>刚开始想到的也是<code>dp</code>，但是没有想到<code>dp</code>的递推公式到底该怎么写？</li><li><code>dp</code>或者记忆化搜索。</li><li>动态规划状态转移方程定义为<code>dp[i][j]</code>：</li></ol><ul><li>代表到达当前索引<code>i</code>处，已经选择删除了<code>j</code>个字符的最短长度。</li><li>假设对于当前索引<code>i+1</code>处的字符，如果我们选择删除第<code>i+1</code>个字符，则此时<script type="math/tex; mode=display">dp[i+1][j+1] = dp[i][j]</script>此时因为第<code>i+1</code>个字符已经被删除，所以我们实际上就相当于等于<code>dp[i][j]</code>.</li></ul></blockquote><ul><li>假设我们保留索引<code>i</code>处的字符，则我们应该选择后续与字符<code>i</code>相同的字符进行保留。则此时的状态转移方程为：<script type="math/tex; mode=display">dp[l][j+l-i-same(s[i],i,l)] = min(dp[i][j], len(same(s[i],i,l))]</script></li><li>方程比较难理解，意思假如我们保留当前字符串，则我们尝试在后续过程中连续增加与该字符相同的字符数量。</li></ul><ol><li>不管怎么算，最优解肯定包含在这个递推公式中，这也是动态规划的魅力。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">111</span>][<span class="number">111</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (n == k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> M = <span class="number">26</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; c(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(M));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i+<span class="number">1</span>] = c[i];</span><br><span class="line">            c[i+<span class="number">1</span>][s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; len(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">            len[i] = to_string(i).size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">                f[i][j] = INF;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] == INF) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> pos = i+<span class="number">1</span>; pos &lt;= n; ++pos)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nxt = <span class="number">0</span>; nxt &lt; <span class="number">26</span>; ++nxt)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> has = c[pos][nxt]-c[i][nxt];</span><br><span class="line">                        <span class="keyword">if</span> (has == <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i)] = min(f[pos][j+(pos-i)], f[i][j]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (j+(pos-i-has) &lt;= k)</span><br><span class="line">                                f[pos][j+(pos-i-has)] = min(f[pos][j+(pos-i-has)], f[i][j]+len[has]+<span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++j)</span><br><span class="line">            res = min(res, f[n][j]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> dp[N][N][N][<span class="number">27</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> killed, <span class="keyword">int</span> len, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == n) <span class="keyword">return</span> len &lt;= <span class="number">1</span> ? len : to_string(len).size() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>&amp; ret = dp[pos][killed][len][last];</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">        ret = N;</span><br><span class="line">        <span class="keyword">if</span> (killed + <span class="number">1</span> &lt;= m) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed + <span class="number">1</span>, len, last));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k = s[pos] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">if</span> (k == last) &#123;</span><br><span class="line">            ret = min(ret, solve(pos + <span class="number">1</span>, killed, len + <span class="number">1</span>, k));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret = min((<span class="keyword">int</span>)ret, (len &lt;= <span class="number">1</span> ? len : (<span class="keyword">int</span>)to_string(len).size() + <span class="number">1</span>) + solve(pos + <span class="number">1</span>, killed, <span class="number">1</span>, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        n = s.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;s = s;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">255</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">int</span> ret = solve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">26</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">len</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; <span class="number">1</span> &amp;&amp; k &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k &gt;= <span class="number">10</span> &amp;&amp; k &lt; <span class="number">100</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLengthOfOptimalCompression</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(k+<span class="number">2</span>,INF));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; k) dp[i][j+<span class="number">1</span>] = min(dp[i][j+<span class="number">1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> same = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> del = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = i; m &lt;= n; ++m)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s[m<span class="number">-1</span>] == s[i<span class="number">-1</span>]) same++;</span><br><span class="line">                    <span class="keyword">else</span> del++;</span><br><span class="line">                    <span class="keyword">if</span>(j + del &lt;= k)&#123;</span><br><span class="line">                        dp[m][j+del] = min(dp[m][j+del],len(same) + dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;199场周赛&quot;&gt;&lt;a href=&quot;#199场周赛&quot; class=&quot;headerlink&quot; title=&quot;199场周赛&quot;&gt;&lt;/a&gt;199场周赛&lt;/h1&gt;&lt;p&gt;稳定的三道选手，最后一题&lt;code&gt;hard&lt;/code&gt;难度不会。&lt;/p&gt;&lt;h2 id=&quot;5472-重新排列字符串&quot;&gt;&lt;a href=&quot;#5472-重新排列字符串&quot; class=&quot;headerlink&quot; title=&quot;5472. 重新排列字符串&quot;&gt;&lt;/a&gt;5472. 重新排列字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 s 和一个 长度相同 的整数数组 &lt;code&gt;indices&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;请你重新排列字符串 s ，其中第 i 个字符需要移动到&lt;code&gt;indices[i]&lt;/code&gt;指示的位置。&lt;/p&gt;&lt;p&gt;返回重新排列后的字符串。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：如图所示，&lt;span class=&quot;string&quot;&gt;&quot;codeleet&quot;&lt;/span&gt; 重新排列后变为 &lt;span class=&quot;string&quot;&gt;&quot;leetcode&quot;&lt;/span&gt; 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：重新排列后，每个字符都还留在原来的位置上。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aiohn&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;nihao&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;aaiougrt&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;arigatou&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 5：&lt;br&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：s = &lt;span class=&quot;string&quot;&gt;&quot;art&quot;&lt;/span&gt;, indices = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;string&quot;&gt;&quot;rat&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 31周双周赛</title>
    <link href="http://yoursite.com/2020/07/26/184/"/>
    <id>http://yoursite.com/2020/07/26/184/</id>
    <published>2020-07-26T01:53:36.554Z</published>
    <updated>2020-07-26T01:53:40.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="31场双周赛"><a href="#31场双周赛" class="headerlink" title="31场双周赛"></a>31场双周赛</h1><p>题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名<code>387</code>.</p><h2 id="5456-在区间范围内统计奇数数目"><a href="#5456-在区间范围内统计奇数数目" class="headerlink" title="5456. 在区间范围内统计奇数数目"></a>5456. 在区间范围内统计奇数数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">3</span>, high = <span class="number">7</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">3</span> 到 <span class="number">7</span> 之间奇数数字为 [<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：low = <span class="number">8</span>, high = <span class="number">10</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="number">8</span> 到 <span class="number">10</span> 之间奇数数字为 [<span class="number">9</span>] 。</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>0 &lt;= low &lt;= high &lt;= 10^9</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学数学问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>小学数学问题，仔细推理一下就得到结果。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countOdds</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> between = high - low;</span><br><span class="line">        <span class="keyword">if</span>(low%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (between+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> between/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5457-和为奇数的子数组数目"><a href="#5457-和为奇数的子数组数目" class="headerlink" title="5457. 和为奇数的子数组数目"></a>5457. 和为奇数的子数组数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>arr</code> 。请你返回和为 奇数 的子数组数目。</p><p>由于答案可能会很大，请你将结果对 <code>10^9 + 7</code> 取余后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有的子数组为 [[<span class="number">1</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],[<span class="number">3</span>],[<span class="number">3</span>,<span class="number">5</span>],[<span class="number">5</span>]] 。</span><br><span class="line">所有子数组的和为 [<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span>].</span><br><span class="line">奇数和包括 [<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>] ，所以答案为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2 ：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有子数组为 [[<span class="number">2</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>],[<span class="number">4</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">6</span>]] 。</span><br><span class="line">所有子数组和为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">6</span>] 。</span><br><span class="line">所有子数组和都是偶数，所以答案为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">100</span>,<span class="number">100</span>,<span class="number">99</span>,<span class="number">99</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 100</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DP</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>简单的动态规划，有两种思路。</li><li>第一种统计直到当前索引处，之前的前缀和中存在的偶数的数目和奇数的数目。</li><li>第二种统计以前一个元素<code>i-1</code>为结尾的子数组的和的数目中有多少个为偶数，有多少个为奇数。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                even++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = odd;</span><br><span class="line">                odd = even+<span class="number">1</span>;</span><br><span class="line">                even = t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + odd)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5458-字符串的好分割数目"><a href="#5458-字符串的好分割数目" class="headerlink" title="5458. 字符串的好分割数目"></a>5458. 字符串的好分割数目</h2><p>给你一个字符串<code>s</code>，一个分割被称为 「好分割」 当它满足：将 s 分割成 <code>2</code>个字符串 <code>p</code>和 <code>q</code>，它们连接起来等于 <code>s</code> 且<code>p</code> 和 <code>q</code>中不同字符的数目相同。</p><p>请你返回 <code>s</code>中好分割的数目。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aacaba"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">5</span> 种分割字符串 <span class="string">"aacaba"</span> 的方法，其中 <span class="number">2</span> 种是好分割。</span><br><span class="line">(<span class="string">"a"</span>, <span class="string">"acaba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aa"</span>, <span class="string">"caba"</span>) 左边字符串和右边字符串分别包含 <span class="number">1</span> 个和 <span class="number">3</span> 个不同的字符。</span><br><span class="line">(<span class="string">"aac"</span>, <span class="string">"aba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aaca"</span>, <span class="string">"ba"</span>) 左边字符串和右边字符串分别包含 <span class="number">2</span> 个和 <span class="number">2</span> 个不同的字符。这是一个好分割。</span><br><span class="line">(<span class="string">"aacab"</span>, <span class="string">"a"</span>) 左边字符串和右边字符串分别包含 <span class="number">3</span> 个和 <span class="number">1</span> 个不同的字符。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abcd"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：好分割为将字符串分割成 (<span class="string">"ab"</span>, <span class="string">"cd"</span>) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaaa"</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：所有分割都是好分割。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"acbadbaada"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s</code> 只包含小写英文字母。</li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 统计字符个数</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次将字符串分裂为两部分，求左右两部分的字符统计个数。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSplits</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            right[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            left[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">            right[s[i]-<span class="string">'a'</span>]--;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left[j] &gt; <span class="number">0</span>) l++;</span><br><span class="line">                <span class="keyword">if</span>(right[j] &gt; <span class="number">0</span>) r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5459-形成目标数组的子数组最少增加次数"><a href="#5459-形成目标数组的子数组最少增加次数" class="headerlink" title="5459. 形成目标数组的子数组最少增加次数"></a>5459. 形成目标数组的子数组最少增加次数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组<code>target</code>和一个数组 <code>initial</code> ，<code>initial</code> 数组与 <code>target</code>  数组有同样的维度，且一开始全部为 0 。</p><p>请你返回从 <code>initial</code> 得到  <code>target</code> 的最少操作次数，每次操作需遵循以下规则：</p><p>在 <code>initial</code> 中选择 任意 子数组，并将子数组中每个元素增加 1 。<br>答案保证在 <code>32</code>位有符号整数以内。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们需要至少 <span class="number">3</span> 次操作从 <span class="built_in">int</span>ial 数组得到 target 数组。</span><br><span class="line">[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 将下标为 <span class="number">0</span> 到 <span class="number">4</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] 将下标为 <span class="number">1</span> 到 <span class="number">3</span> 的元素（包含二者）加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>] 将下表为 <span class="number">2</span> 的元素增加 <span class="number">1</span> 。</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] 得到了目标数组。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>] (target) 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：(initial)[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] -&gt; [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>] </span><br><span class="line">                                  -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>] -&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>] (target)。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= target.length &lt;= 10^5</code></li><li><code>1 &lt;= target[i] &lt;= 10^5</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>数学问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>仔细分析一下，我们可以将类似的图画出来,数组的上升和下降描述如图所示。<br><img src="https://pic.leetcode-cn.com/3be4e85cf2f773d84ad514812a541ceabe6e333a6ae9a2bb3ed0c572051cc0bd-5.png" alt="1"></li><li>类似于爬坡，由于子数组每次增加的大小为1，我们只需要统计从每个区间从谷底爬到谷峰需要的数目之和即可。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberOperations</span><span class="params">(<span class="keyword">int</span>[] target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == null || target.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = target[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target.length; i++) &#123;</span><br><span class="line">            <span class="comment">//若target[i] - target[i - 1] &gt; 0</span></span><br><span class="line">            ans += Math.max(target[i] - target[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;31场双周赛&quot;&gt;&lt;a href=&quot;#31场双周赛&quot; class=&quot;headerlink&quot; title=&quot;31场双周赛&quot;&gt;&lt;/a&gt;31场双周赛&lt;/h1&gt;&lt;p&gt;题目非常简单，除了最后一题有点特色外，其余的题目确实比较简单。不过感觉还是难度的问题。最终排名&lt;code&gt;387&lt;/code&gt;.&lt;/p&gt;&lt;h2 id=&quot;5456-在区间范围内统计奇数数目&quot;&gt;&lt;a href=&quot;#5456-在区间范围内统计奇数数目&quot; class=&quot;headerlink&quot; title=&quot;5456. 在区间范围内统计奇数数目&quot;&gt;&lt;/a&gt;5456. 在区间范围内统计奇数数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个非负整数 low 和 high 。请你返回 low 和 high 之间（包括二者）奇数的数目。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：low = &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, high = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; 之间奇数数字为 [&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;] 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://yoursite.com/2020/07/20/183/"/>
    <id>http://yoursite.com/2020/07/20/183/</id>
    <published>2020-07-20T03:39:33.773Z</published>
    <updated>2020-07-20T15:00:57.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在<code>O(lgn)</code>时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下<code>lowbit</code>的概念.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过lowbit本质即快速的求出一个数二进制最低位的1.<br>对于原始数组<code>A[n]</code>,我们定义一个服装数组<code>tr[n]</code>.其中tr[i]为数组中<code>i</code>开始的前<code>lowbit(i)</code>个元素的和，我们可以用以下公式表示:</p><a id="more"></a><script type="math/tex; mode=display">tr[i] = \sum_{j = (i-lowbit(i)+1)}^{i}A[j]</script><p>实际上我们也可以利用前缀和，快速的求出<code>tr[i]</code>.</p><script type="math/tex; mode=display">tr[i] = presum[i] - presum[i-lowbit(i)]</script><p>利用前缀和即可在<code>O(n)</code>的时间复杂度内初始化<code>tr</code>数组。</p><ul><li><strong>单点更新</strong>：数组A[i]单点更新数组中元素单点跟新后，我们只需要找到它的父节点进行传递更新即可，采用累加<code>lowbit</code>即可。原理其实很简单，本质上是递归。将数组中<code>tr</code>中含有<code>A[i]</code>的节点全部进行更新即可。<br>更新的技巧为，我们不断的叠加<code>lowbit</code>直到<code>i</code>的大于<code>n</code>，我们如何快速的查找它的父节点呢？</li></ul><ol><li>比如<code>i</code>为12，我们如何快速找到12的父节点呢，A[12]最近的父节点为<code>tr[12]</code>.</li><li>第一次加上<code>lowbit(12)</code>,<code>i</code>变为<code>16</code>，A[12]的第二个父节点为<code>tr[16]</code>.,</li><li>第一次加上<code>lowbit(16)</code>,<code>i</code>变为<code>32</code>，A[12]的第三个父节点为<code>tr[32]</code>.,</li><li>直到<code>i</code>大于数组的长度<code>n</code>结束。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) </span><br><span class="line">        tr[i] += a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间和获取</strong>：我们可以快速的获取数组A中前<code>i</code>个元素，则区间和即为<code>tr[i]-tr[j]</code>。其实本质上我们是对<code>i</code>按照二进制进行分解，分别求出前$2^{k}$个元素。<script type="math/tex; mode=display">i = \sum_{j = 1}^{k} 2^{a^{j}}</script>可以举个例子来说明，比如数字12的二进制位<code>1100</code>,可以分解位<code>12 = 8 + 4</code>.</li></ul><ol><li>取第一次<code>lowbit(i)</code>为<code>4</code>，这时我们取得数字<code>12</code>的前4个数组中的元素分别为<code>A[12],A[11],A[10],A[9]</code>。</li><li>减掉第一个<code>lowbit(i)</code>，则数字<code>i</code>变为<code>8</code>，我们再次获取<code>i</code>的<code>lowbit(i)</code>个元素,即获取前8个元素，则这时的取得元素为：<code>A[8],A[7],A[6],A[5],A[4],A[3],A[2],A[1]</code>.<br>通过上面这个例子我们即可以看出如何进行分别求合。原理非常巧妙。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))  res += tr[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>区间更新</strong>：区间更新稍微复杂点，比如我们对数组<code>A</code>的区间<code>[i,j]</code>进行更新，比如同时在区间<code>[i,j]</code>中的元素都加上<code>x</code>,这时我们求范围和该如何解决呢？<br>首先我们思考以下，原始数组的前缀和$sum[i]$能否用辅助数组$tr$来表示呢？<script type="math/tex; mode=display">sum[i] = \sum_{k=1}^{i}A[k] = A[1] + A[2] + A[3] + ... + A[i]</script>试想一下，我们假设能够构造出差分数组$C[i]$满足如下所示：<script type="math/tex; mode=display">A[i] = C[i] - C[i-1] \\sum[n] = \sum_{i=1}^{n}A[i] = A[1] + A[2] + A[3] + ... + A[n] \\\qquad \\= (C[1]) + (C[1] + C[2]) + ... + (C[1] + C[2] + ...+ C[n]) \\\qquad \\= n*C[1] + (n-1)*C[2] + (n-2)*C[3] + ... + C[n] \\\qquad= n*(C[1] + C[2] + C[3] + ... + C[n]) - (0*C[1] + 1*C[2] + ...+(n-1)*C[n]) \\\qquad \\= n\sum_{i=1}^{n}C[i] - \sum_{i=1}^{n}C[i]*(i-1)</script>所以我们需要维护再维护两个树状数组，能够利用树状数组快速的求和，我们知道数组<code>C[i]</code>和<code>C[i]*(i-1)</code>很容易求出来。能够快速的求出<code>C[i]</code>和<code>C[i]*(i-1)</code>的区间和即可。<br>我们维护两个树状数组：<script type="math/tex; mode=display">TA[i] = C[i], TB[i] = C[i]*(i-1)</script>我们进行区间更新时，比如我们需要将原始数组<code>A[n]</code>的区间<code>[l,r]</code>中的元素都增加<code>x</code>,此时我们只需要先将<code>A[1]~A[r]</code>的元素都增加<code>x</code>,然后再将<code>A[1]~A[l]</code>中的元素都减少<code>x</code>即可。</li><li>单点更新：在<code>x</code>处增减<code>val</code>.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += (i&amp;-i))<span class="comment">//更新后缀的父节点</span></span><br><span class="line">&#123;</span><br><span class="line">TA[i] += val;</span><br><span class="line">TB[i] += val * (x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><h3 id="2-区间求极值"><a href="#2-区间求极值" class="headerlink" title="2. 区间求极值"></a>2. 区间求极值</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树状数组&quot;&gt;&lt;a href=&quot;#树状数组&quot; class=&quot;headerlink&quot; title=&quot;树状数组&quot;&gt;&lt;/a&gt;树状数组&lt;/h1&gt;&lt;p&gt;关于树状数组这个类型的题目已经看到过很多次了，每次非常容易忘记，每次看一遍都感慨发明者这个数学工具的强大，可以利用树状数组在&lt;code&gt;O(lgn)&lt;/code&gt;时间复杂度内完成对数组的区间和查询，或者区间更新。先介绍下&lt;code&gt;lowbit&lt;/code&gt;的概念.&lt;br&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lowbit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x &amp;amp; -x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;通过lowbit本质即快速的求出一个数二进制最低位的1.&lt;br&gt;对于原始数组&lt;code&gt;A[n]&lt;/code&gt;,我们定义一个服装数组&lt;code&gt;tr[n]&lt;/code&gt;.其中tr[i]为数组中&lt;code&gt;i&lt;/code&gt;开始的前&lt;code&gt;lowbit(i)&lt;/code&gt;个元素的和，我们可以用以下公式表示:&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 198场双周赛</title>
    <link href="http://yoursite.com/2020/07/19/182/"/>
    <id>http://yoursite.com/2020/07/19/182/</id>
    <published>2020-07-19T10:00:25.189Z</published>
    <updated>2020-07-20T03:20:48.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="198场双周赛"><a href="#198场双周赛" class="headerlink" title="198场双周赛"></a>198场双周赛</h1><p>微软的题目果真很难，基本上都有非常不错的技巧性，还是稳定的三题选手。自我感慨还是智商不够，无论刷再多的题目，可能永远都达不到顶尖级选手,说到底还是资质或者天赋的问题。感觉接触算法这类东西一定要早，越早越能够培养自己的思维能力，思维能力到了一定年龄就会定型或者衰退。越早发现锻炼自己思维能力的训练，越早开始。</p><a id="more"></a><h2 id="5464-换酒问题"><a href="#5464-换酒问题" class="headerlink" title="5464. 换酒问题"></a>5464. 换酒问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 <code>numBottles</code> 瓶酒。</p><p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多 能喝到多少瓶酒。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">9</span>, numExchange = <span class="number">3</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：你可以用 <span class="number">3</span> 个空酒瓶兑换 <span class="number">1</span> 瓶酒。</span><br><span class="line">所以最多能喝到 <span class="number">9</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">13</span> 瓶酒。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">15</span>, numExchange = <span class="number">4</span></span><br><span class="line">输出：<span class="number">19</span></span><br><span class="line">解释：你可以用 <span class="number">4</span> 个空酒瓶兑换 <span class="number">1</span> 瓶酒。</span><br><span class="line">所以最多能喝到 <span class="number">15</span> + <span class="number">3</span> + <span class="number">1</span> = <span class="number">19</span> 瓶酒。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">5</span>, numExchange = <span class="number">5</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = <span class="number">2</span>, numExchange = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/water-bottles" target="_blank" rel="noopener">https://leetcode-cn.com/problems/water-bottles</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  小学奥数问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>小学数学问题<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = numBottles;</span><br><span class="line">        <span class="keyword">while</span>(numBottles &gt;= numExchange)&#123;</span><br><span class="line">            res += (numBottles/numExchange);</span><br><span class="line">            numBottles = (numBottles/numExchange) + (numBottles%numExchange);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5465-子树中标签相同的节点数"><a href="#5465-子树中标签相同的节点数" class="headerlink" title="5465. 子树中标签相同的节点数"></a>5465. 子树中标签相同的节点数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 <code>0</code>到<code>n - 1</code> 的<code>n</code>个节点组成，且恰好有 <code>n - 1</code>条 <code>edges</code> 。树的根节点为节点 <code>0</code>，树上的每一个节点都有一个标签，也就是字符串 <code>labels</code> 中的一个小写字符（编号为 <code>i</code> 的 节点的标签就是 <code>labels[i]</code> ）</p><p>边数组 <code>edges</code> 以<code>edges[i] = [ai, bi]</code>的形式给出，该格式表示节点 <code>ai</code>和 <code>bi</code>之间存在一条边。</p><p>返回一个大小为<code>n</code> 的数组，其中 <code>ans[i]</code>表示第 <code>i</code> 个节点的子树中与节点<code>i</code>标签相同的节点数。</p><p>树<code>T</code> 中的子树是由 <code>T</code>中的某个节点及其所有后代节点组成的树。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">6</span>]], labels = <span class="string">"abaedcd"</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：节点 <span class="number">0</span> 的标签为 'a' ，以 'a' 为根节点的子树中，节点 <span class="number">2</span> 的标签也是 'a' ，因此答案为 <span class="number">2</span> 。注意树中的每个节点都是这棵子树的一部分。</span><br><span class="line">节点 <span class="number">1</span> 的标签为 'b' ，节点 <span class="number">1</span> 的子树包含节点 <span class="number">1</span>、<span class="number">4</span> 和 <span class="number">5</span>，但是节点 <span class="number">4</span>、<span class="number">5</span> 的标签与节点 <span class="number">1</span> 不同，故而答案为 <span class="number">1</span>（即，该节点本身）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">3</span>]], labels = <span class="string">"bbbb"</span></span><br><span class="line">输出：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">解释：节点 <span class="number">2</span> 的子树中只有节点 <span class="number">2</span> ，所以答案为 <span class="number">1</span> 。</span><br><span class="line">节点 <span class="number">3</span> 的子树中只有节点 <span class="number">3</span> ，所以答案为 <span class="number">1</span> 。</span><br><span class="line">节点 <span class="number">1</span> 的子树中包含节点 <span class="number">1</span> 和 <span class="number">2</span> ，标签都是 'b' ，因此答案为 <span class="number">2</span> 。</span><br><span class="line">节点 <span class="number">0</span> 的子树中包含节点 <span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span> 和 <span class="number">3</span>，标签都是 'b'，因此答案为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">4</span>]], labels = <span class="string">"aabab"</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>]], labels = <span class="string">"cbabaa"</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">5</span>,<span class="number">6</span>]], labels = <span class="string">"aaabaaa"</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>edges.length == n - 1</code></li><li><code>edges[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>ai != bi</code></li><li><code>labels.length == n</code></li><li><code>labels 仅由小写英文字母组成</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>常规题目DFS，统计子树含有的字母数目，然后向父节点传递。</li><li>该题有点坑的是父节点和子节点的顺序是不确定的，这就需要自己去判断，可以设标志变量什么的。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dfs(<span class="keyword">int</span> curr,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp; visit,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; tree,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; ans,<span class="built_in">string</span> &amp; labels)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(visit[curr]) <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">        visit[curr] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[curr].size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[tree[curr][i]]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = dfs(tree[curr][i],visit,tree,ans,labels);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                cnt[j] += next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[labels[curr]-<span class="string">'a'</span>]++;</span><br><span class="line">        ans[curr] = cnt[labels[curr]-<span class="string">'a'</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSubTrees(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">string</span> labels) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; tree(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n,<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            tree[edges[i][<span class="number">0</span>]].push_back(edges[i][<span class="number">1</span>]);</span><br><span class="line">            tree[edges[i][<span class="number">1</span>]].push_back(edges[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>,visit,tree,ans,labels);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5466-最多的不重叠子字符串"><a href="#5466-最多的不重叠子字符串" class="headerlink" title="5466. 最多的不重叠子字符串"></a>5466. 最多的不重叠子字符串</h2><p>给你一个只包含小写字母的字符串 <code>s</code>，你需要找到<code>s</code>中最多数目的非空子字符串，满足如下条件：</p><ul><li>这些字符串之间互不重叠，也就是说对于任意两个子字符串 <code>s[i..j]</code> 和 <code>s[k..l]</code> ，要么 <code>j &lt; k</code> 要么 <code>i &gt; l</code> 。</li><li>如果一个子字符串包含字符 <code>c</code> ，那么<code>s</code>中所有 <code>c</code>字符都应该在这个子字符串中。<br>请你找到满足上述条件的最多子字符串数目。如果有多个解法有相同的子字符串数目，请返回这些子字符串总长度最小的一个解。可以证明最小总长度解是唯一的。<br>请注意，你可以以 任意 顺序返回最优解的子字符串。</li></ul><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"adefaddaccc"</span></span><br><span class="line">输出：[<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"ccc"</span>]</span><br><span class="line">解释：下面为所有满足第二个条件的子字符串：</span><br><span class="line">[</span><br><span class="line">  <span class="string">"adefaddaccc"</span></span><br><span class="line">  <span class="string">"adefadda"</span>,</span><br><span class="line">  <span class="string">"ef"</span>,</span><br><span class="line">  <span class="string">"e"</span>,</span><br><span class="line">  <span class="string">"f"</span>,</span><br><span class="line">  <span class="string">"ccc"</span>,</span><br><span class="line">]</span><br><span class="line">如果我们选择第一个字符串，那么我们无法再选择其他任何字符串，所以答案为 <span class="number">1</span> 。如果我们选择 <span class="string">"adefadda"</span> ，剩下子字符串中我们只可以选择 <span class="string">"ccc"</span> ，它是唯一不重叠的子字符串，所以答案为 <span class="number">2</span> 。同时我们可以发现，选择 <span class="string">"ef"</span> 不是最优的，因为它可以被拆分成 <span class="number">2</span> 个子字符串。所以最优解是选择 [<span class="string">"e"</span>,<span class="string">"f"</span>,<span class="string">"ccc"</span>] ，答案为 <span class="number">3</span> 。不存在别的相同数目子字符串解。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"abbaccd"</span></span><br><span class="line">输出：[<span class="string">"d"</span>,<span class="string">"bb"</span>,<span class="string">"cc"</span>]</span><br><span class="line">解释：注意到解 [<span class="string">"d"</span>,<span class="string">"abba"</span>,<span class="string">"cc"</span>] 答案也为 <span class="number">3</span> ，但它不是最优解，因为它的总长度更长。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-number-of-non-overlapping-substrings</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 类似于滑动窗口 + 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>先求出所有字母的在字符串位置的左边界和右边界$(l_{a},r_{a})$。</li><li>求出满足题目两个要求的区间段。我们定义这样的区间内$(l_{a},r_{a})$：</li></ol><ul><li>我们在区间内遍历所有的字符，如果区间内的字符<code>x</code>的右边界$r_{x}$大于$r_{a}$，则令$r_{a} = r_{x}$</li><li>我们在区间内遍历所有的字符，如果区间内的字符<code>x</code>的左边界$l_{x}$小于$l_{a}$，则我们认为该区间$(l_{a},r_{a})$可能已经被区间$l_{x},r_{x}$包含，所以这样的区间则认为是非法的，直接去掉。</li></ul><ol><li>我们利用<code>2</code>的做法，找到所有符合的区间集合$\epsilon$。在这区间中再次进行遍历，去掉区间存在包含的区间段，比如对于区间$(l_{a},r_{a})$，如果在集合$\epsilon$中存在区间$l_{x},r_{x}$被区间$(l_{a},r_{a})$包含，满足以下条件：<script type="math/tex; mode=display">l_{a} \le l_{x},r_{x} \le r_{a}</script>则我们去掉该区间$(l_{a},r_{a})$,最后的结果即为所求。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; maxNumOfSubstrings(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(<span class="number">26</span>,n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            left[x] = min(left[x],i);</span><br><span class="line">            right[x] = max(right[x],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; curr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(right[i] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> l = left[i];</span><br><span class="line">            <span class="keyword">int</span> r = right[i];</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right[s[j]-<span class="string">'a'</span>] &gt; r)&#123;</span><br><span class="line">                    r = right[s[j]-<span class="string">'a'</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(left[s[j]-<span class="string">'a'</span>] &lt; l)&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                curr.push_back(&#123;l,r&#125;);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;s.substr(l,r-l+<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; curr.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != i &amp;&amp; (curr[i].first &lt;= curr[j].first &amp;&amp; curr[i].second &gt;= curr[j].second))&#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans.push_back(s.substr(curr[i].first,curr[i].second - curr[i].first + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5467-找到最接近目标值的函数值"><a href="#5467-找到最接近目标值的函数值" class="headerlink" title="5467. 找到最接近目标值的函数值"></a>5467. 找到最接近目标值的函数值</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Winston</code>构造了一个如上所示的函数 <code>func</code>。他有一个整数数组<code>arr</code>和一个整数 <code>target</code> ，他想找到让 <code>|func(arr, l, r) - target|</code>最小的 <code>l</code> 和<code>r</code> 。<br><img src="https://mike-box.github.io/images/186-1.png" alt="1"></p><p>请你返回 <code>|func(arr, l, r) - target|</code> 的最小值。</p><p>请注意， <code>func</code>的输入参数 <code>l</code>和 <code>r</code>需要满足<code>0 &lt;= l, r &lt; arr.length</code>。<br>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>], target = <span class="number">5</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有可能的 [l,r] 数对包括 [[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">4</span>]]， Winston 得到的相应结果为 [<span class="number">9</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] 。最接近 <span class="number">5</span> 的值是 <span class="number">7</span> 和 <span class="number">3</span>，所以最小差值为 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1000000</span>,<span class="number">1000000</span>,<span class="number">1000000</span>], target = <span class="number">1</span></span><br><span class="line">输出：<span class="number">999999</span></span><br><span class="line">解释：Winston 输入函数的所有可能 [l,r] 数对得到的函数值都为 <span class="number">1000000</span> ，所以最小差值为 <span class="number">999999</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^6</code></li><li><code>0 &lt;= target &lt;= 10^7</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-a-value-of-a-mysterious-function-closest-to-target</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>二分查找</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>我们需要注意一点，题目中是子序列进行<code>and</code>操作，所以我们知道任何两个数：<script type="math/tex; mode=display">(X \And Y) \le X</script>一个数<code>x</code>与上另外一个数<code>y</code>一定是小于等于<code>x</code>本身的。如果知道这点特性就知道数组与操作是递减的，因此：<script type="math/tex; mode=display">func(arr,l,r) \le func(arr,l,r+1)</script>由于按位与我们知道最终的值是从大到小的，所以我们知道<code>arr[i]</code>的最大值为$10^{6}\eqsim 2^{20}$,按照递减规则我们可知最终与的结果最多也就只有$20$种，因此我们可以直接用暴力搜索即可，每次记录前一次<code>i</code>与<code>(0~i-1)</code>的结果，下次将指针往后移一位即可。</li><li>根据1的推理，我们很容易联想到用二分查找，只需要每次固定<code>l</code>查找最接近<code>target</code>的两个数即可获取到差的绝对值的最小值。但是二分查找，如何先线性时间复杂度内计算出<code>arr[l]&amp;arr[l+1]&amp;...&amp;arr[r-1]&amp;arr[r]</code>的结果，我们可以利用前缀和，求出整数位<code>i</code>的前缀和，我们每次只需要计算出<code>(l,r)</code>第<code>i</code>的<code>1</code>的个数：<script type="math/tex; mode=display">sum[i] = bit[r][i] - bits[l-1][i]</script>如果<code>sum[i] == r - l + 1</code>则我们认为该位的连续与的结果不为<code>0</code>.非常巧妙的办法，然后我们就可以利用二分查找，查找出第一个大于等于<code>target</code>的数。注意题目中的测试用例，我们可以去掉连续相等的元素来加快该算法，否则会超时。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ol><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestToTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ns;</span><br><span class="line">            ns.insert(arr[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a : s)</span><br><span class="line">                ns.insert(a&amp;arr[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> a : ns)</span><br><span class="line">                ans=min(ans, <span class="built_in">abs</span>(a-target));</span><br><span class="line">            s=ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>二分查找<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; bits,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="number">0</span>)&#123;</span><br><span class="line">                x = bits[r][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x = bits[r][i] - bits[l<span class="number">-1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( x == (r-l+<span class="number">1</span>))&#123;</span><br><span class="line">                ans += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">closestToTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*detech the same element*/</span></span><br><span class="line">        arr.push_back(A[l]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); )&#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.size() &amp;&amp; A[i] == A[l]) i++;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.size() &amp;&amp; A[i] != A[l])&#123;</span><br><span class="line">                arr.push_back(A[i]);</span><br><span class="line">                l = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">             </span><br><span class="line">        <span class="comment">/*calc bits*/</span></span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; bits(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">30</span>,<span class="number">0</span>));   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt; <span class="number">0</span>) bits[i][j] += bits[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>((arr[i]&amp;(<span class="number">1</span>&lt;&lt;j))&gt;&gt;j)&#123;</span><br><span class="line">                    bits[i][j]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*binary search*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = i;</span><br><span class="line">            <span class="keyword">int</span> r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">int</span> last = arr[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> curr = calc(bits,i,mid);</span><br><span class="line">                <span class="comment">//cout&lt;&lt;l&lt;&lt;":"&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;curr&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(curr &gt;= target)&#123;</span><br><span class="line">                    t = mid;   </span><br><span class="line">                    last = curr;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*first less than target*/</span></span><br><span class="line">            ans = min(ans,<span class="built_in">abs</span>(target - last));</span><br><span class="line">            <span class="keyword">if</span>(t &lt; n<span class="number">-1</span>)&#123;</span><br><span class="line">                ans = min(ans,<span class="built_in">abs</span>(target - (last&amp;arr[t+<span class="number">1</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;198场双周赛&quot;&gt;&lt;a href=&quot;#198场双周赛&quot; class=&quot;headerlink&quot; title=&quot;198场双周赛&quot;&gt;&lt;/a&gt;198场双周赛&lt;/h1&gt;&lt;p&gt;微软的题目果真很难，基本上都有非常不错的技巧性，还是稳定的三题选手。自我感慨还是智商不够，无论刷再多的题目，可能永远都达不到顶尖级选手,说到底还是资质或者天赋的问题。感觉接触算法这类东西一定要早，越早越能够培养自己的思维能力，思维能力到了一定年龄就会定型或者衰退。越早发现锻炼自己思维能力的训练，越早开始。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>牛顿迭代法</title>
    <link href="http://yoursite.com/2020/07/16/181/"/>
    <id>http://yoursite.com/2020/07/16/181/</id>
    <published>2020-07-16T04:53:13.896Z</published>
    <updated>2020-07-16T04:53:44.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><p>今天意外的看到了牛顿迭代法，对这个理论感到很好奇，特意去网上找了下资料，牛顿迭代法<code>（Newton&#39;s method）</code>又称为牛顿-拉夫逊（拉弗森）方法<code>（Newton-Raphson method）</code>，它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。</p><ul><li><p>多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。牛顿迭代法使用函数  的泰勒级数的前面几项来寻找方程  的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程  的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。</p></li><li><p>上面的描述过于偏学术化，我们知道有些一元多次方程的最终解可能非常难求，如果直接求解的话，可能根本就没有解方程的办法，但是我们可以利用牛顿迭代法本质上可以求出方程的近似的一个或者多个解。</p></li></ul><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们设方程函数$f(x) = m$,改方程可以转化为$g(x) = f(x) - m = 0$<br>我们只需要求出函数$g(x) = 0$的解，就可以求出$f(x) = m$的解。</p><h2 id="牛顿迭代公式"><a href="#牛顿迭代公式" class="headerlink" title="牛顿迭代公式"></a>牛顿迭代公式</h2><p>设$r$ 是$f(x) = 0$的根，选取$x_{0}$作为$r$的初始近似值，则我们可以过点$(x_{0},f(x_{0}))$做曲线$y = f(x)$的切线$L$,我们知道切线与$x$轴有交点，我们已知切线$L$的方程为$L : y = f(x_{0}) + f^{‘}(x_{0})(x - x_{0})$我们求的它与$x$轴的交点为$x_{1} = x_{0} - \frac{f(x_{0})}{f^{‘}(x_{0})}$. 我们在以$(x_{1},f({x_{1}}))$斜率为$f^{‘}(x_{1})$做斜线，求出与$x$轴的交点，重复以上过程直到$f(x_{n})$无限接近于0即可。其中第n次的迭代公式为：</p><script type="math/tex; mode=display">x_{n+1} = x_{n} - \frac{f(x_{n})}{f^{'}(x_{n})}</script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>以函数$f(x) = (x-2)^{2}$为例，</p><ol><li>我们可以任意取一点A$(4,4)$,在曲线上做A的切线，求得切线与$x$轴的交点为B。<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105091145041-2070095820.png" alt="1"></li><li>在曲线上做C点的切线，交X轴与D点，在D点做X轴的垂线，交曲线于E点。我们可以看到D点比B点更加接近方程$f(x) = (x - 2) * (x - 2) = 0$ 的根$（x = 2）$.<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105091934676-1885017107.png" alt="2"></li><li>在曲线上做E点的切线，交X轴与F点，在F点做X轴的垂线，交曲线于G点。可以看到G点比D点更加接近方程的根.<br><img src="https://img2018.cnblogs.com/blog/1344012/201811/1344012-20181105092153981-1909291306.png" alt="3"></li><li>按照这个方式一直迭代即可得到函数$f(x) = 0$的近似解。</li></ol><h2 id="牛顿法求平方根"><a href="#牛顿法求平方根" class="headerlink" title="牛顿法求平方根"></a>牛顿法求平方根</h2><p>我们对实数<code>n</code>求其开方，即$f(x) = x^{2} - n = 0$得算法平方根。我们可以根据上述方法得到迭代<code>n</code>次的公式为:</p><script type="math/tex; mode=display">x_{n+1} = x_{n} - \frac{f(x_{n})}{f^{'}(x_{n})} = x_{n} - \frac{x_{n}^{2}-n}{2x_{n}} = \frac{1}{2}(x_{n} + \frac{n}{x_{n}})</script><ul><li>以下为实现代码，初始时设$x_{0} = n$.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">double</span> e = <span class="number">1e-15</span>;</span><br><span class="line">    <span class="keyword">double</span> x = c;</span><br><span class="line">    <span class="keyword">double</span> y = (x + c / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(x - y) &gt; e) &#123;</span><br><span class="line">        x = y;</span><br><span class="line">        y = (x + c / x) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">sqrt-stream</span> n)</span><br><span class="line">    (<span class="name"><span class="builtin-name">letrec</span></span> ([<span class="name">f</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">                    (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">next</span> (<span class="name"><span class="builtin-name">/</span></span> (<span class="name"><span class="builtin-name">+</span></span> x (<span class="name"><span class="builtin-name">/</span></span> n x)) <span class="number">2.0</span>)])</span><br><span class="line">                         (<span class="name"><span class="builtin-name">cons</span></span> next (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> next)))))])</span><br><span class="line">            (<span class="name"><span class="builtin-name">lambda</span></span> () (<span class="name">f</span> n))))</span><br><span class="line">                         </span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">approx-sqrt</span> n e)</span><br><span class="line">    (<span class="name">stream-until</span> (<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">&lt;</span></span> (<span class="name"><span class="builtin-name">*</span></span> e <span class="number">1.0</span>) (<span class="name"><span class="builtin-name">abs</span></span> (<span class="name"><span class="builtin-name">-</span></span> (<span class="name"><span class="builtin-name">*</span></span> n <span class="number">1.0</span>) (<span class="name"><span class="builtin-name">*</span></span> x x))))) (<span class="name">sqrt-stream</span> n)))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;牛顿迭代法&quot;&gt;&lt;a href=&quot;#牛顿迭代法&quot; class=&quot;headerlink&quot; title=&quot;牛顿迭代法&quot;&gt;&lt;/a&gt;牛顿迭代法&lt;/h1&gt;&lt;p&gt;今天意外的看到了牛顿迭代法，对这个理论感到很好奇，特意去网上找了下资料，牛顿迭代法&lt;code&gt;（Newton&amp;#39;s method）&lt;/code&gt;又称为牛顿-拉夫逊（拉弗森）方法&lt;code&gt;（Newton-Raphson method）&lt;/code&gt;，它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多数方程不存在求根公式，因此求精确根非常困难，甚至不可能，从而寻找方程的近似根就显得特别重要。牛顿迭代法使用函数  的泰勒级数的前面几项来寻找方程  的根。牛顿迭代法是求方程根的重要方法之一，其最大优点是在方程  的单根附近具有平方收敛，而且该法还可以用来求方程的重根、复根，此时线性收敛，但是可通过一些方法变成超线性收敛。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;上面的描述过于偏学术化，我们知道有些一元多次方程的最终解可能非常难求，如果直接求解的话，可能根本就没有解方程的办法，但是我们可以利用牛顿迭代法本质上可以求出方程的近似的一个或者多个解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 197场双周赛</title>
    <link href="http://yoursite.com/2020/07/13/180/"/>
    <id>http://yoursite.com/2020/07/13/180/</id>
    <published>2020-07-13T05:50:28.686Z</published>
    <updated>2020-07-13T09:42:31.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="197场双周赛"><a href="#197场双周赛" class="headerlink" title="197场双周赛"></a>197场双周赛</h1><p>稳定的三道选手，比赛排名为263名，最后一题实话实说太蛋疼了。解法诡异，<code>python</code>的梯度下降直接可以搞定。前三题都是水题毫无难度。<br><img src="https://mike-box.github.io/images/183-1.png" alt="1"></p><h2 id="5460-好数对的数目"><a href="#5460-好数对的数目" class="headerlink" title="5460. 好数对的数目"></a>5460. 好数对的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。</p><p>如果一组数字 <code>(i,j)</code>满足 <code>nums[i] == nums[j]</code>且 <code>i &lt; j</code>，就可以认为这是一组 好数对 。</p><a id="more"></a><p>返回好数对的数目。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：有 <span class="number">4</span> 组好数对，分别是 (<span class="number">0</span>,<span class="number">3</span>), (<span class="number">0</span>,<span class="number">4</span>), (<span class="number">3</span>,<span class="number">4</span>), (<span class="number">2</span>,<span class="number">5</span>) ，下标从 <span class="number">0</span> 开始</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：数组中的每组数字都是好数对</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-good-pairs" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-good-pairs</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  统计数目</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>统计数字的数目即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(x))&#123;</span><br><span class="line">                ans += cnt[x];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5461-仅含-1-的子串数"><a href="#5461-仅含-1-的子串数" class="headerlink" title="5461. 仅含 1 的子串数"></a>5461. 仅含 1 的子串数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个二进制字符串 <code>s</code>（仅由<code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的字符串）。</p><p>返回所有字符都为 1 的子字符串的数目。</p><p>由于答案可能很大，请你将它对<code>10^9 + 7</code>取模后返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"0110111"</span></span><br><span class="line">输出：<span class="number">9</span></span><br><span class="line">解释：共有 <span class="number">9</span> 个子字符串仅由 '<span class="number">1</span>' 组成</span><br><span class="line"><span class="string">"1"</span> -&gt; <span class="number">5</span> 次</span><br><span class="line"><span class="string">"11"</span> -&gt; <span class="number">3</span> 次</span><br><span class="line"><span class="string">"111"</span> -&gt; <span class="number">1</span> 次</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"101"</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：子字符串 <span class="string">"1"</span> 在 s 中共出现 <span class="number">2</span> 次</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"111111"</span></span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：每个子字符串都仅由 '<span class="number">1</span>' 组成</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"000"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>s[i] == &#39;0&#39; 或 s[i] == &#39;1&#39;</code></li><li><code>1 &lt;= s.length &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-substrings-with-only-1s</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 滑动窗口</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>统计连续<code>1</code>的个数，然后利用求合公式即可，非常简单，没啥好说的。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSub</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; s.size() &amp;&amp; s[i] == <span class="string">'1'</span>)&#123;</span><br><span class="line">                curr++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = (ans + (curr*(curr+<span class="number">1</span>))/<span class="number">2</span>)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5211-概率最大的路径"><a href="#5211-概率最大的路径" class="headerlink" title="5211. 概率最大的路径"></a>5211. 概率最大的路径</h2><p>给你一个由 <code>n</code>个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中<code>edges[i] = [a, b]</code>表示连接节点 <code>a</code> 和 <code>b</code>的一条无向边，且该边遍历成功的概率为 <code>succProb[i]</code>。</p><p>指定两个节点分别作为起点 <code>start</code> 和终点 <code>end</code>，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p><p>如果不存在从 <code>start</code>到 <code>end</code>的路径，请 返回 0 。只要答案与标准答案的误差不超过 <code>1e-5</code> ，就会被视作正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]], succProb = [<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.2</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.25000</span></span><br><span class="line">解释：从起点到终点有两条路径，其中一条的成功概率为 <span class="number">0.2</span> ，而另一条为 <span class="number">0.5</span> * <span class="number">0.5</span> = <span class="number">0.25</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">2</span>]], succProb = [<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.3</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.30000</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, edges = [[<span class="number">0</span>,<span class="number">1</span>]], succProb = [<span class="number">0.5</span>], start = <span class="number">0</span>, end = <span class="number">2</span></span><br><span class="line">输出：<span class="number">0.00000</span></span><br><span class="line">解释：节点 <span class="number">0</span> 和 节点 <span class="number">2</span> 之间不存在路径</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= n &lt;= 10^4</code></li><li><code>0 &lt;= start, end &lt; n</code></li><li><code>start != end</code></li><li><code>0 &lt;= a, b &lt; n</code></li><li><code>a != b</code></li><li><code>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</code></li><li><code>0 &lt;= succProb[i] &lt;= 1</code></li><li>每两个节点之间最多有一条边</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/path-with-maximum-probability" target="_blank" rel="noopener">https://leetcode-cn.com/problems/path-with-maximum-probability</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dijistra</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的dijistra算法，去掉概率较小的路径即可。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">maxProbability</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; succProb, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dp(n,<span class="number">0.0</span>);</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;&gt; qu;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0.0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.size(); ++i)&#123;</span><br><span class="line">            graph[edges[i][<span class="number">0</span>]].push_back(make_pair(edges[i][<span class="number">1</span>],succProb[i]));</span><br><span class="line">            graph[edges[i][<span class="number">1</span>]].push_back(make_pair(edges[i][<span class="number">0</span>],succProb[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[start] = <span class="number">1.0</span>;</span><br><span class="line">        qu.push(make_pair(start,<span class="number">1.0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; curr = qu.front();</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">int</span> x = curr.first;</span><br><span class="line">            <span class="keyword">double</span> p = curr.second;</span><br><span class="line">            <span class="keyword">if</span>(x == end)&#123;</span><br><span class="line">                ans = max(ans,p);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[x])&#123;</span><br><span class="line">                <span class="keyword">int</span> nx = v.first;</span><br><span class="line">                <span class="keyword">double</span> nxp = v.second*p;</span><br><span class="line">                <span class="keyword">if</span>(dp[nx] &gt;= nxp) <span class="keyword">continue</span>;</span><br><span class="line">                dp[nx] = nxp;</span><br><span class="line">                qu.push(make_pair(nx,nxp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5463-服务中心的最佳位置"><a href="#5463-服务中心的最佳位置" class="headerlink" title="5463. 服务中心的最佳位置"></a>5463. 服务中心的最佳位置</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一家快递公司希望在新城市建立新的服务中心。公司统计了该城市所有客户在二维地图上的坐标，并希望能够以此为依据为新的服务中心选址：使服务中心 到所有客户的欧几里得距离的总和最小 。</p><p>给你一个数组 <code>positions</code>，其中 <code>positions[i] = [xi, yi]</code> 表示第 <code>i</code>个客户在二维地图上的位置，返回到所有客户的 欧几里得距离的最小总和 。</p><p>换句话说，请你为服务中心选址，该位置的坐标<code>[xcentre, ycentre]</code>需要使下面的公式取到最小值：</p><p>与真实值误差在<code>10^-5</code>之内的答案将被视作正确答案。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4.00000</span></span><br><span class="line">解释：如图所示，你可以选 [xcentre, ycentre] = [<span class="number">1</span>, <span class="number">1</span>] 作为新中心的位置，这样一来到每个客户的距离就都是 <span class="number">1</span>，所有距离之和为 <span class="number">4</span> ，这也是可以找到的最小值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">3</span>]]</span><br><span class="line">输出：<span class="number">2.82843</span></span><br><span class="line">解释：欧几里得距离可能的最小总和为 sqrt(<span class="number">2</span>) + sqrt(<span class="number">2</span>) = <span class="number">2.82843</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = <span class="string">[[1,1]]</span></span><br><span class="line">输出：<span class="number">0.00000</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">2.73205</span></span><br><span class="line">解释：乍一看，你可能会将中心定在 [<span class="number">1</span>, <span class="number">0</span>] 并期待能够得到最小总和，但是如果选址在 [<span class="number">1</span>, <span class="number">0</span>] 距离总和为 <span class="number">3</span></span><br><span class="line">如果将位置选在 [<span class="number">1.0</span>, <span class="number">0.5773502711</span>] ，距离总和将会变为 <span class="number">2.73205</span></span><br><span class="line">当心精度问题！</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：positions = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">6</span>],[<span class="number">8</span>,<span class="number">9</span>],[<span class="number">11</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">12</span>]]</span><br><span class="line">输出：<span class="number">32.94036</span></span><br><span class="line">解释：你可以用 [<span class="number">4.3460852395</span>, <span class="number">4.9813795505</span>] 作为新中心的位置</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= positions.length &lt;= 50</code></li><li><code>positions[i].length == 2</code></li><li><code>0 &lt;= positions[i][0], positions[i][1] &lt;= 100</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/best-position-for-a-service-centre" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-position-for-a-service-centre</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>数学问题,凸函数求极值问题</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>拿到这个题目确实没有想到好办法，好多人都用的机器学习中的梯度下降法来解决这个问题的。以前确实从来没有见到过这种题型，所以不知道该怎么解决这类题目。</li><li>本质题目是凸函数求极值的问题。题目貌似为几何中位数，首先证明该函数为凸函数，如果为凸函数则表明该函数只有一个最优解，因此通过模拟得到的局部最优解也即为全局最优解。设目标函数为$f(x,y)$表示选址为<code>(x,y)</code>时的距离，我们最终求得的是最小的$f(x,y)$.<script type="math/tex; mode=display">f(x,y) = \sum_{i=1}^{n}\sqrt{(a_{i}-x)^{2}+(b_{i}-y)^{2}}</script>对$f(x,y)$分别对x,y进行求导则得到：<script type="math/tex; mode=display">\frac{\partial{f(x,y)}}{\partial{x}} = \sum_{i=1}^{n}\frac{x-a_{i}}{\sqrt{(a_{i}-x)^{2}+(b_{i}-y)^{2}}} \\\frac{\partial^{2}{f(x,y)}}{\partial{x^{2}}} = \sum_{i=1}^{n}\frac{(y-b_{i})^{2}}{((a_{i}-x)^{2}+(b_{i}-y)^{2})^{\frac{3}{2}}} \\\frac{\partial^{2}{f(x,y)}}{\partial{y^{2}}} = \sum_{i=1}^{n}\frac{(x-a_{i})^{2}}{((a_{i}-x)^{2}+(b_{i}-y)^{2})^{\frac{3}{2}}}</script>我们可以看出$f(x,y)$ 对$x$和$y$的二阶导数都大于等于<code>0</code>，因此$f(x,y)$在x方向和y方向上都应该为凸函数。<br>对于凸函数来说，凸函数的局部最优就是全局最优，所以使用基于梯度的优化方法不用担心陷入局部最优的情况。</li><li>实际可能的解法有以下三种：</li></ol><ul><li>三分</li><li>模拟退火</li><li>梯度下降</li></ul><ol><li>以下给的是<code>cuiaoxiang</code>的模拟退火算法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> ld = <span class="keyword">double</span>;</span><br><span class="line">    <span class="keyword">const</span> ld pi = <span class="number">3.1415926535897932384626</span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        ld x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            x += p[i][<span class="number">0</span>];</span><br><span class="line">            y += p[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        x /= n;</span><br><span class="line">        y /= n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> go = [&amp;](ld x, ld y)</span><br><span class="line">        &#123;</span><br><span class="line">            ld ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                ret += <span class="built_in">sqrt</span>((x-p[i][<span class="number">0</span>])*(x-p[i][<span class="number">0</span>])+(y-p[i][<span class="number">1</span>])*(y-p[i][<span class="number">1</span>]));</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        ld T = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">const</span> ld eps = <span class="number">1e-8</span>;</span><br><span class="line">        <span class="keyword">while</span> (T &gt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            T *= <span class="number">0.99</span>;</span><br><span class="line">            ld rd = (rand()%<span class="number">10000</span>+<span class="number">1</span>)/<span class="number">10000.0</span>;</span><br><span class="line">            ld a = <span class="number">2</span>*pi*rd;</span><br><span class="line">            ld tx = x+T*<span class="built_in">cos</span>(a), ty = y+T*<span class="built_in">sin</span>(a);</span><br><span class="line">            <span class="keyword">auto</span> d = go(tx, ty)-go(x, y);</span><br><span class="line">            <span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = tx, y = ty;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> go(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">sqr</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">dist</span><span class="params">(<span class="keyword">const</span> Point&amp; p, <span class="keyword">const</span> Point&amp; q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(p.x - q.x) + sqr(p.y - q.y));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt;&amp; a, Point p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; q : a) &#123;</span><br><span class="line">            ret += dist(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getMinDistSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;Point&gt; a(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) a[i] = Point&#123;(<span class="keyword">double</span>)p[i][<span class="number">0</span>], (<span class="keyword">double</span>)p[i][<span class="number">1</span>]&#125;;</span><br><span class="line">        Point c = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            c.x += p[i][<span class="number">0</span>];</span><br><span class="line">            c.y += p[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        c.x /= n;</span><br><span class="line">        c.y /= n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> step = <span class="number">50</span>; step &gt; <span class="number">1e-6</span>; ) &#123;</span><br><span class="line">            Point u = &#123;c.x + step, c.y&#125;;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x - step, c.y&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x, c.y + step&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            u = &#123;c.x, c.y - step&#125;;</span><br><span class="line">            <span class="keyword">if</span> (check(a, u) &lt; check(a, c)) c = u, found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!found) step /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> check(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;197场双周赛&quot;&gt;&lt;a href=&quot;#197场双周赛&quot; class=&quot;headerlink&quot; title=&quot;197场双周赛&quot;&gt;&lt;/a&gt;197场双周赛&lt;/h1&gt;&lt;p&gt;稳定的三道选手，比赛排名为263名，最后一题实话实说太蛋疼了。解法诡异，&lt;code&gt;python&lt;/code&gt;的梯度下降直接可以搞定。前三题都是水题毫无难度。&lt;br&gt;&lt;img src=&quot;https://mike-box.github.io/images/183-1.png&quot; alt=&quot;1&quot;&gt;&lt;/p&gt;&lt;h2 id=&quot;5460-好数对的数目&quot;&gt;&lt;a href=&quot;#5460-好数对的数目&quot; class=&quot;headerlink&quot; title=&quot;5460. 好数对的数目&quot;&gt;&lt;/a&gt;5460. 好数对的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;如果一组数字 &lt;code&gt;(i,j)&lt;/code&gt;满足 &lt;code&gt;nums[i] == nums[j]&lt;/code&gt;且 &lt;code&gt;i &amp;lt; j&lt;/code&gt;，就可以认为这是一组 好数对 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 30场双周赛</title>
    <link href="http://yoursite.com/2020/07/13/179/"/>
    <id>http://yoursite.com/2020/07/13/179/</id>
    <published>2020-07-13T00:38:11.940Z</published>
    <updated>2020-07-13T05:52:44.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30场双周赛"><a href="#30场双周赛" class="headerlink" title="30场双周赛"></a>30场双周赛</h1><p>这次双周赛的题目太水了，4个题目都是水题，估计手速快的10分钟搞定。四个题目完全没有难度。</p><h2 id="5177-转变日期格式"><a href="#5177-转变日期格式" class="headerlink" title="5177. 转变日期格式"></a>5177. 转变日期格式</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>date</code> ，它的格式为 <code>Day Month Year</code> ，其中：</p><ul><li><code>Day</code> 是集合 <code>{&quot;1st&quot;, &quot;2nd&quot;, &quot;3rd&quot;, &quot;4th&quot;, ..., &quot;30th&quot;, &quot;31st&quot;}</code>中的一个元素。</li><li><code>Month</code> 是集合<code>{&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;}</code> 中的一个元素。</li><li><code>Year</code>的范围在 <code>​[1900, 2100]</code> 之间。<br>请你将字符串转变为 <code>YYYY-MM-DD</code> 的格式，其中：</li><li><code>YYYY</code> 表示 4 位的年份。</li><li><code>MM</code> 表示 2 位的月份。</li><li><code>DD</code> 表示 2 位的天数。</li></ul><a id="more"></a><p>示例 1：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"20th Oct 2052"</span></span><br><span class="line">输出：<span class="string">"2052-10-20"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"6th Jun 1933"</span></span><br><span class="line">输出：<span class="string">"1933-06-06"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">date</span> = <span class="string">"26th May 1960"</span></span><br><span class="line">输出：<span class="string">"1960-05-26"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>给定日期保证是合法的，所以不需要处理异常输入。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/reformat-date/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/reformat-date/</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力解析</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>字符串解析<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reformatDate</span><span class="params">(self, date: str)</span> -&gt; str:</span></span><br><span class="line">        day, mon, year = date.split()</span><br><span class="line">        mon_map = [<span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>, <span class="string">"May"</span>, <span class="string">"Jun"</span>, <span class="string">"Jul"</span>, <span class="string">"Aug"</span>, <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span>]</span><br><span class="line">        mon_map = &#123;mon_map[i]:i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s-%02d-%02d"</span> % (year, mon_map[mon]+<span class="number">1</span>, int(day[:<span class="number">-2</span>]))</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5445-子数组和排序后的区间和"><a href="#5445-子数组和排序后的区间和" class="headerlink" title="5445. 子数组和排序后的区间和"></a>5445. 子数组和排序后的区间和</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>，它包含 n 个正整数。你需要计算所有非空连续子数组的和，并将它们按升序排序，得到一个新的包含 <code>n * (n + 1) / 2</code> 个数字的数组。</p><p>请你返回在新数组中下标为 <code>left</code>到 <code>right</code> （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 <code>10^9 + 7</code>取模后返回。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">1</span>, right = <span class="number">5</span></span><br><span class="line">输出：<span class="number">13</span> </span><br><span class="line">解释：所有的子数组和为 <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span> 。将它们升序排序后，我们得到新的数组 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>] 。下标从 le = <span class="number">1</span> 到 ri = <span class="number">5</span> 的和为 <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">3</span> + <span class="number">4</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">3</span>, right = <span class="number">4</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：给定数组与示例 <span class="number">1</span> 一样，所以新数组为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>] 。下标从 le = <span class="number">3</span> 到 ri = <span class="number">4</span> 的和为 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], n = <span class="number">4</span>, left = <span class="number">1</span>, right = <span class="number">10</span></span><br><span class="line">输出：<span class="number">50</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^3</code></li><li><code>nums.length == n</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li><li><code>1 &lt;= left &lt;= right &lt;= n * (n + 1) / 2</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/range-sum-of-sorted-subarray-sums/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/range-sum-of-sorted-subarray-sums/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力排序即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>没啥难度，直接排序暴力就可以过。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; ++j)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                arr.push_back(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)&#123;</span><br><span class="line">            ans = (ans + arr[i<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5446-三次操作后最大值与最小值的最小差"><a href="#5446-三次操作后最大值与最小值的最小差" class="headerlink" title="5446. 三次操作后最大值与最小值的最小差"></a>5446. 三次操作后最大值与最小值的最小差</h2><p>给你一个数组<code>nums</code> ，每次操作你可以选择<code>nums</code>中的任意一个数字并将它改成任意值。</p><p>请你返回三次操作后， <code>nums</code> 中最大值与最小值的差的最小值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：将数组 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>] 变成 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>].</span><br><span class="line">最大值与最小值的差为 <span class="number">2</span><span class="number">-2</span> = <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：将数组 [<span class="number">1</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">14</span>] 变成 [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>] 。</span><br><span class="line">最大值与最小值的差为 <span class="number">1</span><span class="number">-0</span> = <span class="number">1</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">14</span>,<span class="number">15</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/biweekly-contest-30/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves" target="_blank" rel="noopener">https://leetcode-cn.com/contest/biweekly-contest-30/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看起来很唬人，实际非常简单。我们就当作在数组中去掉三个数，然后求最大数与最小数的差。</li><li>去掉三个数，实际上即去掉数组排序后的左边和右边的三个数的组合即可。总共有四种可能：<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num<span class="string">[0]</span>,num<span class="string">[1]</span>,num<span class="string">[2]</span></span><br><span class="line">num<span class="string">[n-1]</span>,num<span class="string">[0]</span>,num<span class="string">[1]</span></span><br><span class="line">num<span class="string">[n-2]</span>,num<span class="string">[n-1]</span>,num<span class="string">[0]</span></span><br><span class="line">num<span class="string">[n-3]</span>,num<span class="string">[n-2]</span>,num<span class="string">[n-1]</span></span><br></pre></td></tr></table></figure>将以上四种可能遍历后求最大值与最小值的最小值即可，数组长度小于4的时候直接返回0。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDifference</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            ans = min(ans,nums[n<span class="number">-4</span>+i] - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5447-石子游戏-IV"><a href="#5447-石子游戏-IV" class="headerlink" title="5447. 石子游戏 IV"></a>5447. 石子游戏 IV</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><code>Alice</code> 和 <code>Bob</code>两个人轮流玩一个游戏，<code>Alice</code> 先手。</p><p>一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。</p><p>如果石子堆里没有石子了，则无法操作的玩家输掉游戏。</p><p>给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：Alice 拿走 <span class="number">1</span> 个石子并赢得胜利，因为 Bob 无法进行任何操作。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：Alice 只能拿走 <span class="number">1</span> 个石子，然后 Bob 拿走最后一个石子并赢得胜利（<span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：n 已经是一个平方数，Alice 可以一次全拿掉 <span class="number">4</span> 个石子并赢得胜利（<span class="number">4</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。</span><br><span class="line">如果 Alice 一开始拿走 <span class="number">4</span> 个石子， Bob 会拿走 <span class="number">1</span> 个石子，然后 Alice 只能拿走 <span class="number">1</span> 个石子，Bob 拿走最后一个石子并赢得胜利（<span class="number">7</span> -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br><span class="line">如果 Alice 一开始拿走 <span class="number">1</span> 个石子， Bob 会拿走 <span class="number">4</span> 个石子，然后 Alice 只能拿走 <span class="number">1</span> 个石子，Bob 拿走最后一个石子并赢得胜利（<span class="number">7</span> -&gt; <span class="number">6</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">0</span>）。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">17</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">+ `<span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/contest/biweekly-contest-30/problems/stone-game-iv/</span></span><br><span class="line">### 题意</span><br><span class="line">dp</span><br><span class="line">### 解题思路</span><br><span class="line"><span class="number">1.</span> 这个题目烂大街的水题了，dp即可，类似博弈论一样，每次双方都是最优选择，最后看谁能在最优策略下取胜。</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">bool</span> winnerSquareGame(<span class="built_in">int</span> n) &#123;</span><br><span class="line">        vector&lt;<span class="built_in">bool</span>&gt; dp(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i-j*j] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;30场双周赛&quot;&gt;&lt;a href=&quot;#30场双周赛&quot; class=&quot;headerlink&quot; title=&quot;30场双周赛&quot;&gt;&lt;/a&gt;30场双周赛&lt;/h1&gt;&lt;p&gt;这次双周赛的题目太水了，4个题目都是水题，估计手速快的10分钟搞定。四个题目完全没有难度。&lt;/p&gt;&lt;h2 id=&quot;5177-转变日期格式&quot;&gt;&lt;a href=&quot;#5177-转变日期格式&quot; class=&quot;headerlink&quot; title=&quot;5177. 转变日期格式&quot;&gt;&lt;/a&gt;5177. 转变日期格式&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;date&lt;/code&gt; ，它的格式为 &lt;code&gt;Day Month Year&lt;/code&gt; ，其中：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Day&lt;/code&gt; 是集合 &lt;code&gt;{&amp;quot;1st&amp;quot;, &amp;quot;2nd&amp;quot;, &amp;quot;3rd&amp;quot;, &amp;quot;4th&amp;quot;, ..., &amp;quot;30th&amp;quot;, &amp;quot;31st&amp;quot;}&lt;/code&gt;中的一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Month&lt;/code&gt; 是集合&lt;code&gt;{&amp;quot;Jan&amp;quot;, &amp;quot;Feb&amp;quot;, &amp;quot;Mar&amp;quot;, &amp;quot;Apr&amp;quot;, &amp;quot;May&amp;quot;, &amp;quot;Jun&amp;quot;, &amp;quot;Jul&amp;quot;, &amp;quot;Aug&amp;quot;, &amp;quot;Sep&amp;quot;, &amp;quot;Oct&amp;quot;, &amp;quot;Nov&amp;quot;, &amp;quot;Dec&amp;quot;}&lt;/code&gt; 中的一个元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Year&lt;/code&gt;的范围在 &lt;code&gt;​[1900, 2100]&lt;/code&gt; 之间。&lt;br&gt;请你将字符串转变为 &lt;code&gt;YYYY-MM-DD&lt;/code&gt; 的格式，其中：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;YYYY&lt;/code&gt; 表示 4 位的年份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MM&lt;/code&gt; 表示 2 位的月份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DD&lt;/code&gt; 表示 2 位的天数。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 196周比赛</title>
    <link href="http://yoursite.com/2020/07/05/178/"/>
    <id>http://yoursite.com/2020/07/05/178/</id>
    <published>2020-07-05T15:55:47.305Z</published>
    <updated>2020-07-09T02:42:00.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="196周比赛"><a href="#196周比赛" class="headerlink" title="196周比赛"></a>196周比赛</h1><p>对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，<code>hard</code>题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。</p><h2 id="5452-判断能否形成等差数列"><a href="#5452-判断能否形成等差数列" class="headerlink" title="5452. 判断能否形成等差数列"></a>5452. 判断能否形成等差数列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数字数组 <code>arr</code> 。</p><p>如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。</p><p>如果可以重新排列数组形成等差数列，请返回 <code>true</code>；否则，返回 <code>false</code> 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：对数组重新排序得到 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] 或者 [<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>] ，任意相邻两项的差分别为 <span class="number">2</span> 或 <span class="number">-2</span> ，可以形成等差数列。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法通过重新排序得到等差数列。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>2 &lt;= arr.length &lt;= 1000</code></li><li><code>-10^6 &lt;= arr[i] &lt;= 10^6</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接排序即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canMakeArithmeticProgression</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        sort(arr.begin(),arr.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((arr[i]-arr[i<span class="number">-1</span>]) != (arr[i<span class="number">-1</span>]-arr[i<span class="number">-2</span>])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5453-所有蚂蚁掉下来前的最后一刻"><a href="#5453-所有蚂蚁掉下来前的最后一刻" class="headerlink" title="5453. 所有蚂蚁掉下来前的最后一刻"></a>5453. 所有蚂蚁掉下来前的最后一刻</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>有一块木板，长度为<code>n</code>个 单位 。一些蚂蚁在木板上移动，每只蚂蚁都以 每秒一个单位 的速度移动。其中，一部分蚂蚁向 左 移动，其他蚂蚁向 右 移动。</p><p>当两只向 不同 方向移动的蚂蚁在某个点相遇时，它们会同时改变移动方向并继续移动。假设更改方向不会花费任何额外时间。</p><p>而当蚂蚁在某一时刻 <code>t</code>到达木板的一端时，它立即从木板上掉下来。</p><p>给你一个整数<code>n</code>和两个整数数组 <code>left</code>以及<code>right</code>。两个数组分别标识向左或者向右移动的蚂蚁在 <code>t = 0</code> 时的位置。请你返回最后一只蚂蚁从木板上掉下来的时刻。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, left = [<span class="number">4</span>,<span class="number">3</span>], right = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：如上图所示：</span><br><span class="line">-下标 <span class="number">0</span> 处的蚂蚁命名为 A 并向右移动。</span><br><span class="line">-下标 <span class="number">1</span> 处的蚂蚁命名为 B 并向右移动。</span><br><span class="line">-下标 <span class="number">3</span> 处的蚂蚁命名为 C 并向左移动。</span><br><span class="line">-下标 <span class="number">4</span> 处的蚂蚁命名为 D 并向左移动。</span><br><span class="line">请注意，蚂蚁在木板上的最后时刻是 t = <span class="number">4</span> 秒，之后蚂蚁立即从木板上掉下来。（也就是说在 t = <span class="number">4.0000000001</span> 时，木板上没有蚂蚁）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [], right = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向右移动，下标为 <span class="number">0</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, left = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>], right = []</span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：所有蚂蚁都向左移动，下标为 <span class="number">7</span> 的蚂蚁需要 <span class="number">7</span> 秒才能从木板上掉落。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, left = [<span class="number">5</span>], right = [<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：t = <span class="number">1</span> 秒时，两只蚂蚁将回到初始位置，但移动方向与之前相反。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, left = [<span class="number">6</span>], right = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li><li><code>0 &lt;= left.length &lt;= n + 1</code></li><li><code>0 &lt;= left[i] &lt;= n</code></li><li><code>0 &lt;= right.length &lt;= n + 1</code></li><li><code>0 &lt;= right[i] &lt;= n</code></li><li><code>1 &lt;= left.length + right.length &lt;= n + 1</code></li><li><code>left</code>和 <code>right</code>中的所有值都是唯一的，并且每个值 只能出现在二者之一 中。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank" target="_blank" rel="noopener">https://leetcode-cn.com/problems/last-moment-before-all-ants-fall-out-of-a-plank</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 小学奥数</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常类似于一个非常著名的小学奥数题目，信鸽的问题。比如这个信鸽飞行问题：(<a href="http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml" target="_blank" rel="noopener">http://www.aoshu.com/e/20180811/5b6e80c6679a2.shtml</a>)</li><li>不管图中有多少只蚂蚁，实际上最终的时间是由最左边且走向向右和最右边且方向向左的两只方向相对的蚂蚁决定的。类似于这样。因为两只蚂蚁调头，并且两只蚂蚁的移动速度相等，则实际就相当于两只蚂蚁调头实际等价于两只蚂蚁直接越过对方。所以总的时间只与某个蚂蚁的最长掉落时间有关。</li><li>我们求出所有蚂蚁的掉落时间，取其中最大的掉落时间即可。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastMoment</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; left, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left.size(); ++i) ans = max(ans,left[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right.size(); ++i) ans = max(ans,n-right[i]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5454-统计全-1-子矩形"><a href="#5454-统计全-1-子矩形" class="headerlink" title="5454. 统计全 1 子矩形"></a>5454. 统计全 1 子矩形</h2><p>给你一个只包含 <code>0</code>和<code>1</code>的 <code>rows * columns</code> 矩阵 <code>mat</code> ，请你返回有多少个 子矩形 的元素全部都是 1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">6</span> 个 <span class="number">1</span>x1 的矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x2 的矩形。</span><br><span class="line">有 <span class="number">3</span> 个 <span class="number">2</span>x1 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">2</span>x2 的矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x1 的矩形。</span><br><span class="line">矩形数目总共 = <span class="number">6</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">1</span> + <span class="number">1</span> = <span class="number">13</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">24</span></span><br><span class="line">解释：</span><br><span class="line">有 <span class="number">8</span> 个 <span class="number">1</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">5</span> 个 <span class="number">1</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">1</span>x3 的子矩形。</span><br><span class="line">有 <span class="number">4</span> 个 <span class="number">2</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">2</span>x2 的子矩形。</span><br><span class="line">有 <span class="number">2</span> 个 <span class="number">3</span>x1 的子矩形。</span><br><span class="line">有 <span class="number">1</span> 个 <span class="number">3</span>x2 的子矩形。</span><br><span class="line">矩形数目总共 = <span class="number">8</span> + <span class="number">5</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">24</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= rows &lt;= 150</code></li><li><code>1 &lt;= columns &lt;= 150</code></li><li><code>0 &lt;= mat[i][j] &lt;= 1</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-submatrices-with-all-ones" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-submatrices-with-all-ones</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目出的还是非常好，看似这种很简单的题目，但是背后的思考技巧，值得深入思考和思索，时间复杂度为O(n^3).首先看到题目中给定的数量范围即可知道本题的实际的时间复杂度应该为<code>O(n^3)</code>或者 <code>O(n^2lgn)</code>.</li><li>如图<img src="https://mike-box.github.io/images/181-1.png" alt="1">所示,我们每次求出以坐标(i,j)为右下角的顶点的所有矩形个数，<code>rectange(i,j)</code>.<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}rectange(i,j)</script></li><li>求这个有点技巧，我们先求出高度为h且右下角的顶点为(i,j)的矩形个数为<code>rectange(i,j，h)</code>，如图<img src="https://mike-box.github.io/images/181-2.png" alt="2">所示。<script type="math/tex; mode=display">sum = \sum_{i = 0}^{row-1}\sum_{j=0}^{col-1}\sum_{h=1}^{i} rectange(i,j,h)</script>我们只需要求出高位为h的矩形的最大宽度即可。<script type="math/tex; mode=display">w(i,j,h) = min(w(i,j,k)_{k=1}^{h-1})</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmat</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.size();</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + (j == <span class="number">0</span> ? <span class="number">0</span>:dp[i][j<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> maxColum = col;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span> &amp;&amp; dp[k][j] &gt; <span class="number">0</span>; --k)&#123;</span><br><span class="line">                    maxColum = min(maxColum,dp[k][j]);</span><br><span class="line">                    ans += maxColum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5455-最多-K-次交换相邻数位后得到的最小整数"><a href="#5455-最多-K-次交换相邻数位后得到的最小整数" class="headerlink" title="5455. 最多 K 次交换相邻数位后得到的最小整数"></a>5455. 最多 K 次交换相邻数位后得到的最小整数</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 <code>num</code>和一个整数 <code>k</code>。其中，<code>num</code>表示一个很大的整数，字符串中的每个字符依次对应整数上的各个 数位 。</p><p>你可以交换这个整数相邻数位的数字 最多 <code>k</code>次。</p><p>请你返回你能得到的最小整数，并以字符串形式返回。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"4321"</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"1342"</span></span><br><span class="line">解释：<span class="number">4321</span> 通过 <span class="number">4</span> 次交换相邻数位得到最小整数的步骤如上图所示。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：num = <span class="string">"100"</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"010"</span></span><br><span class="line">解释：输出可以包含前导 <span class="number">0</span> ，但输入保证不会有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"36789"</span>, <span class="attr">k</span> = <span class="number">1000</span></span><br><span class="line">输出：<span class="string">"36789"</span></span><br><span class="line">解释：不需要做任何交换。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"22"</span>, <span class="attr">k</span> = <span class="number">22</span></span><br><span class="line">输出：<span class="string">"22"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">num</span> = <span class="string">"9438957234785635408"</span>, <span class="attr">k</span> = <span class="number">23</span></span><br><span class="line">输出：<span class="string">"0345989723478563548"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= num.length &lt;= 30000</code></li><li><code>num</code> 只包含 数字 且不含有 前导 <code>0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>贪心算法</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol><li>题目本身用暴力法很简单，只需要在当前数位<code>i</code>后的<code>k</code>个位置内找到比<code>num[i]</code>小的最小数即可，然后交换，并同时将数位往后移动即可。这个题目确实是个高质量的好题，需要仔细思考和思索，但是遇到这类题目往往都歇菜，需要<code>ACM</code>经验的人，需要对<code>segmentTree</code>应用非常熟悉才可以。</li><li>我们可以以公式代替：<script type="math/tex; mode=display">num[i] = min(num[j]_{j=i+1}^{min(i+k,n-1)})</script>即在连续的k个位置中找到最小的num[i]。</li><li>这题的难点在于找到<code>num[i]</code>后续<code>K</code>位内的目标数<code>num[j]</code>以后,需要对<code>(i+1,j-1)</code>都需要将其索引往后移动一位，这点如何在线性时间复杂度内完成，是完成本题的关键。<br>如图<img src="https://mike-box.github.io/images/181-3.png" alt="3">所示，我们的实际移动示意如图所示。</li><li>难点在于segmentTree的使用，需要仔细学习，该题目用的树状数组可以很快解决。，大概是第2次遇到树状数组的题目了。参考这个<a href="https://www.cnblogs.com/findview/archive/2019/08/01/11281628.html" target="_blank" rel="noopener">博客</a>，写的非常明白。定义数组如下：<br><img src="https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png" alt="1"><br>我们知道设原始数组为<code>A[1...n]</code>。则我们新设置数组C如下令：<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C</span>[<span class="number">1</span>] = <span class="symbol">A</span>[<span class="number">1</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">2</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">3</span>] = <span class="symbol">A</span>[<span class="number">3</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">4</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">5</span>] = <span class="symbol">A</span>[<span class="number">5</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">6</span>] = <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">7</span>] = <span class="symbol">A</span>[<span class="number">7</span>];</span><br><span class="line"><span class="symbol">C</span>[<span class="number">8</span>] = <span class="symbol">A</span>[<span class="number">1</span>] + <span class="symbol">A</span>[<span class="number">2</span>] + <span class="symbol">A</span>[<span class="number">3</span>] + <span class="symbol">A</span>[<span class="number">4</span>] + <span class="symbol">A</span>[<span class="number">5</span>] + <span class="symbol">A</span>[<span class="number">6</span>] + <span class="symbol">A</span>[<span class="number">7</span>] + <span class="symbol">A</span>[<span class="number">8</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>实际可以归纳为：<script type="math/tex; mode=display">C[i] = A[i - 2^{k}+1] + A[i - 2^{k}+2] + ... + A[i] \\C[i] = \sum_{j = i-2^{k}+1}^{i}A[j]</script>另一个关键是，如果我们需要求出前<code>i</code>项的前缀和，这个才是树状数组的精髓，通过上述的推理如何实现？实际仔细分析一下：<br><img src="https://bkimg.cdn.bcebos.com/pic/960a304e251f95ca5e588459cf177f3e660952ab?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U4MA==,xp_5,yp_5" alt="2"><br>给定<code>i</code>,我们如何知道前<code>i</code>项的前缀和由后缀数组的哪几项组成？<br>举两个例子m7和m6（sum(i)表示求编号为i的前缀和）</li></ol><ul><li>m==7 sum(7) = C7 + C6 + C4<br>那么我们是怎么得到编号7是由哪几个C[i]求和得到呢（C4, C6, C7怎么得到的），这里有介绍一种巧妙的方法：<br>对于查询的m，将它转换成二进制后，不断对末尾的1的位置进行-1的操作，直到全部为0停止<br>7的二进制为0111（C7得到），那么先对0111的末尾1的位置-1，得到0110 == 6（C6得到），再对0110末尾1位置-1，得到0100 == 4（C4得到），最后对0100末尾1位置-1后得到0000（结束信号），计算停止，至此C7，C6，C4全部得到，求和后就是m == 7时它的前缀和。</li><li>m==6 sum(6) = C6 + C4<br>m == 6时也是一样，先转成2进制等于0110，经过两次变换后为0100（C4）和0000（结束信号），那么求和后同样也得到了预计的结果</li></ul><script type="math/tex; mode=display">sum[i] = C[i] + C[i-2^{k_{1}}] + C[i-2^{k_{1}}-2^{k_{2}}] + ...+</script><p>即每次将<code>i</code>上低位的1去掉。<br>其中<code>k</code>为数字<code>i</code>最低位连续0的个数。可以通过快速计算得到$2^{k}$.</p><script type="math/tex; mode=display">2^{k} = i\&(-i)</script><p>其中的原因如下：<br>这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 x&amp;(-x)有：<br>● 当x为0时，即 0 &amp; 0，结果为0；<br>●当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。<br>●当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x&amp; (-x) 得到的就是x。<br>●当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。<br>总结一下：x&amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。以代码形式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>知道了以上基层我们可以通过树状数组干很多事情，最重要的即为可以进行区间求合和查询。比如加我们在数组中的某个数更新了<code>num</code>.则我们只需要向上跟新即可，即更新<code>arr[i]</code>的父节点即可, 我们向上循环查找它的父节点，即每次加上<code>lowbit</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k)</span></span>&#123;    <span class="comment">//在i位置加上k</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">        c[i] += k;</span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如何求该数组的前<code>i</code>项的前缀和？我们不断的减去<code>i</code>的最低位<code>1</code>即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;        <span class="comment">//求A[1 - i]的和</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        res += c[i];</span><br><span class="line">        i -= lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>假设求区间<code>[i,j]</code>的和，则我们可以利用两个前缀和的组合实现即可。<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(<span class="name">i</span>,j) = getsum(<span class="name">j</span>) - getsum(<span class="name">i-1</span>)</span><br></pre></td></tr></table></figure></li><li><p>区间更新如何实现？</p></li><li><p>例题参考：</p></li></ol><ul><li><a href="https://www.luogu.org/problem/show?pid=3368" target="_blank" rel="noopener">https://www.luogu.org/problem/show?pid=3368</a></li><li><a href="https://vjudge.net/problem/POJ-3468" target="_blank" rel="noopener">https://vjudge.net/problem/POJ-3468</a></li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul><li>暴力<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = 0; i &lt; n &amp;&amp; k &gt; <span class="number">0</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; j &lt;= i + k; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num[j] &lt; num[t])&#123;</span><br><span class="line">                    t = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = num[t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = t; j &gt; i; --j)&#123;</span><br><span class="line">                num[j] = num[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            num[i] = c;</span><br><span class="line">            k -= t - i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>SegmentTree<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt; N; x += x &amp; -x) &#123;</span><br><span class="line">        c[x] += y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= x &amp; -x) &#123;</span><br><span class="line">        ret += c[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minInteger</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;&gt; pos(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = s[i] - <span class="string">'0'</span>;</span><br><span class="line">            pos[x].push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; pick(n);</span><br><span class="line">        fill(c, c + N, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) add(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (m) &#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos[k].empty()) <span class="keyword">continue</span>;</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">char</span> c = (<span class="keyword">char</span>)(<span class="string">'0'</span> + k);</span><br><span class="line">                <span class="keyword">int</span> x = pos[k].front();</span><br><span class="line">                <span class="keyword">int</span> cnt = query(x);</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= cnt) &#123;</span><br><span class="line">                    m -= cnt;</span><br><span class="line">                    add(x + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">                    ret += c;</span><br><span class="line">                    pick[x] = <span class="literal">true</span>;</span><br><span class="line">                    pos[k].pop();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!found) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pick[i]) ret += s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minInteger</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//pqs stores the location of each digit.</span></span><br><span class="line">        List&lt;Queue&lt;Integer&gt;&gt; pqs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            pqs.add(<span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            pqs.get(num.charAt(i) - <span class="string">'0'</span>).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        String ans = <span class="string">""</span>;</span><br><span class="line">        SegmentTree seg = <span class="keyword">new</span> SegmentTree(num.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.length(); ++i) &#123;</span><br><span class="line">            <span class="comment">// At each location, try to place 0....9</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt;= <span class="number">9</span>; ++digit) &#123;</span><br><span class="line">                <span class="comment">// is there any occurrence of digit left?</span></span><br><span class="line">                <span class="keyword">if</span> (pqs.get(digit).size() != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// yes, there is a occurrence of digit at pos</span></span><br><span class="line">                    Integer pos = pqs.get(digit).peek();</span><br><span class="line"><span class="comment">// Since few numbers already shifted to left, this `pos` might be outdated.</span></span><br><span class="line">                    <span class="comment">// we try to find how many number already got shifted that were to the left of pos.</span></span><br><span class="line">                    <span class="keyword">int</span> shift = seg.getCountLessThan(pos);</span><br><span class="line">                    <span class="comment">// (pos - shift) is number of steps to make digit move from pos to i.</span></span><br><span class="line">                    <span class="keyword">if</span> (pos - shift &lt;= k) &#123;</span><br><span class="line">                        k -= pos - shift;</span><br><span class="line">                        seg.add(pos); <span class="comment">// Add pos to our segment tree.</span></span><br><span class="line">                        pqs.get(digit).remove();</span><br><span class="line">                        ans += digit;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SegmentTree</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nodes;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SegmentTree</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">            nodes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span> * (max)];</span><br><span class="line">            n = max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            addUtil(num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addUtil</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt; l || num &gt; r) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                nodes[node]++;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            addUtil(num, l, mid, <span class="number">2</span> * node + <span class="number">1</span>);</span><br><span class="line">            addUtil(num, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">            nodes[node] = nodes[<span class="number">2</span> * node + <span class="number">1</span>] + nodes[<span class="number">2</span> * node + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Essentialy it tells number of numbers &lt; num.</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCountLessThan</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getUtil(<span class="number">0</span>, num, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getUtil</span><span class="params">(<span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (qr &lt; l || ql &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span> nodes[node];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> getUtil(ql, qr, l, mid, <span class="number">2</span> * node + <span class="number">1</span>) + getUtil(ql, qr, mid + <span class="number">1</span>, r, <span class="number">2</span> * node + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;196周比赛&quot;&gt;&lt;a href=&quot;#196周比赛&quot; class=&quot;headerlink&quot; title=&quot;196周比赛&quot;&gt;&lt;/a&gt;196周比赛&lt;/h1&gt;&lt;p&gt;对于我这种菜鸟级别的选手来说，感觉题目还是挺难的，&lt;code&gt;hard&lt;/code&gt;题目依旧不会做。只能说自己是个勤奋的人，但不是个聪明的人。&lt;/p&gt;&lt;h2 id=&quot;5452-判断能否形成等差数列&quot;&gt;&lt;a href=&quot;#5452-判断能否形成等差数列&quot; class=&quot;headerlink&quot; title=&quot;5452. 判断能否形成等差数列&quot;&gt;&lt;/a&gt;5452. 判断能否形成等差数列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数字数组 &lt;code&gt;arr&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。&lt;/p&gt;&lt;p&gt;如果可以重新排列数组形成等差数列，请返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>2020年下半年计划（7月）</title>
    <link href="http://yoursite.com/2020/07/05/177/"/>
    <id>http://yoursite.com/2020/07/05/177/</id>
    <published>2020-07-05T14:36:53.225Z</published>
    <updated>2020-07-13T09:52:59.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2020年全年计划"><a href="#2020年全年计划" class="headerlink" title="2020年全年计划"></a>2020年全年计划</h1><p>2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。</p><h3 id="个人学习计划"><a href="#个人学习计划" class="headerlink" title="个人学习计划"></a>个人学习计划</h3><h4 id="书籍阅读计划"><a href="#书籍阅读计划" class="headerlink" title="书籍阅读计划"></a>书籍阅读计划</h4><p>今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：</p><a id="more"></a><div class="table-container"><table><thead><tr><th>序号</th><th>书籍名称</th><th>进度</th><th>种类</th></tr></thead><tbody><tr><td>1</td><td>少有人走的路</td><td>90%</td><td>心理学相关</td></tr><tr><td>2</td><td>人性的幽微</td><td>100%</td><td>心理学与个人成长相关</td></tr><tr><td>3</td><td>睡眠革命</td><td>100%</td><td>个人习惯养成</td></tr><tr><td>4</td><td>每周工作4小时</td><td>20%</td><td>个人成长系列</td></tr><tr><td>5</td><td>佐贺的超级阿嬷</td><td>100%</td><td>个人纪实成长</td></tr><tr><td>6</td><td>郭鹤年自传</td><td>100%</td><td>个人自传</td></tr><tr><td>7</td><td>自私的基因</td><td>%</td><td></td></tr><tr><td>8</td><td>爱弥儿</td><td>%</td><td></td></tr><tr><td>9</td><td>李光耀观天下</td><td>%</td><td></td></tr><tr><td>10</td><td>金字塔原理</td><td>%</td><td></td></tr><tr><td>11</td><td>怎样解题</td><td>%</td><td></td></tr><tr><td>12</td><td>火与烬</td><td>%</td><td></td></tr><tr><td>13</td><td>人类简史</td><td>%</td><td></td></tr><tr><td>14</td><td>从0到无穷大</td><td>%</td><td></td></tr><tr><td>15</td><td>走出自己的天空</td><td>100%</td><td></td></tr><tr><td>16</td><td></td><td>%</td><td></td></tr><tr><td>17</td><td></td><td>%</td><td></td></tr><tr><td>18</td><td></td><td>%</td><td></td></tr><tr><td>19</td><td></td><td>%</td><td></td></tr><tr><td>20</td><td></td><td>%</td></tr></tbody></table></div><h4 id="课程学习计划"><a href="#课程学习计划" class="headerlink" title="课程学习计划"></a>课程学习计划</h4><p>今年的课程学习我想主要以公开课相关课程学习，计划今年要学习20门以上公开课学习。计划学习人文类的课程和计算机技术的相关课程，以下是大概今年的30门课程计划，计划列表如下，以后每个月会定时更新自己的进度。</p><div class="table-container"><table><thead><tr><th>序号</th><th>课程名称</th><th>进度</th><th>类别</th><th>完成时间</th></tr></thead><tbody><tr><td>1</td><td>coursera: Learning How to Learn: Powerful mental tools to help you master tough subjects</td><td>100%</td><td>人文社科类</td><td>2020.1</td></tr><tr><td>2</td><td>coursera: algorithmic-toolbox</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>3</td><td>coursera: algorithms-on-strings</td><td>100%</td><td>computer scinece</td><td>2020.4</td></tr><tr><td>4</td><td>coursera：algorithms-on-graphs</td><td>100%</td><td>computer scinece</td><td>2020.5</td></tr><tr><td>5</td><td>coursera： algorithms-part2</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>6</td><td>coursera： data-structures</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>7</td><td>coursera： algorithms-part1</td><td>100%</td><td>computer scinece</td><td>2020.3</td></tr><tr><td>8</td><td>coursera：programming-languages partA</td><td>100%</td><td>computer scinece</td><td>2020.6</td></tr><tr><td>9</td><td>coursera：programming-languages partB</td><td>40%</td><td>computer scinece</td><td></td></tr><tr><td>10</td><td>coursera：programming-languages partC</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>11</td><td>coursera：Build a Modern Computer from First Principles: From Nand to Tetris I</td><td>62%</td><td>computer scinece</td><td>2020.7.5</td></tr><tr><td>12</td><td>coursera：Build a Modern Computer from First Principles: From Nand to Tetris II</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>13</td><td>coursera：Machine-learning-techniques</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>14</td><td>coursera：Machine Learning Foundations</td><td>0%</td><td>computer scinece</td><td></td></tr><tr><td>15</td><td>哈佛大学公开课: 学习失败碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>16</td><td>哈佛大学公开课：立大志</td><td>0%</td><td></td><td></td></tr><tr><td>17</td><td>清华大学：高级数据结构</td><td>0%</td><td></td><td></td></tr><tr><td>18</td><td>哈佛大学公开课：科学与烹饪</td><td>0%</td><td></td><td></td></tr><tr><td>19</td><td>哈佛大学公开课：积极心理学碎剪</td><td>0%</td><td></td><td></td></tr><tr><td>20</td><td>哈佛大学公开课：幸福课</td><td>0%</td><td></td><td></td></tr><tr><td>21</td><td>MIT 6.82 opertion system</td><td>0%</td><td></td><td></td></tr><tr><td>22</td><td>MIT 6.824 distribution System</td><td>0%</td><td></td><td></td></tr><tr><td>23</td><td>MIT DatabaseT Systems:</td><td>0%</td><td></td><td></td></tr><tr><td>24</td><td>MIT Advances in Computer Vision</td><td>0%</td><td></td><td></td></tr><tr><td>25</td><td>Javascript</td><td>0%</td><td></td><td></td></tr><tr><td>26</td><td>TensorFlow in Practice</td><td>0%</td><td></td><td></td></tr><tr><td>27</td><td>MIT:  Structure and Interpretation of Computer Programs</td><td>0%</td><td></td><td></td></tr><tr><td>28</td><td>Princeton : An Introduction to the Analysis of Algorithms</td><td>0%</td><td></td><td></td></tr><tr><td>29</td><td>MIT 6.851</td><td>0%</td><td></td><td></td></tr><tr><td>30</td><td>MIT Multicore Programming Primer</td><td>0%</td><td></td></tr></tbody></table></div><h4 id="考证认证"><a href="#考证认证" class="headerlink" title="考证认证"></a>考证认证</h4><ul><li>完成雅思认证</li><li>完成GRE认证</li><li>完成SAT考试<h4 id="刷题计划"><a href="#刷题计划" class="headerlink" title="刷题计划"></a>刷题计划</h4></li></ul><p>　　仔细看了许多所谓的刷题平台，实际上感觉单纯的枯燥的刷题实在是对进步不大，因为单纯的刷题很容易让人产生枯燥和烦躁的感觉，因为只有自己孤单一个人刷题，遇到问题也没有人跟你一起讨论，一起想解决办法。<br>　　我觉得CP练习的最好方式就是以考代练，先过一遍基础的理论和基础的题目，然后通过不断的参加定期的contest练习，反思的思考，跟他人讨论，总结，反馈，我觉得这样才是进步较快，一方面能够避免单纯刷题的枯燥；另一方面通过参加contest，适当的能够提高自己的紧张感觉，强迫自己思考的快速；第三，因为contest结束之后都有很多人参与一起讨论问题的解法，可以快速的学习他人的解题思路和方法，与高手交流才能快速进步；第四，contest都是定期举行，可以非常有效的防止刷题的偷懒，强迫自己定期的练习和提高，给人以监督感。以上四点我认为是<code>contest</code>作为练习的最大有点。在youtube上看到几个牛人都是定期参加各自<code>contest</code>，来保持自己的水平。<br>　　总和看来，我觉得以下三个平台适合新手难度的平台，<code>leetcode</code>适合程序员面试，<code>Atcoder</code>和<code>codeforces</code> 适合<code>CP</code>初级选手练习，上面有许多非常好的题目和牛人，是一个值得终身去学习和跟随的平台。特别是强调的是，这三个平台的社区都运营的很好，在上面能够碰到许多牛人，能够跟大牛一起讨论学习进步，学习他们的解题思路，学习他们的学习方法，这才是最关键的。</p><ul><li><strong>Leetcode contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td>contest 194</td><td>3</td><td>101</td><td>yes</td></tr><tr><td>2</td><td>biweekly contest 29</td><td>3</td><td>275</td><td>yes</td></tr><tr><td>3</td><td>contest 195</td><td>3</td><td>195</td><td>yes</td></tr><tr><td>4</td><td>contest 196</td><td>2</td><td>2138</td><td>yes</td></tr><tr><td>5</td><td>biweekly contest 30</td><td>4</td><td>128</td><td>yes</td></tr><tr><td>6</td><td>contest 197</td><td>3</td><td>263</td><td>yes</td></tr><tr><td>7</td><td>contest 198</td><td></td><td></td><td></td></tr><tr><td>8</td><td>biweekly contest 31</td><td></td><td></td><td></td></tr><tr><td>9</td><td>contest 199</td><td></td><td></td><td></td></tr><tr><td>10</td><td>contest 200</td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Codeforces contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><strong>Atbeginner contest</strong></li></ul><div class="table-container"><table><thead><tr><th>index</th><th>contest</th><th>sloveed</th><th>Rank</th><th>review</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><h3 id="个人理财计划"><a href="#个人理财计划" class="headerlink" title="个人理财计划"></a>个人理财计划</h3><ul><li><strong>积蓄</strong></li><li><strong>基金</strong></li><li><strong>美股投资</strong></li><li><strong>平台</strong></li></ul><h3 id="个人健康计划"><a href="#个人健康计划" class="headerlink" title="个人健康计划"></a>个人健康计划</h3><ul><li>游泳计划</li></ul><div class="table-container"><table><thead><tr><th>序号</th><th>打卡日期</th><th>时间</th><th>游泳距离</th></tr></thead><tbody><tr><td>1</td><td>2020.7.12</td><td>20</td><td>500米</td><td></td></tr><tr><td>2</td><td></td><td></td><td></td><td></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li>健身计划</li></ul><h3 id="个人家庭计划"><a href="#个人家庭计划" class="headerlink" title="个人家庭计划"></a>个人家庭计划</h3><ul><li>放假计划安排</li><li>出游计划安排</li><li>儿女学习安排</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;2020年全年计划&quot;&gt;&lt;a href=&quot;#2020年全年计划&quot; class=&quot;headerlink&quot; title=&quot;2020年全年计划&quot;&gt;&lt;/a&gt;2020年全年计划&lt;/h1&gt;&lt;p&gt;2020年已经过完半年，还有许多目标并未达成，希望自己能够快速的反思和反省自己。以下为2020年下半年的计划总结和全年总结，希望自己能够达成全年目标。通过量化的列举自己的目标和计划来督促自己的年度计划实现。&lt;/p&gt;&lt;h3 id=&quot;个人学习计划&quot;&gt;&lt;a href=&quot;#个人学习计划&quot; class=&quot;headerlink&quot; title=&quot;个人学习计划&quot;&gt;&lt;/a&gt;个人学习计划&lt;/h3&gt;&lt;h4 id=&quot;书籍阅读计划&quot;&gt;&lt;a href=&quot;#书籍阅读计划&quot; class=&quot;headerlink&quot; title=&quot;书籍阅读计划&quot;&gt;&lt;/a&gt;书籍阅读计划&lt;/h4&gt;&lt;p&gt;今年计划完完成阅读书籍20本，目前已经阅读大概5本左右，几年阅读量严重不达标，不知道是因为工作忙的原因还是因为哪些原因导致阅读量不够，需要继续督促自己完成年度目标任务和计划。列表如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="个人计划" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="个人总结" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
