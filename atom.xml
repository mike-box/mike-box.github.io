<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>blow in the wind</title>
  
  <subtitle>just code for fun</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-02T10:23:11.781Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mike meng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Coursera】 算法课程</title>
    <link href="http://yoursite.com/2020/05/02/156/"/>
    <id>http://yoursite.com/2020/05/02/156/</id>
    <published>2020-05-02T10:23:04.359Z</published>
    <updated>2020-05-02T10:23:11.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Algorithmic-Toolbox"><a href="#Algorithmic-Toolbox" class="headerlink" title="Algorithmic Toolbox"></a>Algorithmic Toolbox</h1><p>最近准备学习<code>coursera</code>上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较<code>trikly</code>以外，其余的都是基本题目。得分是<code>100</code> 分，证书如下：<br><a href="https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST" target="_blank" rel="noopener">Algorithmic Toolbox</a><br>下面将该课程的题目的解法。<br>该课程所有提交的代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox/week1_programming_challenges" target="_blank" rel="noopener">source code</a></p><a id="more"></a><h2 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h2><h3 id="1-Sum-of-Two-Digits"><a href="#1-Sum-of-Two-Digits" class="headerlink" title="1. Sum of Two Digits"></a>1. Sum of Two Digits</h3><p>We start from this ridiculously simple problem to show you the<br>pipeline of reading the problem statement, designing an algorithm, implementing<br>it, testing and debugging your program, and submitting it to<br>the grading system.<br>Input format. Integers a and b on the same line (separated by a space).<br>Output format. The sum of a and b.<br>Constraints. 0  a;b  9.<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sample.</span><br><span class="line">Input:</span><br><span class="line"><span class="number">9</span> <span class="number">7</span></span><br><span class="line">Output:</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure></p><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p> 直接相加</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>相加即可<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_of_two_digits</span><span class="params">(<span class="keyword">int</span> first_digit, <span class="keyword">int</span> second_digit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first_digit + second_digit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum_of_two_digits(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h3 id="2-Maximum-Pairwise-Product"><a href="#2-Maximum-Pairwise-Product" class="headerlink" title="2 Maximum Pairwise Product"></a>2 Maximum Pairwise Product</h3><p>Given a sequence of non-negative integers a1; : : : ;an, compute<br>max<br>1i,jn<br>ai  aj :<br>Note that i and j should be different, though it may be the case that ai = aj .<br>Input format. The first line contains an integer n. The next line contains<br>n non-negative integers a1; : : : ;an (separated by spaces).<br>Output format. The maximum pairwise product.<br>Constraints. 2  n  2  105; 0  a1; : : : ;an  2  105.</p><p>Sample 1.<br>Input:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><br>Output:<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>1.找到二维数组中的最大的两个元素即可，返回他们的乘积，时间复杂度$O(n)$。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">MaxPairwiseProduct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> max_product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &gt; first)&#123;</span><br><span class="line">            second = first;</span><br><span class="line">            first = numbers[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] &gt; second)&#123;</span><br><span class="line">            second = numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first*second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; MaxPairwiseProduct(numbers) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h2><h3 id="Fibonacci-Number"><a href="#Fibonacci-Number" class="headerlink" title="Fibonacci Number"></a>Fibonacci Number</h3><p>Given an integer 𝑛, find the 𝑛th Fibonacci number 𝐹𝑛.</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol><li>非常简单了，找到第<code>n</code>个斐波那契数。<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following code calls a naive algorithm for computing a Fibonacci number.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// What to do:</span></span><br><span class="line"><span class="comment">// 1. Compile the following code and run it on an input "40" to check that it is slow.</span></span><br><span class="line"><span class="comment">//    You may also want to submit it to the grader to ensure that it gets the "time limit exceeded" message.</span></span><br><span class="line"><span class="comment">// 2. Implement the fibonacci_fast procedure.</span></span><br><span class="line"><span class="comment">// 3. Remove the line that prints the result of the naive algorithm, comment the lines reading the input,</span></span><br><span class="line"><span class="comment">//    uncomment the line with a call to test_solution, compile the program, and run it.</span></span><br><span class="line"><span class="comment">//    This will ensure that your efficient algorithm returns the same as the naive one for small values of n.</span></span><br><span class="line"><span class="comment">// 4. If test_solution() reveals a bug in your implementation, debug it, fix it, and repeat step 3.</span></span><br><span class="line"><span class="comment">// 5. Remove the call to test_solution, uncomment the line with a call to fibonacci_fast (and the lines reading the input),</span></span><br><span class="line"><span class="comment">//    and submit it to the grader.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fibonacci_naive(n - <span class="number">1</span>) + fibonacci_naive(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fibonacci_fast</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        f3 = f2 + f1;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(fibonacci_fast(<span class="number">3</span>) == <span class="number">2</span>);</span><br><span class="line">    assert(fibonacci_fast(<span class="number">10</span>) == <span class="number">55</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">20</span>; ++n)</span><br><span class="line">        assert(fibonacci_fast(n) == fibonacci_naive(n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; fibonacci_naive(n) &lt;&lt; '\n';</span></span><br><span class="line">    <span class="comment">//test_solution();</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fibonacci_fast(n) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-Last-Digit-of-a-Large-Fibonacci-Number"><a href="#2-Last-Digit-of-a-Large-Fibonacci-Number" class="headerlink" title="2 Last Digit of a Large Fibonacci Number"></a>2 Last Digit of a Large Fibonacci Number</h3><p>Your goal in this problem is to find the last digit of 𝑛-th Fibonacci number. Recall that Fibonacci numbers<br>grow exponentially fast. For example,<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">𝐹<span class="number">200</span> = <span class="number">280</span> <span class="number">571</span> <span class="number">172</span> <span class="number">992</span> <span class="number">510</span> <span class="number">140</span> <span class="number">037</span> <span class="number">611</span> <span class="number">932</span> <span class="number">413</span> <span class="number">038</span> <span class="number">677</span> <span class="number">189</span> <span class="number">525</span> .</span><br></pre></td></tr></table></figure></p><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol><li>找到斐波那契数的个位数。</li><li>我们直接对每一位取模即可。<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_fibonacci_last_digit_naive</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> current  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_previous = previous%<span class="number">10</span>;</span><br><span class="line">        previous = current%<span class="number">10</span>;</span><br><span class="line">        current = (tmp_previous + current)%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> c = get_fibonacci_last_digit_naive(n);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Greatest-Common-Divisor"><a href="#3-Greatest-Common-Divisor" class="headerlink" title="3 Greatest Common Divisor"></a>3 Greatest Common Divisor</h3>The greatest common divisor GCD(𝑎, 𝑏) of two non-negative integers 𝑎 and 𝑏<br>(which are not both equal to 0) is the greatest integer 𝑑 that divides both 𝑎 and 𝑏.<br>Your goal in this problem is to implement the Euclidean algorithm for computing<br>the greatest common divisor.<br>Efficient algorithm for computing the greatest common divisor is an important<br>basic primitive of commonly used cryptographic algorithms like RSA.</li></ol><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol><li>牛顿法找到两个数的最大公约数即可。<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_naive(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_naive(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; gcd_naive(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Least-Common-Multiple"><a href="#4-Least-Common-Multiple" class="headerlink" title="4 Least Common Multiple"></a>4 Least Common Multiple</h3><p>Given two integers 𝑎 and 𝑏, find their least common multiple.</p><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><ol><li>找到两个数的最小公倍数。</li><li>先找两个数的最大公约数，然后乘以他们各自除以最大公约数的结果。<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd_fast</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> gcd_fast(b,a);</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd_fast(a%b,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_naive</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">long</span> l = <span class="number">1</span>; l &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>) a * b; ++l)</span><br><span class="line">    <span class="keyword">if</span> (l % a == <span class="number">0</span> &amp;&amp; l % b == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">lcm_fast</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">long</span>) (a * b)/gcd_fast(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(lcm_fast(<span class="number">6</span>,<span class="number">8</span>) == <span class="number">24</span>);</span><br><span class="line">    assert(lcm_fast(<span class="number">761457</span>,<span class="number">614573</span>) == <span class="number">467970912861</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">  test_solution();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcm_fast(a, b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Fibonacci-Number-Again"><a href="#5-Fibonacci-Number-Again" class="headerlink" title="5 Fibonacci Number Again"></a>5 Fibonacci Number Again</h3>In this problem, your goal is to compute 𝐹𝑛 modulo 𝑚, where 𝑛 may be really huge: up to 1014. For such<br>values of 𝑛, an algorithm looping for 𝑛 iterations will not fit into one second for sure. Therefore we need to<br>avoid such a loop.<br>To get an idea how to solve this problem without going through all 𝐹𝑖 for 𝑖 from 0 to 𝑛, let’s see what<br>happens when 𝑚 is small — say, 𝑚 = 2 or 𝑚 = 3.</li></ol><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><ol><li>用数学方法可以证明斐波那契数列对某个自然数取模后的结果一定存在循环，数学证明方法比较复杂就不展开讲了，知道它肯定会循环，我们需要找到它的循环周期<code>T</code>,则后续处理就非常简单。</li><li>我们只需要找到连续的两个数取模后的结果分别为<code>0,1</code>这即为循环序列的开始，题目稍微有点复杂。<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_pisano_period</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; (m*m); ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">        <span class="keyword">if</span>(previous == <span class="number">0</span> &amp;&amp; current == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_fibonacci_huge_naive</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> current  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> period = get_pisano_period(m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = n%period;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; mod<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp_previous = previous;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = (tmp_previous + current)%m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_fibonacci_huge_naive(n, m) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers"><a href="#6-8-Last-Digit-of-the-Sum-of-Fibonacci-Numbers" class="headerlink" title="6-8 Last Digit of the Sum of Fibonacci Numbers"></a>6-8 Last Digit of the Sum of Fibonacci Numbers</h3><p>The goal in this problem is to find the last digit of a sum of the first 𝑛 Fibonacci numbers.</p><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><ol><li>如果会解决第5题，后面的三道题目都非常简单，在这里就不贴详细的代码。</li><li>主要是利用斐波那契数列取模后的循环数列的技巧，分别求即可。</li></ol><h2 id="week-3-Greedy-Algorithms"><a href="#week-3-Greedy-Algorithms" class="headerlink" title="week 3 Greedy Algorithms"></a>week 3 Greedy Algorithms</h2><p>贪心算法也是非常常见和应用的算法，前1-5题非常简单。重点需要展开讲述一下6-7题。</p><h3 id="6-Maximum-Number-of-Prizes"><a href="#6-Maximum-Number-of-Prizes" class="headerlink" title="6 Maximum Number of Prizes"></a>6 Maximum Number of Prizes</h3><p>You are organizing a funny competition for children. As a prize fund you have 𝑛<br>candies. You would like to use these candies for top 𝑘 places in a competition<br>with a natural restriction that a higher place gets a larger number of candies.<br>To make as many children happy as possible, you are going to find the largest<br>value of 𝑘 for which it is possible.</p><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><ol><li>我们从<code>1</code>开始顺序的加入自然数即可，直到加入第<code>i-1</code>个数后，剩余的元素应该大于等于<code>i</code>.<script type="math/tex; mode=display">i \le n - (i-1)*i/2</script></li><li>本质也是贪心算法<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; optimal_summands(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands;</span><br><span class="line">  <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="keyword">int</span> rest = n - (i*(i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span>(rest &lt;= i)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j)&#123;</span><br><span class="line">              summands.push_back(j);</span><br><span class="line">          &#125;</span><br><span class="line">          summands.push_back(n-(i<span class="number">-1</span>)*i/<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> summands;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; summands = optimal_summands(n);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; summands.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; summands[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Maximum-Salary"><a href="#7-Maximum-Salary" class="headerlink" title="7 Maximum Salary"></a>7 Maximum Salary</h3><strong>Task</strong>. Compose the largest number out of a set of integers.<br><strong>Input Format</strong>. The first line of the input contains an integer 𝑛. The second line contains integers<br>𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Constraints</strong>. 1 ≤ 𝑛 ≤ 100; 1 ≤ 𝑎𝑖 ≤ 103 for all 1 ≤ 𝑖 ≤ 𝑛.<br><strong>Output Format</strong>. Output the largest number that can be composed out of 𝑎1, 𝑎2, . . . , 𝑎𝑛.<br><strong>Sample 1</strong>.<br>Input:<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">21 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>Output:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">221</span></span><br></pre></td></tr></table></figure>Note that in this case the above algorithm also returns an incorrect answer <code>212</code>.<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4></li><li>仔细看下似乎比较麻烦，但是实际上很简单，我们采取贪心的算法，将字典序组合最大的排在前面即可。我们将字符串按照<code>s1,s2</code>如下顺序进行排列：<script type="math/tex; mode=display">(s1 + s2) > (s2 + s1)</script></li><li>我们直接排序然后输出字符串即可，当然了这是<code>leetcode</code>上的原题。<h5 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp; a,<span class="built_in">string</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = a + b;</span><br><span class="line">    <span class="built_in">string</span> s2 = b + a;</span><br><span class="line">    <span class="keyword">return</span> s1 &gt; s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">largest_number</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> ret;</span><br><span class="line">  sort(a.begin(),a.end(),cmp);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    ret &lt;&lt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">string</span> result;</span><br><span class="line">  ret &gt;&gt; result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; largest_number(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week4-Divide-and-Conquer"><a href="#week4-Divide-and-Conquer" class="headerlink" title="week4: Divide-and-Conquer"></a>week4: Divide-and-Conquer</h2><p>这一章主要是将分治法，主要涉及的内容有二分查找和归并排序的应用。非常非常重要的基础算法应用。题目稍微比较难。前2题比较简单，重点把后4题稍微思考一下。<br>分治法的核心思路也是递归。将一个大的<strong>task</strong>划分成为n个小的<strong>task</strong>即可。然后再对<code>n</code>个<strong>task</strong>进行归并调度即可。</p><h3 id="3-Improving-Quick-Sort"><a href="#3-Improving-Quick-Sort" class="headerlink" title="3 Improving Quick Sort"></a>3 Improving Quick Sort</h3><p>To force the given implementation of the quick sort algorithm to efficiently process sequences with<br>few unique elements, your goal is replace a 2-way partition with a 3-way partition. That is, your new<br>partition procedure should partition the array into three parts: &lt; 𝑥 part, = 𝑥 part, and &gt; 𝑥 part.</p><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><ol><li>对快速排序的改进，实际也是所谓的<strong>3-way-partion</strong>，每次将数组划分为3部分，即小于<code>pivot</code>,等于<code>pivot</code>,大于<code>pivot</code>三部分，然后小于<code>pivot</code>和大于<code>pivot</code>的部分进行下一轮划分，等于<code>piovt</code>的保持不变即可。</li><li>这样总的划分效果较好，特别是较少了递归的次数，每次相等的部分位置就固定下来。<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = a[l];</span><br><span class="line">  <span class="keyword">int</span> j = l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] &lt;= x) &#123;</span><br><span class="line">      j++;</span><br><span class="line">      swap(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(a[l], a[j]);</span><br><span class="line">  <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partition3(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; a,<span class="keyword">int</span> l,<span class="keyword">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">int</span> x = a[l];</span><br><span class="line">    <span class="keyword">int</span> j = l;</span><br><span class="line">    <span class="keyword">int</span> k = l+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; x) &#123;</span><br><span class="line">            swap(a[k],a[i]);</span><br><span class="line">            swap(a[k++],a[j++]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == x)&#123;</span><br><span class="line">            swap(a[k++],a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret.push_back(j);</span><br><span class="line">    ret.push_back(k);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threeway_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; partion = partition3(a, l, r);</span><br><span class="line">  threeway_quick_sort(a, l, partion[<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">  threeway_quick_sort(a, partion[<span class="number">1</span>], r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomized_quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> k = l + rand() % (r - l + <span class="number">1</span>);</span><br><span class="line">  swap(a[l], a[k]);</span><br><span class="line">  <span class="keyword">int</span> m = partition2(a, l, r);</span><br><span class="line"></span><br><span class="line">  randomized_quick_sort(a, l, m - <span class="number">1</span>);</span><br><span class="line">  randomized_quick_sort(a, m + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  threeway_quick_sort(a, <span class="number">0</span>, a.size() - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Number-of-Inversions"><a href="#4-Number-of-Inversions" class="headerlink" title="4 Number of Inversions"></a>4 Number of Inversions</h3><p>An inversion of a sequence 𝑎0, 𝑎1, . . . , 𝑎𝑛−1 is a pair of indices 0 ≤ 𝑖 &lt; 𝑗 &lt; 𝑛 such that 𝑎𝑖 &gt; 𝑎𝑗 . The number of inversions of a sequence in some sense measures how close the sequence is to being sorted. For example, a sorted (in non-descending order) sequence contains no inversions at all, while in a sequence sorted in descending order any two elements constitute an inversion (for a total of 𝑛(𝑛 − 1)/2 inversions).The goal in this problem is to count the number of inversions of a given sequence.</p><h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><ol><li>这个是<code>leetcode</code>上的原题，本质是归并排序。</li><li>每次我们将数组划分为前半部分后后半部分，并分别对前半部分进行归并排序，并同时判断两个部分的逆序对。</li><li>每次进行归并时，计算前半部分的元素大于后半部分的数的有多少个，然其所有大于的数组之和相加即可。</li><li>我们刚好利用归并时即可，将两个有序的数组进行归并，所以这次归并时在<code>O(n)</code>时间复杂度内完成本次逆序对的计算和排序。<h4 id><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_number_of_inversions</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="keyword">size_t</span> left, <span class="keyword">size_t</span> right)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> number_of_inversions = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (right &lt;= left + <span class="number">1</span>) <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">  <span class="keyword">size_t</span> ave = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, left, ave);</span><br><span class="line">  number_of_inversions += get_number_of_inversions(a, b, ave, right);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> l = left;</span><br><span class="line">  <span class="keyword">int</span> r = ave;</span><br><span class="line">  <span class="keyword">int</span> curr = left;</span><br><span class="line">  <span class="keyword">while</span>(l &lt; ave || r &lt; right)&#123;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave &amp;&amp; r &lt; right)&#123;</span><br><span class="line">          <span class="keyword">if</span>(a[r] &lt; a[l])&#123;</span><br><span class="line">              number_of_inversions += ave - l;</span><br><span class="line">              b[curr++] = a[r++];</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              b[curr++] = a[l++];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(l &lt; ave) b[curr++] = a[l++];</span><br><span class="line">      <span class="keyword">if</span>(r &lt; right) b[curr++] = a[r++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; ++i)&#123;</span><br><span class="line">      a[i] = b[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> number_of_inversions;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; a.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(a.size());</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_number_of_inversions(a, b, <span class="number">0</span>, a.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Organizing-a-Lottery"><a href="#5-Organizing-a-Lottery" class="headerlink" title="5 Organizing a Lottery"></a>5 Organizing a Lottery</h3>You are organizing an online lottery. To participate, a person bets on a single integer. You then draw several ranges of consecutive integers at random.A participant’s payoff then is proportional to the number of ranges that<br>contain the participant’s number minus the number of ranges that does not contain it. You need an efficient algorithm for computing the payoffs for all participants. A naive way to do this is to simply scan, for all participants, the<br>list of all ranges. However, you lottery is very popular: you have thousands of participants and thousands of ranges. For this reason, you cannot afford a slow naive algorithm.<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4></li><li>这个题目非常好，质量很高。其实拿到这个题目我一开始想到的就是<code>segmentTree</code>，结果就是超时了。</li><li>后来思考了好长时间没有想到更简单的做法。然后去论坛找了提示，发现这个解法非常非常的巧妙。</li><li>我们对所有的元素进行标记，我们可以想像把线段的左端点标记为左括号<code>(</code>,线段的右端点标记为右括号<code>(</code>,需要查找的点标记为<code>p</code>,我们实际上就是判断点p能否被几个完成的左右括号同时覆盖<code>()</code>.</li><li>记住上面的关键点的思考。实际我们可能还有许多细节要思考，比如这种线段<code>s:(x,x)</code>,点p为<code>x</code>,则这时点<code>p</code>应该是被线段<code>s</code>包围的,这点所谓的包含思维需要仔细的思考。我们将线段的左端点标记为<code>l</code>，线段的右端点标记为<code>r</code>，将point标记为<code>p</code>，然后将左端点和右端点加在一起排序。我们判断时，每次遇到左括号则进行计数加<code>1</code>,遇到右括号，则将计数减<code>1</code>,到达当前点<code>p</code>时的计数大小即为所有包含点<code>p</code>的线段数。</li><li>另一种方法可能更快一点，我们直接利用二分查找。对于当前点<code>p:x</code>,我们查找有多少个大于<code>x</code>的左端点，个数即为<code>lx</code>,同时查找大于等于<code>x</code>的右端点的个数为<code>rx</code>.包含点<code>p</code>的线段数为<code>rx-lx</code>.<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; fast_count_segments(vector&lt;int&gt; starts, vector&lt;int&gt; ends, vector&lt;int&gt; points) &#123;</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; cnt(points.size());</span></span><br><span class="line"><span class="comment">    int n = starts.size();</span></span><br><span class="line"><span class="comment">    int m = points.size();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sort(starts.begin(),starts.end());</span></span><br><span class="line"><span class="comment">    sort(ends.begin(),ends.end());</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; m; ++i)&#123;</span></span><br><span class="line"><span class="comment">        auto it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span></span><br><span class="line"><span class="comment">        auto it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span></span><br><span class="line"><span class="comment">        int x = it1 - starts.begin();</span></span><br><span class="line"><span class="comment">        int y = it2 - ends.begin();</span></span><br><span class="line"><span class="comment">        cnt[i] = x - y;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    return cnt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fast_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">    <span class="keyword">int</span> n = starts.size();</span><br><span class="line">    <span class="keyword">int</span> m = points.size();</span><br><span class="line"></span><br><span class="line">    sort(starts.begin(),starts.end());</span><br><span class="line">    sort(ends.begin(),ends.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">auto</span> it1 = upper_bound(starts.begin(),starts.end(),points[i]);</span><br><span class="line">        <span class="keyword">auto</span> it2 = lower_bound(ends.begin(),ends.end(),points[i]);</span><br><span class="line">        <span class="keyword">int</span> x = it1 - starts.begin();</span><br><span class="line">        <span class="keyword">int</span> y = it2 - ends.begin();</span><br><span class="line">        cnt[i] = x - y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; naive_count_segments(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points) &#123;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(points.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; starts.size(); j++) &#123;</span><br><span class="line">      cnt[i] += starts[j] &lt;= points[i] &amp;&amp; points[i] &lt;= ends[j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; starts(n), ends(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; starts.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; starts[i] &gt;&gt; ends[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; points(m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; points[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//use fast_count_segments</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt = fast_count_segments(starts, ends, points);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cnt.size(); i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-Closest-Points"><a href="#6-Closest-Points" class="headerlink" title="6 Closest Points"></a>6 Closest Points</h3><p>In this problem, your goal is to find the closest pair of points among the given 𝑛<br>points. This is a basic primitive in computational geometry having applications in,<br>for example, graphics, computer vision, traffic-control systems.</p><h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><ol><li>题目中的要求求出一堆点的集合中距离最短的两个点的距离。这个题目我按照提示的要求做出来了，但是至今为止还没搞懂原理。</li><li>将点的集合按照横坐标<code>x</code>的大小进行排序，然后将集合按照横坐标的大小划分为左右两部分。递归求出左半部分的最小距离<code>dl</code>,右半部分的最小距离<code>dr</code>.</li><li>令<code>d = min(dl,dr)</code>,令<code>mid = p[(l+r)/2]</code>,求出所有距离线段<code>x = mid</code>的距离小于等于<code>d</code>的点。</li><li>将上述求得所有的点按照纵坐标<code>y</code>的大小进行排序，每次求出连续相邻<code>8</code>个点的最小距离为<code>d&#39;</code>，令<code>d = min(d,d&#39;)</code>,返回<code>d</code>即可。</li><li>代码本身比较简单，但是这个方法确实不容易想到。<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;float.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::pair;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y;</span><br><span class="line">  Point(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpX</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.x &lt; p2.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmpY</span><span class="params">(Point &amp; p1,Point &amp; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.y &lt; p2.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;Point&gt; &amp; arr, <span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r - l &lt;= <span class="number">1</span>) <span class="keyword">return</span> DBL_MAX;</span><br><span class="line">    <span class="keyword">if</span>(r - l == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[l].x-arr[l+<span class="number">1</span>].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[l].y - arr[l+<span class="number">1</span>].y,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sort(arr.begin()+l,arr.begin()+r,cmpX);</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> dl = helper(arr,l,mid);</span><br><span class="line">    <span class="keyword">double</span> dr = helper(arr,mid,r);</span><br><span class="line">    <span class="keyword">double</span> d = min(dl,dr);</span><br><span class="line">    <span class="keyword">int</span> ml = l;</span><br><span class="line">    <span class="keyword">int</span> mr = r<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(ml &lt; r &amp;&amp; <span class="built_in">abs</span>(arr[ml].x - arr[mid].x) &gt; d) ml++;</span><br><span class="line">    <span class="keyword">while</span>(mr &gt;= l &amp;&amp; <span class="built_in">abs</span>(arr[mr].x - arr[mid].x) &gt; d) mr--;</span><br><span class="line">    sort(arr.begin() + ml,arr.begin() + mr + <span class="number">1</span>,cmpY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= mr ; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= mr &amp;&amp; j &lt;= i + <span class="number">7</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">double</span> dy = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(arr[i].x-arr[j].x,<span class="number">2</span>) + <span class="built_in">pow</span>(arr[i].y-arr[j].y,<span class="number">2</span>));</span><br><span class="line">            d = min(d,dy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">minimal_distance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = x.size();</span><br><span class="line">  <span class="built_in">vector</span>&lt;Point&gt; arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; ++i)&#123;</span><br><span class="line">    arr.push_back(Point(x[i],y[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> helper(arr,<span class="number">0</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x(n);</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">9</span>) &lt;&lt; minimal_distance(x, y) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="week5-Dynamic-Programming-1"><a href="#week5-Dynamic-Programming-1" class="headerlink" title="week5:Dynamic Programming 1"></a>week5:Dynamic Programming 1</h2><p>本章为动态规划，比较简单。前面4道题目都非常简单，最后一题稍微难点。</p><h3 id="5-Longest-Common-Subsequence-of-Three-Sequences"><a href="#5-Longest-Common-Subsequence-of-Three-Sequences" class="headerlink" title="5 Longest Common Subsequence of Three Sequences"></a>5 Longest Common Subsequence of Three Sequences</h3><p>Compute the length of a longest common subsequence of three sequences.</p><h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><ol><li>题目是求出三个字符串的最长公共子序列，稍微复杂点。</li><li>本题中有三个字符串<code>a,b,c</code>,我们设递推公式<code>dp[x][y][z]</code>为字符串<code>a</code>的到索引<code>x</code>处，字符串<code>b</code>的到索引<code>y</code>处，字符串<code>c</code>的到索引<code>z</code>处的最长公共子序列数目。</li><li>递推公式如下：<br>如果当<code>a[x] = b[y]</code>且<code>b[y] = c[z]</code>时：<script type="math/tex; mode=display">dp[x][y][z] = dp[x-1][y-1][z-1] \:\:  if(a[x] = b[y] = c[z])</script>否则：<script type="math/tex; mode=display">dp[x][y][z] = min\left\{\begin{aligned}dp[x-1][y][z] \\dp[x][y-1][z] \\dp[x][y][z-1] \\\end{aligned}\right.</script></li><li>根据以上的递推公式即可。<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = a.size();</span><br><span class="line">    <span class="keyword">int</span> n = b.size();</span><br><span class="line">    <span class="keyword">int</span> l = c.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(l+<span class="number">1</span>,<span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= l; ++k)&#123;</span><br><span class="line">              <span class="keyword">if</span>(a[i<span class="number">-1</span>] == b[j<span class="number">-1</span>] &amp;&amp; b[j<span class="number">-1</span>] == c[k<span class="number">-1</span>])&#123;</span><br><span class="line">                  dp[i][j][k] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">              &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i<span class="number">-1</span>][j][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j<span class="number">-1</span>][k]);</span><br><span class="line">                  dp[i][j][k] = max(dp[i][j][k],dp[i][j][k<span class="number">-1</span>]);</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n][l];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> an;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; an;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(an);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; an; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> bn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; bn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(bn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; bn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; b[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">size_t</span> cn;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; cn;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(cn);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cn; i++) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lcs3(a, b, c) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6-Dynamic-Programming-2"><a href="#6-Dynamic-Programming-2" class="headerlink" title="6:Dynamic Programming 2"></a>6:Dynamic Programming 2</h2><p>最后两道题目稍微有点难度，别的都还好，也是<code>dp</code>的重要应用。<code>dp</code>的思想，最关键的是递推关系的确立。递推关系一般不好思考，这点需要经验。不过一般都是跟元素的大小有关系。</p><h3 id="2-Partitioning-Souvenirs"><a href="#2-Partitioning-Souvenirs" class="headerlink" title="2 Partitioning Souvenirs"></a>2 Partitioning Souvenirs</h3><p>You and two of your friends have just returned back home after visiting various countries. Now you would<br>like to evenly split all the souvenirs that all three of you bought.</p><h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><ol><li>这个也是动态规划，我们需要找到递推关系还是需要花费一定时间思考的。</li><li>首先思考一下数组本身，如果整个数组的和<code>sum</code>不能被3整除，那么该数组肯定不能划分成为相等的3个非重复的子序列。最终划分为3个子序列，每个子序列的和为$\frac{sum}{3}$.</li><li>我们思考一下，设动态规划递推公式<code>dp[i][x][y]</code>表示前<code>i</code>个元素能否被划分成为3个子序列，其中有两个字序列的和为<code>x,y</code>.实际这三个子序列的和应该分别为：<code>x,y,sum[i]-x-y</code>,则当我们加入第<code>i+1</code>个元素时，第<code>i+1</code>个元素可以分别加入到这三个不同的子序列，我们判断当其加入到这三个不同的子序列中时，等式是否成立.我们设立递推公式为如下：<script type="math/tex; mode=display">dp[i][x][y] = dp[i-1][x][y]||dp[i-1][x-arr[i]][y]||dp[i-1][x][y-arr[i]]</script></li><li>实际我们可以将题目本身的问题转化为n个元素划分为三个子序列，是否有其中两个子序列的和分别为$\frac{sum}{3}$.即<code>dp[n][sum/3][sum/3]</code>是否为成立。<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">201</span>][<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition3</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> div = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = A.size();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">        all += A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(all%<span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    div = all/<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*intiail*/</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= div; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= div; ++k)&#123;</span><br><span class="line">                dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j-A[i<span class="number">-1</span>]][k];</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= A[i<span class="number">-1</span>]) dp[i][j][k] = dp[i][j][k]||dp[i<span class="number">-1</span>][j][k-A[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][div][div];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; A[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; partition3(A) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-Maximum-Value-of-an-Arithmetic-Expression"><a href="#3-Maximum-Value-of-an-Arithmetic-Expression" class="headerlink" title="3 Maximum Value of an Arithmetic Expression"></a>3 Maximum Value of an Arithmetic Expression</h3><p>Find the maximum value of an arithmetic expression by specifying the order of applying its arithmetic<br>operations using additional parentheses.<br>In this problem, your goal is to add parentheses to a given arithmetic<br>expression to maximize its value. max(5−8+7×4−8+9) =?</p><h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><ol><li>这个题目非常类似于括号匹配的最大值，跟<code>leetcode</code>某个题目非常相似。</li><li>题目中由于加入了加法、减法、乘法，实际情况稍微复杂一些。我们首先设立<code>dpmax[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最大值,<code>dpmin[i][j]</code>代表等式从第<code>i</code>个数字到第<code>j</code>个数字之间的等式的最小值.我们仔细判断一下，分为以下三种情况,<code>l</code>代表符号左边的值，<code>r</code>代表符号右边的值：</li></ol><ul><li><code>+</code>：当符号为加号时我们肯定希望等式表示左右两边的加数最大。<script type="math/tex; mode=display">max(result) = max(l) + max(r)</script></li><li><code>-</code>：当符号为减号号时我们肯定希望等式表示左边的数最大，右边的数。<script type="math/tex; mode=display">max(result) = max(l) - min(r)</script></li><li><code>*</code>：当符号为乘号时，情况比较复杂，因为涉及到乘积的符号的问题，但是<script type="math/tex; mode=display">max(result) = max\left\{\begin{aligned}max(l)*max(r)\\min(l)*max(r)\\    max(l)*min(r)\\min(l)*min(r)\\  \end{aligned}\right.</script></li></ul><ol><li>我们接下来我们需要仔细处理等式划分的问题，因为这涉及到括号的问题。<code>dp[i][j]</code>代表从<code>i</code>到<code>j</code>的表达式，我们可以从<code>i+1</code>,<code>i+2</code>,<code>i+3</code>,…,<code>j-1</code>处进行断开。</li><li>我们可以看到如下：<script type="math/tex; mode=display">dpmax[i][j] = max\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned} \right.</script><script type="math/tex; mode=display">dpmin[i][j] = min\left\{\begin{aligned}eval(dpmax[i][k],op[k],dpmax[k+1][j]\\ eval(dpmax[i][k],op[k],dpmin[k+1][j]\\eval(dpmin[i][k],op[k],dpmax[k+1][j]\\eval(dpmin[i][k],op[k],dpmin[k+1][j]\\\end{aligned}\right.</script><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">eval</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">char</span> op)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (op == <span class="string">'*'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'+'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">'-'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isDigit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">'+'</span>|| c == <span class="string">'-'</span> || c == <span class="string">'*'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">get_maximum_value</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="built_in">exp</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//write your code here</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n = (<span class="built_in">exp</span>.size()+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; nums;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; op;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp1(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MAX));</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; dp2(n,<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(n,INT_MIN));</span><br><span class="line">  <span class="comment">/*intial*/</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">exp</span>.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(isDigit(<span class="built_in">exp</span>[i])) nums.push_back(<span class="built_in">exp</span>[i] - <span class="string">'0'</span>);</span><br><span class="line">      <span class="keyword">if</span>(isOp(<span class="built_in">exp</span>[i])) op.push_back(<span class="built_in">exp</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">    dp1[i][i] = nums[i];</span><br><span class="line">    dp2[i][i] = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; ++j)&#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt;= j+i; ++k)&#123;</span><br><span class="line">              <span class="comment">/*min expression*/</span></span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp1[j][j+i] = min(dp1[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*max expression*/</span></span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp1[j][k<span class="number">-1</span>],dp1[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">              dp2[j][j+i] = max(dp2[j][j+i],eval(dp2[j][k<span class="number">-1</span>],dp2[k][j+i],op[k<span class="number">-1</span>]));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dp2[<span class="number">0</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">string</span> s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; get_maximum_value(s) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Algorithmic-Toolbox&quot;&gt;&lt;a href=&quot;#Algorithmic-Toolbox&quot; class=&quot;headerlink&quot; title=&quot;Algorithmic Toolbox&quot;&gt;&lt;/a&gt;Algorithmic Toolbox&lt;/h1&gt;&lt;p&gt;最近准备学习&lt;code&gt;coursera&lt;/code&gt;上的《算法与数据结构系列课程》，目前已经把第一部分课程《Algorithmic Toolbox》学习完了，这部分的课程难度比较低，除了有几道题目稍微比较&lt;code&gt;trikly&lt;/code&gt;以外，其余的都是基本题目。得分是&lt;code&gt;100&lt;/code&gt; 分，证书如下：&lt;br&gt;&lt;a href=&quot;https://www.coursera.org/account/accomplishments/certificate/XNSXA54YM3ST&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Algorithmic Toolbox
&lt;/a&gt;&lt;br&gt;下面将该课程的题目的解法。&lt;br&gt;该课程所有提交的代码如下：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/Algorithmic%20Toolbox/week1_programming_challenges&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;source code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="《Algorithmic Toolbox》" scheme="http://yoursite.com/tags/%E3%80%8AAlgorithmic-Toolbox%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第186周比赛</title>
    <link href="http://yoursite.com/2020/04/26/155/"/>
    <id>http://yoursite.com/2020/04/26/155/</id>
    <published>2020-04-26T09:15:42.260Z</published>
    <updated>2020-04-26T09:15:44.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="186周比赛"><a href="#186周比赛" class="headerlink" title="186周比赛"></a>186周比赛</h1><p>本周题目的质量不错。</p><h2 id="5392-分割字符串的最大得分"><a href="#5392-分割字符串的最大得分" class="headerlink" title="5392. 分割字符串的最大得分"></a>5392. 分割字符串的最大得分</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个由若干 <code>0</code> 和<code>1</code> 组成的字符串 <code>s</code>，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"011101"</span></span><br><span class="line">输出：<span class="number">5</span> </span><br><span class="line">解释：</span><br><span class="line">将字符串 s 划分为两个非空子字符串的可行方案有：</span><br><span class="line">左子字符串 = <span class="string">"0"</span> 且 右子字符串 = <span class="string">"11101"</span>，得分 = <span class="number">1</span> + <span class="number">4</span> = <span class="number">5</span> </span><br><span class="line">左子字符串 = <span class="string">"01"</span> 且 右子字符串 = <span class="string">"1101"</span>，得分 = <span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span> </span><br><span class="line">左子字符串 = <span class="string">"011"</span> 且 右子字符串 = <span class="string">"101"</span>，得分 = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span> </span><br><span class="line">左子字符串 = <span class="string">"0111"</span> 且 右子字符串 = <span class="string">"01"</span>，得分 = <span class="number">1</span> + <span class="number">1</span> = <span class="number">2</span> </span><br><span class="line">左子字符串 = <span class="string">"01110"</span> 且 右子字符串 = <span class="string">"1"</span>，得分 = <span class="number">2</span> + <span class="number">1</span> = <span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"00111"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：当 左子字符串 = <span class="string">"00"</span> 且 右子字符串 = <span class="string">"111"</span> 时，我们得到最大得分 = <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1111"</span></span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-score-after-splitting-a-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身数据量非常小，我们实际只需暴力匹配即可。非常简单<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScore</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oneCurr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) one++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'0'</span>) zero++;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span>) oneCurr++;</span><br><span class="line">            res = max(res,zero + one - oneCurr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5393-可获得的最大点数"><a href="#5393-可获得的最大点数" class="headerlink" title="5393. 可获得的最大点数"></a>5393. 可获得的最大点数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 <code>cardPoints</code>给出。</p><p>每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。</p><p>你的点数就是你拿到手中的所有卡牌的点数之和。</p><p>给你一个整数数组<code>cardPoints</code> 和整数<code>k</code>，请你返回可以获得的最大点数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：第一次行动，不管拿哪张牌，你的点数总是 <span class="number">1</span> 。但是，先拿最右边的卡牌将会最大化你的可获得点数。最优策略是拿右边的三张牌，最终点数为 <span class="number">1</span> + <span class="number">6</span> + <span class="number">5</span> = <span class="number">12</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：无论你拿起哪两张卡牌，可获得的点数总是 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">9</span>], k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">55</span></span><br><span class="line">解释：你必须拿起所有卡牌，可以获得的点数为所有卡牌的点数之和。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：cardPoints = [<span class="number">1</span>,<span class="number">1000</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：你无法拿到中间那张卡牌，所以可以获得的最大点数为 <span class="number">1</span> 。</span><br><span class="line">``` </span><br><span class="line">示例 <span class="number">5</span>：</span><br></pre></td></tr></table></figure><br>输入：cardPoints = [1,79,80,1,1,1,200,1], k = 3<br>输出：202<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints.length &lt;= <span class="number">10</span>^<span class="number">5</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= cardPoints[i] &lt;= <span class="number">10</span>^<span class="number">4</span>`</span><br><span class="line">+ `<span class="number">1</span> &lt;= k &lt;= cardPoints.length`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 地址</span><br><span class="line">https:<span class="comment">//leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards</span></span><br><span class="line">### 题意</span><br><span class="line">&gt;  滑动窗口</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 数组的前缀和后缀组合，前`i`个前缀和后`k-i`个后缀之和的最大值。</span><br><span class="line">$$</span><br><span class="line">f = max(prefix[i] + suffix[k-i])  \: i \<span class="keyword">in</span>(<span class="number">0</span>,...,k)</span><br><span class="line">$$</span><br><span class="line"><span class="number">2.</span> 另一种思路，求滑动窗口，求出剩余的连续`n-k`个元素的最小值，总数减去这个值即可。</span><br><span class="line">$$</span><br><span class="line">f = \sum_&#123;i=<span class="number">1</span>&#125;^&#123;n&#125; p[i] - min(sum(i,i+n-k<span class="number">-1</span>))  \: i \<span class="keyword">in</span>(<span class="number">1</span>,...,k)</span><br><span class="line">$$</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">int</span> maxScore(vector&lt;<span class="built_in">int</span>&gt;&amp; cardPoints, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">int</span> n = cardPoints.size();</span><br><span class="line">        <span class="built_in">int</span> m = n-k;</span><br><span class="line">        <span class="built_in">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> remove = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += cardPoints[i];</span><br><span class="line">            sum += cardPoints[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= m<span class="number">-1</span> &amp;&amp; m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                remove = min(curr,remove);</span><br><span class="line">                curr -= cardPoints[i-m+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(remove == INT_MAX) remove = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum - remove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="5394-对角线遍历-II"><a href="#5394-对角线遍历-II" class="headerlink" title="5394. 对角线遍历 II"></a>5394. 对角线遍历 II</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个列表 <code>nums</code>，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 <code>nums</code> 中对角线上的整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>],[<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">13</span>,<span class="number">11</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],[<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>提示：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i].length &lt;= <span class="number">10</span>^<span class="number">5</span></span><br><span class="line"><span class="number">1</span> &lt;= nums[i][j] &lt;= <span class="number">10</span>^<span class="number">9</span></span><br><span class="line">nums 中最多有 <span class="number">10</span>^<span class="number">5</span> 个数字。</span><br></pre></td></tr></table></figure></p><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/diagonal-traverse-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/diagonal-traverse-ii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 排序</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目还是蛮有意思。首先对角线打印其实很简单，但是时间复杂度的话 会超时。</li><li>我们应该找规律，想更快的办法，后来仔细分析一下，我们可以对每个元素的下标进行排序，按照<code>rowindex</code>和<code>colindex</code>的和的大小进行顺序排序，如果和相等，再按照<code>rowindex</code>从大到小排序。</li><li>根据索引的排序结果输入所有元素。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; a,pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sa = a.first + a.second;</span><br><span class="line">        <span class="keyword">int</span> sb = b.first + b.second;</span><br><span class="line">        <span class="keyword">if</span>(sa == sb) <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        <span class="keyword">return</span> sa &lt; sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findDiagonalOrder(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> m = nums[n<span class="number">-1</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; idx;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums[i].size(); ++j)&#123;</span><br><span class="line">                idx.push_back(make_pair(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(idx.begin(),idx.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx.size(); ++i)&#123;</span><br><span class="line">            res.push_back(nums[idx[i].first][idx[i].second]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5180-带限制的子序列和"><a href="#5180-带限制的子序列和" class="headerlink" title="5180. 带限制的子序列和"></a>5180. 带限制的子序列和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 nums 和一个整数 k ，请你返回 非空 子序列元素和的最大值，子序列需要满足：子序列中每两个 相邻 的整数 <code>nums[i]</code> 和 <code>nums[j]</code>，它们在原数组中的下标 i 和 j 满足<code>i &lt; j</code>且 <code>j - i &lt;= k</code>。</p><p>数组的子序列定义为：将数组中的若干个数字删除（可以删除 0 个数字），剩下的数字按照原本的顺序排布。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">-10</span>,<span class="number">5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">37</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>], k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：子序列必须是非空的，所以我们选择最大的数字。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">10</span>,<span class="number">-2</span>,<span class="number">-10</span>,<span class="number">-5</span>,<span class="number">20</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">23</span></span><br><span class="line">解释：子序列为 [<span class="number">10</span>, <span class="number">-2</span>, <span class="number">-5</span>, <span class="number">20</span>] 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/constrained-subset-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/constrained-subset-sum</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>本题基本一眼看到就是动态规划。</li><li>仔细思考一下我们设<code>dp[i]</code>为前<code>i</code>个元素的最大子序列和且包含第<code>i</code>个元素。</li><li>按照常规思路<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[0],dp[1],dp[2],...,dp[i-1])+nums[i]);</script></li><li>但是本题中限制了两个元素之间的相隔不超过<code>k</code>则上述递推公式应该变为：<script type="math/tex; mode=display">dp[i] = max(num[i],max(dp[i-k],dp[i-k+1],dp[i-k+2],...,dp[i-1])+nums[i]);</script></li><li>我们用滑动窗口即可，我们利用优先级队列，保留前<code>k</code>元素的最大子序列，每次取前<code>k</code>个元素的最大子序列和的最大值。如果队列的元素个数大于<code>k</code>则去掉队首的元素。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">constrainedSubsetSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; prev;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        prev.insert(dp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            dp[i] = max(nums[i],*prev.rbegin() + nums[i]);</span><br><span class="line">            prev.insert(dp[i]);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k) prev.erase(dp[i-k]);</span><br><span class="line">            res = max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;186周比赛&quot;&gt;&lt;a href=&quot;#186周比赛&quot; class=&quot;headerlink&quot; title=&quot;186周比赛&quot;&gt;&lt;/a&gt;186周比赛&lt;/h1&gt;&lt;p&gt;本周题目的质量不错。&lt;/p&gt;&lt;h2 id=&quot;5392-分割字符串的最大得分&quot;&gt;&lt;a href=&quot;#5392-分割字符串的最大得分&quot; class=&quot;headerlink&quot; title=&quot;5392. 分割字符串的最大得分&quot;&gt;&lt;/a&gt;5392. 分割字符串的最大得分&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个由若干 &lt;code&gt;0&lt;/code&gt; 和&lt;code&gt;1&lt;/code&gt; 组成的字符串 &lt;code&gt;s&lt;/code&gt;，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LCP2020</title>
    <link href="http://yoursite.com/2020/04/20/154/"/>
    <id>http://yoursite.com/2020/04/20/154/</id>
    <published>2020-04-20T15:00:58.392Z</published>
    <updated>2020-04-22T09:39:59.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LCP2020"><a href="#LCP2020" class="headerlink" title="LCP2020"></a>LCP2020</h1><p>还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。</p><h2 id="LCP-06-拿硬币"><a href="#LCP-06-拿硬币" class="headerlink" title="LCP 06. 拿硬币"></a>LCP 06. 拿硬币</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>桌上有 <code>n</code>堆力扣币，每堆的数量保存在数组 <code>coins</code>中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line"></span><br><span class="line">解释：第一堆力扣币最少需要拿 <span class="number">2</span> 次，第二堆最少需要拿 <span class="number">1</span> 次，第三堆最少需要拿 <span class="number">1</span> 次，总共 <span class="number">4</span> 次即可拿完。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">8</span></span><br></pre></td></tr></table></figure><br>限制：</p><a id="more"></a><ul><li><code>1 &lt;= n &lt;= 4</code></li><li><code>1 &lt;= coins[i] &lt;= 10</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/na-ying-bi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/na-ying-bi</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>简单题目直接计算即可。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : coins)&#123;</span><br><span class="line">            res += (c+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-07-传递信息"><a href="#LCP-07-传递信息" class="headerlink" title="LCP 07. 传递信息"></a>LCP 07. 传递信息</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>小朋友 <code>A</code> 在和<code>ta</code>的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li><li>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比3. A 可以向 B 传信息，但 B 不能向 A 传信息）。<br> 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</li></ol><p>给定总玩家数 n，以及按 <code>[玩家编号,对应可传递玩家编号]</code>关系组成的二维数组 <code>relation</code>。返回信息从小<code>A</code>(编号 0 ) 经过 <code>k</code>轮传递到编号为<code>n-1</code> 的小伙伴处的方案数；若不能到达，返回 0。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">4</span>]], k = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：信息从小 A 编号 <span class="number">0</span> 处开始，经 <span class="number">3</span> 轮传递，到达编号 <span class="number">4</span>。共有 <span class="number">3</span> 种方案，分别是 <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">0</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>， <span class="number">0</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, relation = [[<span class="number">0</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">1</span>]], k = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line"></span><br><span class="line">解释：信息不能从小 A 处经过 <span class="number">2</span> 轮传递到编号 <span class="number">2</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/chuan-di-xin-xi" target="_blank" rel="noopener">https://leetcode-cn.com/problems/chuan-di-xin-xi</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><code>dp[i][j]</code>代表从经过<code>i</code>轮传递到<code>j</code>的方案数。<script type="math/tex; mode=display">dp[i][j] = \sum_{v = 1}^{n}dp[i-1][v] \:\:  if(edge[v][j] == true)</script></li><li>非常简单的<code>dp</code>.<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(k+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : relation)&#123;</span><br><span class="line">            graph[v[<span class="number">1</span>]].push_back(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i<span class="number">-1</span>][v] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] += dp[i<span class="number">-1</span>][v];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[k][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-08-剧情触发时间"><a href="#LCP-08-剧情触发时间" class="headerlink" title="LCP 08. 剧情触发时间"></a>LCP 08. 剧情触发时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>在战略游戏中，玩家往往需要发展自己的势力来触发各种新的剧情。一个势力的主要属性有三种，分别是文明等级（C），资源储备（R）以及人口数量（H）。在游戏开始时（第 0 天），三种属性的值均为 0。</p><p>随着游戏进程的进行，每一天玩家的三种属性都会对应增加，我们用一个二维数组 <code>increase</code>来表示每天的增加情况。这个二维数组的每个元素是一个长度为 3 的一维数组，例如<code>[[1,2,1],[3,4,2]]</code>表示第一天三种属性分别增加 1,2,1 而第二天分别增加 3,4,2。</p><p>所有剧情的触发条件也用一个二维数组<code>requirements</code>表示。这个二维数组的每个元素是一个长度为 3 的一维数组，对于某个剧情的触发条件 <code>c[i], r[i], h[i]</code>，如果当前 <code>C &gt;= c[i]</code> 且 <code>R &gt;= r[i]</code>且 <code>H &gt;= h[i]</code>，则剧情会被触发。</p><p>根据所给信息，请计算每个剧情的触发时间，并以一个数组返回。如果某个剧情不会被触发，则该剧情对应的触发时间为 -1 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>],[<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]] requirements = [[<span class="number">2</span>,<span class="number">11</span>,<span class="number">3</span>],[<span class="number">15</span>,<span class="number">10</span>,<span class="number">7</span>],[<span class="number">9</span>,<span class="number">17</span>,<span class="number">12</span>],[<span class="number">8</span>,<span class="number">1</span>,<span class="number">14</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">2</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">初始时，C = <span class="number">0</span>，R = <span class="number">0</span>，H = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">1</span> 天，C = <span class="number">2</span>，R = <span class="number">8</span>，H = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">2</span> 天，C = <span class="number">4</span>，R = <span class="number">13</span>，H = <span class="number">4</span>，此时触发剧情 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">第 <span class="number">3</span> 天，C = <span class="number">14</span>，R = <span class="number">22</span>，H = <span class="number">12</span>，此时触发剧情 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">剧情 <span class="number">1</span> 和 <span class="number">3</span> 无法触发。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = [[<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>],[<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">10</span>,<span class="number">10</span>,<span class="number">0</span>]] requirements = [[<span class="number">12</span>,<span class="number">11</span>,<span class="number">16</span>],[<span class="number">20</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">10</span>,<span class="number">18</span>,<span class="number">3</span>],[<span class="number">8</span>,<span class="number">14</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">输出: [<span class="number">-1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： increase = <span class="string">[[1,1,1]]</span> requirements = <span class="string">[[0,0,0]]</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>限制：`</p><ul><li><code>1 &lt;= increase.length &lt;= 10000</code></li><li><code>1 &lt;= requirements.length &lt;= 100000</code></li><li><code>0 &lt;= increase[i] &lt;= 10</code></li><li><code>0 &lt;= requirements[i] &lt;= 100000</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ju-qing-hong-fa-shi-jian/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常典型的二分查找</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>典型的二分查找，当时竟然很麻烦的用的线段树完成该题的解答。</li><li>我们把所有天数的属性值全部叠加起来组成数组，然后利用二分查找的特性查找满足剧情要求的最小的天数。</li><li>关于二分查找算法，自己掌握的还是不够好，经常对于边界条件处理的不好。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getTriggerTime(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; increase, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; requirements) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = increase.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; days;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        days.push_back(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : increase)&#123;</span><br><span class="line">            curr[<span class="number">0</span>] += v[<span class="number">0</span>];</span><br><span class="line">            curr[<span class="number">1</span>] += v[<span class="number">1</span>];</span><br><span class="line">            curr[<span class="number">2</span>] += v[<span class="number">2</span>];</span><br><span class="line">            days.push_back(curr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : requirements)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> r = days.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(days[mid][<span class="number">0</span>] &lt; v[<span class="number">0</span>] || days[mid][<span class="number">1</span>] &lt; v[<span class="number">1</span>] || days[mid][<span class="number">2</span>] &lt; v[<span class="number">2</span>])&#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    r = mid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(days[l][<span class="number">0</span>] &gt;= v[<span class="number">0</span>] &amp;&amp; days[l][<span class="number">1</span>] &gt;= v[<span class="number">1</span>] &amp;&amp; days[l][<span class="number">2</span>] &gt;= v[<span class="number">2</span>])&#123;</span><br><span class="line">                res.push_back(l);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-09-最小跳跃次数"><a href="#LCP-09-最小跳跃次数" class="headerlink" title="LCP 09. 最小跳跃次数"></a>LCP 09. 最小跳跃次数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射<code>jump[i]</code>的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 <code>i+jump[i]</code> 的弹簧（若 <code>i+jump[i]&gt;=N</code> ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。</p><p>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：jump = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line"></span><br><span class="line">解释：小 Z 最少需要按动 <span class="number">3</span> 次弹簧，小球依次到达的顺序为 <span class="number">0</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span> -&gt; <span class="number">6</span>，最终小球弹出了机器。</span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= jump.length &lt;= 10^6</code></li><li><code>1 &lt;= jump[i] &lt;= 10000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zui-xiao-tiao-yue-ci-shu</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  BFS或者DP</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>刚开始准备用BFS，第一次写BFS时竟然超时了，后来仔细发现还是部分条件存在重复的问题。</li><li>每次往前跳的时候或者往后跳的时候如果发现部分元素已经访问过时，需要将其剔除掉。</li><li>记录当前步数下所能够跳的最远距离，这时下一布如果选择往回跳时，直接从上一次的最大值开始常识，而不必要从0开始跳起。算法的时间复杂度为<code>O(n)</code>.</li><li>其实这个题目刚开始准备利用<code>set</code>自动排序的特性，每次直接将已经访问的元素直接从<code>set</code>中自动去掉。算法的时间时间复杂度为<code>O(lgn)</code>,因为二叉平衡树每次进行查找时需要<code>lgn</code>的时间复杂度，结果意外的超时，最后一个测试用例无法通过。</li><li>时间仔细计算以下，题目中的数量级为<code>10e6</code>,如果利用二分查找，则时间复杂度的数量级在<code>1e7</code>次方的数量级，这种情况下其实很容易超时。</li><li>仔细想想其实绝大部分问题的最优解法其实都是非常简单的，并且基本上思路都很直接和简单，实际在做题的时候如果把题目想的太复杂的话，很可能时自己的解法应该时错误的，这点必须知道自己的错误点在哪里，思路在哪里。其实目前刷题来说对于应付一般的面试肯定没有什么问题，但是如果正对于竞赛的话，自己的水平其实差的太远太远。</li><li>对于竞赛的话，感觉自己这种老人肯定是远远达不到年轻人的水平。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; jump)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = jump.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">        qu.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= n) <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(curr + jump[curr] &gt;= mx) qu.push(curr + jump[curr]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = mx; j &lt; curr; ++j) qu.push(j);</span><br><span class="line">                mx = max(mx,curr + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="LCP-10-二叉树任务调度"><a href="#LCP-10-二叉树任务调度" class="headerlink" title="LCP 10. 二叉树任务调度"></a>LCP 10. 二叉树任务调度</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>任务调度优化是计算机性能优化的关键任务之一。在任务众多时，不同的调度策略可能会得到不同的总体执行时间，因此寻求一个最优的调度方案是非常有必要的。</p><p>通常任务之间是存在依赖关系的，即对于某个任务，你需要先完成他的前导任务（如果非空），才能开始执行该任务。我们保证任务的依赖关系是一棵二叉树，其中 <code>root</code> 为根任务，<code>root.left</code> 和 <code>root.right</code> 为他的两个前导任务（可能为空），<code>root.val</code> 为其自身的执行时间。</p><p>在一个 CPU 核执行某个任务时，我们可以在任何时刻暂停当前任务的执行，并保留当前执行进度。在下次继续执行该任务时，会从之前停留的进度开始继续执行。暂停的时间可以不是整数。</p><p>现在，系统有两个 CPU 核，即我们可以同时执行两个任务，但是同一个任务不能同时在两个核上执行。给定这颗任务树，请求出所有任务执行完毕的最小时间。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">47</span>, <span class="number">74</span>, <span class="number">31</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">121</span></span><br><span class="line"></span><br><span class="line">解释：根节点的左右节点可以并行执行<span class="number">31</span>分钟，剩下的<span class="number">43</span>+<span class="number">47</span>分钟只能串行执行，因此总体执行时间是<span class="number">121</span>分钟。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">15</span>, <span class="number">21</span>, <span class="literal">null</span>, <span class="number">24</span>, <span class="literal">null</span>, <span class="number">27</span>, <span class="number">26</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">87</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.png</span><br><span class="line"></span><br><span class="line">输入：root = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">输出：<span class="number">7.5</span></span><br></pre></td></tr></table></figure><br>限制：</p><ul><li><code>1 &lt;= 节点数量 &lt;= 1000</code></li><li><code>1 &lt;= 单节点执行时间 &lt;= 1000</code></li></ul><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  贪心算法</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>当时比赛的时候没有想明白，解题思路可以参考lee215的微信公众号<a href="https://mp.weixin.qq.com/s/rmwVuDpbQlhoK7DcD715bg" target="_blank" rel="noopener">2020力扣杯</a>。</li><li>后来仔细思考了一下，还是非常有意思的，当时比赛时想到了这点，但是如何进一步优化确实没有深入思考，遇到困难就放弃，确实是自己最大的问题。</li><li>根据题目种的思路，实际上对于节点<code>root</code>,它的左右子树的任务是可以进行并行运行的，我们整个的解题思路也是围绕着，如何能够更好的解决左右子树同时并行的任务的最大值的问题。我们<code>dfs</code>时，每次返回<code>root</code>节点下双核并行任务的运行时间和单核任务运行的时间，分别为<code>s</code>,<code>d</code>,如何围绕左右子树的任务进行合并。</li><li>我们假设当前<code>root</code>节点的左子树返回的双核并行时间和单核运行时间分别为<code>d1</code>,<code>s1</code>.右子树返回的双核并行时间和单核运行时间分别为<code>d2</code>,<code>s2</code>.常规思路是我们讲所有的并行时间加起来，再把单核运行的时间中的部分最小值部分进行并行即<code>min(s1,s2)</code>.<br>所以我们可以得到左右子树的总共的并行时间为：<script type="math/tex; mode=display">d = d1 + d2 + min(s1,s2)</script>左右子树的总共的单核运行时间为:<script type="math/tex; mode=display">s = abs(s1-s2)</script>所以完成左右子树的任务的总时间应该为：<script type="math/tex; mode=display">t = d + s = d1 + d2 + min(s1,s2) + abs(s1-s2)\\</script></li><li>上面这样的结果基本上大部分人都能想到，但是实际上这样真的是最小吗？我们能否再增加d的时间，减少s的时间？但是如何再增加并行的时间，可能讨论就非常的复杂。隐隐约约感觉可以进行优化，因为我们知道假设并行的时间d再增减$\Delta t1$,单核运行的时间就可以减少$2\Delta t1$,总的时间也就减少$\Delta t1$, 也即我们想办法如何减少<code>abs(s1-s2)</code>，减少单核运行的时间。<script type="math/tex; mode=display">t = d + \Delta t1 + s - 2\Delta t1 = d + s - \Delta t1\\0 \le \Delta t1 \le \frac{s}{2} \\</script>仔细思考一下，这点稍微有点绕弯。如何进行优化呢？比如<code>s1 &gt; s2</code>,我们能否减少<code>d2</code>的并行时间$\Delta t$,然后<code>s2</code>就增加了$2 \Delta t$的时间内然后<code>s1</code>就能增加$2 \Delta t$与<code>s2</code>进行并行，这样我们就能够增加并行时间，那么总的消耗时间也就减少了。<script type="math/tex; mode=display">d2 = d2 - \Delta t\\s2 = s2 + 2*\Delta t\\t = d + s  \\t = d1 + d2  - \Delta t + min(s1,s2 + 2*\Delta t) + abs(s1-s2-2*\Delta t)</script>也就是我们要从<code>d2</code>中剥离部分时间尽量延长<code>s2</code>的使得<code>abs(s1-s2)</code>最小。只有这样才能得到最小值，实际也是贪心算法。所以当<code>s1 &gt; s2</code>时我们就要想办法提高<code>s2</code>,当<code>s2 &gt; s1</code>时我们就需要想办法提高<code>s1</code>.只有这样才能保证绝对值之差最小。<br>已知如下条件:<script type="math/tex; mode=display">s1 \ge s2 \\s1 \ge s2 - 2*\Delta t\\d2 \ge \Delta t\\d = d1 + d2 + min(s1,s2) = d1 + d2 + s2\\s = abs(s1-s2) = s1 - s2 \\t = d1 + d2 + s1 \\</script>我们对上述表达式进行展开：<script type="math/tex; mode=display">d^{'} = d1 + d2 + s2 + \Delta t \\s^{'} = s1 - s2 - 2*\Delta t \\t^{'} = d1 + d2  - \Delta t + s2 + 2*\Delta t  + (s1-s2-2*\Delta t)  \\t^{'} = d1 + d2 - \Delta t + s1</script>当然最优解的话肯定为：<script type="math/tex; mode=display">\Delta t = \frac{s1-s2}{2}</script>但由于还有下面的限制。<script type="math/tex; mode=display">d2 \ge \Delta t\\</script>所以总结起来：<script type="math/tex; mode=display">\Delta T = min(\frac{s1-s2}{2},d2)</script><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; dfs(TreeNode * root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; l = dfs(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; r = dfs(root-&gt;right);</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> d = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> delta = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(l.first &gt;= r.first)&#123;</span><br><span class="line">            delta = min((l.first-r.first)/<span class="number">2</span>,r.second);</span><br><span class="line">            d = l.second + r.second + r.first + delta;</span><br><span class="line">            s = l.first - r.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            delta = min((r.first-l.first)/<span class="number">2</span>,l.second);</span><br><span class="line">            d = l.second + r.second + l.first + delta;</span><br><span class="line">            s = r.first - l.first - <span class="number">2</span>*delta;</span><br><span class="line">            <span class="keyword">return</span> &#123;s + root-&gt;val,d&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">minimalExecTime</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; t = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> t.first + t.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LCP2020&quot;&gt;&lt;a href=&quot;#LCP2020&quot; class=&quot;headerlink&quot; title=&quot;LCP2020&quot;&gt;&lt;/a&gt;LCP2020&lt;/h1&gt;&lt;p&gt;还是比赛的题目质量高，可惜只做出来了4道题目，最后一道题目没有思路。&lt;/p&gt;&lt;h2 id=&quot;LCP-06-拿硬币&quot;&gt;&lt;a href=&quot;#LCP-06-拿硬币&quot; class=&quot;headerlink&quot; title=&quot;LCP 06. 拿硬币&quot;&gt;&lt;/a&gt;LCP 06. 拿硬币&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;桌上有 &lt;code&gt;n&lt;/code&gt;堆力扣币，每堆的数量保存在数组 &lt;code&gt;coins&lt;/code&gt;中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：第一堆力扣币最少需要拿 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 次，第二堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，第三堆最少需要拿 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 次，总共 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 次即可拿完。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;限制：&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第185周比赛</title>
    <link href="http://yoursite.com/2020/04/19/153/"/>
    <id>http://yoursite.com/2020/04/19/153/</id>
    <published>2020-04-19T00:37:17.252Z</published>
    <updated>2020-04-20T15:00:07.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="185周比赛"><a href="#185周比赛" class="headerlink" title="185周比赛"></a>185周比赛</h1><p>今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。</p><h2 id="5388-重新格式化字符串"><a href="#5388-重新格式化字符串" class="headerlink" title="5388. 重新格式化字符串"></a>5388. 重新格式化字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。</p><p>请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。</p><p>请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"a0b1c2"</span></span><br><span class="line">输出：<span class="string">"0a1b2c"</span></span><br><span class="line">解释：<span class="string">"0a1b2c"</span> 中任意两个相邻字符的类型都不同。 <span class="string">"a0b1c2"</span>, <span class="string">"0a1b2c"</span>, <span class="string">"0c2a1b"</span> 也是满足题目要求的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"leetcode"</span> 中只有字母，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"1229857369"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：<span class="string">"1229857369"</span> 中只有数字，所以无法满足重新格式化的条件。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"covid2019"</span></span><br><span class="line">输出：<span class="string">"c2o0v1i9d"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ab123"</span></span><br><span class="line">输出：<span class="string">"1a2b3"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li>s 仅由小写英文字母和/或数字组成。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reformat-the-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reformat-the-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  暴力。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>字母的数目和数字的数目差的绝对值大于2则不可能产生出相应的字符串。</li><li>排序依次交替打印出字母或者数字的个数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reformat</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alpha = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(s.size(),<span class="string">' '</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) digit++;</span><br><span class="line">            <span class="keyword">else</span> alpha++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(digit-alpha) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> la = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(digit &gt; alpha)&#123;</span><br><span class="line">            ld = <span class="number">0</span>;</span><br><span class="line">            la = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ld = <span class="number">1</span>;</span><br><span class="line">            la = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                res[ld] = c;</span><br><span class="line">                ld += <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[la] = c;</span><br><span class="line">                la += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5389-点菜展示表"><a href="#5389-点菜展示表" class="headerlink" title="5389. 点菜展示表"></a>5389. 点菜展示表</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>orders</code>，表示客户在餐厅中完成的订单，确切地说， <code>orders[i]=[customerNamei,tableNumberi,foodItemi]</code> ，其中 <code>customerNamei</code>是客户的姓名，<code>tableNumberi</code> 是客户所在餐桌的桌号，而 <code>foodItemi</code>是客户点的餐品名称。</p><p>请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 <code>“Table”</code> ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。</p><p>注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Corina"</span>,<span class="string">"10"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"David"</span>,<span class="string">"3"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Water"</span>],[<span class="string">"Carla"</span>,<span class="string">"5"</span>,<span class="string">"Ceviche"</span>],[<span class="string">"Rous"</span>,<span class="string">"3"</span>,<span class="string">"Ceviche"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Ceviche"</span>,<span class="string">"Fried Chicken"</span>,<span class="string">"Water"</span>],[<span class="string">"3"</span>,<span class="string">"0"</span>,<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>],[<span class="string">"5"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"1"</span>],[<span class="string">"10"</span>,<span class="string">"1"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>,<span class="string">"0"</span>]] </span><br><span class="line">解释：</span><br><span class="line">点菜展示表如下所示：</span><br><span class="line">Table,Beef Burrito,Ceviche,Fried Chicken,Water</span><br><span class="line"><span class="number">3</span>    ,<span class="number">0</span>           ,<span class="number">2</span>      ,<span class="number">1</span>            ,<span class="number">0</span></span><br><span class="line"><span class="number">5</span>    ,<span class="number">0</span>           ,<span class="number">1</span>      ,<span class="number">0</span>            ,<span class="number">1</span></span><br><span class="line"><span class="number">10</span>   ,<span class="number">1</span>           ,<span class="number">0</span>      ,<span class="number">0</span>            ,<span class="number">0</span></span><br><span class="line">对于餐桌 <span class="number">3</span>：David 点了 <span class="string">"Ceviche"</span> 和 <span class="string">"Fried Chicken"</span>，而 Rous 点了 <span class="string">"Ceviche"</span></span><br><span class="line">而餐桌 <span class="number">5</span>：Carla 点了 <span class="string">"Water"</span> 和 <span class="string">"Ceviche"</span></span><br><span class="line">餐桌 <span class="number">10</span>：Corina 点了 <span class="string">"Beef Burrito"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"James"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Ratesh"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Amadeus"</span>,<span class="string">"12"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"Adam"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>],[<span class="string">"Brianna"</span>,<span class="string">"1"</span>,<span class="string">"Canadian Waffles"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Canadian Waffles"</span>,<span class="string">"Fried Chicken"</span>],[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"0"</span>],[<span class="string">"12"</span>,<span class="string">"0"</span>,<span class="string">"3"</span>]] </span><br><span class="line">解释：</span><br><span class="line">对于餐桌 <span class="number">1</span>：<span class="symbol">Adam</span> 和 <span class="symbol">Brianna</span> 都点了 <span class="string">"Canadian Waffles"</span></span><br><span class="line">而餐桌 <span class="number">12</span>：<span class="symbol">James</span>, <span class="symbol">Ratesh</span> 和 <span class="symbol">Amadeus</span> 都点了 <span class="string">"Fried Chicken"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：orders = [[<span class="string">"Laura"</span>,<span class="string">"2"</span>,<span class="string">"Bean Burrito"</span>],[<span class="string">"Jhon"</span>,<span class="string">"2"</span>,<span class="string">"Beef Burrito"</span>],[<span class="string">"Melissa"</span>,<span class="string">"2"</span>,<span class="string">"Soda"</span>]]</span><br><span class="line">输出：[[<span class="string">"Table"</span>,<span class="string">"Bean Burrito"</span>,<span class="string">"Beef Burrito"</span>,<span class="string">"Soda"</span>],[<span class="string">"2"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= orders.length &lt;= 5 * 10^4</code></li><li><code>orders[i].length == 3</code></li><li><code>1 &lt;= customerNamei.length, foodItemi.length &lt;= 20</code></li><li><code>customerNamei</code> 和 <code>foodItemi</code> 由大小写英文字母及空格字符 ‘ ‘ 组成。</li><li><code>tableNumberi</code> 是 1 到 500 范围内的整数。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant" target="_blank" rel="noopener">https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 系统设计</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>用map保存每桌的点餐的事物和数量。同时<code>set</code>保存所有的菜品。</li><li>每次点餐时在每桌的订单上进行数据叠加。</li><li>最后统计就非常简单了。直接map查询每周每个菜品订单的数量即可。</li><li>用<code>map</code>和<code>set</code>可以直接利用二叉查找树的自动排序功能，避免二次排序。</li></ol></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; displayTable(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; orders) &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; table;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; foods;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; type;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> order : orders)&#123;</span><br><span class="line">            table[stoi(order[<span class="number">1</span>])][order[<span class="number">2</span>]]++;</span><br><span class="line">            foods.insert(order[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        type.push_back(<span class="string">"Table"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : foods)&#123;</span><br><span class="line">            type.push_back(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*first colum*/</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        res.push_back(type);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p : table)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; col;</span><br><span class="line">            col.push_back(to_string(p.first));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; type.size(); ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.second.count(type[i]))&#123;</span><br><span class="line">                    col.push_back(to_string(p.second[type[i]]));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    col.push_back(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(col);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5390-数青蛙"><a href="#5390-数青蛙" class="headerlink" title="5390. 数青蛙"></a>5390. 数青蛙</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串<code>croakOfFrogs</code>，它表示不同青蛙发出的蛙鸣声（字符串 <code>&quot;croak&quot;</code> ）的组合。由于同一时间可以有多只青蛙呱呱作响，所以 <code>croakOfFrogs</code> 中会混合多个 <code>“croak”</code>。请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。</p><p>注意：要想发出蛙鸣 <code>&quot;croak&quot;</code>，青蛙必须 依序 输出<code>‘c’, ’r’, ’o’, ’a’, ’k’</code>这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。</p><p>如果字符串 <code>croakOfFrogs</code>不是由若干有效的<code>&quot;croak&quot;</code> 字符混合而成，请返回 -1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroak"</span></span><br><span class="line">输出：<span class="number">1</span> </span><br><span class="line">解释：一只青蛙 “呱呱” 两次</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"crcoakroak"</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：最少需要两只青蛙，“呱呱” 声用黑体标注</span><br><span class="line">第一只青蛙 <span class="string">"crcoakroak"</span></span><br><span class="line">第二只青蛙 <span class="string">"crcoakroak"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcrook"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：给出的字符串不是 <span class="string">"croak"</span> 的有效组合。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：croakOfFrogs = <span class="string">"croakcroa"</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= croakOfFrogs.length &lt;= 10^5</code></li><li>字符串中的字符只有<code>&#39;c&#39;, &#39;r&#39;, &#39;o&#39;, &#39;a&#39;</code>或者 <code>&#39;k&#39;</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-number-of-frogs-croaking</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 题目出的不错，非常有点绕</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>判断是否需要数目加1</code>：遇到字母<code>c</code>时判断当前是否已经有完成呼叫的任务，如果有则直接将其拿过来进行重新呼叫一次，否则再新加进来一只青蛙进行呼叫。</li><li><code>判断当前呼叫是否合法</code>: 判断当前字母的统计数目是否大于前一个字母的数目，如果是则时非法的，表示该次呼叫未按照顺序进行拼写呼叫。全部呼叫完成后，最后判断所有的青蛙是否全部完成呼叫，即所有的字母统计数目相等。</li><li>返回字符的统计数目即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkFrog</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;  p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; &amp; cnt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = cnt.begin()-&gt;second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; p : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x != p.second) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberOfFrogs</span><span class="params">(<span class="built_in">string</span> A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">"croak"</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; prev;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            prev[s[i]] = s[(i+<span class="number">4</span>)%<span class="number">5</span>];</span><br><span class="line">            cnt[s[i]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] == <span class="string">'c'</span> &amp;&amp; checkFrog(cnt))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.size(); ++j) cnt[s[j]]--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[A[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(A[i] != <span class="string">'c'</span> &amp;&amp; cnt[A[i]] &gt; cnt[prev[A[i]]]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!checkValid(cnt)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="string">'c'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5391-生成数组"><a href="#5391-生成数组" class="headerlink" title="5391. 生成数组"></a>5391. 生成数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你三个整数 <code>n、m 和 k</code>。下图描述的算法用于找出正整数数组中最大的元素。</p><p>请你生成一个具有下述属性的数组 <code>arr</code>：</p><ul><li><code>arr</code>中有 n 个整数。</li><li><code>1 &lt;= arr[i] &lt;= m</code>其中<code>(0 &lt;= i &lt; n)</code> 。</li><li>将上面提到的算法应用于 <code>arr ，search_cost</code>的值等于 k 。</li></ul><p>返回上述条件下生成数组 <code>arr</code>的 方法数 ，由于答案可能会很大，所以 必须 对 <code>10^9 + 7</code>取余。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, m = <span class="number">3</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：可能的数组分别为 [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">2</span>] [<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5</span>, m = <span class="number">2</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：没有数组可以满足上述条件</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">9</span>, m = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：可能的数组只有 [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">50</span>, m = <span class="number">100</span>, k = <span class="number">25</span></span><br><span class="line">输出：<span class="number">34549172</span></span><br><span class="line">解释：不要忘了对 <span class="number">1000000007</span> 取余</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">37</span>, m = <span class="number">17</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">418930126</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 50</code></li><li><code>1 &lt;= m &lt;= 100</code></li><li><code>0 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons" target="_blank" rel="noopener">https://leetcode-cn.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>设<code>dp[i][j][k]</code>代表数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>的数组的方案数目。</li><li>我们假设当前数组长度为<code>i</code>,且当前的最大值为<code>j</code>且得分为<code>k</code>。则当数组长度为<code>i+1</code>时，如果第<code>i+1</code>个数大于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该为为<code>k+1</code>,则这时第<code>i+1</code>个数的取值范围为<code>j+1~m</code>;如果第<code>i+1</code>个数小于等于前<code>i</code>个数的最大值<code>j</code>，则他的得分应该仍然为<code>k</code>,则这时第<code>i+1</code>个数应该取值范围为<code>1~j</code>。因此我们可以得到递推公式如下：<script type="math/tex; mode=display">dp[i][j][k] = dp[i-1][j][k]*j + \sum_{x=1}^{j-1}dp[i-1][x][k-1]</script></li><li>最后我们可以得到得分为<code>k</code>的总的方案数目:<script type="math/tex; mode=display">total = \sum_{i=1}^{m}dp[n][i][k]</script></li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">51</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> K = <span class="number">51</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfArrays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp[N][M][K];</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            dp[<span class="number">1</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">2</span>; a &lt;= n; ++a)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt;= m; ++b)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= k &amp;&amp; c &lt;= b &amp;&amp; c &lt;= a; ++c)&#123;</span><br><span class="line">                    dp[a][b][c] = (b*dp[a<span class="number">-1</span>][b][c])%mod;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> mx = <span class="number">1</span>; mx &lt; b; ++mx)&#123;</span><br><span class="line">                        dp[a][b][c] = (dp[a][b][c] + dp[a<span class="number">-1</span>][mx][c<span class="number">-1</span>])%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">            total = (total + dp[n][i][k])%mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;185周比赛&quot;&gt;&lt;a href=&quot;#185周比赛&quot; class=&quot;headerlink&quot; title=&quot;185周比赛&quot;&gt;&lt;/a&gt;185周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高,题目质量都不错，有一定的小技巧。&lt;/p&gt;&lt;h2 id=&quot;5388-重新格式化字符串&quot;&gt;&lt;a href=&quot;#5388-重新格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;5388. 重新格式化字符串&quot;&gt;&lt;/a&gt;5388. 重新格式化字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。&lt;/p&gt;&lt;p&gt;请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。&lt;/p&gt;&lt;p&gt;请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第24场双周比赛</title>
    <link href="http://yoursite.com/2020/04/18/152/"/>
    <id>http://yoursite.com/2020/04/18/152/</id>
    <published>2020-04-18T10:19:10.180Z</published>
    <updated>2020-04-19T12:19:12.166Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24周双周比赛"><a href="#24周双周比赛" class="headerlink" title="24周双周比赛"></a>24周双周比赛</h1><p>今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部<code>AC</code>，不过跟那些大神不能比，10分钟<code>AC</code>四道题的那种。</p><h2 id="5372-逐步求和得到正数的最小值"><a href="#5372-逐步求和得到正数的最小值" class="headerlink" title="5372. 逐步求和得到正数的最小值"></a>5372. 逐步求和得到正数的最小值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> 。你可以选定任意的 正数 <code>startValue</code> 作为初始值。</p><p>你需要从左到右遍历<code>nums</code> 数组，并将 <code>startValue</code> 依次累加上<code>nums</code>数组中的值。</p><a id="more"></a><p>请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 <code>startValue</code> 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">-3</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：如果你选择 startValue = <span class="number">4</span>，在第三次累加时，和小于 <span class="number">1</span> 。</span><br><span class="line">                累加求和</span><br><span class="line">                startValue = <span class="number">4</span> | startValue = <span class="number">5</span> | nums</span><br><span class="line">                  (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>  | (<span class="number">5</span> <span class="number">-3</span> ) = <span class="number">2</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">1</span> +<span class="number">2</span> ) = <span class="number">3</span>  | (<span class="number">2</span> +<span class="number">2</span> ) = <span class="number">4</span>    |   <span class="number">2</span></span><br><span class="line">                  (<span class="number">3</span> <span class="number">-3</span> ) = <span class="number">0</span>  | (<span class="number">4</span> <span class="number">-3</span> ) = <span class="number">1</span>    |  <span class="number">-3</span></span><br><span class="line">                  (<span class="number">0</span> +<span class="number">4</span> ) = <span class="number">4</span>  | (<span class="number">1</span> +<span class="number">4</span> ) = <span class="number">5</span>    |   <span class="number">4</span></span><br><span class="line">                  (<span class="number">4</span> +<span class="number">2</span> ) = <span class="number">6</span>  | (<span class="number">5</span> +<span class="number">2</span> ) = <span class="number">7</span>    |   <span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：最小的 startValue 需要是正数。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>-100 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-value-to-get-positive-step-by-step-sum</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  求前<code>n</code>项和的最小值。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>我们最低需要满足前<code>n</code>项和的最小值与这个数相加大于等于<code>1</code>即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minStartValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            res = max(res,<span class="number">1</span>-sum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5373-和为-K-的最少斐波那契数字数目"><a href="#5373-和为-K-的最少斐波那契数字数目" class="headerlink" title="5373. 和为 K 的最少斐波那契数字数目"></a>5373. 和为 K 的最少斐波那契数字数目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你数字 <code>k</code>，请你返回和为<code>k</code>的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。</p><p>斐波那契数字定义为：</p><ul><li><code>F1 = 1</code></li><li><code>F2 = 1</code></li><li><code>Fn = Fn-1 + Fn-2</code> ， 其中 n &gt; 2 。</li></ul><p>数据保证对于给定的 k ，一定能找到可行解。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">7</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：斐波那契数字为：<span class="number">1</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">8</span>，<span class="number">13</span>，……</span><br><span class="line">对于 k = <span class="number">7</span> ，我们可以得到 <span class="number">2</span> + <span class="number">5</span> = <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">2</span> </span><br><span class="line">解释：对于 k = <span class="number">10</span> ，我们可以得到 <span class="number">2</span> + <span class="number">8</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = <span class="number">19</span></span><br><span class="line">输出：<span class="number">3</span> </span><br><span class="line">解释：对于 k = <span class="number">19</span> ，我们可以得到 <span class="number">1</span> + <span class="number">5</span> + <span class="number">13</span> = <span class="number">19</span> 。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= k &lt;= 10^9</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目看似很简单，但当时卡壳了好久。后来仔细研究了一下，发现了规律。</li><li>我们找出所有不大于<code>k</code>的斐波那契数列，如果k在数列中，我们直接返回1.</li><li>否则我们找到最大且最接近<code>k</code>的斐波那契数<code>m</code>, 然后再递归求<code>k-m</code>最少需要多少个费不纳妾数组合。<code>fib(k)</code>表示最大的小于等于<code>K</code>的斐波那契数。<script type="math/tex; mode=display">F(k) = 1 + F(k-fib(k))</script></li><li>贴了一下证明过程，用数学归纳法证明比较有意思：</li></ol><ul><li>对于$k=1$是显然成立.</li><li>假设$k=1…N$都成立,则当$k=N+1$时，如果$k$本身是斐波那契数，自然成立，否则一定存在<code>m</code>,使得下述不等式成立：<script type="math/tex; mode=display">Fib_{m}<k<Fib_{m+1}</script></li><li>根据上述不等式可以化为：<script type="math/tex; mode=display">0<k−Fib_{m}<Fib_{m+1}−Fib_{m}=Fib_{m−1} \\k = Fib_{m} + (k-Fib_{m})</script></li><li>按照题目中的归纳条件，根据斐波那契数列数列递增的特性$Fib_{m} \le Fib_{m+1}$,显然我们可以得出<script type="math/tex; mode=display">1\le Fib_{m} \le N \\1\le (k-Fib_{m}) \le N \\k - Fib_{m} \le Fib_{m} \\</script></li><li>按照归纳条件$k−Fib_{m}$可以表示为不同的斐波那契数之和，这些斐波那契数里面显然不包括$Fib_{m}$.所以$k=N+1$也可以表示为不同的斐波那契数之和.且序列中每个数都不相等，而且必须是不连续的斐波那契数之和.因为存在以下等式：<script type="math/tex; mode=display">Fib_{m} + Fib_{m} = Fib_{m+1} \:\:\:  (m == 1) \\Fib_{m} + Fib_{m} = Fib_{m-1} + Fib_{m-2} + Fib{m}  = Fib_{m-2} + Fib_{m+1} \:\:\: (m \neq 1) \\\\Fib_{m} + Fib_{m+1} = Fib_{m+2} \\</script></li></ul></blockquote><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinFibonacciNumbers</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> f3 = <span class="number">0</span>;</span><br><span class="line">        cnt.insert(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;  f3 &lt; k ; ++i)&#123;</span><br><span class="line">            f3 = f1+f2;</span><br><span class="line">            f1 = f2;</span><br><span class="line">            f2 = f3;</span><br><span class="line">            cnt.insert(f3);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt.count(k))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.lower_bound(k);</span><br><span class="line">            it--;</span><br><span class="line">            k -= *it;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5374-长度为-n-的开心字符串中字典序第-k-小的字符串"><a href="#5374-长度为-n-的开心字符串中字典序第-k-小的字符串" class="headerlink" title="5374. 长度为 n 的开心字符串中字典序第 k 小的字符串"></a>5374. 长度为 n 的开心字符串中字典序第 k 小的字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>一个 「开心字符串」定义为：</p><ul><li>仅包含小写字母 <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code>.</li><li>对所有在 1 到 <code>s.length - 1</code>之间的 i ，满足<code>s[i] != s[i + 1]</code>（字符串的下标从 1 开始）。</li></ul><p>比方说，字符串 <code>&quot;abc&quot;</code>，<code>&quot;ac&quot;，&quot;b&quot;</code>和 <code>&quot;abcbabcbcb&quot;</code> 都是开心字符串，但是<code>&quot;aa&quot;，&quot;baa&quot;</code>和<code>&quot;ababbc&quot;</code>都不是开心字符串。</p><p>给你两个整数 <code>n</code> 和 <code>k</code>，你需要将长度为 <code>n</code>的所有开心字符串按字典序排序。</p><p>请你返回排序后的第 <code>k</code> 个开心字符串，如果长度为 <code>n</code>的开心字符串少于 <code>k</code>个，那么请你返回 空字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">3</span></span><br><span class="line">输出：<span class="string">"c"</span></span><br><span class="line">解释：列表 [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>] 包含了所有长度为 <span class="number">1</span> 的开心字符串。按照字典序排序后第三个字符串为 <span class="string">"c"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：长度为 <span class="number">1</span> 的开心字符串只有 <span class="number">3</span> 个。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, k = <span class="number">9</span></span><br><span class="line">输出：<span class="string">"cab"</span></span><br><span class="line">解释：长度为 <span class="number">3</span> 的开心字符串总共有 <span class="number">12</span> 个 [<span class="string">"aba"</span>, <span class="string">"abc"</span>, <span class="string">"aca"</span>, <span class="string">"acb"</span>, <span class="string">"bab"</span>, <span class="string">"bac"</span>, <span class="string">"bca"</span>, <span class="string">"bcb"</span>, <span class="string">"cab"</span>, <span class="string">"cac"</span>, <span class="string">"cba"</span>, <span class="string">"cbc"</span>] 。第 <span class="number">9</span> 个字符串为 <span class="string">"cab"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, k = <span class="number">7</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">10</span>, k = <span class="number">100</span></span><br><span class="line">输出：<span class="string">"abacbabacb"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><pre><code>1 &lt;= n &lt;= 101 &lt;= k &lt;= 100</code></pre><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n" target="_blank" rel="noopener">https://leetcode-cn.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接DFS暴力匹配</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量非常小，也没啥好优化的，直接DFS搞起。</li><li>因为题目中是求得是第<code>k</code>个字符串，所以不太好弄，直接DFS模拟求出第k个即可。如果求数量得话，直接<code>DP</code>搞定。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> &amp; curr,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(res.size() &gt;= k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(curr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.back() == <span class="string">'a'</span> + i) <span class="keyword">continue</span>;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span> + i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">getHappyString</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> curr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">            curr.push_back(<span class="string">'a'</span>+i);</span><br><span class="line">            dfs(curr,n<span class="number">-1</span>,k,res);</span><br><span class="line">            curr.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.size() != k) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> res.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5375-恢复数组"><a href="#5375-恢复数组" class="headerlink" title="5375. 恢复数组"></a>5375. 恢复数组</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>某个程序本来应该输出一个整数数组。但是这个程序忘记输出空格了以致输出了一个数字字符串，我们所知道的信息只有：数组中所有整数都在 ·<code>[1, k]</code>之间，且数组中的数字都没有前导 0 。</p><p>给你字符串 <code>s</code> 和整数<code>k</code> 。可能会有多种不同的数组恢复结果。</p><p>按照上述程序，请你返回所有可能输出字符串 s 的数组方案数。</p><p>由于数组方案数可能会很大，请你返回它对 10^9 + 7 取余 后的结果。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10000</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一一种可能的数组方案是 [<span class="number">1000</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1000"</span>, k = <span class="number">10</span></span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：不存在任何数组方案满足所有整数都 &gt;= <span class="number">1</span> 且 &lt;= <span class="number">10</span> 同时输出结果为 s 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1317"</span>, k = <span class="number">2000</span></span><br><span class="line">输出：<span class="number">8</span></span><br><span class="line">解释：可行的数组方案为 [<span class="number">1317</span>]，[<span class="number">131</span>,<span class="number">7</span>]，[<span class="number">13</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">317</span>]，[<span class="number">13</span>,<span class="number">1</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">31</span>,<span class="number">7</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">17</span>]，[<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"2020"</span>, k = <span class="number">30</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：唯一可能的数组方案是 [<span class="number">20</span>,<span class="number">20</span>] 。 [<span class="number">2020</span>] 不是可行的数组方案，原因是 <span class="number">2020</span> &gt; <span class="number">30</span> 。 [<span class="number">2</span>,<span class="number">020</span>] 也不是可行的数组方案，因为 <span class="number">020</span> 含有前导 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1234567890"</span>, k = <span class="number">90</span></span><br><span class="line">输出：<span class="number">34</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code>.</li><li><code>s 只包含数字且不包含前导 0</code> 。</li><li><code>1 &lt;= k &lt;= 10^9</code>.<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><a href="https://leetcode-cn.com/problems/restore-the-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/restore-the-array</a><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  基本上需要取模的都是动态规划。</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>本题基本一眼看到就是动态规划。</li><li><code>dp[i]</code>代表前数组前<code>i</code>个数的组合数目，则递推公式为：<script type="math/tex; mode=display">dp[i] = \sum_{j=1}^{i} dp[i-j] \: \: if(num(i-j+1,i) \le k)</script></li><li>因为题目中给定的<code>k</code>的最大长度为<code>10</code>，所以非常简单，我们只需要判断从<code>i</code>往前数<code>i-10</code>组成的字串是否为合法的数目，且其是否大于给定的数目<code>k</code>.</li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArrays</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> m = to_string(k).size();</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m &amp;&amp; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i-j] == <span class="string">'0'</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(stoll(s.substr(i-j,j)) &lt;= k)&#123;</span><br><span class="line">                    dp[i] = (dp[i] + dp[i-j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;24周双周比赛&quot;&gt;&lt;a href=&quot;#24周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;24周双周比赛&quot;&gt;&lt;/a&gt;24周双周比赛&lt;/h1&gt;&lt;p&gt;今天的题目质量还是非常高，难度不是很大，但都需要一些小的技巧，全部&lt;code&gt;AC&lt;/code&gt;，不过跟那些大神不能比，10分钟&lt;code&gt;AC&lt;/code&gt;四道题的那种。&lt;/p&gt;&lt;h2 id=&quot;5372-逐步求和得到正数的最小值&quot;&gt;&lt;a href=&quot;#5372-逐步求和得到正数的最小值&quot; class=&quot;headerlink&quot; title=&quot;5372. 逐步求和得到正数的最小值&quot;&gt;&lt;/a&gt;5372. 逐步求和得到正数的最小值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 。你可以选定任意的 正数 &lt;code&gt;startValue&lt;/code&gt; 作为初始值。&lt;/p&gt;&lt;p&gt;你需要从左到右遍历&lt;code&gt;nums&lt;/code&gt; 数组，并将 &lt;code&gt;startValue&lt;/code&gt; 依次累加上&lt;code&gt;nums&lt;/code&gt;数组中的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【算法】</title>
    <link href="http://yoursite.com/2020/04/17/151/"/>
    <id>http://yoursite.com/2020/04/17/151/</id>
    <published>2020-04-17T04:25:14.114Z</published>
    <updated>2020-04-21T15:50:33.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ACautomation的DFA的写法"><a href="#ACautomation的DFA的写法" class="headerlink" title="ACautomation的DFA的写法"></a>ACautomation的DFA的写法</h1><p>最近学习了字符串的相关算法，特别是对<code>kmp</code>和 <code>DFA</code>以及正则表达式的<code>NFA</code>的匹配。特别是<code>kmp</code>这种字符串匹配算法，其实本质也是贪心算法得一种，每次匹配前一个字符为结尾的最长后缀的下一个字母。后来仔细研究了下<code>Aho-Corasick automation</code>,它的算法本质其实也是和<code>kmp</code>一样，如果当前字符<code>s[i]</code>不能匹配，则匹配上一个字符<code>s[i-1]</code>为结尾的最长后缀的下一个字符。</p><a id="more"></a><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>我们假设<code>s[i]</code>的最长后缀为<code>prefix[i-1] = k</code>,一旦遇到<code>s[i]</code>不能匹配当前字符串时，则我们就将<code>s[i]</code>与<code>s[prefix[i-1]+1]</code>进行匹配。<br>同时学习Princeton的算法课程时，看到了课件上的<code>kmp</code>的<code>dfa</code>写法，其实非常非常的简单。强烈建议学习一下这个<code>dfa</code>的写法。<br><img src="https://mike-box.github.io/images/148-1.png" alt="kmp"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><code>dfa</code>则为确定的状态机，当前状态接受输入后的下一个状态只有一个，是可预测的，所以称之为确定状态机。<code>nfa</code>为不确定状态机，当前状态接受下一个字符后，后续状态可以有多个，因此下一个状态不确定，所以我们称之为不确定状态机。</li><li>对于单个字符串的匹配，我们可以用<code>dfa</code>来进行匹配。<code>dfa</code>的建立的原理可以参考Princeton的算法课程，老爷爷讲的特别清楚。当前正确的匹配状态从<code>0~n-1</code>开始匹配，失败的匹配状态从<code>1~n</code>开始匹配。比如字符串<code>ababac</code>.<br><code>dfa</code>正确的匹配状态如下。<script type="math/tex; mode=display">0\stackrel{a}{\longrightarrow}1\stackrel{b}{\longrightarrow}2\stackrel{a}{\longrightarrow}3\stackrel{b}{\longrightarrow}4\stackrel{a}{\longrightarrow}5\stackrel{c}{\longrightarrow}6</script>则我们知道正确的匹配状态如下<script type="math/tex; mode=display">dfa(0,a) = 1 \\dfa(1,b) = 2  \\dfa(2,a) = 3  \\dfa(3,b) = 4  \\dfa(4,a) = 5  \\dfa(5,c) = 6  \\</script></li><li>我们可以知道当处于状态<code>0</code>时，则不正确的匹配状态为<script type="math/tex; mode=display">dfa(0,b) = 0 \\dfa(0,c) = 0 \\</script>我们设置另一个<code>fail</code>状态的匹配从<code>1~n-1</code>开始匹配字符串<code>babac</code>。<br>设置状态<code>1</code>匹配失败的状态<script type="math/tex; mode=display">fail = 0 \\dfa(1,b) = dfa(fail,b) \\dfa(1,c) = dfa(fail,c) \\</script>设置状态<code>2</code>匹配失败的状态<script type="math/tex; mode=display">fail = dfa(fail,b) = 0 \\dfa(2,a) = dfa(fail,b) \\dfa(2,c) = dfa(fail,c) \\</script>剩余的状态计算匹配依次按照上述规律即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; pat,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; dfa,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; prefix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = pat.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">           dfa.push_back(state);</span><br><span class="line">           dfa[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       dfa[pat[<span class="number">0</span>]-<span class="string">'a'</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       prefix[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; n; ++i )&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">               dfa[j][i] = dfa[j][x];</span><br><span class="line">           &#125;</span><br><span class="line">           dfa[pat[i]-<span class="string">'a'</span>][i] = i+<span class="number">1</span>;</span><br><span class="line">           x = dfa[pat[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           prefix[i] = x;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> end = dfa[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">           x = dfa[str[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           <span class="keyword">if</span>(x == end) <span class="keyword">return</span> i-x+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="匹配原理"><a href="#匹配原理" class="headerlink" title="匹配原理"></a>匹配原理</h3></li><li>我们知道KMP的匹配状态如此，那么AC automation的状态匹配也应该如此，其实本来AC匹配属于多字符串匹配，应该用<code>NFA</code>来实现的，比如我们常见的正则表达式的<code>|</code>操作即可匹配多个字符串。但是实际过程中我们也可以用模拟DFA的操作来完成这个状态转移。<br>只不过每次设置DFA的时候需要设置第<code>i</code>个字符串的前<code>j</code>个字符的最长匹配后缀。代码写的比较复杂，但是实际运行效果还是可以的。我们对所有字符串组成<code>trie</code>树，对每个非空节点进行编码和定义状态。实际也是搜索过程也是在这些状态种跳转。</li><li>我们按层对<code>trie</code>树进行遍历，每次记住上层的<code>fail</code>状态,然后计算本层的匹配失败后的跳转状态。但是它与<code>kmp</code>有点区别的是，需要对最终结束的节点的下一个状态进行计算，对于单个字符串的<code>kmp</code>匹配算法来说，我们只需匹配到结束状态即可，计算出相应的匹配位置即可，但是多个字符串匹配时可能情况会比较复杂，有可能匹配某个字符串<code>s</code>结束状态时，实际还需要进行匹配下一个字符串<code>t</code>。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    TrieNode * next[<span class="number">26</span>];</span><br><span class="line">    TrieNode(<span class="keyword">int</span> idx)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;idx = idx;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;TrieNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">acAutomation</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    acAutomation()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> TrieNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodes.push_back(root);</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildAc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        buildTrie(words);</span><br><span class="line">        buildFail(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildTrie</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; word : words)&#123;</span><br><span class="line">            insertTrie(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buildFail</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="keyword">int</span> m = nodes.size();        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prev(n,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curr(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;dfa = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">this</span>-&gt;fail = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> c = words[i][<span class="number">0</span>]-<span class="string">'a'</span>;</span><br><span class="line">            dfa[<span class="number">0</span>][c] = <span class="keyword">this</span>-&gt;nodes[<span class="number">0</span>]-&gt;next[c]-&gt;idx;</span><br><span class="line">            curr[i] = dfa[<span class="number">0</span>][c];</span><br><span class="line">            prev[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>-&gt;fail[curr[i]] = prev[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;width; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[j].size() &lt;= i) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                    dfa[curr[j]][k] = dfa[prev[j]][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> c = words[j][i] - <span class="string">'a'</span>;</span><br><span class="line">                dfa[curr[j]][c] = <span class="keyword">this</span>-&gt;nodes[curr[j]]-&gt;next[c]-&gt;idx;</span><br><span class="line">                curr[j] = dfa[curr[j]][c];</span><br><span class="line">                prev[j] = dfa[prev[j]][c];</span><br><span class="line">                fail[curr[j]] = prev[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*linked the complate state*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nodes[i]-&gt;isWord)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nodes[i]-&gt;next[j] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        dfa[i][j] = dfa[fail[i]][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> &amp; content)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : content)&#123;</span><br><span class="line">            curr = dfa[curr][c-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">int</span> state = curr;</span><br><span class="line">            <span class="keyword">while</span>(state != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodes[state]-&gt;isWord)&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;nodes[state]-&gt;word&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                state = fail[state];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%4c"</span>,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%3c "</span>,<span class="string">'a'</span> + i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nodes.size(); ++j)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%4d"</span>,dfa[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fail"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%4d"</span>,fail[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insertTrie</span><span class="params">(<span class="built_in">string</span> &amp; word)</span></span>&#123;</span><br><span class="line">        TrieNode * curr = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : word)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!curr-&gt;next[c-<span class="string">'a'</span>])&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;nodes.push_back(<span class="keyword">new</span> TrieNode(nodes.size()));</span><br><span class="line">                curr-&gt;next[c-<span class="string">'a'</span>] = <span class="keyword">this</span>-&gt;nodes.back();</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        curr-&gt;word = word;</span><br><span class="line">        <span class="keyword">this</span>-&gt;width = max(<span class="keyword">this</span>-&gt;width,<span class="keyword">int</span>(word.size()));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode * root;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode *&gt; nodes;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fail;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">"abcd"</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">"bcde"</span>;</span><br><span class="line">    <span class="built_in">string</span> s3 = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">string</span> s4 = <span class="string">"bc"</span>;</span><br><span class="line">    <span class="built_in">string</span> s5 = <span class="string">"c"</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; words;</span><br><span class="line">    words.push_back(s1);</span><br><span class="line">    words.push_back(s2);</span><br><span class="line">    words.push_back(s3);</span><br><span class="line">    words.push_back(s4);</span><br><span class="line">    words.push_back(s5);</span><br><span class="line">    acAutomation * ac = <span class="keyword">new</span> acAutomation();</span><br><span class="line">    ac-&gt;buildAc(words);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> content = <span class="string">"abcdefabcd"</span>;</span><br><span class="line">    ac-&gt;search(content);</span><br><span class="line">    ac-&gt;debug();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ACautomation的DFA的写法&quot;&gt;&lt;a href=&quot;#ACautomation的DFA的写法&quot; class=&quot;headerlink&quot; title=&quot;ACautomation的DFA的写法&quot;&gt;&lt;/a&gt;ACautomation的DFA的写法&lt;/h1&gt;&lt;p&gt;最近学习了字符串的相关算法，特别是对&lt;code&gt;kmp&lt;/code&gt;和 &lt;code&gt;DFA&lt;/code&gt;以及正则表达式的&lt;code&gt;NFA&lt;/code&gt;的匹配。特别是&lt;code&gt;kmp&lt;/code&gt;这种字符串匹配算法，其实本质也是贪心算法得一种，每次匹配前一个字符为结尾的最长后缀的下一个字母。后来仔细研究了下&lt;code&gt;Aho-Corasick automation&lt;/code&gt;,它的算法本质其实也是和&lt;code&gt;kmp&lt;/code&gt;一样，如果当前字符&lt;code&gt;s[i]&lt;/code&gt;不能匹配，则匹配上一个字符&lt;code&gt;s[i-1]&lt;/code&gt;为结尾的最长后缀的下一个字符。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="AC" scheme="http://yoursite.com/tags/AC/"/>
    
  </entry>
  
  <entry>
    <title>【Atcoder】 AtCoder Beginner Contest 162</title>
    <link href="http://yoursite.com/2020/04/15/150/"/>
    <id>http://yoursite.com/2020/04/15/150/</id>
    <published>2020-04-15T04:39:48.065Z</published>
    <updated>2020-04-15T07:30:22.656Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AtCoder-Beginner-Contest-162"><a href="#AtCoder-Beginner-Contest-162" class="headerlink" title="AtCoder Beginner Contest 162"></a>AtCoder Beginner Contest 162</h1><p><code>atcoder</code>题目比<code>leetcode</code>题目质量高多了。非常有意思。</p><h2 id="A-Lucky-7"><a href="#A-Lucky-7" class="headerlink" title="A - Lucky 7"></a>A - Lucky 7</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB</p><p>Score : 100</p><p>points</p><h4 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Given is a three-digit integer N<br>. Does N contain the digit 7</p><a id="more"></a><p>If so, print Yes; otherwise, print No.</p><h4 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>100≤N≤999</code></li></ul><p>Input<br><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span> is given <span class="meta">from</span> Standard <span class="meta">Input</span> <span class="meta">in</span> the following <span class="meta">format</span>:</span><br><span class="line"></span><br><span class="line">N</span><br></pre></td></tr></table></figure></p><p>Output<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">If</span> N</span><br><span class="line">contains the digit 7</span><br><span class="line"></span><br><span class="line">, <span class="builtin-name">print</span> <span class="literal">Yes</span>; otherwise, <span class="builtin-name">print</span> <span class="literal">No</span>.</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code>仅包含小写英文字母。</li><li>题目数据 保证 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_a" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_a</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力破解即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身题目比较简单，直接取出数据的每位即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">10</span> == <span class="number">7</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="B-FizzBuzz-Sum"><a href="#B-FizzBuzz-Sum" class="headerlink" title="B - FizzBuzz Sum /"></a>B - FizzBuzz Sum /</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB</p><p>Score : 200<br>points</p><h4 id="Problem-Statement-1"><a href="#Problem-Statement-1" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Let us define the FizzBuzz sequence a1,a2,…</p><p>as follows:</p><ul><li>If both 3 and 5 divides i, ai=FizzBuzz</li><li>If the above does not hold but 3 divides i, ai=Fizz</li><li>If none of the above holds but 5 divides i, ai=Buzz</li><li>If none of the above holds, ai=i</li></ul><p>Find the sum of all numbers among the first N<br>terms of the FizzBuzz sequence.</p><h4 id="Constraints-1"><a href="#Constraints-1" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>1≤N≤1e9</code></li></ul><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Input</span> is given <span class="meta">from</span> Standard <span class="meta">Input</span> <span class="meta">in</span> the following <span class="meta">format</span>:</span><br><span class="line"></span><br><span class="line">N</span><br></pre></td></tr></table></figure><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Print <span class="keyword">the</span> <span class="built_in">sum</span> <span class="keyword">of</span> all numbers <span class="keyword">among</span> <span class="keyword">the</span> <span class="keyword">first</span> N</span><br></pre></td></tr></table></figure><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_b" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_b</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接暴力即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>直接计算能被3整出的和能被5整出的，然后加上能被15整出的。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> f = n/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b = n/<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fb = n/<span class="number">15</span>;</span><br><span class="line">    sum = n*(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    sum = sum - <span class="number">3</span>*(f*(f+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    sum = sum - <span class="number">5</span>*(b*(b+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    sum = sum + <span class="number">15</span>*(fb*(fb+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="C-Sum-of-gcd-of-Tuples-Easy"><a href="#C-Sum-of-gcd-of-Tuples-Easy" class="headerlink" title="C - Sum of gcd of Tuples (Easy) /"></a>C - Sum of gcd of Tuples (Easy) /</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 300<br>points</p><h4 id="Problem-Statement-2"><a href="#Problem-Statement-2" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Find</p><script type="math/tex; mode=display">\sum_{a=1}^{K}\sum_{b=1}^{K}\sum_{c=1}^{K}gcd(a,b,c)</script><p>Here gcd(a,b,c) denotes the greatest common divisor of a, b, and c.</p><h4 id="Constraints-2"><a href="#Constraints-2" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>1≤ K ≤ 200</code></li><li><code>K is an integer.</code><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4>Input is given from Standard Input in the following format:<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">K</span></span><br></pre></td></tr></table></figure><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4>Print the value of:<script type="math/tex; mode=display">\sum_{a=1}^{K}\sum_{b=1}^{K}\sum_{c=1}^{K}gcd(a,b,c)</script><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><a href="https://atcoder.jp/contests/abc162/tasks/abc162_c" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_c</a><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数据量非常小，直接暴力</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>数据量非常小，基本上就是直接暴力匹配。</li><li>我们直接三个<code>for</code>循环即可以解决这个问题，数据量非常小。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= n; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)&#123;</span><br><span class="line">                sum += __gcd(i,__gcd(j,k));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="D-RGB-Triplets"><a href="#D-RGB-Triplets" class="headerlink" title="D - RGB Triplets"></a>D - RGB Triplets</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 400<br>points</p><h4 id="Problem-Statement-3"><a href="#Problem-Statement-3" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>We have a string S of length N<br>consisting of R, G, and B.<br>Find the number of triples <code>(i, j, k) (1≤i&lt;j&lt;k≤N)</code><br>that satisfy both of the following conditions:</p><ul><li><code>Si≠Sj</code></li><li><code>Si≠Sk, and Sj≠Sk</code></li><li><code>j−i≠k−j</code><h4 id="Constraints-3"><a href="#Constraints-3" class="headerlink" title="Constraints"></a>Constraints</h4></li><li><code>1≤N≤4000</code></li><li><code>N</code>is a string of length N consisting of R, G, and B.<h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4>Input is given from Standard Input in the following format:<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">N</span></span><br><span class="line"><span class="attribute">S</span></span><br></pre></td></tr></table></figure><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4>Print the number of triplets in question.<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><a href="https://atcoder.jp/contests/abc162/tasks/abc162_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_d</a><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  排列组合</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote></li></ul><ol><li>其实本质是数学组合。首先我们计算所有3种颜色组合的数目。</li><li>去除掉三种颜色组合中存在等差数列的数目。</li><li>本质是个小技巧即可，时间复杂度即可控制在<code>O(n^2)</code>。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.size();</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rcopy;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; gcopy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'R'</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            rcopy.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'G'</span>)&#123;</span><br><span class="line">            g++;</span><br><span class="line">            gcopy.push_back(i);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">'B'</span>)&#123;</span><br><span class="line">            b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">0</span> || g == <span class="number">0</span> || b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = r*g*b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rcopy.size(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; gcopy.size(); ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> d = <span class="built_in">abs</span>(rcopy[i] - gcopy[j]);</span><br><span class="line">            <span class="keyword">int</span> l = min(rcopy[i],gcopy[j]) - d;</span><br><span class="line">            <span class="keyword">int</span> r = max(rcopy[i],gcopy[j]) + d;</span><br><span class="line">            <span class="keyword">int</span> m = (rcopy[i] + gcopy[j])/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &gt;= <span class="number">0</span> &amp;&amp; s[l] == <span class="string">'B'</span>) res--;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; n &amp;&amp; s[r] == <span class="string">'B'</span>) res--;</span><br><span class="line">            <span class="keyword">if</span>( d%<span class="number">2</span> == <span class="number">0</span> &amp;&amp; s[m] == <span class="string">'B'</span>) res--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    slove(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="E-Sum-of-gcd-of-Tuples-Hard"><a href="#E-Sum-of-gcd-of-Tuples-Hard" class="headerlink" title="E - Sum of gcd of Tuples (Hard)"></a>E - Sum of gcd of Tuples (Hard)</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 500<br>points</p><h4 id="Problem-Statement-4"><a href="#Problem-Statement-4" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Consider sequences {A1,…,AN} of length N consisting of integers between 1 and K</p><p>(inclusive).</p><p>There are KN<br>such sequences. Find the sum of gcd(A1,…,AN)</p><p>over all of them.</p><p>Since this sum can be enormous, print the value modulo (109+7)</p><p>.<br>Here gcd(A1,…,AN)<br>denotes the greatest common divisor of A1,…,AN.</p><h4 id="Constraints-4"><a href="#Constraints-4" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>2 ≤ N ≤ 105</code></li><li><code>1 ≤ K ≤ 105</code></li><li>All values in input are integers.</li></ul><h4 id="Input-3"><a href="#Input-3" class="headerlink" title="Input"></a>Input</h4><p>Print the sum of <code>gcd(A1,...,AN)</code> over all KN sequences, modulo <code>(109+7)</code>.</p><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><p>Print the number of triplets in question.</p><h3 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_d" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_d</a></p><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  数学问题</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol><li>转化为数学问题，思路确实不容易想到。</li><li>我们知道:<code>gcd(a1,a2,a3,a4,...,ak)</code>,一共用<code>1~k</code>种取值的可能，我们只需要找到每种取值<code>i</code>的个数<code>f(i)</code>,最终的结果为$\sum_{i=1}^{k}f(i)$.</li><li>递推关系为：<script type="math/tex; mode=display">f[i] = [\frac{K}{i}]^{N} - \sum_{j>i,i|j}f[j]</script><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> f[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) ans=<span class="number">1L</span>L*ans*x%MD;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%MD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x+=y;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=MD) x-=MD;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=MD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&gt;=<span class="number">1</span>;i--) &#123;</span><br><span class="line">        f[i]=quick_pow(k/i,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>*i;j&lt;=k;j+=i) &#123;</span><br><span class="line">            add(f[i],-f[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) &#123;</span><br><span class="line">        add(ans,<span class="number">1L</span>L*f[i]*i%MD);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="F-Select-Half"><a href="#F-Select-Half" class="headerlink" title="F - Select Half"></a>F - Select Half</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><p>Time Limit: 2 sec / Memory Limit: 1024 MB<br>Score : 600<br>points</p><h4 id="Problem-Statement-5"><a href="#Problem-Statement-5" class="headerlink" title="Problem Statement"></a>Problem Statement</h4><p>Given is an integer sequence A1,…,AN of length N.</p><p>We will choose exactly <code>⌊N2⌋</code></p><p>elements from this sequence so that no two adjacent elements are chosen.</p><p>Find the maximum possible sum of the chosen elements.</p><p>Here <code>⌊x⌋</code><br>denotes the greatest integer not greater than x.</p><h4 id="Constraints-5"><a href="#Constraints-5" class="headerlink" title="Constraints"></a>Constraints</h4><ul><li><code>2≤N≤2×105</code></li><li><code>|Ai|≤109</code></li><li>All values in input are integers.</li></ul><h4 id="Input-4"><a href="#Input-4" class="headerlink" title="Input"></a>Input</h4><p>Input is given from Standard Input in the following format:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">N</span><br><span class="line"><span class="function"><span class="title">A1</span></span>...AN</span><br></pre></td></tr></table></figure></p><h4 id="Output-4"><a href="#Output-4" class="headerlink" title="Output"></a>Output</h4><p>Print the maximum possible sum of the chosen elements.</p><h3 id="地址-5"><a href="#地址-5" class="headerlink" title="地址"></a>地址</h3><p><a href="https://atcoder.jp/contests/abc162/tasks/abc162_f" target="_blank" rel="noopener">https://atcoder.jp/contests/abc162/tasks/abc162_f</a></p><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 动态规划</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><ol><li>这个题目非常有意思。非常典型的竞赛题目，很有技巧；</li><li>我们设<code>dp[i]</code>代表从前i个元素中选去最多[i/2]个元素和的最大值,我们分为两种情况来讨论。</li><li>如果前i个元素共有偶数个元素，也即i位偶数。则这时从<code>i</code>个元素中选取$[\frac{i}{2}]$个元素，则这时最多只有两种选择，要么是等差从<code>0</code>开始选择<code>{a[0],a[2],a[4],a[6],...,a[i]}</code>,要么是等差数列从<code>1</code>开始选择<code>{a[1],a[3],a[5],...,a[i-1]}</code>。所以我们当i位偶数时，推出递推公式为：<script type="math/tex; mode=display">dp[i] = max(\sum_{k=0}^{\frac{i}{2}}a[2*i+1],\sum_{k=0}^{\frac{i}{2}}a[2*i])</script></li><li>如果前i个元素共有奇数个元素，也即i位奇数。则这时情况稍微比较复杂，如果i为奇数，则我们需要选择$\frac{i-1}{2}$个元素,我们要么从前<code>i-1</code>个元素选择，要么加上元素<code>i</code>。则我们可以推出递推公式为：<script type="math/tex; mode=display">dp[i] = max(d[i-1],dp[i-2] + a[i])</script></li><li>这个题目质量很高，出的很好，我觉得<code>leetcode</code> 质量高多了。</li></ol></blockquote><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*0 1 2 3 4 5 6 7*/</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*dp[i] 代表从前i个元素中选去最多[i/2]个元素和的最大值*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; arr(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; dp(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> left = arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + arr[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">            left += arr[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-2</span>] + arr[i],left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    slove();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AtCoder-Beginner-Contest-162&quot;&gt;&lt;a href=&quot;#AtCoder-Beginner-Contest-162&quot; class=&quot;headerlink&quot; title=&quot;AtCoder Beginner Contest 162&quot;&gt;&lt;/a&gt;AtCoder Beginner Contest 162&lt;/h1&gt;&lt;p&gt;&lt;code&gt;atcoder&lt;/code&gt;题目比&lt;code&gt;leetcode&lt;/code&gt;题目质量高多了。非常有意思。&lt;/p&gt;&lt;h2 id=&quot;A-Lucky-7&quot;&gt;&lt;a href=&quot;#A-Lucky-7&quot; class=&quot;headerlink&quot; title=&quot;A - Lucky 7&quot;&gt;&lt;/a&gt;A - Lucky 7&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Time Limit: 2 sec / Memory Limit: 1024 MB&lt;/p&gt;&lt;p&gt;Score : 100&lt;/p&gt;&lt;p&gt;points&lt;/p&gt;&lt;h4 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h4&gt;&lt;p&gt;Given is a three-digit integer N&lt;br&gt;. Does N contain the digit 7&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="atcoder" scheme="http://yoursite.com/tags/atcoder/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第184周比赛</title>
    <link href="http://yoursite.com/2020/04/13/149/"/>
    <id>http://yoursite.com/2020/04/13/149/</id>
    <published>2020-04-12T16:27:19.040Z</published>
    <updated>2020-04-12T16:27:24.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="184周比赛"><a href="#184周比赛" class="headerlink" title="184周比赛"></a>184周比赛</h1><p>感觉题目越来越水了啊，质量不够高。</p><h2 id="5380-数组中的字符串匹配"><a href="#5380-数组中的字符串匹配" class="headerlink" title="5380. 数组中的字符串匹配"></a>5380. 数组中的字符串匹配</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串数组 <code>words</code> ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回<code>words</code>中是其他单词的子字符串的所有单词。</p><p>如果你可以删除<code>words[j]</code> 最左侧和/或最右侧的若干字符得到 <code>word[i]</code> ，那么字符串 <code>words[i]</code>就是 <code>words[j]</code>的一个子字符串。</p><a id="more"></a><p>示例 1：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"mass"</span>,<span class="string">"as"</span>,<span class="string">"hero"</span>,<span class="string">"superhero"</span>]</span><br><span class="line">输出：[<span class="string">"as"</span>,<span class="string">"hero"</span>]</span><br><span class="line">解释：<span class="string">"as"</span> 是 <span class="string">"mass"</span> 的子字符串，<span class="string">"hero"</span> 是 <span class="string">"superhero"</span> 的子字符串。</span><br><span class="line">[<span class="string">"hero"</span>,<span class="string">"as"</span>] 也是有效的答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"leetcode"</span>,<span class="string">"et"</span>,<span class="string">"code"</span>]</span><br><span class="line">输出：[<span class="string">"et"</span>,<span class="string">"code"</span>]</span><br><span class="line">解释：<span class="string">"et"</span> 和 <span class="string">"code"</span> 都是 <span class="string">"leetcode"</span> 的子字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"blue"</span>,<span class="string">"green"</span>,<span class="string">"bu"</span>]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= words.length &lt;= 100</code></li><li><code>1 &lt;= words[i].length &lt;= 30</code></li><li><code>words[i]</code>仅包含小写英文字母。</li><li>题目数据 保证 每个 <code>words[i]</code> 都是独一无二的。</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/string-matching-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-matching-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力匹配</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>本身数据量非常小，我们实际只需暴力匹配即可。</li><li>对字符串按照长度长短进行排序，然后每次直接用<code>find</code>进行暴力匹配，其实find的本质也是字符串字串匹配的问题。</li><li>本质是非常简单的解法。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> &amp; a,<span class="built_in">string</span> &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.size() &gt; b.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; stringMatching(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        sort(words.begin(),words.end(),cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i &amp;&amp; words[j].size() &gt; words[i].size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(words[j].find(words[i]) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)&#123;</span><br><span class="line">                    res.push_back(words[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5381-查询带键的排列"><a href="#5381-查询带键的排列" class="headerlink" title="5381. 查询带键的排列"></a>5381. 查询带键的排列</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个待查数组<code>queries</code>，数组中的元素为 <code>1</code>到<code>m</code> 之间的正整数。 请你根据以下规则处理所有待查项 <code>queries[i]</code>（从 <code>i=0</code>到 <code>i=queries.length-1</code>）：</p><ul><li>一开始，排列 <code>P=[1,2,3,...,m]</code>。</li><li>对于当前的 i ，请你找出待查项 <code>queries[i]</code>在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列<code>P</code>的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 <code>queries[i]</code>的查询结果。</li></ul><p>请你以数组形式返回待查数组 <code>queries</code>的查询结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>], m = <span class="number">5</span></span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] </span><br><span class="line">解释：待查数组 queries 处理如下：</span><br><span class="line">对于 i=<span class="number">0</span>: queries[i]=<span class="number">3</span>, P=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span> 在 P 中的位置是 <span class="number">2</span>，接着我们把 <span class="number">3</span> 移动到 P 的起始位置，得到 P=[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">对于 i=<span class="number">1</span>: queries[i]=<span class="number">1</span>, P=[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">1</span> 在 P 中的位置是 <span class="number">1</span>，接着我们把 <span class="number">1</span> 移动到 P 的起始位置，得到 P=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>] 。 </span><br><span class="line">对于 i=<span class="number">2</span>: queries[i]=<span class="number">2</span>, P=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">2</span> 在 P 中的位置是 <span class="number">2</span>，接着我们把 <span class="number">2</span> 移动到 P 的起始位置，得到 P=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。</span><br><span class="line">对于 i=<span class="number">3</span>: queries[i]=<span class="number">1</span>, P=[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], <span class="number">1</span> 在 P 中的位置是 <span class="number">1</span>，接着我们把 <span class="number">1</span> 移动到 P 的起始位置，得到 P=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] 。 </span><br><span class="line">因此，返回的结果数组为 [<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>], m = <span class="number">4</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：queries = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>], m = <span class="number">8</span></span><br><span class="line">输出：[<span class="number">6</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= m &lt;= 10^3</code></li><li><code>1 &lt;= queries.length &lt;= m</code></li><li><code>1 &lt;= queries[i] &lt;= m</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/queries-on-a-permutation-with-key" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queries-on-a-permutation-with-key</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>题目中给的数据量只有<code>1o^3</code>的数量级，怎么做都可以出来。</li><li>题目中采用的移位的办法，我们记录每个数在序列中的排序位置。每次需要移动时，我们将所有小于该位置的数的位置全部向后移动一位，然后将数本身再移动到第0位处。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; processQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; queries, <span class="keyword">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queries.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order(m,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) order[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            res.push_back(order[queries[i]<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(order[j] &lt; order[queries[i]<span class="number">-1</span>]) order[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            order[queries[i]<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1410-HTML-实体解析器"><a href="#1410-HTML-实体解析器" class="headerlink" title="1410. HTML 实体解析器"></a>1410. HTML 实体解析器</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>「HTML 实体解析器」 是一种特殊的解析器，它将 HTML 代码作为输入，并用字符本身替换掉所有这些特殊的字符实体。</p><p><code>HTML</code>里这些特殊字符和它们对应的字符实体包括：</p><ul><li>双引号：字符实体为 &quot; ，对应的字符是 “ 。</li><li>单引号：字符实体为 &apos; ，对应的字符是 ‘ 。</li><li>与符号：字符实体为 &amp; ，对应对的字符是 &amp; 。</li><li>大于号：字符实体为 &gt; ，对应的字符是 &gt; 。</li><li>小于号：字符实体为 &lt; ，对应的字符是 &lt; 。</li><li>斜线号：字符实体为 &frasl; ，对应的字符是 / 。</li></ul><p>给你输入字符串<code>text</code> ，请你实现一个 <code>HTML</code> 实体解析器，返回解析器解析后的结果。</p><p>示例 1：<br><figure class="highlight mizar"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text = "&amp;amp; <span class="keyword">is</span> an HTML entity but &amp;ambassador; <span class="keyword">is</span> <span class="keyword">not</span>."</span><br><span class="line">输出："&amp; <span class="keyword">is</span> an HTML entity but &amp;ambassador; <span class="keyword">is</span> <span class="keyword">not</span>."</span><br><span class="line">解释：解析器把字符实体 &amp;amp; 用 &amp; 替换</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = <span class="string">"and I quote: &amp;quot;...&amp;quot;"</span></span><br><span class="line">输出：<span class="string">"and I quote: <span class="subst">\"</span>...<span class="subst">\"</span>"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"Stay home! Practice on Leetcode :)"</span></span><br><span class="line">输出：<span class="string">"Stay home! Practice on Leetcode :)"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"x &amp;gt; y &amp;amp;&amp;amp; x &amp;lt; y is always false"</span></span><br><span class="line">输出：<span class="string">"x &gt; y &amp;&amp; x &lt; y is always false"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">text</span> = <span class="string">"leetcode.com&amp;frasl;problemset&amp;frasl;all"</span></span><br><span class="line">输出：<span class="string">"leetcode.com/problemset/all"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= text.length &lt;= 10^5</code></li><li>字符串可能包含<code>256</code>个<code>ASCII</code> 字符中的任意字符。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/html-entity-parser" target="_blank" rel="noopener">https://leetcode-cn.com/problems/html-entity-parser</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接暴力匹配</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>数据量非常小，基本上就是直接暴力匹配。</li><li>当然看了别人的解答，每次匹配连续的<code>&amp;</code>与<code>;</code>，将之间的字符串进行查找和替换。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">entityParser</span><span class="params">(<span class="built_in">string</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = text.size();</span><br><span class="line">        <span class="built_in">string</span> keys[<span class="number">6</span>] = &#123;<span class="string">"&amp;quot;"</span>,<span class="string">"&amp;apos;"</span>,<span class="string">"&amp;amp;"</span>,<span class="string">"&amp;gt;"</span>,<span class="string">"&amp;lt;"</span>,<span class="string">"&amp;frasl;"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> rep[<span class="number">6</span>] = &#123;<span class="string">'"'</span>,<span class="string">'\''</span>,<span class="string">'&amp;'</span>,<span class="string">'&gt;'</span>,<span class="string">'&lt;'</span>,<span class="string">'/'</span>&#125;;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; )&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i] == <span class="string">'&amp;'</span>)&#123;</span><br><span class="line">                <span class="keyword">bool</span> isMatch = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(n-i &gt;= keys[j].size() &amp;&amp; text.substr(i,keys[j].size()) == keys[j])&#123;</span><br><span class="line">                        res.push_back(rep[j]);</span><br><span class="line">                        i += keys[j].size();</span><br><span class="line">                        isMatch = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!isMatch) res.push_back(text[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(text[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                       </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5383-给-N-x-3-网格图涂色的方案数"><a href="#5383-给-N-x-3-网格图涂色的方案数" class="headerlink" title="5383. 给 N x 3 网格图涂色的方案数"></a>5383. 给 N x 3 网格图涂色的方案数</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>你有一个 <code>n x 3</code>的网格图 <code>grid</code> ，你需要用 红，黄，绿 三种颜色之一给每一个格子上色，且确保相邻格子颜色不同（也就是有相同水平边或者垂直边的格子颜色不同）。</p><p>给你网格图的行数 n 。</p><p>请你返回给<code>grid</code>涂色的方案数。由于答案可能会非常大，请你返回答案对<code>10^9 + 7</code> 取余的结果。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：<span class="number">12</span></span><br><span class="line">解释：总共有 <span class="number">12</span> 种可行的方法：</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">54</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：<span class="number">246</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span></span><br><span class="line">输出：<span class="number">106494</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">5000</span></span><br><span class="line">输出：<span class="number">30228214</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == grid.length</code></li><li><code>grid[i].length == 3</code></li><li><code>1 &lt;= n &lt;= 5000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-ways-to-paint-n-x-3-grid</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>本题基本一眼看到就是动态规划，状态压缩的dp。</li><li>我们定义符合行要求的放置的颜色组合一共有12种，而第<code>i</code>行的可以放置的颜色也仅仅与第<code>i-1</code>行的颜色有关，采用动态规划。</li><li>记录<code>dp[i-1]</code>的每种组合的方案数，<code>dp[i]</code>在这12种组合方案中进行遍历，同时记录符合条件的组合方案数。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp1[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> dp2[<span class="number">12</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; next(<span class="number">12</span>);</span><br><span class="line">        <span class="built_in">string</span> state[<span class="number">12</span>] = &#123;<span class="string">"123"</span>,<span class="string">"121"</span>,<span class="string">"131"</span>,<span class="string">"132"</span>, \</span><br><span class="line">                            <span class="string">"212"</span>,<span class="string">"213"</span>,<span class="string">"232"</span>,<span class="string">"231"</span>, \</span><br><span class="line">                            <span class="string">"313"</span>,<span class="string">"312"</span>,<span class="string">"321"</span>,<span class="string">"323"</span> &#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; dict;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) dict[state[i]] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> s1 = state[i][<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> s2 = state[i][<span class="number">1</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">int</span> s3 = state[i][<span class="number">2</span>] - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l1 = <span class="number">1</span>; l1 &lt;= <span class="number">3</span>; ++l1)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l2 = <span class="number">1</span>; l2 &lt;= <span class="number">3</span>; ++l2)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> l3 = <span class="number">1</span>; l3 &lt;= <span class="number">3</span>; ++l3)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(l1 == l2 || l2 == l3) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(l1 == s1 || l2 == s2 || l3 == s3) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="built_in">string</span> x = to_string(l1) + to_string(l2) + to_string(l3);</span><br><span class="line">                        <span class="keyword">int</span> id = dict[x];</span><br><span class="line">                        next[i].push_back(id);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(dp1,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp1));</span><br><span class="line">        <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i) dp1[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp2,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp2));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp1[j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; next[j].size(); ++k) dp2[next[j][k]] = (dp2[next[j][k]] + dp1[j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">12</span>; ++j) dp1[j] = dp2[j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; ++i)&#123;</span><br><span class="line">            res = (res + dp1[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;184周比赛&quot;&gt;&lt;a href=&quot;#184周比赛&quot; class=&quot;headerlink&quot; title=&quot;184周比赛&quot;&gt;&lt;/a&gt;184周比赛&lt;/h1&gt;&lt;p&gt;感觉题目越来越水了啊，质量不够高。&lt;/p&gt;&lt;h2 id=&quot;5380-数组中的字符串匹配&quot;&gt;&lt;a href=&quot;#5380-数组中的字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;5380. 数组中的字符串匹配&quot;&gt;&lt;/a&gt;5380. 数组中的字符串匹配&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;words&lt;/code&gt; ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回&lt;code&gt;words&lt;/code&gt;中是其他单词的子字符串的所有单词。&lt;/p&gt;&lt;p&gt;如果你可以删除&lt;code&gt;words[j]&lt;/code&gt; 最左侧和/或最右侧的若干字符得到 &lt;code&gt;word[i]&lt;/code&gt; ，那么字符串 &lt;code&gt;words[i]&lt;/code&gt;就是 &lt;code&gt;words[j]&lt;/code&gt;的一个子字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>字符串</title>
    <link href="http://yoursite.com/2020/04/10/148/"/>
    <id>http://yoursite.com/2020/04/10/148/</id>
    <published>2020-04-10T04:27:14.175Z</published>
    <updated>2020-04-14T05:22:35.195Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串算法"><a href="#字符串算法" class="headerlink" title="字符串算法"></a>字符串算法</h3><p>字符串作为一个非常重要的应用，。对所有字符串算法的总结，包括字符串的排序与字符串的匹配，在实际的程序中是非常非常重要的两块应用，其中的算法又非常的复杂。光把这几个研究透就非常需要耗费精力和时间。</p><h4 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h4><h5 id="count-index"><a href="#count-index" class="headerlink" title="count index"></a><code>count index</code></h5><p><code>count index</code>作为一种快速的排序算法，可以在O(n+m)的时间复杂度内即可完成字符串的排序。本质是基数排序，实际应用中这个排序算法效率非常高，基本上可以在线性时间内完成对字符串的排序。空间复杂度为O(m+n).<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">countIndex</span><span class="params">(<span class="keyword">char</span> [] a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">257</span>];</span><br><span class="line">    <span class="keyword">int</span> [] aux = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length; ++i)&#123;</span><br><span class="line">        count[str[i]+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">        count[i+<span class="number">1</span>] += count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        aux[count[a[i]++]] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        a[i] = aux[i];</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="LSD"><a href="#LSD" class="headerlink" title="LSD"></a><code>LSD</code></h4><p>基数排序的重要应用，按照字母的先后顺序进行排序，从后往前进行排列,这种算法只适合等长度得数据值，实际应用范围较窄。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> W)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    String[] aux = <span class="keyword">new</span> String[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = W<span class="number">-1</span>; d &gt;= <span class="number">0</span>; d--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            count[a[i].charAt(d) + <span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)</span><br><span class="line">            count[r+<span class="number">1</span>] += count[r];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            aux[count[a[i].charAt(d)]++] = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            a[i] = aux[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="MSD"><a href="#MSD" class="headerlink" title="MSD"></a><code>MSD</code></h4><p>基数排序的重要应用，按照字母的先后顺序进行排序，从前往后进行排列。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> String[a.length];</span><br><span class="line">    sort(a, aux, <span class="number">0</span>, a.length<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, String[] aux, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[R+<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        count[charAt(a[i], d) + <span class="number">2</span>]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R+<span class="number">1</span>; r++)</span><br><span class="line">        count[r+<span class="number">1</span>] += count[r];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        aux[count[charAt(a[i], d) + <span class="number">1</span>]++] = a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++)</span><br><span class="line">        a[i] = aux[i - lo];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; r++)</span><br><span class="line">        sort(a, aux, lo + count[r], lo + count[r+<span class="number">1</span>] - <span class="number">1</span>, d+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-way-quick-sort"><a href="#3-way-quick-sort" class="headerlink" title="3-way quick sort"></a><code>3-way quick sort</code></h4><p>这是类似于<code>quicksort</code>的基数排序方法，其实排序的速度非常快，需要经常应用的一个算法。每次读取字符串的第一个字符，并根据第一个字符的比较大小，对字符串数组分为三类，第一个字符小于<code>target</code>的字符串，第一个字符等于<code>target</code>的字符串，第一个字符大于于<code>target</code>的字符串，然后再依次对这三种分类递归进行下次排序划分。比如字符串数组如下：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bac</span></span><br><span class="line"><span class="keyword">aab</span></span><br><span class="line"><span class="keyword">cba</span></span><br><span class="line"><span class="keyword">aac</span></span><br><span class="line"><span class="keyword">bda</span></span><br></pre></td></tr></table></figure><br>第一次比较则划分，我们选去<code>b</code>作为关键字进行比较：</p><ul><li>第一类：首字符比<code>b</code>小<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">aab</span></span><br><span class="line"><span class="attribute">aac</span></span><br></pre></td></tr></table></figure></li><li>第二类：首字符与<code>b</code>相等<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bac</span></span><br><span class="line"><span class="keyword">bda</span></span><br></pre></td></tr></table></figure></li><li>第三类：首字符比<code>b</code>大<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cba</span></span><br></pre></td></tr></table></figure>然后再对这三类字符分别进行划分和排序，第一类字符串再从第1个字符开始比较和交换，第二类字符串从第2个字符开始比较和划分，第三类字符串从第1个字符串比较和划分。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">0</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lt = lo, gt = hi;</span><br><span class="line">    <span class="keyword">int</span> v = charAt(a[lo], d);</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = charAt(a[i], d);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; v) exch(a, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t &gt; v) exch(a, i, gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a, lo, lt<span class="number">-1</span>, d);</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) sort(a, lt, gt, d+<span class="number">1</span>);</span><br><span class="line">    sort(a, gt+<span class="number">1</span>, hi, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>suffix array</code><br>后缀数组排序算法，刚开始看到这个算法感觉像天书一样，不太晓得是什么意思，后来学了算法涉及课程之后，就知道后缀数组的大概的原理了，知道了大概的原理之后就对倍增的原理到底是怎么来的了解的多了，非常<code>clever</code>的一种算法，当然细节太过于繁琐。我把原理图贴在这里大概就晓得倍增到底是怎么一回事了。不过后缀数组得写法实在太难记了，我觉得还是知道原理就可以了，因为除了竞赛或者写论文外，很少会遇到这么难写的算法，就跟红黑树一样，大家都知道是一种二叉平衡树，但是说实话应该知道就可以了，大可不必花太多时间浪费在细节上。<br><img src="https://mike-box.github.io/images/148-2.png" alt="suffixarray"><br>后缀数组可以解决以下问题：</li></ol><ul><li>给定一个字符串，询问某两个后缀的最长公共前缀。</li><li>给定一个字符串，求最长重复子串，这两个子串可以重叠</li><li><p>给定一个字符串，求最长重复子串，这两个子串不能重叠</p></li><li><p>给定一个字符串，求至少出现k 次的最长重复子串，这k 个子串可以重叠</p></li><li><p>给定一个字符串，求不相同的子串的个数</p></li><li><p>给定一个字符串，求最长回文子串</p></li><li><p>给定一个字符串L，已知这个字符串是由某个字符串S 重复R 次而得到的，求R 的最大值</p></li><li><p>给定一个字符串，求重复次数最多的连续重复子</p></li><li><p>给定两个字符串A 和B，求最长公共子串。</p></li><li><p>给定两个字符串A 和B，求长度不小于k 的公共子串的个数（可以相同）</p></li><li><p>给定n 个字符串，求出现在不小于k 个字符串中的最长子串。</p></li><li><p>给定n 个字符串，求在每个字符串中至少出现两次且不重叠的最长子串</p></li><li><p>给定n 个字符串，求出现或反转后出现在每个字符串中的最长子串。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F(x) ((x)/3+((x)%3==1?0:tb))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G(x) ((x)&lt;tb?(x)*3+1:((x)-tb)*3+2)</span></span><br><span class="line"><span class="keyword">int</span> wa[maxn],wb[maxn],wv[maxn],ws[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c0</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r[a]==r[b]&amp;&amp;r[a+<span class="number">1</span>]==r[b+<span class="number">1</span>]&amp;&amp;r[a+<span class="number">2</span>]==r[b+<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c12</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> *r,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">2</span>) <span class="keyword">return</span> r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;c12(<span class="number">1</span>,r,a+<span class="number">1</span>,b+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> r[a]&lt;r[b]||r[a]==r[b]&amp;&amp;wv[a+<span class="number">1</span>]&lt;wv[b+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *a,<span class="keyword">int</span> *b,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) wv[i]=r[a[i]];</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++) ws[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) ws[wv[i]]++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;m;i++) ws[i]+=ws[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) b[--ws[wv[i]]]=a[i];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc3</span><span class="params">(<span class="keyword">int</span> *r,<span class="keyword">int</span> *sa,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,*rn=r+n,*san=sa+n,ta=<span class="number">0</span>,tb=(n+<span class="number">1</span>)/<span class="number">3</span>,tbc=<span class="number">0</span>,p;</span><br><span class="line">r[n]=r[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) <span class="keyword">if</span>(i%<span class="number">3</span>!=<span class="number">0</span>) wa[tbc++]=i;</span><br><span class="line">sort(r+<span class="number">2</span>,wa,wb,tbc,m);</span><br><span class="line">sort(r+<span class="number">1</span>,wb,wa,tbc,m);</span><br><span class="line">sort(r,wa,wb,tbc,m);</span><br><span class="line"><span class="keyword">for</span>(p=<span class="number">1</span>,rn[F(wb[<span class="number">0</span>])]=<span class="number">0</span>,i=<span class="number">1</span>;i&lt;tbc;i++)</span><br><span class="line">rn[F(wb[i])]=c0(r,wb[i<span class="number">-1</span>],wb[i])?p<span class="number">-1</span>:p++;</span><br><span class="line"><span class="keyword">if</span>(p&lt;tbc) dc3(rn,san,tbc,p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) san[rn[i]]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) <span class="keyword">if</span>(san[i]&lt;tb) wb[ta++]=san[i]*<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">3</span>==<span class="number">1</span>) wb[ta++]=n<span class="number">-1</span>;</span><br><span class="line">sort(r,wb,wa,ta,m);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;tbc;i++) wv[wb[i]=G(san[i])]=i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">0</span>,p=<span class="number">0</span>;i&lt;ta &amp;&amp; j&lt;tbc;p++)</span><br><span class="line">sa[p]=c12(wb[j]%<span class="number">3</span>,r,wa[i],wb[j])?wa[i++]:wb[j++];</span><br><span class="line"><span class="keyword">for</span>(;i&lt;ta;p++) sa[p]=wa[i++];</span><br><span class="line"><span class="keyword">for</span>(;j&lt;tbc;p++) sa[p]=wb[j++];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h4><h5 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a><code>kmp</code></h5><p>题目中直接给的是<code>KMP</code>的<code>DFA</code>的解法，其实非常容易理解。也非常的好写，主要是涉及到匹配时的移位操作。强烈建议看看<code>Princeton</code>的老教授讲的<code>KMP</code>的原理，非常非常的简单。<br>确定状态机的构造原理很简单，当前状态接受当前字符，然后跳到下一个状态:</p><script type="math/tex; mode=display">output_{next} = Fuction(input_{curr})</script><p>比如我们定义初始匹配字符串的初始状态为<code>0</code>，需要接受匹配的字符串为<code>ababaab</code>,则我们需要定义<code>n+1</code>个状态,共可接受<code>n</code>个输入，初始的状态机如下：</p><script type="math/tex; mode=display">0\stackrel{a}{\longrightarrow}1\stackrel{b}{\longrightarrow}2\stackrel{a}{\longrightarrow}3\stackrel{b}{\longrightarrow}4\stackrel{a}{\longrightarrow}5\stackrel{a}{\longrightarrow}6\stackrel{b}{\longrightarrow}7</script><p>我们可以看到初始状态为0，可接受的终止状态为<code>7</code>.这是最初的状态机。我们先计算玩<code>ababaab</code>的作为输入，然后再左移一位，计算<code>babaab</code>作为状态机的输入,且从状态1开始输入。即可计算出整个<code>kmp</code>的DFA状态机。以下为状态机构建与搜索：<br>比如我们可以看到正确的匹配和状态如下：<br>|输入|0|1|2|3|4|5|6|7|<br>|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|<br>|-|a|b|a|b|a|a|b|-|<br>|a|1|-|3|-|5|6|-|-|<br>|b|0|2|-|4|-|-|7|-|<br>|*|0|0|0|0|0|0|0|-|<br>DFA状态机的建立也非常有意思。我们保留另一个状态从字符串第<code>2</code>位开始遍历,当前的状态为x,每次拷贝状态<code>x</code>的指向即可。实际上x的状态即为当前匹配的最长后缀长度。<br>|输入|0|1|2|3|4|5|6|7|<br>|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|:——-:|<br>|-|a|b|a|b|a|a|b|-|<br>|a|1|1|3|1|5|6|1|-|<br>|b|0|2|0|4|0|4|7|-|<br>|状态x|0|0|1|2|3|1|2|-|</p><p><img src="https://mike-box.github.io/images/148-1.png" alt="kmp"></p><ol><li><code>KMP DFA</code>的搜索<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">kmp</span><span class="params">(<span class="built_in">string</span> &amp; pat,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n = pat.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; state(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">           dfa.push_back(state);</span><br><span class="line">           dfa[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       dfa[pat[<span class="number">0</span>]-<span class="string">'a'</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>, i = <span class="number">1</span>; i &lt; n; ++i )&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">               dfa[j][i] = dfa[j][x];</span><br><span class="line">           &#125;</span><br><span class="line">           dfa[pat[i]-<span class="string">'a'</span>][i] = i+<span class="number">1</span>;</span><br><span class="line">           x = dfa[pat[i]-<span class="string">'a'</span>][x];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dfa)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">       <span class="keyword">int</span> end = dfa[<span class="number">0</span>].size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); ++i)&#123;</span><br><span class="line">           x = dfa[str[i]-<span class="string">'a'</span>][x];</span><br><span class="line">           <span class="keyword">if</span>(x == end) <span class="keyword">return</span> i-x+<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>KMP next<br>这个时之前教科书上的next数组的表示法，确实有一些比较<code>tricky</code>的地方，计算每个前缀的最长匹配后缀长度，这个稍微需要一点点技巧，特别时用到递归的思想，只需要计算出最长匹配后，后面的就非常简单。<br>比如字符串<code>ababaababd</code>,他所有的前缀字符串为：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">索引</th><th style="text-align:center">前缀</th><th style="text-align:center">匹配的最长后缀</th><th style="text-align:center">最长匹配后缀长度</th><th style="text-align:center">递推</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ab</td><td style="text-align:center">‘’</td><td style="text-align:center">0</td><td style="text-align:center">prefix(1) = 0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">aba</td><td style="text-align:center">a</td><td style="text-align:center">1</td><td style="text-align:center">prefix(1) = 1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">abab</td><td style="text-align:center">ab</td><td style="text-align:center">2</td><td style="text-align:center">prefix(1) = 2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">ababa</td><td style="text-align:center">aba</td><td style="text-align:center">3</td><td style="text-align:center">prefix(4) = 3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ababaa</td><td style="text-align:center">a</td><td style="text-align:center">1</td><td style="text-align:center">prefix(5) = prefix(prefix(4))</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ababaab</td><td style="text-align:center">ab</td><td style="text-align:center">2</td><td style="text-align:center">prefix(6) = 2</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ababaaba</td><td style="text-align:center">aba</td><td style="text-align:center">3</td><td style="text-align:center">prefix(7) = 3</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">ababaabab</td><td style="text-align:center">abab</td><td style="text-align:center">4</td><td style="text-align:center">prefix(8) = 4</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ababaababd</td><td style="text-align:center">‘’</td><td style="text-align:center">0</td><td style="text-align:center">prefix(9) = 0</td></tr></tbody></table></div><p>我们看到kmp的本质就是当前位置索引<code>i</code>去匹配前缀<code>prefix(i-1)</code>的下一个字母，如果能够匹配则相等，否则则匹配下一个更短的后缀。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kmp(<span class="built_in">string</span> str)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prefix(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(; k &gt; <span class="number">0</span> &amp;&amp; str[k] != str[i]; k = prefix[k<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">if</span>(str[k] == str[i])  prefix[i++] = ++k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; --i) prefix[i] = prefix[i<span class="number">-1</span>];</span><br><span class="line">    prefix[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> need)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = kmp(need);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt; str.size() &amp;&amp; j &lt; need.size())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">-1</span> || str[i] == str[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j == <span class="built_in">strlen</span>(need)) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h5><ol><li>bm算法的特点为字符串比较时从右向左比较，因此非常快的跳跃过去。</li><li>如果发现当前可能匹配的字符串中不存在模式中的字符，直接跳到当前字符的下一个字符进行比较。</li><li>尽可能的向右移动，本质就是贪心算法，每次计算移动位置。<br><img src="https://mike-box.github.io/images/148-3.png" alt="bm"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bm_search</span><span class="params">(<span class="built_in">string</span> str,<span class="built_in">string</span> needle)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> m = str.size();</span><br><span class="line">       <span class="keyword">int</span> n = needle.size();</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(<span class="number">26</span>,<span class="number">-1</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; needle.size(); ++i)&#123;</span><br><span class="line">           right[needle[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">int</span> skip = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m-n; i += skip)&#123;</span><br><span class="line">           skip = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">               <span class="keyword">if</span>(str[i+j] != needle[j])&#123;</span><br><span class="line">                   skip = max(<span class="number">1</span>,j-right[str[i+j]-<span class="string">'a'</span>]);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(skip == <span class="number">0</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> i;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="KR"><a href="#KR" class="headerlink" title="KR"></a>KR</h5><ol><li><code>KR</code>算法的本质<br><img src="https://mike-box.github.io/images/148-4.png" alt="kr"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabinKarp</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> patHash; <span class="comment">// pattern hash value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M; <span class="comment">// pattern length</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> Q; <span class="comment">// modulus</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> R; <span class="comment">// radix</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> RM; <span class="comment">// R^(M-1) % Q</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RabinKarp</span><span class="params">(String pat)</span> </span>&#123;</span><br><span class="line">        M = pat.length();</span><br><span class="line">        R = <span class="number">256</span>;</span><br><span class="line">        Q = longRandomPrime();</span><br><span class="line">        RM = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M-<span class="number">1</span>; i++)</span><br><span class="line">            RM = (R * RM) % Q;</span><br><span class="line">        patHash = hash(pat, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String key, <span class="keyword">int</span> M)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="comment">/* as before */</span> </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = txt.length();</span><br><span class="line">        <span class="keyword">int</span> txtHash = hash(txt, M);</span><br><span class="line">        <span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = M; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            txtHash = (txtHash + Q - RM*txt.charAt(i-M) % Q) % Q;</span><br><span class="line">            txtHash = (txtHash*R + txt.charAt(i)) % Q;</span><br><span class="line">            <span class="keyword">if</span> (patHash == txtHash) <span class="keyword">return</span> i - M + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="AC-automation"><a href="#AC-automation" class="headerlink" title="AC automation"></a>AC automation</h4><p>匹配单字符串时我们可以用快速的匹配算法<code>KMP</code>,但是实际程序中我们可能需要进行多个字符串的匹配，这时我们就需要新的算法。AC自动机作为匹配多字符串的算法，其也有非常重要的应用，比如<code>DPI</code>,互联网上的报文搜索。AC自动机的本质也是避免所谓的<code>backup</code>，也是类似于<code>KMP</code>所谓的指当前能够匹配的最长后缀, 关键点在于设置节点的<code>fail</code>指针。知乎上有相关解释，其实ac自动机的本质即为 <code>kmp + trie</code>的组合，原理其实非常简单，也是找到当前字符位置的最长匹配的后缀。<code>trie</code>树作为一个最基本的应用应该需要掌握的基础。<br><a href="https://zhuanlan.zhihu.com/p/80325757" target="_blank" rel="noopener">AC自动机</a><br><img src="https://mike-box.github.io/images/148-8.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-9.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-10.png" alt="ac"><br><img src="https://mike-box.github.io/images/148-11.png" alt="ac"><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    TrieNode * next[<span class="number">26</span>];</span><br><span class="line">    TrieNode * fail;</span><br><span class="line">    TrieNode()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isword = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;word = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;fail = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bulidTrie</span><span class="params">(TrieNode * root,<span class="built_in">string</span> &amp; word)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    TrieNode * node = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; c : word)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node-&gt;next[c-<span class="string">'a'</span>]) node-&gt;next[c-<span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">        node = node-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    node-&gt;word = word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">buildFail</span><span class="params">(TrieNode * root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; w : words)&#123;</span><br><span class="line">        insertTrie(root,w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TrieNode *&gt; qu;</span><br><span class="line">    qu.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">        TrieNode * curr = qu.front();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            TrieNode * next = curr-&gt;next[i];</span><br><span class="line">            <span class="keyword">if</span>(!next) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curr == root)&#123;</span><br><span class="line">                next-&gt;fail = curr;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                TrieNode * fail = curr-&gt;fail;</span><br><span class="line">                <span class="keyword">while</span>(fail)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fail-&gt;next[i])&#123;</span><br><span class="line">                        next-&gt;fail = fail-&gt;next[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fail = fail-&gt;fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!fail) next-&gt;fail = root;</span><br><span class="line">            &#125;   </span><br><span class="line"></span><br><span class="line">            qu.push(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TrieNode * <span class="title">buildAcAutomation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp; words)</span></span>&#123;</span><br><span class="line">    TrieNode * root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    bulidTrie(root,words);</span><br><span class="line">    buildFail(root,words);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(TrieNode * root,<span class="built_in">string</span> content)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    TrieNode * curr = root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : content)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!curr-&gt;next[c-<span class="string">'a'</span>] &amp;&amp; curr != root)&#123;</span><br><span class="line">            curr = curr-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = curr-&gt;next[c-<span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span>(!curr) curr = root;</span><br><span class="line">        TrieNode * t = curr;</span><br><span class="line">        <span class="keyword">while</span>(t != root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;isWord == <span class="literal">true</span>) <span class="built_in">cout</span>&lt;&lt;t-&gt;word&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            t = t-&gt;fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NFA状态机"><a href="#NFA状态机" class="headerlink" title="NFA状态机"></a>NFA状态机</h4><p><code>NFA</code>状态机的构造理论也是非常复杂的一个问题，感觉不是一两句话就能说清楚，特别是<code>nfa</code>的建造，实际上非常又技巧的一个巧妙的算法。另一个是关于<code>nfa</code>的搜索，如果不进行优化的话，就是实际的<code>DFS</code>查找。以下的代码是参考<code>princeton</code>的例子简单的写了一个<code>NFA</code>的模式匹配算法，支持<code>(),|,+,*,</code>的匹配，写的非常简单，但是对于理解基本的<code>nfa</code>原理来说肯定够用了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nfa</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Nfa()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;regexpr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">build</span><span class="params">(<span class="built_in">string</span> re)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m = re.size();</span><br><span class="line">        <span class="keyword">this</span>-&gt;regexpr = re;</span><br><span class="line">        <span class="keyword">this</span>-&gt;graph.clear();</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ops;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; re.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> lp = i;</span><br><span class="line">            <span class="keyword">if</span>(re[i] == <span class="string">'('</span>||re[i] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                ops.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(re[i] == <span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ops.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(re[ops.top()] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; curr;</span><br><span class="line">                    <span class="keyword">while</span>(!ops.empty()&amp;&amp;re[ops.top()] == <span class="string">'|'</span>)&#123;</span><br><span class="line">                        curr.push(ops.top());</span><br><span class="line">                        ops.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ops.empty()||re[ops.top()] != <span class="string">'('</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    lp = ops.top();</span><br><span class="line">                    ops.pop();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(!curr.empty())&#123;</span><br><span class="line">                        <span class="keyword">this</span>-&gt;addEdge(lp,curr.top()+<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">this</span>-&gt;addEdge(curr.top(),i);</span><br><span class="line">                        curr.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(re[ops.top()] == <span class="string">'('</span>)&#123;</span><br><span class="line">                    lp = ops.top();</span><br><span class="line">                    ops.pop();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; <span class="keyword">this</span>-&gt;m &amp;&amp; re[i+<span class="number">1</span>] == <span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i+<span class="number">1</span>,lp);</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(lp,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; <span class="keyword">this</span>-&gt;m &amp;&amp; re[i+<span class="number">1</span>] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i+<span class="number">1</span>,lp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(re[i] == <span class="string">'('</span> || re[i] == <span class="string">'*'</span> || </span><br><span class="line">               re[i] == <span class="string">')'</span> || re[i] == <span class="string">'+'</span>)&#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;addEdge(i,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!ops.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">debug</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">this</span>-&gt;m; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;graph.count(i))&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> v : <span class="keyword">this</span>-&gt;graph[i])&#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"--&gt;"</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> target)</span></span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; marked;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pc;</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>,marked);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : marked)&#123;</span><br><span class="line">            pc.push_back(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target.size(); ++i)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matched;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : pc)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v == <span class="keyword">this</span>-&gt;m) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;this-&gt;regexpr[v]&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;regexpr[v] == target[i] || <span class="keyword">this</span>-&gt;regexpr[v] == <span class="string">'.'</span>)&#123;</span><br><span class="line">                    matched.push_back(v+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            marked.clear();</span><br><span class="line">            pc.clear();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : matched)&#123;</span><br><span class="line">                dfs(v,marked);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : marked)&#123;</span><br><span class="line">                pc.push_back(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : pc)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == <span class="keyword">this</span>-&gt;m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; marked)</span></span>&#123;</span><br><span class="line">        marked.insert(curr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(marked.count(v)) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v,marked);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;graph[v].push_back(w);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> regexpr;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> regexpr = <span class="string">"(a|b)*cd"</span>;</span><br><span class="line">    <span class="built_in">string</span> target1 = <span class="string">"ABD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target2 = <span class="string">"ADD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target3 = <span class="string">"ABD"</span>;</span><br><span class="line">    <span class="built_in">string</span> target4 = <span class="string">"CBBD"</span>;</span><br><span class="line">    Nfa nfa;</span><br><span class="line">    nfa.build(regexpr);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;nfa.isMatch(target4)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li><code>NFA</code>转<code>DFA</code>的算法实现<br>这个算法也是我一直像学的，但是一直没有时间来好好思考这个问题。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="number">3.</span> 正则表达式引擎编写</span><br><span class="line">```c++</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;字符串算法&quot;&gt;&lt;a href=&quot;#字符串算法&quot; class=&quot;headerlink&quot; title=&quot;字符串算法&quot;&gt;&lt;/a&gt;字符串算法&lt;/h3&gt;&lt;p&gt;字符串作为一个非常重要的应用，。对所有字符串算法的总结，包括字符串的排序与字符串的匹配，在实际的程序中是非常非常重要的两块应用，其中的算法又非常的复杂。光把这几个研究透就非常需要耗费精力和时间。&lt;/p&gt;&lt;h4 id=&quot;字符串排序&quot;&gt;&lt;a href=&quot;#字符串排序&quot; class=&quot;headerlink&quot; title=&quot;字符串排序&quot;&gt;&lt;/a&gt;字符串排序&lt;/h4&gt;&lt;h5 id=&quot;count-index&quot;&gt;&lt;a href=&quot;#count-index&quot; class=&quot;headerlink&quot; title=&quot;count index&quot;&gt;&lt;/a&gt;&lt;code&gt;count index&lt;/code&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;count index&lt;/code&gt;作为一种快速的排序算法，可以在O(n+m)的时间复杂度内即可完成字符串的排序。本质是基数排序，实际应用中这个排序算法效率非常高，基本上可以在线性时间内完成对字符串的排序。空间复杂度为O(m+n).&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;countIndex&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; [] a)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [] count = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;257&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; [] aux = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;[a.length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ; i &amp;lt; str.length; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count[str[i]+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;256&lt;/span&gt;; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count[i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] += count[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        aux[count[a[i]++]] = a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; N; ++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i] = aux[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Priceton 算法课程学习</title>
    <link href="http://yoursite.com/2020/04/09/147/"/>
    <id>http://yoursite.com/2020/04/09/147/</id>
    <published>2020-04-09T15:34:46.798Z</published>
    <updated>2020-04-10T01:58:42.949Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法课程总结"><a href="#算法课程总结" class="headerlink" title="算法课程总结"></a>算法课程总结</h2><p>在疫情的两个月内已经把相关材料全部学习完成了，特别是把几个project全部做了一遍，感觉<code>project</code>全部做了一遍，总的感觉是课程的质量非常非常的高，难得见到这么高质量的课程。我是全程把课程资料和project全部下下来了，总共10个<code>project</code>全部做了一遍，感慨一下算法的强大，虽然自己也仅仅只是学到了皮毛，但是对于已经过了中年还坚持学习的自己感到很满意。“学无止境”，我想这永远是对自己的一种激励和鞭策。中国古人言，“求其上者，得其中，求其中者，得其下”，我想保持一颗永远学习进去得心，在哪里都会有自己得空间。<br>其实我最想点赞得是10个<code>project</code>得难度都很棒，还记得从刚开始得<code>java</code>的语法都搞不清楚，到后面基本上<code>java</code>的一般语法问题难不倒我。其实学完了这些课程以后，其实很羡慕那些能够去世界名校学习的学生们，你们始终是幸运儿。再想想10年前我所经历的大学，很少有这样的顶级学习资源和老师。虽然时光已逝，这些年经历了许多，经历了亲人的去世，也经历了两个小宝贝的诞生，让我逐渐成熟了许多，越来越知道自己想要追求什么，到底喜欢什么样的生活，我想说的是人需要为了理想而努力，虽然我出身低微贫穷，但是这些年来一直也没有放弃自己对美好生活和理想的追求。以下是 <code>github</code>上的地址连接：<br><a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1" target="_blank" rel="noopener">algorithms-part1</a><br><a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2" target="_blank" rel="noopener">algorithms-part2</a><br>从最开始连题目都看不懂，等到后面几个<code>project</code>基本上都能得到满分，还是非常欣慰的能看到自己的进步。强烈建议学习算法的同学们能够把这个课程坚持学习完整。<br>我觉得这个课程的<code>project</code> 非常有特色，需要提交的代码不仅仅是求出结果，还会对代码的输入检查、异常抛出、代码的风格、变量的定义以及运行时间和运行</p><a id="more"></a><h3 id="algorithms-part1"><a href="#algorithms-part1" class="headerlink" title="algorithms-part1"></a>algorithms-part1</h3><h4 id="week1"><a href="#week1" class="headerlink" title="week1"></a>week1</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week1" target="_blank" rel="noopener">percolation</a><br>本次的<code>project</code>是关于<code>union-set</code>，<code>tricky</code>的地方查找集合中的元素同时存在上下边缘的元素。我们可以为每个集合定义两个变量表示该集合是否同时存在上下边缘的元素。<br><img src="https://mike-box.github.io/images/147-1.png" alt="percolation"></p><h4 id="week2"><a href="#week2" class="headerlink" title="week2"></a>week2</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week2" target="_blank" rel="noopener">queues</a><br>本次的<code>project</code>是关于<code>queue</code>，这个project比较简单，<code>tricky</code>的地方randomQueue和Dequue。<br><img src="https://mike-box.github.io/images/147-2.png" alt="queues"></p><h4 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week3" target="_blank" rel="noopener">collinear</a><br>本次的<code>project</code>是关于线段合并，这个project稍微比较难，难点在于需要对所有的点的斜率进行排序，然后取斜率相等，<code>tricky</code>的地方在于如何去重，需要一点技巧，要按照元素的大小进行排序。<br><img src="https://mike-box.github.io/images/147-3.png" alt="collinear"></p><h4 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week4" target="_blank" rel="noopener">8puzzle</a><br>本次的<code>project</code>是关于优先级队列，这个project稍微比较难，首先题目非常不容易理解，再次对优先级的定义涉及到<code>mahanton</code>距离的计算。<code>tricky</code>的地方在于如何如何涉及优先级队列。<br>关于优先级队列中另有一个<code>project</code>我觉得非常有意思，<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week4/CollisionSystem" target="_blank" rel="noopener">CollisionSystem</a>.我用<code>python</code>重新写了一个碰撞模拟的系统，感觉非常有意思，如果感兴趣的同学非常建议把这个<code>project</code>学习以下，强烈的推荐。<br><img src="https://mike-box.github.io/images/147-4.png" alt="collinear"></p><h4 id="week5"><a href="#week5" class="headerlink" title="week5"></a>week5</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part1/week5" target="_blank" rel="noopener">kdtree</a><br>本次的<code>project</code>是关于<code>kdtree</code>，本质上是二分搜索树，非常经典的一个问题，通过这个project详细的了解了<code>kdtree</code>的原理，其实这个算法非常的有用，在<code>LBS</code>应用算法中非常有用。这个project稍微难，难点在于如何对<code>kdtree</code>进行查找，如何在<code>lgn</code>时间内对树进行搜索和查找。<code>tricky</code>的地方在写查找函数还是非常需要一定的技巧，当然对于经历过竞赛的同学，这个题目肯定非常简单。<br><img src="https://mike-box.github.io/images/147-6.png" alt="kdtree"></p><h3 id="algorithms-part2"><a href="#algorithms-part2" class="headerlink" title="algorithms-part2"></a>algorithms-part2</h3><h4 id="week1-1"><a href="#week1-1" class="headerlink" title="week1"></a>week1</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week1" target="_blank" rel="noopener">wordnet</a><br>本次的<code>project</code>是关于<code>图的搜索</code>，本质上是<code>BFS</code>，这个<code>project</code>比较简单，本质就是图的遍历。<code>tricky</code>的地方在在树中查找求最短距离之和。<br><img src="https://mike-box.github.io/images/147-7.png" alt="wordnet"></p><h4 id="week2-1"><a href="#week2-1" class="headerlink" title="week2"></a>week2</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week2" target="_blank" rel="noopener">seam</a><br>本次的<code>project</code>是关于<code>dp</code>，这个<code>project</code>比较有意思，用<code>DP</code>解决了这个问题，性能比给的参考答案性能还快几倍，这个project稍微比较简单，关键点在于找到能量最低的那条线，每次去掉能量最低的一条线的元素。<br><img src="https://mike-box.github.io/images/147-8.png" alt="seam"></p><h4 id="week3-1"><a href="#week3-1" class="headerlink" title="week3"></a>week3</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week3" target="_blank" rel="noopener">baseball</a><br>本次的<code>project</code>是关于<code>maxflow</code>，由于以前一直对<code>maxflow</code>这个算法不太了解，其中那几天想了好长时间才想明白这个算法的道理。如果明白了<code>maxflow</code>算法的原理，这个<code>project</code>非常简单，就是把图的边的对应关系要建立起来。<code>tricky</code>的地方在于对这个题目好多地方不太明白，看清楚图中每条边的<code>capbility</code>的是如何约束的，了解清楚就非常简单。<br><img src="https://mike-box.github.io/images/147-9.png" alt="baseball"></p><h4 id="week4-1"><a href="#week4-1" class="headerlink" title="week4"></a>week4</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week4" target="_blank" rel="noopener">boggle</a><br>本次的<code>project</code>是关于<code>trie</code>，题目很简单，在<code>leetcode</code>上有基本上类似的题目，早就对这个题目相当明白了。只要知道<code>trie</code>的搜索，这个题目时非常简单的。<br><img src="https://mike-box.github.io/images/147-9.png" alt="boggle"></p><h4 id="week5-1"><a href="#week5-1" class="headerlink" title="week5"></a>week5</h4><p>课程地址连接：<a href="https://github.com/mike-box/coursera/tree/master/algorithms-part2/week5" target="_blank" rel="noopener">burrows</a><br>本次的<code>project</code>是关于<code>compress</code>算法，题目比较难，主要是压缩算法转换时对性能要求非常高，性能方面比较容易丢分要拿到满分不容易，最后性能跟题目中的参考答案差了一倍。<code>tricky</code>的地方在于如何理解题目，题目部分地方非常不好理解，另一方面性能如何优化是一个挑战。<br><img src="https://mike-box.github.io/images/147-10.png" alt="burrows"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法课程总结&quot;&gt;&lt;a href=&quot;#算法课程总结&quot; class=&quot;headerlink&quot; title=&quot;算法课程总结&quot;&gt;&lt;/a&gt;算法课程总结&lt;/h2&gt;&lt;p&gt;在疫情的两个月内已经把相关材料全部学习完成了，特别是把几个project全部做了一遍，感觉&lt;code&gt;project&lt;/code&gt;全部做了一遍，总的感觉是课程的质量非常非常的高，难得见到这么高质量的课程。我是全程把课程资料和project全部下下来了，总共10个&lt;code&gt;project&lt;/code&gt;全部做了一遍，感慨一下算法的强大，虽然自己也仅仅只是学到了皮毛，但是对于已经过了中年还坚持学习的自己感到很满意。“学无止境”，我想这永远是对自己的一种激励和鞭策。中国古人言，“求其上者，得其中，求其中者，得其下”，我想保持一颗永远学习进去得心，在哪里都会有自己得空间。&lt;br&gt;其实我最想点赞得是10个&lt;code&gt;project&lt;/code&gt;得难度都很棒，还记得从刚开始得&lt;code&gt;java&lt;/code&gt;的语法都搞不清楚，到后面基本上&lt;code&gt;java&lt;/code&gt;的一般语法问题难不倒我。其实学完了这些课程以后，其实很羡慕那些能够去世界名校学习的学生们，你们始终是幸运儿。再想想10年前我所经历的大学，很少有这样的顶级学习资源和老师。虽然时光已逝，这些年经历了许多，经历了亲人的去世，也经历了两个小宝贝的诞生，让我逐渐成熟了许多，越来越知道自己想要追求什么，到底喜欢什么样的生活，我想说的是人需要为了理想而努力，虽然我出身低微贫穷，但是这些年来一直也没有放弃自己对美好生活和理想的追求。以下是 &lt;code&gt;github&lt;/code&gt;上的地址连接：&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/algorithms-part1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;algorithms-part1&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/mike-box/coursera/tree/master/algorithms-part2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;algorithms-part2&lt;/a&gt;&lt;br&gt;从最开始连题目都看不懂，等到后面几个&lt;code&gt;project&lt;/code&gt;基本上都能得到满分，还是非常欣慰的能看到自己的进步。强烈建议学习算法的同学们能够把这个课程坚持学习完整。&lt;br&gt;我觉得这个课程的&lt;code&gt;project&lt;/code&gt; 非常有特色，需要提交的代码不仅仅是求出结果，还会对代码的输入检查、异常抛出、代码的风格、变量的定义以及运行时间和运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 LFU</title>
    <link href="http://yoursite.com/2020/04/06/146/"/>
    <id>http://yoursite.com/2020/04/06/146/</id>
    <published>2020-04-06T15:12:08.192Z</published>
    <updated>2020-04-07T02:26:44.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h1><p>题目比较简单，都做出来了。</p><h2 id="460-LFU缓存"><a href="#460-LFU缓存" class="headerlink" title="460. LFU缓存"></a>460. LFU缓存</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请你为 最不经常使用<code>（LFU）</code>缓存算法设计并实现数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p><ul><li><code>get(key)</code> - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li><li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。</li></ul><a id="more"></a><p>「项的使用次数」就是自插入该项以来对其调用 <code>get</code>和 <code>put</code> 函数的次数之和。使用次数会在对应项被移除后置为 0 。`</p><p>进阶：<br>你是否可以在<code>O(1)</code> 时间复杂度内执行两项操作？<br>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LFUCache cache = new LFUCache( <span class="number">2</span> <span class="comment">/* capacity (缓存容量) */</span> );</span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 去除 key 2</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到key 2)</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">3</span>);       <span class="comment">// 返回 3</span></span><br><span class="line">cache.put(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 去除 key 1</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到 key 1)</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">3</span>);       <span class="comment">// 返回 3</span></span><br><span class="line">cache.<span class="keyword">get</span>(<span class="number">4</span>);       <span class="comment">// 返回 4</span></span><br></pre></td></tr></table></figure><br>归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/lfu-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lfu-cache</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> LFU算法  hash + 双链表</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>对所有的key按照使用频次大小和使用时间的先后进行排列，即我们将最少使用次数，且最长时间未用的节点放在链表队列的首部，每次队列满时直接从队列的头部取出元素进行淘汰。</li><li>我们将用将key映射到链表的节点的指针，所以我们可以在O(1)的时间复杂度内即可以访问到链表的节点，然后将链表的节点中存储的freq进行加一，并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).</li><li><code>get</code>操作时，直接查找hash表，查找该值是否存在映射的链表的节点。将链表的节点中存储的freq进行加一，并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).</li><li><code>put</code>操作时，直接查找hash表，查找该值是否存在映射的链表的节点。如果该节点存在，则改变存储的value的值，同时将存储的freq进行加1操作，然后移动链表。并且该节点与其后续的节点进行比较，发现频次与其相同或者比它小的节点则将节点进行后移操作，直到该节点到达指定位置。但是这种情况下如果进行替换时，则时间复杂度可能达到O(N).如果该节点不存在，则有两种情况需要讨论。一是队列已经满，则这时只需要将双链表队列的头部元素去掉，然后再添加新的头节点到队列中，然后进行比较移动操作。如果队列未满，则直接再双链表队列的头部添加新的元素，然后进行频次比较移位操作。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CacheNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    CacheNode(<span class="keyword">int</span> k, <span class="keyword">int</span> v):freq(<span class="number">1</span>), key(k), val(v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> CacheNode&amp; a, <span class="keyword">const</span> CacheNode&amp; b)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.freq &lt; b.freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        size = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = cacheMap.find(key);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || it == cacheMap.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        CacheNode temp = *(it-&gt;second);</span><br><span class="line">        temp.freq++;</span><br><span class="line">        cacheSet.erase(it-&gt;second);</span><br><span class="line">        cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">        <span class="keyword">return</span> temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = cacheMap.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == cacheMap.end())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cacheMap.size() == size)&#123;</span><br><span class="line">                cacheMap.erase((cacheSet.begin())-&gt;key);</span><br><span class="line">                cacheSet.erase(cacheSet.begin());</span><br><span class="line">            &#125;</span><br><span class="line">            CacheNode temp = CacheNode(key, value);</span><br><span class="line">            cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CacheNode temp = *(it-&gt;second);</span><br><span class="line">        temp.freq++;</span><br><span class="line">        temp.val = value;</span><br><span class="line">        cacheSet.erase(it-&gt;second);</span><br><span class="line">        cacheMap[key] = cacheSet.insert(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;CacheNode, Compare&gt; cacheSet;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;CacheNode, Compare&gt;::iterator&gt; cacheMap;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    Node * next;</span><br><span class="line">    Node * prev;</span><br><span class="line">    Node()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;freq = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> currSize;</span><br><span class="line">    Node * head;</span><br><span class="line">    Queue(<span class="keyword">int</span> capacity)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxSize = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;currSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu || qu-&gt;currSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> qu-&gt;currSize &gt;= qu-&gt;maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">shiftQueue</span><span class="params">(Queue * qu,Node * curr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu || !curr) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(qu)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*shift every node if freq is less or equal than curr*/</span></span><br><span class="line">    <span class="keyword">bool</span> replace = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(Node * node = curr-&gt;next; node ; node = curr-&gt;next)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"swap :"&lt;&lt;curr-&gt;val &lt;&lt;" "&lt;&lt; node-&gt;val &lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">/*swap node*/</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;freq &lt;= curr-&gt;freq)&#123;</span><br><span class="line">            curr-&gt;next = node-&gt;next;</span><br><span class="line">            node-&gt;prev = curr-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;prev) curr-&gt;prev-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;next) node-&gt;next-&gt;prev = curr;</span><br><span class="line">            curr-&gt;prev = node;</span><br><span class="line">            node-&gt;next = curr;</span><br><span class="line">            <span class="keyword">if</span>(qu-&gt;head == curr &amp;&amp; !replace)&#123;</span><br><span class="line">                qu-&gt;head = node;</span><br><span class="line">                replace = <span class="literal">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pushFront</span><span class="params">(Queue * qu, Node * node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu||!node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isEmpty(qu))&#123;</span><br><span class="line">        qu-&gt;head = node;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        node-&gt;next = qu-&gt;head;</span><br><span class="line">        qu-&gt;head-&gt;prev = node;</span><br><span class="line">        qu-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">    qu-&gt;currSize++;</span><br><span class="line">    shiftQueue(qu,node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popFront</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;currSize == <span class="number">0</span> || !qu-&gt;head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Node * e = qu-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> ret = e-&gt;key;</span><br><span class="line">    qu-&gt;head = qu-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(qu-&gt;head) qu-&gt;head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    qu-&gt;currSize--;</span><br><span class="line">    e-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    e-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">debugQueue</span><span class="params">(Queue * qu)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!qu) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"curr size = "</span>&lt;&lt;qu-&gt;currSize&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(Node * node = qu-&gt;head; node; node = node-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"key:"</span>&lt;&lt;node-&gt;key&lt;&lt;<span class="string">" value:"</span>&lt;&lt;node-&gt;val&lt;&lt;<span class="string">" freq:"</span>&lt;&lt;node-&gt;freq&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;qu = <span class="keyword">new</span> Queue(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>-&gt;hash.count(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">        curr-&gt;freq++;</span><br><span class="line">        <span class="keyword">int</span> ret = curr-&gt;val;</span><br><span class="line">        shiftQueue(<span class="keyword">this</span>-&gt;qu,curr);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash.count(key))&#123;</span><br><span class="line">             Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">             curr-&gt;val = value;</span><br><span class="line">             curr-&gt;freq++;</span><br><span class="line">             shiftQueue(<span class="keyword">this</span>-&gt;qu,curr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">/* buffer is full*/</span></span><br><span class="line">            <span class="keyword">if</span>(isFull(qu))&#123;</span><br><span class="line">                <span class="keyword">if</span>(qu-&gt;head)&#123;</span><br><span class="line">                    <span class="keyword">this</span>-&gt;hash.erase(qu-&gt;head-&gt;key);</span><br><span class="line">                    popFront(qu);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isFull(qu))&#123;</span><br><span class="line">                Node * node = <span class="keyword">new</span> Node();</span><br><span class="line">                node-&gt;key = key;</span><br><span class="line">                node-&gt;val = value;</span><br><span class="line">                node-&gt;freq = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;hash[key] = node;</span><br><span class="line">                pushFront(<span class="keyword">this</span>-&gt;qu,node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node *&gt; hash;</span><br><span class="line">    Queue *qu;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> freq;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    Node(<span class="keyword">int</span> key,<span class="keyword">int</span> val,<span class="keyword">int</span> freq,<span class="keyword">int</span> time)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;freq = freq;</span><br><span class="line">        <span class="keyword">this</span>-&gt;time = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Node * x,<span class="keyword">const</span> Node * y)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(x-&gt;freq == y-&gt;freq) <span class="keyword">return</span> x-&gt;time &lt; y-&gt;time;</span><br><span class="line">        <span class="keyword">return</span> x-&gt;freq &lt; y-&gt;freq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LFUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;maxSize = capacity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash.count(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        Node * curr = hash[key];</span><br><span class="line">        buffer.erase(curr);</span><br><span class="line">        <span class="keyword">int</span> ret = curr-&gt;val;</span><br><span class="line">        curr-&gt;freq++;</span><br><span class="line">        curr-&gt;time = <span class="keyword">this</span>-&gt;timer;</span><br><span class="line">        buffer.insert(curr);</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;maxSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(hash.count(key))&#123;</span><br><span class="line">            Node * curr = <span class="keyword">this</span>-&gt;hash[key];</span><br><span class="line">            buffer.erase(curr);</span><br><span class="line">            curr-&gt;val = value;</span><br><span class="line">            curr-&gt;freq++;</span><br><span class="line">            curr-&gt;time = <span class="keyword">this</span>-&gt;timer;</span><br><span class="line">            buffer.insert(curr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer.size() &gt;= <span class="keyword">this</span>-&gt;maxSize)&#123;</span><br><span class="line">                Node * curr = *buffer.begin();</span><br><span class="line">                <span class="keyword">this</span>-&gt;hash.erase(curr-&gt;key);</span><br><span class="line">                buffer.erase(curr);</span><br><span class="line">            &#125;</span><br><span class="line">            Node * node = <span class="keyword">new</span> Node(key,value,<span class="number">1</span>,<span class="keyword">this</span>-&gt;timer);</span><br><span class="line">            <span class="keyword">this</span>-&gt;hash[key] = node;</span><br><span class="line">            buffer.insert(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;timer++;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,Node *&gt; hash;</span><br><span class="line">    <span class="built_in">set</span>&lt;Node*,cmp&gt; buffer;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;LFU&quot;&gt;&lt;a href=&quot;#LFU&quot; class=&quot;headerlink&quot; title=&quot;LFU&quot;&gt;&lt;/a&gt;LFU&lt;/h1&gt;&lt;p&gt;题目比较简单，都做出来了。&lt;/p&gt;&lt;h2 id=&quot;460-LFU缓存&quot;&gt;&lt;a href=&quot;#460-LFU缓存&quot; class=&quot;headerlink&quot; title=&quot;460. LFU缓存&quot;&gt;&lt;/a&gt;460. LFU缓存&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;请你为 最不经常使用&lt;code&gt;（LFU）&lt;/code&gt;缓存算法设计并实现数据结构。它应该支持以下操作：&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt;。&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;get(key)&lt;/code&gt; - 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put(key, value)&lt;/code&gt; - 如果键不存在，请设置或插入值。当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近 最少使用的键。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 23周双周比赛</title>
    <link href="http://yoursite.com/2020/04/05/145/"/>
    <id>http://yoursite.com/2020/04/05/145/</id>
    <published>2020-04-05T15:07:04.024Z</published>
    <updated>2020-04-05T15:07:10.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23周比赛"><a href="#23周比赛" class="headerlink" title="23周比赛"></a>23周比赛</h1><p>题目比较简单，都做出来了。</p><h2 id="5360-统计最大组的数目"><a href="#5360-统计最大组的数目" class="headerlink" title="5360. 统计最大组的数目"></a>5360. 统计最大组的数目</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。</p><p>请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">13</span></span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：总共有 <span class="number">9</span> 个组，将 <span class="number">1</span> 到 <span class="number">13</span> 按数位求和后这些组分别是：</span><br><span class="line">[<span class="number">1</span>,<span class="number">10</span>]，[<span class="number">2</span>,<span class="number">11</span>]，[<span class="number">3</span>,<span class="number">12</span>]，[<span class="number">4</span>,<span class="number">13</span>]，[<span class="number">5</span>]，[<span class="number">6</span>]，[<span class="number">7</span>]，[<span class="number">8</span>]，[<span class="number">9</span>]。总共有 <span class="number">4</span> 个组拥有的数字并列最多。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：总共有 <span class="number">2</span> 个大小为 <span class="number">1</span> 的组 [<span class="number">1</span>]，[<span class="number">2</span>]。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">15</span></span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">24</span></span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：`</p><ul><li><code>1 &lt;= n &lt;= 10^4</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-largest-group" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-largest-group</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序之后，暴力即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            res += (n%<span class="number">10</span>);</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countLargestGroup</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            cnt[sum(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">            maxFreq = max(x.second,maxFreq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.second == maxFreq) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5362-构造-K-个回文字符串"><a href="#5362-构造-K-个回文字符串" class="headerlink" title="5362. 构造 K 个回文字符串"></a>5362. 构造 K 个回文字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。</p><p>如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 <code>True</code>，否则返回 <code>False</code>。</p><p>示例 1：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"annabelle"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：可以用 s 中所有字符构造 <span class="number">2</span> 个回文字符串。</span><br><span class="line">一些可行的构造方案包括：<span class="string">"anna"</span> + <span class="string">"elble"</span>，<span class="string">"anbna"</span> + <span class="string">"elle"</span>，<span class="string">"anellena"</span> + <span class="string">"b"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span>, <span class="attr">k</span> = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：无法用 s 中所有字符构造 <span class="number">3</span> 个回文串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"true"</span>, <span class="attr">k</span> = <span class="number">4</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：唯一可行的方案是让 s 中每个字符单独构成一个字符串。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"yzyzyzyzyzyzyzy"</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：你只需要将所有的 z 放在一个字符串中，所有的 y 放在另一个字符串中。那么两个字符串都是回文串。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"cr"</span>, <span class="attr">k</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：我们没有足够的字符去构造 <span class="number">7</span> 个回文串。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>1 &lt;= s.length &lt;= 10^5</li><li>s 中所有字符都是小写英文字母。</li><li>1 &lt;= k &lt;= 10^5</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/construct-k-palindrome-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/construct-k-palindrome-strings</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 判定不符合条件</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>只需要统计字符的个数即可。对于偶数的字符，我们可以知道它可以拆成一个或者两个或者零个回文字符串都可以。比如 “aaaaa”:<br>我们可以把该字符串本身串联都其他的回文字符串，或者将其当作一个单独的字符串，或者拆成两个字符串。</li><li>但是对于字符数目为奇数的字符我们最少都需要占用一个回文字符串，因为它有一个奇数的字符没法拆分。</li><li>此题实际上转换为求偶数数目的字符的个数。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.size() == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            cnt[c-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]%<span class="number">2</span>) odd++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(odd &gt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5361-圆和矩形是否有重叠"><a href="#5361-圆和矩形是否有重叠" class="headerlink" title="5361. 圆和矩形是否有重叠"></a>5361. 圆和矩形是否有重叠</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个以 <code>(radius, x_center, y_center)</code> 表示的圆和一个与坐标轴平行的矩形 <code>(x1, y1, x2, y2)</code>，其中 <code>(x1, y1)</code> 是矩形左下角的坐标，<code>(x2, y2)</code>是右上角的坐标。</p><p>如果圆和矩形有重叠的部分，请你返回 <code>True</code>，否则返回 <code>False</code> 。</p><p>换句话说，请你检测是否 存在 点 <code>(xi, yi)</code>，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">0</span>, y_center = <span class="number">0</span>, x1 = <span class="number">1</span>, y1 = <span class="number">-1</span>, x2 = <span class="number">3</span>, y2 = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：圆和矩形有公共点 (<span class="number">1</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">0</span>, y_center = <span class="number">0</span>, x1 = <span class="number">-1</span>, y1 = <span class="number">0</span>, x2 = <span class="number">0</span>, y2 = <span class="number">1</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">1</span>, y_center = <span class="number">1</span>, x1 = <span class="number">-3</span>, y1 = <span class="number">-3</span>, x2 = <span class="number">3</span>, y2 = <span class="number">3</span></span><br><span class="line">输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：radius = <span class="number">1</span>, x_center = <span class="number">1</span>, y_center = <span class="number">1</span>, x1 = <span class="number">1</span>, y1 = <span class="number">-3</span>, x2 = <span class="number">2</span>, y2 = <span class="number">-1</span></span><br><span class="line">输出：<span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= radius &lt;= 2000</code></li><li><code>-10^4 &lt;= x_center, y_center, x1, y1, x2, y2 &lt;= 10^4</code></li><li><code>x1 &lt; x2</code></li><li><code>y1 &lt; y2</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/circle-and-rectangle-overlapping" target="_blank" rel="noopener">https://leetcode-cn.com/problems/circle-and-rectangle-overlapping</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数学问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>圆心如果在矩形内肯定存在交集。</li><li>矩形的边缘如果在园内，则肯定存在交集。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkOverlap</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x_center, <span class="keyword">int</span> y_center, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*inside */</span></span><br><span class="line">        <span class="keyword">if</span>(x_center &gt;= x1 &amp;&amp; x_center &lt;= x2 &amp;&amp; y_center &gt;= y1 &amp;&amp; y_center &lt;= y2) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">/*left and right*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = y1; i &lt;= y2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(x1-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(i-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(x2-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(i-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*top and buttom*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = x1; i &lt;= x2; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(i-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(y1-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="built_in">pow</span>(i-x_center,<span class="number">2</span>) + <span class="built_in">pow</span>(y2-y_center,<span class="number">2</span>)) &lt;= radius*radius) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5363-做菜顺序"><a href="#5363-做菜顺序" class="headerlink" title="5363. 做菜顺序"></a>5363. 做菜顺序</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>一个厨师收集了他 n 道菜的满意程度<code>satisfaction</code>，这个厨师做出每道菜的时间都是 1 单位时间。<br>一道菜的 「喜爱时间」系数定义为烹饪这道菜以及之前每道菜所花费的时间乘以这道菜的满意程度，也就是 <code>time[i]*satisfaction[i]</code> 。<br>请你返回做完所有菜 「喜爱时间」总和的最大值为多少。<br>你可以按 任意 顺序安排做菜的顺序，你也可以选择放弃做某些菜来获得更大的总和。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-1</span>,<span class="number">-8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">-9</span>]</span><br><span class="line">输出：<span class="number">14</span></span><br><span class="line">解释：去掉第二道和最后一道菜，最大的喜爱时间系数和为 (<span class="number">-1</span>*<span class="number">1</span> + <span class="number">0</span>*<span class="number">2</span> + <span class="number">5</span>*<span class="number">3</span> = <span class="number">14</span>) 。每道菜都需要花费 <span class="number">1</span> 单位时间完成。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：按照原来顺序相反的时间做菜 (<span class="number">2</span>*<span class="number">1</span> + <span class="number">3</span>*<span class="number">2</span> + <span class="number">4</span>*<span class="number">3</span> = <span class="number">20</span>)</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-1</span>,<span class="number">-4</span>,<span class="number">-5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：大家都不喜欢这些菜，所以不做任何菜可以获得最大的喜爱时间系数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：satisfaction = [<span class="number">-2</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="number">35</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == satisfaction.length</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>-10^3 &lt;= satisfaction[i] &lt;= 10^3</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/reducing-dishes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reducing-dishes</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划  </p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>本题还是比较常见的DP，首先对菜单进行从小到大排序。</li><li>二维dp，<code>dp[i][j]</code>代表从前<code>i</code>道菜品中选择<code>j</code>道菜品所获得最大满意度。</li><li>递推公式为：<script type="math/tex; mode=display">dp[i][j] = max(dp[i-1][j],dp[i-1][j-1] + satisfaction[i]*j)</script></li><li>简单的二维DP，很容易就得到结果。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">501</span>;</span><br><span class="line"><span class="keyword">int</span> dp[M][M];</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfaction</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; satisfaction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = satisfaction.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        sort(satisfaction.begin(),satisfaction.end());</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + satisfaction[i<span class="number">-1</span>]*j;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + satisfaction[i<span class="number">-1</span>]*j);</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;23周比赛&quot;&gt;&lt;a href=&quot;#23周比赛&quot; class=&quot;headerlink&quot; title=&quot;23周比赛&quot;&gt;&lt;/a&gt;23周比赛&lt;/h1&gt;&lt;p&gt;题目比较简单，都做出来了。&lt;/p&gt;&lt;h2 id=&quot;5360-统计最大组的数目&quot;&gt;&lt;a href=&quot;#5360-统计最大组的数目&quot; class=&quot;headerlink&quot; title=&quot;5360. 统计最大组的数目&quot;&gt;&lt;/a&gt;5360. 统计最大组的数目&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;。请你先求出从 1 到 n 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。&lt;/p&gt;&lt;p&gt;请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：总共有 &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; 个组，将 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 到 &lt;span class=&quot;number&quot;&gt;13&lt;/span&gt; 按数位求和后这些组分别是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]。总共有 &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; 个组拥有的数字并列最多。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：总共有 &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; 个大小为 &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; 的组 [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]，[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 4：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：n = &lt;span class=&quot;number&quot;&gt;24&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 183周比赛</title>
    <link href="http://yoursite.com/2020/04/05/144/"/>
    <id>http://yoursite.com/2020/04/05/144/</id>
    <published>2020-04-05T11:03:32.352Z</published>
    <updated>2020-04-05T11:03:38.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="183周比赛"><a href="#183周比赛" class="headerlink" title="183周比赛"></a>183周比赛</h1><p>题目都比较简单，除了第三题稍微有点绕弯以外，其余的都比较简单。</p><h2 id="5376-非递增顺序的最小子序列"><a href="#5376-非递增顺序的最小子序列" class="headerlink" title="5376. 非递增顺序的最小子序列"></a>5376. 非递增顺序的最小子序列</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个数组 <code>nums</code>，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。<br>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。<br>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。<br>注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">9</span>] </span><br><span class="line">解释：子序列 [<span class="number">10</span>,<span class="number">9</span>] 和 [<span class="number">10</span>,<span class="number">8</span>] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [<span class="number">10</span>,<span class="number">9</span>] 的元素之和最大。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>] </span><br><span class="line">解释：子序列 [<span class="number">7</span>,<span class="number">7</span>] 的和为 <span class="number">14</span> ，不严格大于剩下的其他元素之和（<span class="number">14</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">6</span>）。因此，[<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[6]</span></span><br><span class="line">输出：<span class="string">[6]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 500</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-subsequence-in-non-increasing-order</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>排序之后，暴力即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minSubsequence(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        reverse(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : nums) sum += x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            curr += nums[i];</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(curr &gt; sum - curr)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5377-将二进制表示减到-1-的步骤数"><a href="#5377-将二进制表示减到-1-的步骤数" class="headerlink" title="5377. 将二进制表示减到 1 的步骤数"></a>5377. 将二进制表示减到 1 的步骤数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个以二进制形式表示的数字 s 。请你返回按下述规则将其减少到 1 所需要的步骤数：<br>如果当前数字为偶数，则将其除以 2 。<br>如果当前数字为奇数，则将其加上 1 。<br>题目保证你总是可以按上述规则将测试用例变为 1 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1101"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：<span class="string">"1101"</span> 表示十进制数 <span class="number">13</span> 。</span><br><span class="line">Step <span class="number">1</span>) <span class="number">13</span> 是奇数，加 <span class="number">1</span> 得到 <span class="number">14</span> </span><br><span class="line">Step <span class="number">2</span>) <span class="number">14</span> 是偶数，除 <span class="number">2</span> 得到 <span class="number">7</span></span><br><span class="line">Step <span class="number">3</span>) <span class="number">7</span>  是奇数，加 <span class="number">1</span> 得到 <span class="number">8</span></span><br><span class="line">Step <span class="number">4</span>) <span class="number">8</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">4</span>  </span><br><span class="line">Step <span class="number">5</span>) <span class="number">4</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">2</span> </span><br><span class="line">Step <span class="number">6</span>) <span class="number">2</span>  是偶数，除 <span class="number">2</span> 得到 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"10"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：<span class="string">"10"</span> 表示十进制数 <span class="number">2</span> 。</span><br><span class="line">Step <span class="number">1</span>) <span class="number">2</span> 是偶数，除 <span class="number">2</span> 得到 <span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"1"</span></span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s 由字符 &#39;0&#39; 或 &#39;1&#39; 组成</code></li><li><code>s[0] == &#39;1&#39;</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接模拟计算即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>由于本身的二进制长度很长，可能大于200.</li><li><code>python</code>或者<code>java</code>支持超长数目，所以可以直接计算即可。</li><li><code>c/c++</code>由于没有不支持超长整形，所以我们直接对二进制字符串本身进行模拟加法或者减法即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">increment</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = s.size()<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">'1'</span> &amp;&amp; carry == <span class="number">1</span>)&#123;</span><br><span class="line">                s[i] = <span class="string">'0'</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s[i] = s[i] + carry;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> carry == <span class="number">1</span>?(<span class="string">'1'</span>+ s):(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decrement</span><span class="params">(<span class="built_in">string</span> &amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substr(<span class="number">0</span>,s.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSteps</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s != <span class="string">"1"</span>)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span>(s.back() == <span class="string">'1'</span>) s = increment(s);</span><br><span class="line">            <span class="keyword">else</span> s = decrement(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5195-最长快乐字符串"><a href="#5195-最长快乐字符串" class="headerlink" title="5195. 最长快乐字符串"></a>5195. 最长快乐字符串</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>如果字符串中不含有任何 <code>&#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39;</code>这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。</p><p>给你三个整数 <code>a，b ，c，</code>请你返回 任意一个 满足下列全部条件的字符串 s：</p><ul><li><code>s</code>是一个尽可能长的快乐字符串。</li><li><code>s</code>中 最多 有a 个字母 ‘a’、b 个字母 ‘b’、c 个字母 ‘c’ 。</li><li><code>s</code>中只含有 ‘a’、’b’ 、’c’ 三种字母。</li></ul><p>如果不存在这样的字符串<code>s</code>，请返回一个空字符串 “”。<br>示例 1：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">1</span>, <span class="selector-tag">b</span> = <span class="number">1</span>, c = <span class="number">7</span></span><br><span class="line">输出：<span class="string">"ccaccbcc"</span></span><br><span class="line">解释：<span class="string">"ccbccacc"</span> 也是一种正确答案。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">2</span>, <span class="selector-tag">b</span> = <span class="number">2</span>, c = <span class="number">1</span></span><br><span class="line">输出：<span class="string">"aabbc"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="selector-tag">a</span> = <span class="number">7</span>, <span class="selector-tag">b</span> = <span class="number">1</span>, c = <span class="number">0</span></span><br><span class="line">输出：<span class="string">"aabaa"</span></span><br><span class="line">解释：这是该测试用例的唯一正确答案。</span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>0 &lt;= a, b, c &lt;= 100</code></li><li><code>a + b + c &gt; 0</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-happy-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-happy-string</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 贪心算法</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>每次优先取长度最长的那个字符，如果该字符之前已经出现了两次，则我们选择次等长度的。</li><li>但是这个题目确实出的不够好，因为实际也并没有对字符的数目进行限制。比较混乱。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDiverseString</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>((a+b+c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> len = res.size();</span><br><span class="line">            <span class="keyword">int</span> x = max(a,max(b,c));</span><br><span class="line">            <span class="keyword">if</span>(x == a)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"aa"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'a'</span>;</span><br><span class="line">                    a--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(b,c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b == max(b,c))&#123;</span><br><span class="line">                        res += <span class="string">'b'</span>;</span><br><span class="line">                        b--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'c'</span>;</span><br><span class="line">                        c--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == b)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"bb"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'b'</span>;</span><br><span class="line">                    b--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(a,c) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a == max(a,c))&#123;</span><br><span class="line">                        res += <span class="string">'a'</span>;</span><br><span class="line">                        a--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'c'</span>;</span><br><span class="line">                        c--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x == c)&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; <span class="number">2</span> || res.substr(len<span class="number">-2</span>) != <span class="string">"cc"</span>)&#123;</span><br><span class="line">                    res += <span class="string">'c'</span>;</span><br><span class="line">                    c--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(max(a,b) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(a == max(a,b))&#123;</span><br><span class="line">                        res += <span class="string">'a'</span>;</span><br><span class="line">                        a--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        res += <span class="string">'b'</span>;</span><br><span class="line">                        b--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5379-石子游戏-III"><a href="#5379-石子游戏-III" class="headerlink" title="5379. 石子游戏 III"></a>5379. 石子游戏 III</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。</p><p>Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。</p><p>每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。</p><p>假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 “Alice” ，Bob 赢了就返回 “Bob”，平局（分数相同）返回 “Tie” 。</p><p>示例 1：</p><p>输入：values = [1,2,3,7]<br>输出：”Bob”<br>解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。</p><p>示例 2：</p><p>输入：values = [1,2,3,-9]<br>输出：”Alice”<br>解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。<br>如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。<br>如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。<br>注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。</p><p>示例 3：</p><p>输入：values = [1,2,3,6]<br>输出：”Tie”<br>解释：Alice 无法赢得比赛。如果她决定选择前三堆，她可以以平局结束比赛，否则她就会输。</p><p>示例 4：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="string">"Alice"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：values = [<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-3</span>]</span><br><span class="line">输出：<span class="string">"Tie"</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= values.length &lt;= 50000</code></li><li><code>-1000 &lt;= values[i] &lt;= 1000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/stone-game-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/stone-game-iii</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p>  动态规划  </p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>比较传统的题目，我们设立dp动态规划。<code>dp[i]</code>代表从<code>i</code>处进行游戏时，在最优策略下直到游戏结束时，自己所能取到的最多的石子的数目。<code>sum[i]</code>代表从i到n的石子的总的数目；</li><li>递推公式为：<script type="math/tex; mode=display">dp[i] = max\left\{\begin{aligned}\sum_{k = 0}^{0}stones[i+k] + sum[i+1] - dp[i+1] \\\sum_{k = 0}^{1}stones[i+k] + sum[i+2] - dp[i+2] \\\sum_{k = 0}^{2}stones[i+k] + sum[i+3] - dp[i+3] \\\end{aligned}\right.</script></li><li>我们倒序从最后的元素开始计算，设dp[n] = 0;我们在O(N)的时间复杂度内既可以求出结果。</li></ol></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">stoneGameIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stoneValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stoneValue.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>,INT_MIN);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) sum[i] = sum[i+<span class="number">1</span>] + stoneValue[i];</span><br><span class="line">      </span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i= n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n &amp;&amp; j &lt;= i + <span class="number">2</span>; j++)&#123;</span><br><span class="line">                curr += stoneValue[j];</span><br><span class="line">                dp[i] = max(dp[i],curr+sum[j+<span class="number">1</span>]-dp[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>] == sum[<span class="number">0</span>] - dp[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">"Tie"</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[<span class="number">0</span>] &gt; sum[<span class="number">0</span>] - dp[<span class="number">0</span>]) <span class="keyword">return</span> <span class="string">"Alice"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Bob"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;183周比赛&quot;&gt;&lt;a href=&quot;#183周比赛&quot; class=&quot;headerlink&quot; title=&quot;183周比赛&quot;&gt;&lt;/a&gt;183周比赛&lt;/h1&gt;&lt;p&gt;题目都比较简单，除了第三题稍微有点绕弯以外，其余的都比较简单。&lt;/p&gt;&lt;h2 id=&quot;5376-非递增顺序的最小子序列&quot;&gt;&lt;a href=&quot;#5376-非递增顺序的最小子序列&quot; class=&quot;headerlink&quot; title=&quot;5376. 非递增顺序的最小子序列&quot;&gt;&lt;/a&gt;5376. 非递增顺序的最小子序列&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt;，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。&lt;br&gt;如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。&lt;br&gt;与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。&lt;br&gt;注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>读书感想</title>
    <link href="http://yoursite.com/2020/04/01/143/"/>
    <id>http://yoursite.com/2020/04/01/143/</id>
    <published>2020-04-01T05:19:38.278Z</published>
    <updated>2020-04-01T05:19:48.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="少有人走的路"><a href="#少有人走的路" class="headerlink" title="少有人走的路"></a>少有人走的路</h3><p>最近自己一直在看关于心理方面和社会方面的书，越来越感慨好自己以往的过失与浪费生命。越来越想针对自身的错误来分析自身。<br>总结一下自己所犯的错误的原因如下：</p><h4 id="1-缺乏目标"><a href="#1-缺乏目标" class="headerlink" title="1.缺乏目标"></a>1.缺乏目标</h4><p>感慨自身缺乏目标的有内在的原因也有外在的原因。正是因为却反目标得人生导致了现在被动得自己，自己正所谓得随波逐流，本质上就是昏昏耗耗，其实许多周围人也不见得在这个问题上比自己做的更好，因为毕竟“现世太辛苦和匆忙”，能有时间和精力把健康、家庭、工作都兼顾好都已经非常不容易了，哪里还顾得上更远大得追求，所谓得人生活着得意义这种虚无缥缈得问题，更是少有人去思考。当然人类在进化过程中，进喜欢深度思考和做决策，毕竟深度思考和做决策都需要耗费极大的精力，承担极大的责任，冒着极大的风险，这是本身就是人类进化的结果导致，毕竟现世生活中越操心的人老的越快，反而那些什么都不思考的人活得最长寿。人类进化过程中少部分精英能够有极大的耐心，从内部打破这种依赖，深度去思考世界，思考社会。</p><a id="more"></a><ul><li>内在的原因是因为对自身不够自信，很少独立的去做自己的决定，做决定前害怕做错决定，殊不知人生中哪有会不做错误的决定，究其原因也是从小养成的习惯，从童年开始自己就是一个没有目标的人，做事情只想着做到最好，但没有明确的目标。包括高考，找工作，考研，结婚，买房。感觉人生中的几年大事似乎都是糊里糊涂的就过去了，从来没有认真的思考，这些工作，这些东西是否有过遵从自己的内心。当然了，虽然自己取得一定的成就，从偏远的农村出来，能够在大城市安身立命本身就是非常的不容易。但是时常回顾过往的三十几年，回想起来很多事情其实都过得糊里糊涂，虽然自我评价智商可以，但是很多更长远得目标并没有去实施。我想存在以上这些问题可能本身得出身有关，出身不易，大部分时间只顾的”眼前得苟且“，哪里还有时间去思考”远方得田野“。当然目标是生活稍微安定了以后，物质条件满足了以后，才有很多得闲暇时间来思考人生，来思考活着意义，来思考个人追求得价值观，正所谓得“饱暖思淫欲”吧，人的欲望总是随着周围得环境在不断放大。</li><li>外在得原因是没有进入一个更好的环境。周围人也绝大部分昏昏耗耗，找到志同道合得人已经非常难得，大毕竟大部分人都是普通人，哪有心思去思考人生的追求和意义。在这样物欲横流的社会，大部分都去谁随经济收入、房子、车子、名誉、地位了。有时候跟一些朋友探讨一些问题或者现象时，很少有人对这些话题感兴趣，毕竟大家都是俗人，吃饱饭、住大房子、开豪车、追求权力和地位，这才是最现实的需求。可能我自己觉得自身还是层次太低了，接触的真正的有目标有行动力的人群太少了，大都只能通过网上交流和认识一些网友。从自身来说，一直想跳出体制内这个圈子，不喜欢体制内这种氛围，大部分人都没啥追求的动力，都是安安稳稳的过日子，没有目标没有追求。当然，体制内对于普通人来说绝对时最好的选择，基本上一辈子不会有太大的风险，也不用费劲自己做决定和努力，只需要安安稳稳的过日子即可，一辈子虽不能大富大贵，但是大部分人身体健康，也没有失业的风险，但是自身的成就感太差，绝大分基层很少感受到自身存在的价值。在这种氛围下，时间长了人也会变得非常没有上进心，只想安安稳稳的混日子。所以非常需要一个良好的外部坏境来刺激自己进入到正循环。</li><li>解决办法：</li></ul><ol><li>每年定好自己的目标，每月定时公布自己的进度与进展。不要随意更改自己的目标。疫情过去了，终于可以正常上班了，计划用excel或者表格，定时在网上公布自己每天的进展和进度总结。只有日继月累才有成效。</li><li>今年要主动去寻求改变，改变自身和外部，希望能够跳出体制，找到一个更加让人上进的环境去奋斗。</li></ol><h4 id="2-缺乏自律"><a href="#2-缺乏自律" class="headerlink" title="2.缺乏自律"></a>2.缺乏自律</h4><p>只有自律的人生，才能有所成就和收获。现实社会中，能够真正做到自律的少之又少，我现在回想起来，自己真正进步最快的那段时光，第一段时间是在初二的时候，依稀还记得当时刚开始学习三角几何，那是一段让人充实而又难忘得自学时光。每天自己提前预习课本，每天自己定时自己得进度，每天回顾自身，回想起来那段时间也是自己进度最快得时候，完全凭借着自己得兴趣和热情，然而工作以来，很少再有这种冲动了。另外一段时光是自己考研的时候，每天自己安排生活，自己定好进度和目标，隔一天复习，那时候的自己是简单而又充实的，虽然物质生活过得很苦，但是精神上却非常满足。如今的社会中，诱惑太多，毕竟当自己</p><ul><li>自身的原因。还是对目标不够坚定，没有追求导致。只有心中有非常坚定的目标，才能坚持不懈的努力和追求。我想实际上真正投入后，工作带来的乐趣远大于游戏和娱乐的乐趣，因为工作带来的成就感会持久很长一段，而娱乐带来的快感只有一小段时间，而且长时间的娱乐和放松反而会给人带来浪费时间的愧疚感。</li><li>外界的原因。当前社会的诱惑太多，许多年轻人，包括我自己对于电子游戏、互联网媒体沉迷，长时间陷入不能自拔。这时一个很重要的问题所在，在所有容易收到诱惑的地方浪费了太多宝贵的时间，本来应该利用这些时间来锻炼身体，学习，陪伴关心家人，却都被自身浪费在了一些无所事事的社交媒体上，特别是疫情期间又无法外出，大家都憋在家中无所事事，只能通过社交媒体发泄自己的情绪和不满。每天尽量少看手机和微信，除工作必须以外，将手机使用时间控制在1个小时以内。这是非常重要的一个原因。</li><li>身体的原因。由于疫情期间不能正常外出作息，每天憋在家里，运动量严重不足，时间长了难免心里压抑，并且饮食结构严重不健康。希望快点能够恢复正常，恢复正常的活力，将身体养好。晚上睡觉前坚决不带手机到卧室，这样可以有效的改善自己晚睡的坏习惯。其实本来在武汉的疫情到来以前，晚睡的坏习惯早就改善了，可惜因为疫情的到来，严重的影响了自身的身体健康和作息习惯，要快速的调整过来。只有身心健康，一个人的心情才好，只有心情好，才能拥有事业的进步，才能拥有人生的选择权。</li><li>解决办法：</li></ul><ol><li>坚持锻炼身体。我想只有健康的体魄才是解决问题的根源。按照医学的统计，运动会促进体内的多巴胺的分泌，多巴胺会导致神经兴奋，这也是大多数人运动后心情愉快的根本原因。目前健身房还是没有开门，计划健身房开门后，还是坚持每周3-4次的游泳，每次半个小时。这点一定一定要坚持。</li><li>杜绝一切干扰自身的因素。坚持早上12点前，除非有重要事情，坚持不刷手机。退出所有不必要的微信群，QQ群。除了工作群和校友群以外，全部退出。因为绝大多数的群到了后期都是灌水，很少有真正有营养的东西值得自己去学习和交流，删除电脑上所有的电子游戏。所有不必要的微信公众号全部不再关注。晚上睡觉前坚决不带手机到卧室。</li><li>晚上10点30准时上床休息或看书，养成早睡早起的好习惯。</li><li>每天坚持早上到办公室做好一天的工作计划和安排。<h4 id="3-缺乏自信"><a href="#3-缺乏自信" class="headerlink" title="3.缺乏自信"></a>3.缺乏自信</h4>缺乏自信这个问题，我想跟自身的原生家庭有很大的影响，小时候形成的价值观太难改变了。从小父母给自己的感觉是父亲是个沉默寡言的老实人，顺从不会反抗。父亲做个好榜样其实对自身的影响非常大，很少做过让我们觉得骄傲的事情，依稀还记得小时候的自己又瘦又小，在整个村里面家庭条件都非常差，整天感觉家里面逆来顺受，很少因为这个家庭而感到骄傲。母亲那时候身体不好，时常生病，父亲总是唉声叹气，却很少主动想办法去解决问题，那时候给自己幼小的自己带来很多生活上的阴影。有时候回忆起来，感觉小时候家庭的负面影响太大了，有时候觉得自己读书读研，进入体制内能够到大城市定居真心不容易，历经的挫折和艰辛只有自己知道，这些从来很少跟父亲提到过一路走来的艰辛和不易，别人只看到你表面的光鲜，没看到你背后的努力和受到的委屈。</li></ol><ul><li>现在自己也当了父母了，时刻回忆起来自己小时候受到的挫折和鄙视。怎样给自己的下一代塑造一个健康和正面的心里非常重要，所以现在很少用负面消息去贬低自己的孩子，希望能够给他们正面的形象，让他们的童年能够真正的快乐和健康。每天晚上看着儿子和女儿两个小家伙开心的在床上蹦蹦跳跳的，觉得很知足。希望下一代能够不要再经历我们这一代的不幸。一代总比一代好。他们有着这么好的资源和生活条件，远比我们小时候幸福的多。</li></ul><h4 id="4-遵从自己得内心"><a href="#4-遵从自己得内心" class="headerlink" title="4. 遵从自己得内心"></a>4. 遵从自己得内心</h4><p>人到中年，就会越发感慨，见了许多的离别与生死。身边许多小时候的亲人一个接一个的走掉，人难免都会到达终点，开始思考人生的意义。人活着到底为了什么，怎么样活才能不白活一辈子。难得世上走一回，我觉得更应该要遵从自己的内心，活给自己看，自己活得开心才是最重要，整日的带着面具活着才是最没有意义的。所以以后对自己小孩的要求是千万不要从政，在体制内很少能够活出自己本来的面目，从上到小可能都需要带着面具活着。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;少有人走的路&quot;&gt;&lt;a href=&quot;#少有人走的路&quot; class=&quot;headerlink&quot; title=&quot;少有人走的路&quot;&gt;&lt;/a&gt;少有人走的路&lt;/h3&gt;&lt;p&gt;最近自己一直在看关于心理方面和社会方面的书，越来越感慨好自己以往的过失与浪费生命。越来越想针对自身的错误来分析自身。&lt;br&gt;总结一下自己所犯的错误的原因如下：&lt;/p&gt;&lt;h4 id=&quot;1-缺乏目标&quot;&gt;&lt;a href=&quot;#1-缺乏目标&quot; class=&quot;headerlink&quot; title=&quot;1.缺乏目标&quot;&gt;&lt;/a&gt;1.缺乏目标&lt;/h4&gt;&lt;p&gt;感慨自身缺乏目标的有内在的原因也有外在的原因。正是因为却反目标得人生导致了现在被动得自己，自己正所谓得随波逐流，本质上就是昏昏耗耗，其实许多周围人也不见得在这个问题上比自己做的更好，因为毕竟“现世太辛苦和匆忙”，能有时间和精力把健康、家庭、工作都兼顾好都已经非常不容易了，哪里还顾得上更远大得追求，所谓得人生活着得意义这种虚无缥缈得问题，更是少有人去思考。当然人类在进化过程中，进喜欢深度思考和做决策，毕竟深度思考和做决策都需要耗费极大的精力，承担极大的责任，冒着极大的风险，这是本身就是人类进化的结果导致，毕竟现世生活中越操心的人老的越快，反而那些什么都不思考的人活得最长寿。人类进化过程中少部分精英能够有极大的耐心，从内部打破这种依赖，深度去思考世界，思考社会。&lt;/p&gt;
    
    </summary>
    
    
      <category term="人生感悟" scheme="http://yoursite.com/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="《少有人走得路》" scheme="http://yoursite.com/tags/%E3%80%8A%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E5%BE%97%E8%B7%AF%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 182周比赛</title>
    <link href="http://yoursite.com/2020/03/31/142/"/>
    <id>http://yoursite.com/2020/03/31/142/</id>
    <published>2020-03-31T06:10:48.236Z</published>
    <updated>2020-04-01T07:51:04.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="182周比赛"><a href="#182周比赛" class="headerlink" title="182周比赛"></a>182周比赛</h1><p>前三题都是暴力，最后一题比较难</p><h2 id="5368-找出数组中的幸运数"><a href="#5368-找出数组中的幸运数" class="headerlink" title="5368. 找出数组中的幸运数"></a>5368. 找出数组中的幸运数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p><p>给你一个整数数组 <code>arr</code>，请你从中找出并返回一个幸运数。</p><p>如果数组中存在多个幸运数，只需返回 最大 的那个。<br>如果数组中不含幸运数，则返回 -1 。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：数组中唯一的幸运数是 <span class="number">2</span> ，因为数值 <span class="number">2</span> 的出现频次也是 <span class="number">2</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：<span class="number">1</span>、<span class="number">2</span> 以及 <span class="number">3</span> 都是幸运数，只需要返回其中最大的 <span class="number">3</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：数组中不存在幸运数。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>1 &lt;= arr[i] &lt;= 500</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-lucky-integer-in-an-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-lucky-integer-in-an-array</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>幸运数即出现的次数于数目本身相等，直接暴力统计数目的次数即可<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : arr)&#123;</span><br><span class="line">            cnt[a]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.first == e.second)&#123;</span><br><span class="line">                res = e.first;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5369-统计作战单位数"><a href="#5369-统计作战单位数" class="headerlink" title="5369. 统计作战单位数"></a>5369. 统计作战单位数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><code>n</code>名士兵站成一排。每个士兵都有一个 独一无二 的评分 <code>rating</code>。</p><p>每 3 个士兵可以组成一个作战单位，分组规则如下：</p><ul><li>从队伍中选出下标分别为<code>i、j、k</code> 的 3 名士兵，他们的评分分别为 `rating[i]、rating[j]、rating[k]``</li><li>作战单位需满足： <code>rating[i] &lt; rating[j] &lt; rating[k]</code>或者 <code>rating[i] &gt; rating[j] &gt; rating[k]</code>，其中 <code>0 &lt;= i &lt; j &lt; k &lt; n</code><br>请你返回按上述条件可以组建的作战单位数量。每个士兵都可以是多个作战单位的一部分。</li></ul><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rating = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：我们可以组建三个作战单位 (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)、(<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>)、(<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>) 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rating = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：根据题目条件，我们无法组建作战单位。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rating = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>n == rating.length</code></li><li><code>1 &lt;= n &lt;= 200</code></li><li><code>1 &lt;= rating[i] &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/count-number-of-teams" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-number-of-teams</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 数据量很小，直接暴力即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力三次循环，直接就可以算出来</li><li>稍微用点技巧O(n^2)。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rating.size() &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rating.size()<span class="number">-2</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; rating.size()<span class="number">-1</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &lt; rating.size(); ++k)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(rating[i] &gt; rating[j] &amp;&amp; rating[j] &gt; rating[k])</span><br><span class="line">                        res++;</span><br><span class="line">                    <span class="keyword">if</span>(rating[i] &lt; rating[j] &amp;&amp; rating[j] &lt; rating[k])</span><br><span class="line">                        res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTeams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = rating.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n <span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> l1 = <span class="number">0</span>,r1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> l2 = <span class="number">0</span>,r2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rating[j] &lt; rating[i])&#123;</span><br><span class="line">                    l1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rating[j] &gt; rating[i])&#123;</span><br><span class="line">                    l2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(rating[j] &gt; rating[i])&#123;</span><br><span class="line">                    r1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rating[j] &lt; rating[i])&#123;</span><br><span class="line">                    r2++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += l1*r1;</span><br><span class="line">            res += l2*r2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5370-设计地铁系统"><a href="#5370-设计地铁系统" class="headerlink" title="5370. 设计地铁系统"></a>5370. 设计地铁系统</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>请你实现一个类 <code>UndergroundSystem</code>，它支持以下 3 种方法：</p><ol><li><code>checkIn(int id, string stationName, int t)</code></li></ol><ul><li>编号为 id 的乘客在 t 时刻进入地铁站 <code>stationName</code> 。</li><li>一个乘客在同一时间只能在一个地铁站进入或者离开。</li></ul><ol><li><code>checkOut(int id, string stationName, int t)</code></li></ol><ul><li>编号为 id 的乘客在 t 时刻离开地铁站 <code>stationName</code>。</li></ul><ol><li><code>getAverageTime(string startStation, string endStation)</code> </li></ol><ul><li>返回从地铁站 <code>startStation</code> 到地铁站<code>endStation</code> 的平均花费时间。</li><li>平均时间计算的行程包括当前为止所有从 <code>startStation</code> 直接到达<code>endStation</code> 的行程。</li><li>调用<code>getAverageTime</code> 时，询问的路线至少包含一趟行程。<br>你可以假设所有对<code>checkIn</code> 和 <code>checkOut</code>的调用都是符合逻辑的。也就是说，如果一个顾客在 t1 时刻到达某个地铁站，那么他离开的时间 t2 一定满足 t2 &gt; t1 。所有的事件都按时间顺序给出。</li></ul><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"UndergroundSystem"</span>,<span class="string">"checkIn"</span>,<span class="string">"checkIn"</span>,<span class="string">"checkIn"</span>,<span class="string">"checkOut"</span>,<span class="string">"checkOut"</span>,<span class="string">"checkOut"</span>,<span class="string">"getAverageTime"</span>,<span class="string">"getAverageTime"</span>,<span class="string">"checkIn"</span>,<span class="string">"getAverageTime"</span>,<span class="string">"checkOut"</span>,<span class="string">"getAverageTime"</span>]</span><br><span class="line">[[],[<span class="number">45</span>,<span class="string">"Leyton"</span>,<span class="number">3</span>],[<span class="number">32</span>,<span class="string">"Paradise"</span>,<span class="number">8</span>],[<span class="number">27</span>,<span class="string">"Leyton"</span>,<span class="number">10</span>],[<span class="number">45</span>,<span class="string">"Waterloo"</span>,<span class="number">15</span>],[<span class="number">27</span>,<span class="string">"Waterloo"</span>,<span class="number">20</span>],[<span class="number">32</span>,<span class="string">"Cambridge"</span>,<span class="number">22</span>],[<span class="string">"Paradise"</span>,<span class="string">"Cambridge"</span>],[<span class="string">"Leyton"</span>,<span class="string">"Waterloo"</span>],[<span class="number">10</span>,<span class="string">"Leyton"</span>,<span class="number">24</span>],[<span class="string">"Leyton"</span>,<span class="string">"Waterloo"</span>],[<span class="number">10</span>,<span class="string">"Waterloo"</span>,<span class="number">38</span>],[<span class="string">"Leyton"</span>,<span class="string">"Waterloo"</span>]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,null,null,null,<span class="number">14.0</span>,<span class="number">11.0</span>,null,<span class="number">11.0</span>,null,<span class="number">12.0</span>]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">UndergroundSystem undergroundSystem = new UndergroundSystem();</span><br><span class="line">undergroundSystem.checkIn(<span class="number">45</span>, <span class="string">"Leyton"</span>, <span class="number">3</span>);</span><br><span class="line">undergroundSystem.checkIn(<span class="number">32</span>, <span class="string">"Paradise"</span>, <span class="number">8</span>);</span><br><span class="line">undergroundSystem.checkIn(<span class="number">27</span>, <span class="string">"Leyton"</span>, <span class="number">10</span>);</span><br><span class="line">undergroundSystem.checkOut(<span class="number">45</span>, <span class="string">"Waterloo"</span>, <span class="number">15</span>);</span><br><span class="line">undergroundSystem.checkOut(<span class="number">27</span>, <span class="string">"Waterloo"</span>, <span class="number">20</span>);</span><br><span class="line">undergroundSystem.checkOut(<span class="number">32</span>, <span class="string">"Cambridge"</span>, <span class="number">22</span>);</span><br><span class="line">undergroundSystem.getAverageTime(<span class="string">"Paradise"</span>, <span class="string">"Cambridge"</span>);       <span class="comment">// 返回 14.0。从 "Paradise"（时刻 8）到 "Cambridge"(时刻 22)的行程只有一趟</span></span><br><span class="line">undergroundSystem.getAverageTime(<span class="string">"Leyton"</span>, <span class="string">"Waterloo"</span>);          <span class="comment">// 返回 11.0。总共有 2 躺从 "Leyton" 到 "Waterloo" 的行程，编号为 id=45 的乘客出发于 time=3 到达于 time=15，编号为 id=27 的乘客于 time=10 出发于 time=20 到达。所以平均时间为 ( (15-3) + (20-10) ) / 2 = 11.0</span></span><br><span class="line">undergroundSystem.checkIn(<span class="number">10</span>, <span class="string">"Leyton"</span>, <span class="number">24</span>);</span><br><span class="line">undergroundSystem.getAverageTime(<span class="string">"Leyton"</span>, <span class="string">"Waterloo"</span>);          <span class="comment">// 返回 11.0</span></span><br><span class="line">undergroundSystem.checkOut(<span class="number">10</span>, <span class="string">"Waterloo"</span>, <span class="number">38</span>);</span><br><span class="line">undergroundSystem.getAverageTime(<span class="string">"Leyton"</span>, <span class="string">"Waterloo"</span>);          <span class="comment">// 返回 12.0</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>总共最多有 <code>20000</code> 次操作。</li><li><code>1 &lt;= id, t &lt;= 10^6</code></li><li>所有的字符串包含大写字母，小写字母和数字。</li><li><code>1 &lt;= stationName.length &lt;= 10</code></li><li>与标准答案误差在<code>10^-5</code> 以内的结果都视为正确结果。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/design-underground-system" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-underground-system</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 系统设计题目</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>系统设计题目本身很简单，本周的5分钟就搞定了。没有涉及到太多技巧的东西。</li><li>存储每个人的进站信息，<code>checkout</code>时计算该人的花费的时间。并将该人的花费时间加入到统计信息中。</li><li>每次获取平均时间时，直接用耗费的总时间除以总人数。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UndergroundSystem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    UndergroundSystem() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        getIn[id] = make_pair(stationName,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkOut</span><span class="params">(<span class="keyword">int</span> id, <span class="built_in">string</span> stationName, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p = <span class="keyword">this</span>-&gt;getIn[id];</span><br><span class="line">        <span class="keyword">int</span> cost = t - p.second;</span><br><span class="line">        <span class="built_in">string</span> key = p.first + <span class="string">":"</span> + stationName;</span><br><span class="line">        count[key]++;</span><br><span class="line">        sum[key] += cost;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getAverageTime</span><span class="params">(<span class="built_in">string</span> startStation, <span class="built_in">string</span> endStation)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> key = startStation + <span class="string">":"</span> + endStation;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">double</span>(sum[key])/count[key];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; count;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; sum;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; getIn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your UndergroundSystem object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * UndergroundSystem* obj = new UndergroundSystem();</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkIn(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * obj-&gt;checkOut(id,stationName,t);</span></span><br><span class="line"><span class="comment"> * double param_3 = obj-&gt;getAverageTime(startStation,endStation);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="5371-找到所有好字符串"><a href="#5371-找到所有好字符串" class="headerlink" title="5371. 找到所有好字符串"></a>5371. 找到所有好字符串</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你两个长度为 n 的字符串 s1 和 s2 ，以及一个字符串<code>evil</code> 。请你返回 好字符串 的数目。</p><p>好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 s2 ，且不包含 <code>evil</code>为子字符串。</p><p>由于答案可能很大，请你返回答案对 <code>10^9 + 7</code>取余的结果。</p><p>示例 1：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, s1 = <span class="string">"aa"</span>, s2 = <span class="string">"da"</span>, evil = <span class="string">"b"</span></span><br><span class="line">输出：<span class="number">51</span> </span><br><span class="line">解释：总共有 <span class="number">25</span> 个以 <span class="string">'a'</span> 开头的好字符串：<span class="string">"aa"</span>，<span class="string">"ac"</span>，<span class="string">"ad"</span>，<span class="params">...</span>，<span class="string">"az"</span>。还有 <span class="number">25</span> 个以 <span class="string">'c'</span> 开头的好字符串：<span class="string">"ca"</span>，<span class="string">"cc"</span>，<span class="string">"cd"</span>，<span class="params">...</span>，<span class="string">"cz"</span>。最后，还有一个以 <span class="string">'d'</span> 开头的好字符串：<span class="string">"da"</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">8</span>, <span class="built_in">s1</span> = <span class="string">"leetcode"</span>, <span class="built_in">s2</span> = <span class="string">"leetgoes"</span>, evil = <span class="string">"leet"</span></span><br><span class="line">输出：<span class="number">0</span> </span><br><span class="line">解释：所有字典序大于等于 <span class="built_in">s1</span> 且小于等于 <span class="built_in">s2</span> 的字符串都以 evil 字符串 <span class="string">"leet"</span> 开头。所以没有好字符串。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">n</span> = <span class="number">2</span>, <span class="attr">s1</span> = <span class="string">"gx"</span>, <span class="attr">s2</span> = <span class="string">"gz"</span>, <span class="attr">evil</span> = <span class="string">"x"</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>s1.length == n</code></li><li><code>s2.length == n</code></li><li><code>1 &lt;= n &lt;= 500</code></li><li><code>1 &lt;= evil.length &lt;= 50</code></li><li>所有字符串都只包含小写英文字母。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-all-good-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-good-strings</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3></blockquote><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1000000007</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt[<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">505</span>][<span class="number">55</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">55</span>][<span class="number">27</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subp</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span>&amp; s, <span class="built_in">string</span>&amp; e)</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">int</span> l = e.length();</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; l; ++t)&#123;</span><br><span class="line">                    f[i][fd[t][j]][<span class="number">0</span>] = (f[i][fd[t][j]][<span class="number">0</span>] + f[i - <span class="number">1</span>][t][<span class="number">0</span>]) % M;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; s[i - <span class="number">1</span>] - <span class="string">'a'</span>)</span><br><span class="line">                        f[i][fd[t][j]][<span class="number">0</span>] = (f[i][fd[t][j]][<span class="number">0</span>] + f[i - <span class="number">1</span>][t][<span class="number">1</span>]) % M;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (j == s[i - <span class="number">1</span>] - <span class="string">'a'</span>)</span><br><span class="line">                        f[i][fd[t][j]][<span class="number">1</span>] = (f[i][fd[t][j]][<span class="number">1</span>] + f[i - <span class="number">1</span>][t][<span class="number">1</span>]) % M;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l; ++j)&#123;</span><br><span class="line">            res = (res + f[n][j][<span class="number">0</span>]) % M;</span><br><span class="line">            res = (res + f[n][j][<span class="number">1</span>]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findGoodStrings</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> s1, <span class="built_in">string</span> s2, <span class="built_in">string</span> evil)</span> </span>&#123;</span><br><span class="line">        nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = evil.size();</span><br><span class="line">        <span class="comment">// 构造 next 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>, i = <span class="number">1</span>; i &lt; l; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">-1</span> &amp;&amp; evil[i] != evil[j + <span class="number">1</span>])</span><br><span class="line">                j = nxt[j];</span><br><span class="line">            <span class="keyword">if</span> (evil[i] == evil[j + <span class="number">1</span>])</span><br><span class="line">                nxt[i] = ++j;</span><br><span class="line">            <span class="keyword">else</span> nxt[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算失配转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; l - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (evil[i + <span class="number">1</span>] - <span class="string">'a'</span> == j)</span><br><span class="line">                    fd[i + <span class="number">1</span>][j] = i + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">-1</span>) fd[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> fd[i + <span class="number">1</span>][j] = fd[nxt[i] + <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res1 = subp(n, s2, evil), res2 = subp(n, s1, evil);</span><br><span class="line">        <span class="keyword">int</span> ans = (res1 + M - res2) % M;</span><br><span class="line">        <span class="comment">// 补一个 check</span></span><br><span class="line">        <span class="keyword">if</span> (s1.find(evil) == <span class="built_in">string</span>::npos) </span><br><span class="line">            ans = (ans + <span class="number">1</span>) % M;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;182周比赛&quot;&gt;&lt;a href=&quot;#182周比赛&quot; class=&quot;headerlink&quot; title=&quot;182周比赛&quot;&gt;&lt;/a&gt;182周比赛&lt;/h1&gt;&lt;p&gt;前三题都是暴力，最后一题比较难&lt;/p&gt;&lt;h2 id=&quot;5368-找出数组中的幸运数&quot;&gt;&lt;a href=&quot;#5368-找出数组中的幸运数&quot; class=&quot;headerlink&quot; title=&quot;5368. 找出数组中的幸运数&quot;&gt;&lt;/a&gt;5368. 找出数组中的幸运数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。&lt;/p&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;arr&lt;/code&gt;，请你从中找出并返回一个幸运数。&lt;/p&gt;&lt;p&gt;如果数组中存在多个幸运数，只需返回 最大 的那个。&lt;br&gt;如果数组中不含幸运数，则返回 -1 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 181周双周赛</title>
    <link href="http://yoursite.com/2020/03/25/141/"/>
    <id>http://yoursite.com/2020/03/25/141/</id>
    <published>2020-03-25T15:30:35.080Z</published>
    <updated>2020-03-31T02:15:05.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="181周双周比赛"><a href="#181周双周比赛" class="headerlink" title="181周双周比赛"></a>181周双周比赛</h1><p>周赛题目稍微好点</p><h2 id="5364-按既定顺序创建目标数组"><a href="#5364-按既定顺序创建目标数组" class="headerlink" title="5364. 按既定顺序创建目标数组"></a>5364. 按既定顺序创建目标数组</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数数组 <code>nums</code>和<code>index</code>。你需要按照以下规则创建目标数组：</p><p>目标数组<code>target</code> 最初为空。<br>按从左到右的顺序依次读取 <code>nums[i]</code>和 <code>index[i]</code>，在<code>target</code> 数组中的下标 <code>index[i]</code> 处插入值 <code>nums[i]</code> 。<br>重复上一步，直到在 <code>nums</code> 和 <code>index</code>中都没有要读取的元素。<br>请你返回目标数组。</p><a id="more"></a><p>题目保证数字插入位置总是存在。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line"><span class="number">0</span>            <span class="number">0</span>        [<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span>            <span class="number">1</span>        [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span>            <span class="number">2</span>        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">3</span>            <span class="number">2</span>        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">4</span>            <span class="number">1</span>        [<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">0</span>], index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">nums       index     target</span><br><span class="line"><span class="number">1</span>            <span class="number">0</span>        [<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span>            <span class="number">1</span>        [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="number">3</span>            <span class="number">2</span>        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">4</span>            <span class="number">3</span>        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">0</span>            <span class="number">0</span>        [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = <span class="string">[1]</span>, index = <span class="string">[0]</span></span><br><span class="line">输出：<span class="string">[1]</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li><li><code>nums.length == index.length</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li><li><code>0 &lt;= index[i] &lt;= i</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-decreasing-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 类似于插入排序</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>需要向后移动数组<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; createTargetArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; index) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[index[i]] == <span class="number">-1</span>)&#123;</span><br><span class="line">                res[index[i]] = nums[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = index[i]; nums[i] != <span class="number">-1</span> &amp;&amp; j &lt; n; ++j)&#123;</span><br><span class="line">                swap(nums[i],res[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5350-将整数按权重排序"><a href="#5350-将整数按权重排序" class="headerlink" title="5350. 将整数按权重排序"></a>5350. 将整数按权重排序</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：</p><ul><li>如果 x 是偶数，那么 x = x / 2<br>如果 x 是奇数，那么 x = 3 * x + 1<br>比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 —&gt; 10 —&gt; 5 —&gt; 16 —&gt; 8 —&gt; 4 —&gt; 2 —&gt; 1）。</li></ul><p>给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。</p><p>请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。</p><p>注意，题目保证对于任意整数 x （lo &lt;= x &lt;= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：lo = <span class="number">12</span>, hi = <span class="number">15</span>, k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：<span class="number">12</span> 的权重为 <span class="number">9</span>（<span class="number">12</span> --&gt; <span class="number">6</span> --&gt; <span class="number">3</span> --&gt; <span class="number">10</span> --&gt; <span class="number">5</span> --&gt; <span class="number">16</span> --&gt; <span class="number">8</span> --&gt; <span class="number">4</span> --&gt; <span class="number">2</span> --&gt; <span class="number">1</span>）</span><br><span class="line"><span class="number">13</span> 的权重为 <span class="number">9</span></span><br><span class="line"><span class="number">14</span> 的权重为 <span class="number">17</span></span><br><span class="line"><span class="number">15</span> 的权重为 <span class="number">17</span></span><br><span class="line">区间内的数按权重排序以后的结果为 [<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>] 。对于 k = <span class="number">2</span> ，答案是第二个整数也就是 <span class="number">13</span> 。</span><br><span class="line">注意，<span class="number">12</span> 和 <span class="number">13</span> 有相同的权重，所以我们按照它们本身升序排序。<span class="number">14</span> 和 <span class="number">15</span> 同理。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lo = <span class="number">1</span>, hi = <span class="number">1</span>, k = <span class="number">1</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：lo = <span class="number">7</span>, hi = <span class="number">11</span>, k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">7</span></span><br><span class="line">解释：区间内整数 [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>] 对应的权重为 [<span class="number">16</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">6</span>, <span class="number">14</span>] 。</span><br><span class="line">按权重排序后得到的结果为 [<span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">9</span>] 。</span><br><span class="line">排序后数组中第 <span class="number">4</span> 个数字为 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lo = <span class="number">10</span>, hi = <span class="number">20</span>, k = <span class="number">5</span></span><br><span class="line">输出：<span class="number">13</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lo = <span class="number">1</span>, hi = <span class="number">1000</span>, k = <span class="number">777</span></span><br><span class="line">输出：<span class="number">570</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= lo &lt;= hi &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= hi - lo + 1</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/sort-integers-by-the-power-value/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-integers-by-the-power-value/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力求权重即可</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>递归求权重即可，也没啥技巧。<br>2。 当然也可以用map保存表项记录，方便查找。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">weight</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(num%<span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + weight(num/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + weight(num*<span class="number">3</span>+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKth</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; ++i)&#123;</span><br><span class="line">            w.push_back(make_pair(weight(i),i));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(w.begin(),w.end(),cmp);</span><br><span class="line">        <span class="keyword">return</span> w[k<span class="number">-1</span>].second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5366-检查网格中是否存在有效路径"><a href="#5366-检查网格中是否存在有效路径" class="headerlink" title="5366. 检查网格中是否存在有效路径"></a>5366. 检查网格中是否存在有效路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：</p><p>1 表示连接左单元格和右单元格的街道。<br>2 表示连接上单元格和下单元格的街道。<br>3 表示连接左单元格和下单元格的街道。<br>4 表示连接右单元格和下单元格的街道。<br>5 表示连接左单元格和上单元格的街道。<br>6 表示连接右单元格和上单元格的街道。</p><p>你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。</p><p>注意：你 不能 变更街道。</p><p>如果网格中存在有效的路径，则返回 true，否则返回 false 。</p><p>示例 1：</p><p>输入：grid = [[2,4,3],[6,5,2]]<br>输出：true<br>解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。<br>示例 2：</p><p>输入：grid = [[1,2,1],[1,2,1]]<br>输出：false<br>解释：如图所示，单元格 (0, 0) 上的街道没有与任何其他单元格上的街道相连，你只会停在 (0, 0) 处。<br>示例 3：</p><p>输入：grid = [[1,1,2]]<br>输出：false<br>解释：你会停在 (0, 1)，而且无法到达 (0, 2) 。<br>示例 4：</p><p>输入：grid = [[1,1,1,1,1,1,3]]<br>输出：true<br>示例 5：</p><p>输入：grid = [[2],[2],[2],[2],[2],[2],[6]]<br>输出：true</p><p>提示：</p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>1 &lt;= grid[i][j] &lt;= 6</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 图的搜索问题</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>最基本的图的搜索问题，基本上BFS或者DFS均可以解决该问题。</li><li>题目本身不难，但是需要把代码写的容易且不出错还是需要一点基本功。</li><li>假设4个方向，分别用0，1，2，3表示左右上下四个方向，设立next数目，<code>next[i][j]</code>表示以第<code>i</code>种方向进入第<code>j</code>种类型的表格后的路径方向，如果<code>next[i][j] = -1</code>则表示从这个方向无法进入该表格。比如：<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">next[<span class="string">0</span>][<span class="symbol">1</span>] = 0表示从右侧进入第1种类型的单元格后的后续方向也为从左到右。</span><br></pre></td></tr></table></figure></li><li>我们采用<code>BFS</code>解法。初始化时，单元格<code>0</code>可以接受两种方向，这个时本题的一个<code>corner</code>,稍微复杂点。我们每次需要判断队列中的元素是否可以进入。每次传递两个元素，方向和单元格的坐标。</li></ol></blockquote><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValidPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visit(row,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">4</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">memset</span>(next,<span class="number">-1</span>,<span class="keyword">sizeof</span>(next));</span><br><span class="line">        <span class="comment">/*left*/</span></span><br><span class="line">        next[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>][<span class="number">4</span>] = <span class="number">3</span>;</span><br><span class="line">        next[<span class="number">0</span>][<span class="number">6</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*right*/</span></span><br><span class="line">        next[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        next[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        next[<span class="number">1</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/*up*/</span></span><br><span class="line">        next[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        next[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">2</span>][<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*down*/</span></span><br><span class="line">        next[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">        next[<span class="number">3</span>][<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">3</span>][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(next[i][grid[<span class="number">0</span>][<span class="number">0</span>]]!= <span class="number">-1</span>)&#123;</span><br><span class="line">                qu.push(make_pair(i,<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> cd = qu.front().first;</span><br><span class="line">            <span class="keyword">int</span> cx = qu.front().second/col;</span><br><span class="line">            <span class="keyword">int</span> cy = qu.front().second%col;</span><br><span class="line">            qu.pop();</span><br><span class="line">            <span class="keyword">if</span>(next[cd][grid[cx][cy]] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cx == row<span class="number">-1</span> &amp;&amp; cy == col<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> nd = next[cd][grid[cx][cy]];</span><br><span class="line">            <span class="keyword">int</span> nx = cx + d[nd][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> ny = cy + d[nd][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx &lt; <span class="number">0</span> || nx &gt;= row || ny &lt; <span class="number">0</span> || ny &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            qu.push(make_pair(nd,nx*col+ny));</span><br><span class="line">            visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5367-最长快乐前缀"><a href="#5367-最长快乐前缀" class="headerlink" title="5367. 最长快乐前缀"></a>5367. 最长快乐前缀</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。</p><p>给你一个字符串 s，请你返回它的 最长快乐前缀。</p><p>如果不存在满足题意的前缀，则返回一个空字符串。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"level"</span></span><br><span class="line">输出：<span class="string">"l"</span></span><br><span class="line">解释：不包括 s 自己，一共有 <span class="number">4</span> 个前缀（<span class="string">"l"</span>, <span class="string">"le"</span>, <span class="string">"lev"</span>, <span class="string">"leve"</span>）和 <span class="number">4</span> 个后缀（<span class="string">"l"</span>, <span class="string">"el"</span>, <span class="string">"vel"</span>, <span class="string">"evel"</span>）。最长的既是前缀也是后缀的字符串是 <span class="string">"l"</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">``</span>s = <span class="string">"ababab"</span></span><br><span class="line">输出：<span class="string">"abab"</span></span><br><span class="line">解释：<span class="string">"abab"</span> 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcodeleet"</span></span><br><span class="line">输出：<span class="string">"leet"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"a"</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s 只含有小写英文字母</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-happy-prefix/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> KMP或者字符串KR hash算法</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>KMP算法，求next数组。</li><li>KR 字符串hash算法。这个是本身看到该题就想到用这个算法。KR hash算法在字符串种非常有用的一个算法，需要去重点掌握这个算法的应用。<br>对于字符串我们可以压缩用一个hash函数表示。非常容易。对于<code>base</code>和<code>mod</code>的应用，特别是求子串的hash函数，另外我们加一个判断，可以防止字符串hash之后出现冲突的判断，我认为这是一个在实际工程项目种也是非常应用很广的一个算法。</li><li>KMP字符串匹配算法。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Base = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">string</span> &amp; s,<span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> d = s.size()-l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[i+d]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; h(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; p(n+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            h[i+<span class="number">1</span>] = (h[i]*Base + s[i])%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            p[i+<span class="number">1</span>] = (p[i]*Base)%Mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> get = [&amp;](<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">return</span> (h[y] - h[x<span class="number">-1</span>]*p[y-x+<span class="number">1</span>]%Mod + Mod)%Mod;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(get(i,n) == h[n-i+<span class="number">1</span>]&amp;&amp;check(s,n-i+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> s.substr(<span class="number">0</span>,n-i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPrefix</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next(n,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(k &gt; <span class="number">0</span> &amp;&amp; s[i] != s[k]) k = next[k<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[k] == s[i]) next[i] = ++k;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> s.substr(n-next[n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;181周双周比赛&quot;&gt;&lt;a href=&quot;#181周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;181周双周比赛&quot;&gt;&lt;/a&gt;181周双周比赛&lt;/h1&gt;&lt;p&gt;周赛题目稍微好点&lt;/p&gt;&lt;h2 id=&quot;5364-按既定顺序创建目标数组&quot;&gt;&lt;a href=&quot;#5364-按既定顺序创建目标数组&quot; class=&quot;headerlink&quot; title=&quot;5364. 按既定顺序创建目标数组&quot;&gt;&lt;/a&gt;5364. 按既定顺序创建目标数组&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数数组 &lt;code&gt;nums&lt;/code&gt;和&lt;code&gt;index&lt;/code&gt;。你需要按照以下规则创建目标数组：&lt;/p&gt;&lt;p&gt;目标数组&lt;code&gt;target&lt;/code&gt; 最初为空。&lt;br&gt;按从左到右的顺序依次读取 &lt;code&gt;nums[i]&lt;/code&gt;和 &lt;code&gt;index[i]&lt;/code&gt;，在&lt;code&gt;target&lt;/code&gt; 数组中的下标 &lt;code&gt;index[i]&lt;/code&gt; 处插入值 &lt;code&gt;nums[i]&lt;/code&gt; 。&lt;br&gt;重复上一步，直到在 &lt;code&gt;nums&lt;/code&gt; 和 &lt;code&gt;index&lt;/code&gt;中都没有要读取的元素。&lt;br&gt;请你返回目标数组。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 22周双周赛</title>
    <link href="http://yoursite.com/2020/03/25/140/"/>
    <id>http://yoursite.com/2020/03/25/140/</id>
    <published>2020-03-25T15:30:25.681Z</published>
    <updated>2020-03-25T15:30:48.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22周双周比赛"><a href="#22周双周比赛" class="headerlink" title="22周双周比赛"></a>22周双周比赛</h1><p>题目质量一般般，除了最后一题以外，其余的都是暴力即可。</p><h2 id="5348-两个数组间的距离值"><a href="#5348-两个数组间的距离值" class="headerlink" title="5348. 两个数组间的距离值"></a>5348. 两个数组间的距离值</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你两个整数数组 <code>arr1</code>， <code>arr2</code> 和一个整数 <code>d</code> ，请你返回两个数组之间的 距离值 。</p><p>「距离值」 定义为符合此描述的元素数目：对于元素<code>arr1[i]</code> ，不存在任何元素 <code>arr2[j]</code>满足 <code>|arr1[i]-arr2[j]| &lt;= d</code>。</p><a id="more"></a><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>], arr2 = [<span class="number">10</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>], d = <span class="number">2</span></span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：</span><br><span class="line">对于 arr1[<span class="number">0</span>]=<span class="number">4</span> 我们有：</span><br><span class="line">|<span class="number">4</span><span class="number">-10</span>|=<span class="number">6</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">4</span><span class="number">-9</span>|=<span class="number">5</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">4</span><span class="number">-1</span>|=<span class="number">3</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">4</span><span class="number">-8</span>|=<span class="number">4</span> &gt; d=<span class="number">2</span> </span><br><span class="line">对于 arr1[<span class="number">1</span>]=<span class="number">5</span> 我们有：</span><br><span class="line">|<span class="number">5</span><span class="number">-10</span>|=<span class="number">5</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">5</span><span class="number">-9</span>|=<span class="number">4</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">5</span><span class="number">-1</span>|=<span class="number">4</span> &gt; d=<span class="number">2</span> </span><br><span class="line">|<span class="number">5</span><span class="number">-8</span>|=<span class="number">3</span> &gt; d=<span class="number">2</span></span><br><span class="line">对于 arr1[<span class="number">2</span>]=<span class="number">8</span> 我们有：</span><br><span class="line">|<span class="number">8</span><span class="number">-10</span>|=<span class="number">2</span> &lt;= d=<span class="number">2</span></span><br><span class="line">|<span class="number">8</span><span class="number">-9</span>|=<span class="number">1</span> &lt;= d=<span class="number">2</span></span><br><span class="line">|<span class="number">8</span><span class="number">-1</span>|=<span class="number">7</span> &gt; d=<span class="number">2</span></span><br><span class="line">|<span class="number">8</span><span class="number">-8</span>|=<span class="number">0</span> &lt;= d=<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [<span class="number">-4</span>,<span class="number">-3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], d = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">100</span>,<span class="number">3</span>], arr2 = [<span class="number">-5</span>,<span class="number">-2</span>,<span class="number">10</span>,<span class="number">-3</span>,<span class="number">7</span>], d = <span class="number">6</span></span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>1 &lt;= arr1.length, arr2.length &lt;= 500</code></li><li><code>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</code></li><li><code>0 &lt;= d &lt;= 100</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-decreasing-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力解决即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>暴力计算即可，时间复杂度O（n^2)。</li><li>二分查找即可，查找距离最近的d。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheDistanceValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">bool</span> isCan = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr2.size(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(arr1[i]-arr2[j]) &lt;= d)&#123;</span><br><span class="line">                    isCan = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isCan) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5178-四因数"><a href="#5178-四因数" class="headerlink" title="5178. 四因数"></a>5178. 四因数</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你返回该数组中恰有四个因数的这些整数的各因数之和。</p><p>如果数组中不存在满足题意的整数，则返回 0 。</p><p>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [<span class="number">21</span>,<span class="number">4</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">32</span></span><br><span class="line">解释：</span><br><span class="line"><span class="number">21</span> 有 <span class="number">4</span> 个因数：<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">21</span></span><br><span class="line"><span class="number">4</span> 有 <span class="number">3</span> 个因数：<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span></span><br><span class="line"><span class="number">7</span> 有 <span class="number">2</span> 个因数：<span class="number">1</span>, <span class="number">7</span></span><br><span class="line">答案仅为 <span class="number">21</span> 的所有因数的和。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/four-divisors/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/four-divisors/</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力求因素</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>不知道这个题目想考什么，直接暴力计算数的因子数目即可。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FourDivsors</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">sqrt</span>(num);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = num+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; x; ++i )&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%i == <span class="number">0</span> )&#123;</span><br><span class="line">                cnt += <span class="number">2</span>;</span><br><span class="line">                res += i;</span><br><span class="line">                res += (num/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumFourDivisors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)&#123;</span><br><span class="line">            sum += FourDivsors(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5349-安排电影院座位"><a href="#5349-安排电影院座位" class="headerlink" title="5349. 安排电影院座位"></a>5349. 安排电影院座位</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>如上图所示，电影院的观影厅中有<code>n</code>行座位，行编号从 1 到 n ，且每一行内总共有 10 个座位，列编号从 1 到 10 。</p><p>给你数组 <code>reservedSeats</code>，包含所有已经被预约了的座位。比如说，<code>researvedSeats[i]=[3,8]</code>，它表示第 3 行第 8 个座位被预约了。</p><p>请你返回 最多能安排多少个 4 人家庭 。4 人家庭要占据 同一行内连续 的 4 个座位。隔着过道的座位（比方说 [3,3] 和 [3,4]）不是连续的座位，但是如果你可以将 4 人家庭拆成过道两边各坐 2 人，这样子是允许的。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">3</span>, reservedSeats = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">10</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：上图所示是最优的安排方案，总共可以安排 <span class="number">4</span> 个家庭。蓝色的叉表示被预约的座位，橙色的连续座位表示一个 <span class="number">4</span> 人家庭。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, reservedSeats = [[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, reservedSeats = [[<span class="number">4</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">6</span>],[<span class="number">1</span>,<span class="number">7</span>]]</span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^9</code></li><li><code>1 &lt;= reservedSeats.length &lt;= min(10*n, 10^4)</code></li><li><code>reservedSeats[i].length == 2</code></li><li><code>1 &lt;= reservedSeats[i][0] &lt;= n</code></li><li><code>1 &lt;= reservedSeats[i][1] &lt;= 10</code></li><li>所有 <code>reservedSeats[i]</code> 都是互不相同的。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/cinema-seat-allocation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/cinema-seat-allocation/</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力计算</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>题目看起来很复杂，实际很简单。首先对于空的行，那么这行最多只有两个满足4人连坐的订票要求。</li><li>剩余的每行中分别判断即可，每排10个作为，只需要判断连续的（2345，4567，6789）这三种情况是否存在即可。</li><li>这个题目不管怎么优化都没有太大意思。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNumberOfFamilies</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; reservedSeats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; seats;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : reservedSeats)&#123;</span><br><span class="line">            seats[e[<span class="number">0</span>]].insert(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; v : seats)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v.second.count(<span class="number">2</span>)&amp;&amp;!v.second.count(<span class="number">3</span>)&amp;&amp;</span><br><span class="line">               !v.second.count(<span class="number">4</span>)&amp;&amp;!v.second.count(<span class="number">5</span>))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                v.second.insert(<span class="number">2</span>);</span><br><span class="line">                v.second.insert(<span class="number">3</span>);</span><br><span class="line">                v.second.insert(<span class="number">4</span>);</span><br><span class="line">                v.second.insert(<span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!v.second.count(<span class="number">4</span>)&amp;&amp;!v.second.count(<span class="number">5</span>)&amp;&amp;</span><br><span class="line">               !v.second.count(<span class="number">6</span>)&amp;&amp;!v.second.count(<span class="number">7</span>))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                v.second.insert(<span class="number">4</span>);</span><br><span class="line">                v.second.insert(<span class="number">5</span>);</span><br><span class="line">                v.second.insert(<span class="number">6</span>);</span><br><span class="line">                v.second.insert(<span class="number">7</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!v.second.count(<span class="number">6</span>)&amp;&amp;!v.second.count(<span class="number">7</span>)&amp;&amp;</span><br><span class="line">               !v.second.count(<span class="number">8</span>)&amp;&amp;!v.second.count(<span class="number">9</span>))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                v.second.insert(<span class="number">6</span>);</span><br><span class="line">                v.second.insert(<span class="number">7</span>);</span><br><span class="line">                v.second.insert(<span class="number">8</span>);</span><br><span class="line">                v.second.insert(<span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (n - seats.size())*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5351-3n-块披萨"><a href="#5351-3n-块披萨" class="headerlink" title="5351. 3n 块披萨"></a>5351. 3n 块披萨</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：</p><p>你挑选 任意 一块披萨。<br>Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。<br>Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。<br>重复上述过程直到没有披萨剩下。<br>每一块披萨的大小按顺时针方向由循环数组 <code>slices</code>表示。</p><p>请你返回你可以获得的披萨大小总和的最大值。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：选择大小为 <span class="number">4</span> 的披萨，Alice 和 Bob 分别挑选大小为 <span class="number">3</span> 和 <span class="number">5</span> 的披萨。然后你选择大小为 <span class="number">6</span> 的披萨，Alice 和 Bob 分别挑选大小为 <span class="number">2</span> 和 <span class="number">1</span> 的披萨。你获得的披萨总大小为 <span class="number">4</span> + <span class="number">6</span> = <span class="number">10</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">16</span></span><br><span class="line">解释：两轮都选大小为 <span class="number">8</span> 的披萨。如果你选择大小为 <span class="number">9</span> 的披萨，你的朋友们就会选择大小为 <span class="number">8</span> 的披萨，这种情况下你的总和不是最大的。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">7</span>]</span><br><span class="line">输出：<span class="number">21</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：slices = [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= slices.length &lt;= 500</code></li><li><code>slices.length % 3 == 0</code></li><li><code>1 &lt;= slices[i] &lt;= 1000</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/pizza-with-3n-slices/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pizza-with-3n-slices/</a></p><h3 id="题意d"><a href="#题意d" class="headerlink" title="题意d"></a>题意d</h3><blockquote><p> 动态规划</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>dp跟213题基本上一样的思路，但是题目如何转换成将题目变化为从长度为<code>n</code>的序列中选出<code>n/3</code>个不相邻的数。</li><li>由于题目中数列成环，则<code>0</code>与<code>n-1</code>也是相邻的。</li><li>因此我们可以转换为从<code>0</code>到<code>n-2</code>中选出<code>n/3</code>个不相邻的数，要么从<code>1</code>到<code>n-1</code>个数中选出<code>n/3</code>个不相邻的数。</li><li>我们用两个dp即可实现。dp1选择从<code>[1,n-1]</code>,dp2选择从<code>[2,n]</code>。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSizeSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; slices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = slices.size();</span><br><span class="line">        <span class="keyword">int</span> select = n/<span class="number">3</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp1(n,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(select+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp2(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(select+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        dp1[<span class="number">1</span>][<span class="number">1</span>] = slices[<span class="number">0</span>];</span><br><span class="line">        dp2[<span class="number">2</span>][<span class="number">1</span>] = slices[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= select; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                dp1[j][i] = max(dp1[j<span class="number">-1</span>][i],dp1[j<span class="number">-2</span>][i<span class="number">-1</span>] + slices[j<span class="number">-1</span>]);</span><br><span class="line">                dp2[j+<span class="number">1</span>][i] = max(dp2[j][i],dp2[j<span class="number">-1</span>][i<span class="number">-1</span>] + slices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp1[n<span class="number">-1</span>][select],dp2[n][select]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;22周双周比赛&quot;&gt;&lt;a href=&quot;#22周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;22周双周比赛&quot;&gt;&lt;/a&gt;22周双周比赛&lt;/h1&gt;&lt;p&gt;题目质量一般般，除了最后一题以外，其余的都是暴力即可。&lt;/p&gt;&lt;h2 id=&quot;5348-两个数组间的距离值&quot;&gt;&lt;a href=&quot;#5348-两个数组间的距离值&quot; class=&quot;headerlink&quot; title=&quot;5348. 两个数组间的距离值&quot;&gt;&lt;/a&gt;5348. 两个数组间的距离值&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你两个整数数组 &lt;code&gt;arr1&lt;/code&gt;， &lt;code&gt;arr2&lt;/code&gt; 和一个整数 &lt;code&gt;d&lt;/code&gt; ，请你返回两个数组之间的 距离值 。&lt;/p&gt;&lt;p&gt;「距离值」 定义为符合此描述的元素数目：对于元素&lt;code&gt;arr1[i]&lt;/code&gt; ，不存在任何元素 &lt;code&gt;arr2[j]&lt;/code&gt;满足 &lt;code&gt;|arr1[i]-arr2[j]| &amp;lt;= d&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 180周比赛</title>
    <link href="http://yoursite.com/2020/03/15/139/"/>
    <id>http://yoursite.com/2020/03/15/139/</id>
    <published>2020-03-15T11:51:24.662Z</published>
    <updated>2020-03-15T12:04:39.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="180周比赛"><a href="#180周比赛" class="headerlink" title="180周比赛"></a>180周比赛</h1><p>题目质量非常高，题目本身难度不是很大，适合面试。</p><h2 id="5356-矩阵中的幸运数"><a href="#5356-矩阵中的幸运数" class="headerlink" title="5356. 矩阵中的幸运数"></a>5356. 矩阵中的幸运数</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个<code>m * n</code>的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p><p>幸运数是指矩阵中满足同时下列两个条件的元素：</p><p>在同一行的所有元素中最小<br>在同一列的所有元素中最大</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>],[<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>]]</span><br><span class="line">输出：[<span class="number">15</span>]</span><br><span class="line">解释：<span class="number">15</span> 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">12</span>]</span><br><span class="line">解释：<span class="number">12</span> 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出：[<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>提示：</p><ul><li><code>m == mat.length</code></li><li><code>n == mat[i].length</code></li><li><code>1 &lt;= n, m &lt;= 50</code></li><li><code>1 &lt;= matrix[i][j] &lt;= 10^5</code></li><li>矩阵中的所有元素都是不同的</li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 暴力枚举即可</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>找到每列的最大值的行号，然后坚持该数是否为所在行的最小值。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; luckyNumbers (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*calc col*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; ++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> maxRow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">bool</span> isLucky = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[j][i] &gt; matrix[maxRow][i])&#123;</span><br><span class="line">                    maxRow = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[maxRow][j] &lt; matrix[maxRow][i])&#123;</span><br><span class="line">                    isLucky = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isLucky) res.push_back(matrix[maxRow][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5357-设计一个支持增量操作的栈"><a href="#5357-设计一个支持增量操作的栈" class="headerlink" title="5357. 设计一个支持增量操作的栈"></a>5357. 设计一个支持增量操作的栈</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>请你设计一个支持下述操作的栈。</p><p>实现自定义栈类 <code>CustomStack</code>：</p><ul><li><code>CustomStack(int maxSize)：</code>用 <code>maxSize</code> 初始化对象，<code>maxSize</code> 是栈中最多能容纳的元素数量，栈在增长到 <code>maxSize</code>之后则不支持 <code>push</code> 操作。</li><li><code>void push(int x)</code>：如果栈还未增长到<code>maxSize</code> ，就将<code>x</code>添加到栈顶。</li><li><code>int pop()</code>：返回栈顶的值，或栈为空时返回 -1 。</li><li><code>void inc(int k, int val)</code>：栈底的 k 个元素的值都增加 <code>val</code>。如果栈中元素总数小于 k ，则栈中的所有元素都增加 <code>val</code>。</li></ul><p>示例：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CustomStack"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"pop"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"push"</span>,<span class="string">"increment"</span>,<span class="string">"increment"</span>,<span class="string">"pop"</span>,<span class="string">"pop"</span>,<span class="string">"pop"</span>,<span class="string">"pop"</span>]</span><br><span class="line">[[<span class="number">3</span>],[<span class="number">1</span>],[<span class="number">2</span>],[],[<span class="number">2</span>],[<span class="number">3</span>],[<span class="number">4</span>],[<span class="number">5</span>,<span class="number">100</span>],[<span class="number">2</span>,<span class="number">100</span>],[],[],[],[]]</span><br><span class="line">输出：</span><br><span class="line">[null,null,null,<span class="number">2</span>,null,null,null,null,null,<span class="number">103</span>,<span class="number">202</span>,<span class="number">201</span>,<span class="number">-1</span>]</span><br><span class="line">解释：</span><br><span class="line">CustomStack customStack = new CustomStack(<span class="number">3</span>); <span class="comment">// 栈是空的 []</span></span><br><span class="line">customStack.push(<span class="number">1</span>);                          <span class="comment">// 栈变为 [1]</span></span><br><span class="line">customStack.push(<span class="number">2</span>);                          <span class="comment">// 栈变为 [1, 2]</span></span><br><span class="line">customStack.pop();                            <span class="comment">// 返回 2 --&gt; 返回栈顶值 2，栈变为 [1]</span></span><br><span class="line">customStack.push(<span class="number">2</span>);                          <span class="comment">// 栈变为 [1, 2]</span></span><br><span class="line">customStack.push(<span class="number">3</span>);                          <span class="comment">// 栈变为 [1, 2, 3]</span></span><br><span class="line">customStack.push(<span class="number">4</span>);                          <span class="comment">// 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4</span></span><br><span class="line">customStack.increment(<span class="number">5</span>, <span class="number">100</span>);                <span class="comment">// 栈变为 [101, 102, 103]</span></span><br><span class="line">customStack.increment(<span class="number">2</span>, <span class="number">100</span>);                <span class="comment">// 栈变为 [201, 202, 103]</span></span><br><span class="line">customStack.pop();                            <span class="comment">// 返回 103 --&gt; 返回栈顶值 103，栈变为 [201, 202]</span></span><br><span class="line">customStack.pop();                            <span class="comment">// 返回 202 --&gt; 返回栈顶值 202，栈变为 [201]</span></span><br><span class="line">customStack.pop();                            <span class="comment">// 返回 201 --&gt; 返回栈顶值 201，栈变为 []</span></span><br><span class="line">customStack.pop();                            <span class="comment">// 返回 -1 --&gt; 栈为空，返回 -1</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= maxSize &lt;= 1000</code></li><li><code>1 &lt;= x &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= 1000</code></li><li><code>0 &lt;= val &lt;= 100</code></li><li>每种方法 <code>increment</code>，<code>push</code> 以及 <code>pop</code>分别最多调用 <code>1000</code>次</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-a-stack-with-increment-operation</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 辅助数组</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>设计一个辅助数据add. add[x]代表从栈底到x个元素需要增加的值add[x]。</li><li>进行<code>increment(k,val)</code>操作时，将<code>add[k]</code>增加<code>val</code>.</li><li>进行<code>push</code>操作时，正常增加栈的元素，需要判断当前栈空间的大小是否达到<code>maxsize</code>。</li><li>进行<code>pop</code>操作时，稍微复杂点，返回的值为栈顶的元素 加上<code>add[stack.size()]</code>的元素,同时将栈进行弹出，并将<code>add[stack.size()-1]</code>加上<code>add[stack.size()]</code>，同时将<code>add[stack.size()]</code>的值置为0;<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CustomStack(<span class="keyword">int</span> maxSize) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capbility = maxSize;</span><br><span class="line">        <span class="keyword">this</span>-&gt;add = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1001</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.size() &gt;= <span class="keyword">this</span>-&gt;capbility) <span class="keyword">return</span>;</span><br><span class="line">        s.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> sz = s.size();</span><br><span class="line">        <span class="keyword">int</span> curr = s.top() + add[sz];</span><br><span class="line">        add[sz<span class="number">-1</span>] += add[sz];</span><br><span class="line">        add[sz] = <span class="number">0</span>;</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; s.size())&#123;</span><br><span class="line">            add[s.size()] += val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            add[k] += val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> capbility;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; add;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CustomStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CustomStack* obj = new CustomStack(maxSize);</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * obj-&gt;increment(k,val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5179-将二叉搜索树变平衡"><a href="#5179-将二叉搜索树变平衡" class="headerlink" title="5179. 将二叉搜索树变平衡"></a>5179. 将二叉搜索树变平衡</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。</p><p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。</p><p>如果有多种构造方法，请你返回任意一种。</p><p>示例：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>]</span><br><span class="line">解释：这不是唯一的正确答案，[<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="literal">null</span>,<span class="literal">null</span>] 也是一个可行的构造方案。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>树节点的数目在 1 到<code>10^4</code>之间。</li><li>树节点的值互不相同，且在 1 到 <code>10^5</code>之间。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/balance-a-binary-search-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 使用二分法重建立二分查找树 </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>AVL的重建，方法比较复杂，需要很复杂的扭转和偏移。竞赛时间有限，没有必要来重新建一遍。</li><li>遍历二分查找树，然后采用二分法重新建树，二分查找平衡树的建树过程很简单，严格的二分法即可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">preOrderBst</span><span class="params">(TreeNode * root,<span class="built_in">vector</span>&lt;TreeNode *&gt; &amp; nodes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        preOrderBst(root-&gt;left,nodes);</span><br><span class="line">        nodes.push_back(root);</span><br><span class="line">        preOrderBst(root-&gt;right,nodes);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode * <span class="title">buildBst</span><span class="params">(<span class="built_in">vector</span>&lt;TreeNode *&gt; &amp; nodes,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        nodes[mid]-&gt;left = buildBst(nodes,l,mid<span class="number">-1</span>);</span><br><span class="line">        nodes[mid]-&gt;right = buildBst(nodes,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> nodes[mid];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">balanceBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode *&gt; nodes;</span><br><span class="line">        preOrderBst(root,nodes);</span><br><span class="line">        <span class="keyword">return</span> buildBst(nodes,<span class="number">0</span>,nodes.size()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="5359-最大的团队表现值"><a href="#5359-最大的团队表现值" class="headerlink" title="5359. 最大的团队表现值"></a>5359. 最大的团队表现值</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>公司有编号为 1 到 n 的 n 个工程师，给你两个数组 <code>speed</code> 和 <code>efficiency</code>，其中<code>speed[i]</code>和 <code>efficiency[i]</code>分别代表第 i 位工程师的速度和效率。请你返回由最多 k 个工程师组成的 ​​​​​​最大团队表现值 ，由于答案可能很大，请你返回结果对 <code>10^9</code>+ 7 取余后的结果。</p><p>团队表现值 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, speed = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>], efficiency = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>], k = <span class="number">2</span></span><br><span class="line">输出：<span class="number">60</span></span><br><span class="line">解释：</span><br><span class="line">我们选择工程师 <span class="number">2</span>（speed=<span class="number">10</span> 且 efficiency=<span class="number">4</span>）和工程师 <span class="number">5</span>（speed=<span class="number">5</span> 且 efficiency=<span class="number">7</span>）。他们的团队表现值为 performance = (<span class="number">10</span> + <span class="number">5</span>) * min(<span class="number">4</span>, <span class="number">7</span>) = <span class="number">60</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, speed = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>], efficiency = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>], k = <span class="number">3</span></span><br><span class="line">输出：<span class="number">68</span></span><br><span class="line">解释：</span><br><span class="line">此示例与第一个示例相同，除了 k = <span class="number">3</span> 。我们可以选择工程师 <span class="number">1</span> ，工程师 <span class="number">2</span> 和工程师 <span class="number">5</span> 得到最大的团队表现值。表现值为 performance = (<span class="number">2</span> + <span class="number">10</span> + <span class="number">5</span>) * min(<span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>) = <span class="number">68</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, speed = [<span class="number">2</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>], efficiency = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>], k = <span class="number">4</span></span><br><span class="line">输出：<span class="number">72</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>speed.length == n</code></li><li><code>efficiency.length == n</code></li><li><code>1 &lt;= speed[i] &lt;= 10^5</code></li><li><code>1 &lt;= efficiency[i] &lt;= 10^8</code></li><li><code>1 &lt;= k &lt;= n</code></li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/weekly-contest-180/problems/maximum-performance-of-a-team/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-180/problems/maximum-performance-of-a-team/</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 优先级队列</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>仔细分析一下题目，我们只需要再满足最低的效率<code>e</code>时，选取最大的K个<code>speed</code>即可，贪心算法即可。</li><li>我们将所有的工程师按照效率最大到小进行排列，每次选择速度最快的<code>k</code>个工程师，贪心算法用优先级队列即可，每次淘汰队列中的速度最小的值。</li><li>算法的时间复杂度为<code>nlogk</code>.</li><li>题目的还有一个<code>corner</code>，尽量用长整型来保存数据，在进行取模操作时，一定要在最后一步再进行取模，否则判断大小会可能出错。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pii &amp; a,pii &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first == b.first) <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPerformance</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; efficiency, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pii&gt; p;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            p.push_back(make_pair(efficiency[i],speed[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p.begin(),p.end(),cmp);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            sum += p[i].second;</span><br><span class="line">            pq.push(p[i].second);</span><br><span class="line">            <span class="keyword">if</span>(pq.size() &gt; k)&#123;</span><br><span class="line">                sum -= pq.top();</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,(sum*p[i].first));</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;180周比赛&quot;&gt;&lt;a href=&quot;#180周比赛&quot; class=&quot;headerlink&quot; title=&quot;180周比赛&quot;&gt;&lt;/a&gt;180周比赛&lt;/h1&gt;&lt;p&gt;题目质量非常高，题目本身难度不是很大，适合面试。&lt;/p&gt;&lt;h2 id=&quot;5356-矩阵中的幸运数&quot;&gt;&lt;a href=&quot;#5356-矩阵中的幸运数&quot; class=&quot;headerlink&quot; title=&quot;5356. 矩阵中的幸运数&quot;&gt;&lt;/a&gt;5356. 矩阵中的幸运数&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个&lt;code&gt;m * n&lt;/code&gt;的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。&lt;/p&gt;&lt;p&gt;幸运数是指矩阵中满足同时下列两个条件的元素：&lt;/p&gt;&lt;p&gt;在同一行的所有元素中最小&lt;br&gt;在同一列的所有元素中最大&lt;/p&gt;&lt;p&gt;示例 1：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;13&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt; 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 2：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;17&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;span class=&quot;number&quot;&gt;12&lt;/span&gt; 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;示例 3：&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：matrix = [[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;],[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：[&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 21周双周赛</title>
    <link href="http://yoursite.com/2020/03/09/138/"/>
    <id>http://yoursite.com/2020/03/09/138/</id>
    <published>2020-03-09T08:42:10.743Z</published>
    <updated>2020-03-09T08:42:20.135Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21周双周比赛"><a href="#21周双周比赛" class="headerlink" title="21周双周比赛"></a>21周双周比赛</h1><p>题目质量非常高，四个题目都有难度。</p><h2 id="1370-上升下降字符串"><a href="#1370-上升下降字符串" class="headerlink" title="1370. 上升下降字符串"></a>1370. 上升下降字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：<br>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。<br>重复步骤 2 ，直到你没法从 s 中选择字符。<br>从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。<br>从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。<br>重复步骤 5 ，直到你没法从 s 中选择字符。<br>重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。<br>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p><a id="more"></a><p>请你返回将 s 中字符重新排序后的 结果字符串 。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"aaaabbbbcccc"</span></span><br><span class="line">输出：<span class="string">"abccbaabccba"</span></span><br><span class="line">解释：第一轮的步骤 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> 后，结果字符串为 result = <span class="string">"abc"</span></span><br><span class="line">第一轮的步骤 <span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span> 后，结果字符串为 result = <span class="string">"abccba"</span></span><br><span class="line">第一轮结束，现在 s = <span class="string">"aabbcc"</span> ，我们再次回到步骤 <span class="number">1</span></span><br><span class="line">第二轮的步骤 <span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span> 后，结果字符串为 result = <span class="string">"abccbaabc"</span></span><br><span class="line">第二轮的步骤 <span class="number">4</span>，<span class="number">5</span>，<span class="number">6</span> 后，结果字符串为 result = <span class="string">"abccbaabccba"</span></span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"rat"</span></span><br><span class="line">输出：<span class="string">"art"</span></span><br><span class="line">解释：单词 <span class="string">"rat"</span> 在上述算法重排序以后变成 <span class="string">"art"</span></span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"leetcode"</span></span><br><span class="line">输出：<span class="string">"cdelotee"</span></span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"ggggggg"</span></span><br><span class="line">输出：<span class="string">"ggggggg"</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="attr">s</span> = <span class="string">"spo"</span></span><br><span class="line">输出：<span class="string">"ops"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s 只包含小写英文字母。</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/increasing-decreasing-string</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接按照字符的排列顺序访问即可。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>每次按照字符大小的升序和降序各访问一遍，直到所有的字符均被访问过。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">sortString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i)&#123;</span><br><span class="line">            cnt[s[i]-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    res += <span class="string">'a'</span> + i;</span><br><span class="line">                    cnt[i]--;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    res += <span class="string">'a'</span> + i;</span><br><span class="line">                    cnt[i]--;</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1371-每个元音包含偶数次的最长子字符串"><a href="#1371-每个元音包含偶数次的最长子字符串" class="headerlink" title="1371. 每个元音包含偶数次的最长子字符串"></a>1371. 每个元音包含偶数次的最长子字符串</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 <code>&#39;a&#39;，&#39;e&#39;，&#39;i&#39;，&#39;o&#39;，&#39;u&#39;</code>，在子字符串中都恰好出现了偶数次。</p><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"eleetminicoworoep"</span></span><br><span class="line">输出：<span class="number">13</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"leetminicowor"</span> ，它包含 e，i，o 各 <span class="number">2</span> 个，以及 <span class="number">0</span> 个 a，u 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"leetcodeisgreat"</span></span><br><span class="line">输出：<span class="number">5</span></span><br><span class="line">解释：最长子字符串是 <span class="string">"leetc"</span> ，其中包含 <span class="number">2</span> 个 e 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">"bcbcbc"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：这个示例中，字符串 <span class="string">"bcbcbc"</span> 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 <span class="number">0</span> 次。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 5 x 10^5</code></li><li>s 只包含小写英文字母。</li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> dp</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li>将5个元音字母出现次数的奇偶视为一种状态，一共有32种状态，不妨使用一个整数代表状态，第0位为1表示a出现奇数次，第一位为1表示e出现奇数次……以此类推。仅有状态0符合题意。而如果子串[0，i]与字串[0,j]状态相同，那么字串[i+1,j]的状态一定是0，因此可以记录每个状态第一次出现的位置，此后再出现该状态时相减即可。需要注意状态0首次出现的位置应该设定为-1。</li><li>在计算状态的时候可以利用异或运算。</li><li>这题的解法确实非常巧妙，当时这道题目没有做出来，想不到还有这种解题思路，本次比赛这道题目估计是最难的了。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre(<span class="number">32</span>,INT_MAX);</span><br><span class="line">        pre[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> N=s.size();</span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'a'</span>:cur^=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'e'</span>:cur^=<span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'i'</span>:cur^=<span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'o'</span>:cur^=<span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'u'</span>:cur^=<span class="number">16</span>;<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre[cur]==INT_MAX) pre[cur]=i;</span><br><span class="line">            <span class="keyword">else</span> ans=max(ans,i-pre[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1372-二叉树中的最长交错路径"><a href="#1372-二叉树中的最长交错路径" class="headerlink" title="1372. 二叉树中的最长交错路径"></a>1372. 二叉树中的最长交错路径</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给你一棵以 root 为根的二叉树，二叉树中的交错路径定义如下：</p><ul><li>选择二叉树中 任意 节点和一个方向（左或者右）。</li><li>如果前进方向为右，那么移动到当前节点的的右子节点，否则移动到它的左子节点。</li><li>改变前进方向：左变右或者右变左。</li><li>重复第二步和第三步，直到你在树中无法继续移动。<br>交错路径的长度定义为：访问过的节点数目 - 1（单个节点的路径长度为 0 ）。</li></ul><p>请你返回给定树中最长 交错路径 的长度。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：蓝色节点为树中最长交错路径（右 -&gt; 左 -&gt; 右）。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="literal">null</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">4</span></span><br><span class="line">解释：蓝色节点为树中最长交错路径（左 -&gt; 右 -&gt; 左 -&gt; 右）。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li>每棵树最多有 <code>50000</code>个节点。</li><li>每个节点的值在 <code>[1, 100]</code>之间。</li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-zigzag-path-in-a-binary-tree</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS </p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><code>flag</code>用于标记当前的根节点是左孩子还是右孩子，按照交替访问的规则，如果当前的root节点是左孩子，按照规则应该访问<code>root</code>节点的右孩子，同时长度加1；如果当前的<code>root</code>节点是右孩子，按照规则应该访问root节点的左孩子，同时长度加1</li><li><code>count</code>用于标记，当前节点已经满足交替访问的长度。如果按照规则进行访问，则将长度置为1.</li><li>这个题目是个非常好的题目，收藏一下，以后可以多多进行复习。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> count,<span class="keyword">int</span> flag,<span class="keyword">int</span> &amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        res = max(res,count);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(root-&gt;left,<span class="number">1</span>,<span class="number">0</span>,res);</span><br><span class="line">            dfs(root-&gt;right,count+<span class="number">1</span>,<span class="number">1</span>,res);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(root-&gt;left,count+<span class="number">1</span>,<span class="number">0</span>,res);</span><br><span class="line">            dfs(root-&gt;right,<span class="number">1</span>,<span class="number">1</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestZigZag</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root-&gt;left,<span class="number">1</span>,<span class="number">0</span>,res);</span><br><span class="line">        dfs(root-&gt;right,<span class="number">1</span>,<span class="number">1</span>,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1373-二叉搜索子树的最大键值和"><a href="#1373-二叉搜索子树的最大键值和" class="headerlink" title="1373. 二叉搜索子树的最大键值和"></a>1373. 二叉搜索子树的最大键值和</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一棵以<code>root</code> 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p><p>二叉搜索树的定义如下：</p><p>任意节点的左子树中的键值都 小于 此节点的键值。<br>任意节点的右子树中的键值都 大于 此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">20</span></span><br><span class="line">解释：键值为 <span class="number">3</span> 的子树是和最大的二叉搜索树。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">4</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：键值为 <span class="number">2</span> 的单节点子树是和最大的二叉搜索树。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">-4</span>,<span class="number">-2</span>,<span class="number">-5</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：所有节点键值都为负数，和最大的二叉搜索树为空。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">7</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>每棵树最多有 <code>40000</code>个节点。</li><li>每个节点的键值在 <code>[-4 * 10^4 , 4 * 10^4]</code>之间。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 递归</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>本题的思路还是判断二叉树的子树是否为二叉搜索树，如果是二叉搜索树，则求最大的二叉搜索子树的和。本质上结合了判断二叉搜索和树的和两部分内容。题目还是非常不错，但是作为hard难度的题目还是简单了一点。</li><li>每次遍历根节点的子树，同时返回子树的和以及子树是否为二叉搜索树。</li><li>根据左右子树的返回结果判断以<code>root</code>为根节点的子树是否为二叉搜索树，如果是则返回子树的和。</li><li>稍微复杂点的在于如何判断二叉树为二叉树搜索树，即根节点的值大于左子树的最大值，根节点的值小于右子树的最小值。<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; arr,<span class="keyword">int</span> &amp; curr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">        <span class="keyword">int</span> sum = root-&gt;val;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> l = dfs(root-&gt;left,left,curr);</span><br><span class="line">        <span class="keyword">bool</span> r = dfs(root-&gt;right,right,curr);</span><br><span class="line">        <span class="keyword">if</span>(!l||!r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left.size() &gt; <span class="number">0</span> &amp;&amp; root-&gt;val &lt;= left[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(right.size() &gt; <span class="number">0</span> &amp;&amp; root-&gt;val &gt;= right[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr.push_back(left[<span class="number">0</span>]);</span><br><span class="line">            sum += left[<span class="number">2</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            arr.push_back(right[<span class="number">1</span>]);</span><br><span class="line">            sum += right[<span class="number">2</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr.push_back(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curr = max(curr,sum);</span><br><span class="line">        arr.push_back(sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root,arr,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;21周双周比赛&quot;&gt;&lt;a href=&quot;#21周双周比赛&quot; class=&quot;headerlink&quot; title=&quot;21周双周比赛&quot;&gt;&lt;/a&gt;21周双周比赛&lt;/h1&gt;&lt;p&gt;题目质量非常高，四个题目都有难度。&lt;/p&gt;&lt;h2 id=&quot;1370-上升下降字符串&quot;&gt;&lt;a href=&quot;#1370-上升下降字符串&quot; class=&quot;headerlink&quot; title=&quot;1370. 上升下降字符串&quot;&gt;&lt;/a&gt;1370. 上升下降字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个字符串 s ，请你根据下面的算法重新构造字符串：&lt;br&gt;从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。&lt;br&gt;从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。&lt;br&gt;重复步骤 2 ，直到你没法从 s 中选择字符。&lt;br&gt;从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。&lt;br&gt;从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。&lt;br&gt;重复步骤 5 ，直到你没法从 s 中选择字符。&lt;br&gt;重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。&lt;br&gt;在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【Leetcode】 第 179周 比赛</title>
    <link href="http://yoursite.com/2020/03/09/137/"/>
    <id>http://yoursite.com/2020/03/09/137/</id>
    <published>2020-03-09T08:12:04.560Z</published>
    <updated>2020-03-09T08:12:10.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="179周比赛"><a href="#179周比赛" class="headerlink" title="179周比赛"></a>179周比赛</h1><p>这周的题目质量一般，不如双周赛的题目好，题目比较简单。</p><h2 id="1374-生成每种字符都是奇数个的字符串"><a href="#1374-生成每种字符都是奇数个的字符串" class="headerlink" title="1374. 生成每种字符都是奇数个的字符串"></a>1374. 生成每种字符都是奇数个的字符串</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数 <code>n</code>，请你返回一个含 <code>n</code> 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。</p><p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p><a id="more"></a><p>示例 1：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span></span><br><span class="line">输出：<span class="string">"pppz"</span></span><br><span class="line">解释：<span class="string">"pppz"</span> 是一个满足题目要求的字符串，因为 'p' 出现 <span class="number">3</span> 次，且 'z' 出现 <span class="number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="string">"ohhh"</span> 和 <span class="string">"love"</span>。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"xy"</span></span><br><span class="line">解释：<span class="string">"xy"</span> 是一个满足题目要求的字符串，因为 'x' 和 'y' 各出现 <span class="number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="string">"ag"</span> 和 <span class="string">"ur"</span>。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">n</span> = <span class="number">7</span></span><br><span class="line">输出：<span class="string">"holasss"</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 500</code></li></ul><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-a-string-with-characters-that-have-odd-counts</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 直接计算</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>直接计算当前的n为偶数还是奇数，如果<code>n</code>为奇数，则直接字符串由<code>n</code>个<code>a</code>组成即可。</li><li>如果<code>n</code>为偶数，字符串由<code>n-1</code>个<code>a</code>和<code>1</code>个<code>b</code>构成即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">                res += <span class="string">'a'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="string">'b'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">                res += <span class="string">'a'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1375-灯泡开关-III"><a href="#1375-灯泡开关-III" class="headerlink" title="1375. 灯泡开关 III"></a>1375. 灯泡开关 III</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>房间中有 n 枚灯泡，编号从 1 到 n，自左向右排成一排。最初，所有的灯都是关着的。</p><p>在 k  时刻（ k 的取值范围是 0 到 n - 1），我们打开 <code>light[k]</code> 这个灯。</p><p>灯的颜色要想 变成蓝色 就必须同时满足下面两个条件：</p><p>灯处于打开状态。<br>排在它之前（左侧）的所有灯也都处于打开状态。<br>请返回能够让 所有开着的 灯都 变成蓝色 的时刻 数目 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：light = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：所有开着的灯都变蓝的时刻分别是 <span class="number">1</span>，<span class="number">2</span> 和 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：light = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">2</span></span><br><span class="line">解释：所有开着的灯都变蓝的时刻分别是 <span class="number">3</span> 和 <span class="number">4</span>（index<span class="number">-0</span>）。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：light = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：所有开着的灯都变蓝的时刻是 <span class="number">3</span>（index<span class="number">-0</span>）。</span><br><span class="line">第 <span class="number">4</span> 个灯在时刻 <span class="number">3</span> 变蓝。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：light = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：light = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br></pre></td></tr></table></figure><br>提示：</p><ul><li><code>n == light.length</code></li><li><code>1 &lt;= n &lt;= 5 * 10^4</code></li><li><code>light 是 [1, 2, ..., n] 的一个排列。</code></li></ul><h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/bulb-switcher-iii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/bulb-switcher-iii</a></p><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote><p> 两种办法</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>两种办法均可求出。仔细分析题目，实际上要求，当点亮第<code>i</code>个灯时，要求从<code>1~i</code>为全排列。我们可以有两种办法。</p><ol><li>求前n项和是否等于当前最大数的等差数列和。记录前<code>i</code>个元素的和<code>sum</code>，并记录前<code>i</code>个元素的最大值<code>max</code>，判断 <code>sum == max*(max+1)/2</code>.</li><li>判断当前序列第<code>i</code>个元素时的最大值为max(i),  如果是则满足要求<code>max(i) == i</code>。<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTimesAllBlue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; light.size(); ++i)&#123;</span><br><span class="line">            right = max(right,light[i]);</span><br><span class="line">            sum += light[i];</span><br><span class="line">            <span class="keyword">if</span>(sum == (<span class="keyword">long</span> <span class="keyword">long</span>)right*(right+<span class="number">1</span>)/<span class="number">2</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTimesAllBlue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; light.size(); ++i)&#123;</span><br><span class="line">            r = max(r,light[i]);</span><br><span class="line">            <span class="keyword">if</span>(r == i+<span class="number">1</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="1376-通知所有员工所需的时间"><a href="#1376-通知所有员工所需的时间" class="headerlink" title="1376. 通知所有员工所需的时间"></a>1376. 通知所有员工所需的时间</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>公司里有 n 名员工，每个员工的 <code>ID</code> 都是独一无二的，编号从 <code>0</code>到 <code>n - 1</code>。公司的总负责人通过 <code>headID</code>进行标识。</p><p>在 <code>manager</code> 数组中，每个员工都有一个直属负责人，其中 <code>manager[i]</code>是第 i 名员工的直属负责人。对于总负责人，<code>manager[headID] = -1</code>。题目保证从属关系可以用树结构显示。</p><p>公司总负责人想要向公司所有员工通告一条紧急消息。他将会首先通知他的直属下属们，然后由这些下属通知他们的下属，直到所有的员工都得知这条紧急消息。</p><p>第 i 名员工需要 <code>informTime[i]</code>分钟来通知它的所有直属下属（也就是说在 <code>informTime[i]</code>分钟后，他的所有直属下属都可以开始传播这一消息）。</p><p>返回通知所有员工这一紧急消息所需要的 分钟数 。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">1</span>, headID = <span class="number">0</span>, manager = [<span class="number">-1</span>], informTime = [<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：公司总负责人是该公司的唯一一名员工。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">6</span>, headID = <span class="number">2</span>, manager = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], informTime = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：id = <span class="number">2</span> 的员工是公司的总负责人，也是其他所有员工的直属负责人，他需要 <span class="number">1</span> 分钟来通知所有员工。</span><br><span class="line">上图显示了公司员工的树结构。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, headID = <span class="number">6</span>, manager = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-1</span>], informTime = [<span class="number">0</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">21</span></span><br><span class="line">解释：总负责人 id = <span class="number">6</span>。他将在 <span class="number">1</span> 分钟内通知 id = <span class="number">5</span> 的员工。</span><br><span class="line">id = <span class="number">5</span> 的员工将在 <span class="number">2</span> 分钟内通知 id = <span class="number">4</span> 的员工。</span><br><span class="line">id = <span class="number">4</span> 的员工将在 <span class="number">3</span> 分钟内通知 id = <span class="number">3</span> 的员工。</span><br><span class="line">id = <span class="number">3</span> 的员工将在 <span class="number">4</span> 分钟内通知 id = <span class="number">2</span> 的员工。</span><br><span class="line">id = <span class="number">2</span> 的员工将在 <span class="number">5</span> 分钟内通知 id = <span class="number">1</span> 的员工。</span><br><span class="line">id = <span class="number">1</span> 的员工将在 <span class="number">6</span> 分钟内通知 id = <span class="number">0</span> 的员工。</span><br><span class="line">所需时间 = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span> + <span class="number">5</span> + <span class="number">6</span> = <span class="number">21</span> 。</span><br></pre></td></tr></table></figure><br>示例 4：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">15</span>, headID = <span class="number">0</span>, manager = [<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>], informTime = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：第一分钟总负责人通知员工 <span class="number">1</span> 和 <span class="number">2</span> 。</span><br><span class="line">第二分钟他们将会通知员工 <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> 和 <span class="number">6</span> 。</span><br><span class="line">第三分钟他们将会通知剩下的员工。</span><br></pre></td></tr></table></figure><br>示例 5：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, headID = <span class="number">2</span>, manager = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">2</span>], informTime = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">162</span>,<span class="number">914</span>]</span><br><span class="line">输出：<span class="number">1076</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 10^5</code></li><li><code>0 &lt;= headID &lt; n</code></li><li><code>manager.length == n</code></li><li><code>0 &lt;= manager[i] &lt; n</code></li><li><code>manager[headID] == -1</code></li><li><code>informTime.length == n</code></li><li><code>0 &lt;= informTime[i] &lt;= 1000</code></li><li><code>如果员工 i 没有下属，informTime[i] == 0 。</code></li><li><code>题目 保证 所有员工都可以收到通知。</code></li></ul><h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/time-needed-to-inform-all-employees" target="_blank" rel="noopener">https://leetcode-cn.com/problems/time-needed-to-inform-all-employees</a></p><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote><p> DFS 或者 BFS</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li>求树的根节点到叶子节点的路径的最大值,每一条边都权重。</li><li>解法非常简单，实际解法我们用<code>BFS</code>或者<code>DFS</code>均可。<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; manager, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; informTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pii&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; child(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; manager.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(manager[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                child[manager[i]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        qu.push(make_pair(headID,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!qu.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = qu.front().first;</span><br><span class="line">            <span class="keyword">int</span> cost = qu.front().second;</span><br><span class="line">            qu.pop();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(informTime[curr] == <span class="number">0</span>)&#123;</span><br><span class="line">                res = max(res,cost);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> next : child[curr])&#123;</span><br><span class="line">                qu.push(make_pair(next,cost+informTime[curr]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,<span class="keyword">int</span> tot,<span class="keyword">int</span> &amp; res,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; manager, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; informTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(manager[curr] == <span class="number">-1</span>) &#123;</span><br><span class="line">            res = max(tot,res);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(manager[curr],tot+informTime[manager[curr]],res,manager,informTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfMinutes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> headID, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; manager, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; informTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; informTime.size(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(informTime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                dfs(i,<span class="number">0</span>,res,manager,informTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1377-T-秒后青蛙的位置"><a href="#1377-T-秒后青蛙的位置" class="headerlink" title="1377. T 秒后青蛙的位置"></a>1377. T 秒后青蛙的位置</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p>给你一棵由 n 个顶点组成的无向树，顶点编号从 1 到 n。青蛙从 顶点 1 开始起跳。规则如下：</p><p>在一秒内，青蛙从它所在的当前顶点跳到另一个 未访问 过的顶点（如果它们直接相连）。<br>青蛙无法跳回已经访问过的顶点。<br>如果青蛙可以跳到多个不同顶点，那么它跳到其中任意一个顶点上的机率都相同。<br>如果青蛙不能跳到任何未访问过的顶点上，那么它每次跳跃都会停留在原地。<br>无向树的边用数组 <code>edges</code>描述，其中<code>edges[i] = [fromi, toi]</code>意味着存在一条直接连通 <code>fromi</code>和<code>toi</code>两个顶点的边。</p><p>返回青蛙在<code>t</code>秒后位于目标顶点 <code>target</code> 上的概率。</p><p>示例 1：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], t = <span class="number">2</span>, target = <span class="number">4</span></span><br><span class="line">输出：<span class="number">0.16666666666666666</span> </span><br><span class="line">解释：上图显示了青蛙的跳跃路径。青蛙从顶点 <span class="number">1</span> 起跳，第 <span class="number">1</span> 秒 有 <span class="number">1</span>/<span class="number">3</span> 的概率跳到顶点 <span class="number">2</span> ，然后第 <span class="number">2</span> 秒 有 <span class="number">1</span>/<span class="number">2</span> 的概率跳到顶点 <span class="number">4</span>，因此青蛙在 <span class="number">2</span> 秒后位于顶点 <span class="number">4</span> 的概率是 <span class="number">1</span>/<span class="number">3</span> * <span class="number">1</span>/<span class="number">2</span> = <span class="number">1</span>/<span class="number">6</span> = <span class="number">0.16666666666666666</span> 。</span><br></pre></td></tr></table></figure><br>示例 2：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], t = <span class="number">1</span>, target = <span class="number">7</span></span><br><span class="line">输出：<span class="number">0.3333333333333333</span></span><br><span class="line">解释：上图显示了青蛙的跳跃路径。青蛙从顶点 <span class="number">1</span> 起跳，有 <span class="number">1</span>/<span class="number">3</span> = <span class="number">0.3333333333333333</span> 的概率能够 <span class="number">1</span> 秒 后跳到顶点 <span class="number">7</span> 。</span><br></pre></td></tr></table></figure><br>示例 3：<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">7</span>, edges = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>]], t = <span class="number">20</span>, target = <span class="number">6</span></span><br><span class="line">输出：<span class="number">0.16666666666666666</span></span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 100</code></li><li><code>edges.length == n-1</code></li><li><code>edges[i].length == 2</code></li><li><code>1 &lt;= edges[i][0], edges[i][1] &lt;= n</code></li><li><code>1 &lt;= t &lt;= 50</code></li><li><code>1 &lt;= target &lt;= n</code></li><li>与准确值误差在 <code>10^-5</code> 之内的结果将被判定为正确。</li></ul><h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/frog-position-after-t-seconds" target="_blank" rel="noopener">https://leetcode-cn.com/problems/frog-position-after-t-seconds</a></p><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote><p> BFS或者DFS均可</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol><li>题目本身不是很难，但是感觉这个题目出的不好，计算每层的概率即可。本周全部<code>AC</code>的有几百人就可以看出这个题目确实不难。</li><li>采用<code>BFS</code>或者<code>DFS</code>即可，主要是父节点·<code>p</code>跳到与其相邻的节点的概率为<code>1/n</code>,n为节点<code>p</code>的孩子的数目。</li><li>采用<code>BFS</code>或者<code>DFS</code>的思路相同，将概率每层进行传递即可。</li><li>本题的<code>cornel</code>在于一旦<code>p</code>为叶子节点和非叶子的节点的处理，在<code>t &gt; 0</code>的时间内如果跳到了节点<code>p</code>且该节点为非叶子节点，在<code>t</code>时刻时，跳到节点<code>p</code>的概率为0；在<code>t &gt; 0</code>的时间内如果跳到了叶子节点<code>p</code>，在<code>t</code>时刻时，跳到节点<code>p</code>的概率为则为固定值.<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">frogPosition</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> t, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt;&gt; qu;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; probability(n+<span class="number">1</span>,<span class="number">0.0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visit(n+<span class="number">1</span>,<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            graph[e[<span class="number">0</span>]].insert(e[<span class="number">1</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].insert(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        qu.push(make_pair(<span class="number">1</span>,<span class="number">1.0</span>));</span><br><span class="line">        visit[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        probability[<span class="number">1</span>] = <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!qu.empty() &amp;&amp; t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sz = qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; ++i)&#123;</span><br><span class="line">                <span class="keyword">int</span> curr = qu.front().first;</span><br><span class="line">                <span class="keyword">double</span> p = qu.front().second;</span><br><span class="line">                qu.pop();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> next : graph[curr])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(visit[next]) graph[curr].erase(next);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> next : graph[curr])&#123;</span><br><span class="line">                    visit[next] = <span class="literal">true</span>;</span><br><span class="line">                    qu.push(make_pair(next,p/graph[curr].size()));</span><br><span class="line">                    probability[next] = p/graph[curr].size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(graph[curr].size() &gt; <span class="number">0</span>) probability[curr] = <span class="number">0.0</span>;</span><br><span class="line">                <span class="keyword">else</span> probability[curr] = p;</span><br><span class="line">                <span class="keyword">if</span>(curr == target &amp;&amp; t &gt; <span class="number">0</span>) <span class="keyword">return</span> probability[curr];</span><br><span class="line">            &#125;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> probability[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;179周比赛&quot;&gt;&lt;a href=&quot;#179周比赛&quot; class=&quot;headerlink&quot; title=&quot;179周比赛&quot;&gt;&lt;/a&gt;179周比赛&lt;/h1&gt;&lt;p&gt;这周的题目质量一般，不如双周赛的题目好，题目比较简单。&lt;/p&gt;&lt;h2 id=&quot;1374-生成每种字符都是奇数个的字符串&quot;&gt;&lt;a href=&quot;#1374-生成每种字符都是奇数个的字符串&quot; class=&quot;headerlink&quot; title=&quot;1374. 生成每种字符都是奇数个的字符串&quot;&gt;&lt;/a&gt;1374. 生成每种字符都是奇数个的字符串&lt;/h2&gt;&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你返回一个含 &lt;code&gt;n&lt;/code&gt; 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。&lt;/p&gt;&lt;p&gt;返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
