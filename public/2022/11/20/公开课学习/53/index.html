<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="good study, day day up">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      【MIT6.S081】 lab8 lock | 且听疯吟
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>且听疯吟</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>【MIT6.S081】 lab8 lock</h2>
  <p class="post-date">2022-11-20</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>感觉<code>lock lab</code>是自我感觉还算是比较难的<code>lab</code>了, 第二个练习想了很久才想到如何写出正确的代码,特别是中间又莫名出现了 <code>panic: freeing free blocks</code>, 找了很长时间都没有找到问题所在, 还好的是最终解决该问题, 将文件系统 <code>fs</code> 删除后就莫名奇妙好了, 所有的 <code>testcase</code> 全部都可以通过了, 后面需要继续研究一下 <code>lock free</code> 队列的实现.</p>
<ul>
<li>本章终点讲述操作系统中 <code>sleep</code> 和 <code>wakeup</code> 的实现原理, 感觉还是挺有趣的实现, 当然本质上 <code>sleep</code>的实现原理非常简单, 即将当前线程设置为<code>sleeping</code>状态, 并标记当前线程的 $chan$, 然后将当前线程切换出去, 线程调度程序在运行时,发现当前线程的状态不是 <code>runable</code>时就不会将该线程调度到 <code>cpu</code> 核心上, 从而实现了该线程的睡眠.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">(<span class="type">void</span> *chan, <span class="keyword">struct</span> spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    <span class="built_in">release</span>(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sched</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="built_in">acquire</span>(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们同时也可以观察一下系统调用程序中 <code>sleep</code> 函数的实现, 原理实际上也是调用 <code>sleep lock</code>来实现, 当前如果等待的时间小于 <code>sleep</code> 睡眠的时间,如果当前进程被唤醒，则继续执行 <code>sleep</code>, 否则则释放 <code>ticklocks</code>,　此时进行就可以从调度程序中被唤醒. <code>sleep</code> 系统调用都是标记在<code>ticks</code>中，我们可以看到时间中断中，每次会将标记为<code>ticks</code>的进程进行唤醒，从而实现时间计数．<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sleep</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  uint ticks0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">  ticks0 = ticks;</span><br><span class="line">  <span class="keyword">while</span>(ticks - ticks0 &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">myproc</span>()-&gt;killed)&#123;</span><br><span class="line">      <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(&amp;ticks, &amp;tickslock);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">clockintr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;tickslock);</span><br><span class="line">  ticks++;</span><br><span class="line">  <span class="built_in">wakeup</span>(&amp;ticks);</span><br><span class="line">  <span class="built_in">release</span>(&amp;tickslock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>关于<code>wake</code>的原理实现也非常简单,即将进程的状态由<code>sleeping</code>设置为 <code>runable</code>即可, 此时在进行进程调度时,该进程即可就唤醒,加载到 <code>CPU</code>核心中运行.<code>wakeup</code>时需要传入 <code>chan</code> 参数标记.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup</span><span class="params">(<span class="type">void</span> *chan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="built_in">acquire</span>(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>lecture</code>中还提到了<code>lost wakeup</code>的问题, 很多细节问题真心值得深入的去思考这些细节实现. 还是认真的学习视频感觉比较.</li>
<li>本章的<code>lab</code>主要以如何减少<code>lock</code>冲突的出发点去优化代码, 同时如何避免死锁的问题去寻求解决办法, 总的来说还算是比较有意思的<code>lab</code>.</li>
</ul>
<h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>本次<code>lab</code>的几个程序倒是感觉不是太难，实现代码倒是不多，但是很多值得思考的地方,整个<a target="_blank" rel="noopener" href="https://github.com/mike-box/MIT6.S081/tree/main/">MIT 6.S081</a>的课程总结全部放到github上了.<br><a target="_blank" rel="noopener" href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lock-handin">git repo</a></p>
<h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The program user/kalloctest stresses xv6&#x27;s memory allocator: three processes grow and shrink their address spaces, resulting in many calls to kalloc and kfree. kalloc and kfree obtain kmem.lock. kalloctest prints (as &quot;#fetch-and-add&quot;) the number of loop iterations in acquire due to attempts to acquire a lock that another core already holds, for the kmem lock and a few other locks. The number of loop iterations in acquire is a rough measure of lock contention. The output of kalloctest looks similar to this before you complete the lab:</span><br><span class="line"></span><br><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br><span class="line">acquire maintains, for each lock, the count of calls to acquire for that lock, and the number of times the loop in acquire tried but failed to set the lock. kalloctest calls a system call that causes the kernel to print those counts for the kmem and bcache locks (which are the focus of this lab) and for the 5 most contended locks. If there is lock contention the number of acquire loop iterations will be large. The system call returns the sum of the number of loop iterations for the kmem and bcache locks.</span><br><span class="line"></span><br><span class="line">For this lab, you must use a dedicated unloaded machine with multiple cores. If you use a machine that is doing other things, the counts that kalloctest prints will be nonsense. You can use a dedicated Athena workstation, or your own laptop, but don&#x27;t use a dialup machine.</span><br><span class="line"></span><br><span class="line">The root cause of lock contention in kalloctest is that kalloc() has a single free list, protected by a single lock. To remove lock contention, you will have to redesign the memory allocator to avoid a single lock and list. The basic idea is to maintain a free list per CPU, each list with its own lock. Allocations and frees on different CPUs can run in parallel, because each CPU will operate on a different list. The main challenge will be to deal with the case in which one CPU&#x27;s free list is empty, but another CPU&#x27;s list has free memory; in that case, the one CPU must &quot;steal&quot; part of the other CPU&#x27;s free list. Stealing may introduce lock contention, but that will hopefully be infrequent.</span><br></pre></td></tr></table></figure>

<ul>
<li>题目提示由于目前实现的<code>kalloc</code>所有的线程都共享一把锁, 此时如何所有的线程在<code>heap</code>上申请时会造成冲突, 从而都在锁上进行自旋, 从而进行等待,题目要求优化<code>kalloc</code>,减少<code>lock accquire</code>时的冲突. 题目也给了思路, 就是为每个线程建立一个<code>memory pool</code>, 每个线程的内存申请都发生在自身的<code>memory pool</code>, 当如果自身的<code>memory pool</code>用完时,则从其他线程的<code>memory pool</code>中进行<code>steal</code>操作.</li>
<li>本身比较简单, 但是需要注意的几个细节:<ul>
<li><code>kalloc</code>模块对外提供的接口不变, 每次进行<code>alloc</code>操作时, 首先需要获取当前线程的<code>cpuid</code>的信息, 可以通过寄存器读取即可获取,<code>xv6</code>中已经封装好接口<code>cpuid()</code>,但是调用该接口时,需要关闭中断, 读取完成后, 还需要开启中断.</li>
<li>进行<code>steal</code>操作时, 需要防止死锁.</li>
<li>初始化时, 可以将所有未使用的内存都挂载在<code>cpu 0</code>上.</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ul>
<li><code>memory</code>初始化:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *freelist;</span><br><span class="line">  <span class="type">int</span>  freesize;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];</span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">  	<span class="built_in">snprintf</span>(kmem[i].name, <span class="number">16</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;kmem&quot;</span>, i);</span><br><span class="line">	<span class="built_in">initlock</span>(&amp;kmem[i].lock, kmem[i].name);</span><br><span class="line">	kmem[i].freelist = <span class="number">0</span>;</span><br><span class="line">	kmem[i].freesize = <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="comment">// we wiil alloc each cup heap lock and list</span></span><br><span class="line">  <span class="built_in">freerange</span>(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kfree</code>操作:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Free the page of physical memory pointed at by v,</span></span><br><span class="line"><span class="comment">// which normally should have been returned by a</span></span><br><span class="line"><span class="comment">// call to kalloc().  (The exception is when</span></span><br><span class="line"><span class="comment">// initializing the allocator; see kinit above.)</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line">  r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> hart = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[hart].lock);</span><br><span class="line">  r-&gt;next = kmem[hart].freelist;</span><br><span class="line">  kmem[hart].freelist = r;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[hart].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>kalloc</code>操作:<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate one 4096-byte page of physical memory.</span></span><br><span class="line"><span class="comment">// Returns a pointer that the kernel can use.</span></span><br><span class="line"><span class="comment">// Returns 0 if the memory cannot be allocated.</span></span><br><span class="line"><span class="function"><span class="type">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">run</span> *r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//add this block to the free list</span></span><br><span class="line">  <span class="built_in">push_off</span>();</span><br><span class="line">  <span class="type">int</span> hart = <span class="built_in">cpuid</span>();</span><br><span class="line">  <span class="built_in">pop_off</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;kmem[hart].lock);</span><br><span class="line">  r = kmem[hart].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">  	kmem[hart].freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;kmem[hart].lock);</span><br><span class="line">  <span class="keyword">if</span>(r == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="comment">// we steal memory from other cpus</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NCPU; ++i) &#123;</span><br><span class="line">		<span class="built_in">acquire</span>(&amp;kmem[i].lock);</span><br><span class="line">		r = kmem[i].freelist;</span><br><span class="line">		<span class="keyword">if</span>(r) &#123;</span><br><span class="line">			kmem[i].freelist = r-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">release</span>(&amp;kmem[i].lock);</span><br><span class="line">		<span class="keyword">if</span>(r) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This half of the assignment is independent from the first half; you can work on this half (and pass the tests) whether or not you have completed the first half.</span><br><span class="line"></span><br><span class="line">If multiple processes use the file system intensively, they will likely contend for bcache.lock, which protects the disk block cache in kernel/bio.c. bcachetest creates several processes that repeatedly read different files in order to generate contention on bcache.lock; its output looks like this (before you complete this lab):</span><br><span class="line"></span><br><span class="line">$ bcachetest</span><br><span class="line">start test0</span><br><span class="line">test0 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 0 #acquire() 33035</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: virtio_disk: #fetch-and-add 162870 #acquire() 1188</span><br><span class="line">lock: proc: #fetch-and-add 51936 #acquire() 73732</span><br><span class="line">lock: bcache: #fetch-and-add 16142 #acquire() 65978</span><br><span class="line">lock: uart: #fetch-and-add 7505 #acquire() 117</span><br><span class="line">lock: proc: #fetch-and-add 6937 #acquire() 73420</span><br><span class="line">tot= 16142</span><br><span class="line">test0: FAIL</span><br><span class="line">start test1</span><br><span class="line">test1 OK</span><br><span class="line">You will likely see different output, but the number of acquire loop iterations for the bcache lock will be high. If you look at the code in kernel/bio.c, you&#x27;ll see that bcache.lock protects the list of cached block buffers, the reference count (b-&gt;refcnt) in each block buffer, and the identities of the cached blocks (b-&gt;dev and b-&gt;blockno).</span><br></pre></td></tr></table></figure>
<ul>
<li>这个题目要求实现磁盘的<code>cache</code>的优化, 之前所有的设备请求都挂在一个链式的<code>cahce</code>上.所有针对磁盘的<code>block</code>请求读写全部共享一把锁, 这就必然会造成锁的请求冲突, 从而影响读写效率, 现在要求对读写的<code>cache buffer</code>进行优化, 从而降低锁的请求冲突, 从而提升效率.细节实现如下:<ul>
<li>题目中最关键的提示使用<code>hash table</code>,对应于不同的<code>block</code>请求通过<code>hash</code>映射到不同的<code>buffer</code>中, 从而降低锁的冲突. 当<code>hash</code>对应的<code>bucket</code>用完时, 则需要从别的<code>bucket</code>中未使用的<code>buffer</code>中<code>steal</code>一些.实际采用链式<code>hash</code>即可, 即每个<code>bucket</code>存储的是<code>buffer</code>的<code>list</code>.</li>
<li>题目中最需要值得处理的细节是, 即同一个<code>dev</code>和<code>block</code>对应的<code>buffer</code>具有唯一性, 这样保证不同的线程读取或者写入的<code>blcok</code>的<code>cache buffer</code>是同一个, 这样就能保证原子性, 否则则会出现读写不一致的问题, 这点也是本<code>lab</code>比较难处理的地方.</li>
<li>具体实现时, 我们需要对<code>hash table</code>的每个<code>bucket</code>进行加锁操作, 当对该<code>bucket</code>操作时, 则需要获取锁, 操作完成后, 需要释放该锁.但是如何保证每个唯一的<code>dev</code>和<code>block</code>对应的唯一性的<code>buffer</code>,则需要处理稍微麻烦一些, 首先我们查找该<code>block</code>对应的<code>bucket</code>是否对应其含有的<code>dev</code>和<code>block</code>, 如果已经含有表示其已经进行缓存了, 则直接进行返回查找到的<code>buffer</code>即可; 否则我们先获取全局锁，再获取该<code>bucket</code>对应的锁, 再次再该<code>bucket</code>中进行查找一遍, 是否有存在该<code>block</code>对应的<code>buffer</code>缓存, 这样做的目的是为了防止, <code>bucket</code>释放锁到获取全局锁之间的这段时间中, 是否有其他的线程将该<code>block</code>对应的<code>buffer</code>进行了更新, 从而保证<code>block</code>对应的<code>buffer</code>的唯一性.我们在所有的<code>bucket</code>中找到一个最久且未使用的<code>buffer</code>分配给该<code>block</code>, 然后将该<code>buffer</code>移动到该<code>block</code>对应的<code>bucket</code>中.这样就完成了<code>steal</code>的操作.</li>
<li>我们查找时优先从该<code>bucket</code>找到一个未使用的<code>buffer</code>, 如果未找到则从其他的<code>bucket</code>中进行查找即可.</li>
<li>题目中很容易出的问题是会报<code>panic: freeing free block</code>的错误, 这个可能是之前的代码错误导致文件系统<code>fs</code>中的<code>block</code>存在错误, 解决办法是执行<code>maka clean</code>操作, 从新编译一遍文件系统<code>fs</code>即可.</li>
</ul>
</li>
</ul>
<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><ul>
<li><p>从新定义<code>bcache</code>的结构, 采用<code>hashtable</code>的方式存储<code>buf</code>信息.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HASH_BUCKETS 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line"><span class="keyword">extern</span> uint ticks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> buf[NBUF]; </span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line">  <span class="comment">// hash table </span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> hashlock[MAX_HASH_BUCKETS];</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> hashtable[MAX_HASH_BUCKETS];</span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化<code>bcache</code>操作, 此时我们需要初始化每个<code>bucket</code>对应的锁,并初始化每个<code>bucket</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line">	<span class="comment">// init buffer lock and init free list buffer</span></span><br><span class="line">	<span class="comment">// initial the hash table and hash lock</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line">		<span class="built_in">initlock</span>(&amp;bcache.hashlock[i], <span class="string">&quot;hashlock&quot;</span>);</span><br><span class="line">		<span class="comment">// Create linked list of buffers</span></span><br><span class="line">		bcache.hashtable[i].prev = &amp;bcache.hashtable[i];</span><br><span class="line">		bcache.hashtable[i].next = &amp;bcache.hashtable[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">initlock</span>(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf + NBUF; b++)&#123;</span><br><span class="line">		<span class="built_in">initsleeplock</span>(&amp;b-&gt;lock, <span class="string">&quot;bufferlock&quot;</span>);</span><br><span class="line">		b-&gt;timestamp = <span class="number">0</span>;</span><br><span class="line">		b-&gt;dev = <span class="number">-1</span>;</span><br><span class="line">		b-&gt;blockno = <span class="number">-1</span>;</span><br><span class="line">		b-&gt;refcnt = <span class="number">0</span>;</span><br><span class="line">		b-&gt;next = bcache.hashtable[<span class="number">0</span>].next;</span><br><span class="line">		b-&gt;prev = &amp;bcache.hashtable[<span class="number">0</span>];</span><br><span class="line">		bcache.hashtable[<span class="number">0</span>].next-&gt;prev = b;</span><br><span class="line">		bcache.hashtable[<span class="number">0</span>].next = b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>查找<code>block</code>对应的<code>buffer</code>时, 操作稍微麻烦一些.　我们首先在<code>bucket</code>中进行查找, 然后获取全局锁, 从其他的<code>bucket</code>中的查找一个未使用的<code>buffer</code>.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Look through buffer cache for block on device dev.</span></span><br><span class="line"><span class="comment">// If not found, allocate a buffer.</span></span><br><span class="line"><span class="comment">// In either case, return locked buffer.</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">buf</span>*</span><br><span class="line"><span class="built_in">bget</span>(uint dev, uint blockno)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> *b;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">buf</span> * lrub = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> minticks = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> no = <span class="built_in">bhash</span>(blockno);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// Is the block already cached?</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached.</span></span><br><span class="line">  <span class="comment">// Recycle the least recently used (LRU) unused buffer.</span></span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.lock);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.hashtable[no].next; b != &amp;bcache.hashtable[no]; b = b-&gt;next)&#123;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">	  <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">      <span class="built_in">acquiresleep</span>(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">		lrub = b;</span><br><span class="line">		minticks = b-&gt;timestamp;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">  	lrub-&gt;dev = dev;</span><br><span class="line">	lrub-&gt;blockno = blockno;</span><br><span class="line">    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">	lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">	<span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">    <span class="built_in">acquiresleep</span>(&amp;lrub-&gt;lock);</span><br><span class="line">	<span class="keyword">return</span> lrub;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we steal a buffer block from other buckets</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_HASH_BUCKETS; ++i) &#123;</span><br><span class="line">	<span class="type">int</span> newno = <span class="built_in">bhash</span>(no + i);</span><br><span class="line">	<span class="built_in">acquire</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">  	<span class="keyword">for</span> (b = bcache.hashtable[newno].prev; b != &amp;bcache.hashtable[newno]; b = b-&gt;prev)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; minticks &gt;= b-&gt;timestamp) &#123;</span><br><span class="line">			lrub = b;</span><br><span class="line">			minticks = b-&gt;timestamp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lrub) &#123;</span><br><span class="line">	  	lrub-&gt;dev = dev;</span><br><span class="line">		lrub-&gt;blockno = blockno;</span><br><span class="line">	    lrub-&gt;valid = <span class="number">0</span>;</span><br><span class="line">		lrub-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">		lrub-&gt;next-&gt;prev = lrub-&gt;prev;</span><br><span class="line">		lrub-&gt;prev-&gt;next = lrub-&gt;next;</span><br><span class="line">		lrub-&gt;next = bcache.hashtable[no].next;</span><br><span class="line">		lrub-&gt;prev = &amp;bcache.hashtable[no];</span><br><span class="line">		bcache.hashtable[no].next-&gt;prev = lrub;</span><br><span class="line">    	bcache.hashtable[no].next = lrub;</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">		<span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">	    <span class="built_in">acquiresleep</span>(&amp;lrub-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span> lrub;</span><br><span class="line">	&#125;</span><br><span class="line">  	<span class="built_in">release</span>(&amp;bcache.hashlock[newno]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.lock);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we check the the cache again and the one block must atomic  </span></span><br><span class="line">  <span class="built_in">panic</span>(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>释放<code>buffer</code>时, 则我们需要记录该<code>buffer</code>的<code>timestamp</code>,用于<code>lru</code>算法.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Release a locked buffer.</span></span><br><span class="line"><span class="comment">// Move to the head of the most-recently-used list.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(<span class="keyword">struct</span> buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">holdingsleep</span>(&amp;b-&gt;lock))</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">releasesleep</span>(&amp;b-&gt;lock);</span><br><span class="line">  <span class="type">int</span> no = <span class="built_in">bhash</span>(b-&gt;blockno);</span><br><span class="line">  <span class="built_in">acquire</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line"> 	b-&gt;timestamp = <span class="built_in">btime</span>();</span><br><span class="line">  &#125; 	</span><br><span class="line">  <span class="built_in">release</span>(&amp;bcache.hashlock[no]);</span><br><span class="line">  <span class="comment">// bdegub();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bhash</span><span class="params">(<span class="type">int</span> blockno)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> blockno%MAX_HASH_BUCKETS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">btime</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ticks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><ul>
<li>通过这一章的学习，其实给了许多可以思考的地方，从本质上思考锁的作用和原理，以及<code>sleep</code>和<code>wakeup</code>的实现原理，非常简洁而又优雅的实现方式.</li>
<li>下一步计划:</li>
<li><ul>
<li>完成<code>option chanllenge</code>的<code>project</code>;</li>
</ul>
</li>
<li><ul>
<li>仔细研究一下无锁队列的实现，在<code>xv6</code>中添加无锁队列;</li>
</ul>
</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a target="_blank" rel="noopener" href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#公开课学习" >
    <span class="tag-code">公开课学习</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/52/">
        <span class="nav-arrow">← </span>
        
          【clickhouse】 clickhouse学习记录(一)
        
      </a>
    
    
      <a class="nav-right" href="/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/58/">
        
          【MIT6.S081】 lab7 thread
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo="mike-box/blogtalk"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#lock"><span class="toc-nav-text">lock</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-nav-text">实现代码</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Memory-allocator"><span class="toc-nav-text">Memory allocator</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-nav-text">代码实现</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Buffer-cache"><span class="toc-nav-text">Buffer cache</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-nav-text">代码实现：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#%E6%80%9D%E8%80%83%E6%80%BB%E7%BB%93"><span class="toc-nav-text">思考总结</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-text"></span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/11/20/公开课学习/53/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>







  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>



<!-- Baidu Tongji -->


<script src="/js/script.js"></script>



  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  </body>
</html>