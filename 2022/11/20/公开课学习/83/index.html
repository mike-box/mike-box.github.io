<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="good study, day day up">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      【MIT6.S081】lab10 mmap | 且听疯吟
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>且听疯吟</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>【MIT6.S081】lab10 mmap</h2>
  <p class="post-date">2022-11-20</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="MIT-6-S081-lab10"><a href="#MIT-6-S081-lab10" class="headerlink" title="MIT 6.S081 lab10"></a>MIT 6.S081 lab10</h2><p>感觉这个 <code>lab</code> 还是挺有意思的，但是感觉没有前面几个 <code>lab</code> 难，感觉前面几个 <code>lab</code> 的难度太大了，这个 <code>lab</code> 花了<code>2</code> 天左右就完成了，当前中间还是有些点比较有疑问的问题，后续还需要进一步来思考的空间。在这个 <code>lab</code> 中的学习内容比较多，主要学习了以下几个知识重点:</p>
<ul>
<li><code>mmap</code> 的实现原理：如果仅仅实现 <code>mmap</code> 的话，原理比较简单。每次发起系统调用 <code>mmap</code> 时，就会在该进程的内核空间中申请一块内存并与之对应 <code>WMA AREA</code> 相对应，并更新当前进程的页表，如果我们使用 <code>lazy alloc</code>，此时并不会马上更新物理内存的内容，也并未申请实际的物理页与之相对应。</li>
<li>当进程读取到该 <code>VMA</code> 对应的内存区域时，会发生缺页中断，当进程捕获到该中断时会检测缺页的地址是否属于某个 <code>VMA</code>，如果该地址合法则申请新的物理页并将其进行 <code>mapping</code> 到 <code>VMA</code> 给定的地址空间中。同时将给定的 <code>fd</code> 中对应的内容读取到该物理页中，此时对于用户空间的应用则可以读取到相应的 <code>fd</code> 对应的内容，我们可以将同一个 <code>fd</code> 中对应的内容 <code>map</code> 到多个进程中。实际上每个 <code>fd</code> 可能对应的是某个文件或者设备，我们如果将其映射到内存的地址空间中就可以很方便和快速的进行读写与共享。 </li>
<li>当我们试图对 <code>VMA</code> 对应的内存进行修改时，修改的内容暂时保存在物理内存中，比如可能多个应用程序对某个文件进行多次写操作，但这些执行都保存在内存中并未实际写入到文件中，当我们执行 <code>unmap</code> 操作时，操作系统才可能将这些修改内容一次性的全部写入到文件中，这是一种非常高效的共享机制。</li>
<li>使得用户空间的程序能够处理进程捕获的 <code>page fault</code>，这就需要每个用户进程在内核空间存在一个对应的内核线程来传递这些 <code>trap</code>。用户空间中能够处理这样 <code>trap</code>，并同时能够对物理页进行操纵。用户空间的 <code>handler</code> 处理完成后，再返回内核。</li>
</ul>
<p>重要的是本章节提到了 <code>Baker&#39;s Real-Time Copying Garbage Collector</code> 的运行工作原理:<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202211121533490.png"><br>当然其中的原理还是挺复杂，需要专门的一个章节来完成。</p>
<h4 id="lab10-mmap"><a href="#lab10-mmap" class="headerlink" title="lab10 mmap"></a>lab10 mmap</h4><p>本章的 <code>lab</code> 比较起来就不算是特别难的 <code>lab</code> 了。但是 <code>lab</code> 后面的 <code>Optional challenges</code> 难度就非常大了，可能需要花费非常多的时间来完成了。所有的源代码都放在<a target="_blank" rel="noopener" href="https://github.com/mike-box/MIT6.S081">github</a>。</p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The mmap and munmap system calls allow UNIX programs to exert detailed control over their address spaces. They can be used to share memory among processes, to map files into process address spaces, and as part of user-level page fault schemes such as the garbage-collection algorithms discussed in lecture. In this lab you&#x27;ll add mmap and munmap to xv6, focusing on memory-mapped files.</span><br><span class="line">Fetch the xv6 source for the lab and check out the mmap branch:</span><br><span class="line"></span><br><span class="line">  $ git fetch</span><br><span class="line">  $ git checkout mmap</span><br><span class="line">  $ make clean</span><br><span class="line">The manual page (run man 2 mmap) shows this declaration for mmap:</span><br><span class="line"></span><br><span class="line">void *mmap(void *addr, size_t length, int prot, int flags,</span><br><span class="line">           int fd, off_t offset);</span><br><span class="line">mmap can be called in many ways, but this lab requires only a subset of its features relevant to memory-mapping a file. You can assume that addr will always be zero, meaning that the kernel should decide the virtual address at which to map the file. mmap returns that address, or 0xffffffffffffffff if it fails. length is the number of bytes to map; it might not be the same as the file&#x27;s length. prot indicates whether the memory should be mapped readable, writeable, and/or executable; you can assume that prot is PROT_READ or PROT_WRITE or both. flags will be either MAP_SHARED, meaning that modifications to the mapped memory should be written back to the file, or MAP_PRIVATE, meaning that they should not. You don&#x27;t have to implement any other bits in flags. fd is the open file descriptor of the file to map. You can assume offset is zero (it&#x27;s the starting point in the file at which to map).</span><br><span class="line"></span><br><span class="line">It&#x27;s OK if processes that map the same MAP_SHARED file do not share physical pages.</span><br><span class="line"></span><br><span class="line">munmap(addr, length) should remove mmap mappings in the indicated address range. If the process has modified the memory and has it mapped MAP_SHARED, the modifications should first be written to the file. An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</span><br></pre></td></tr></table></figure>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li><code>mmap</code> 的实现: 在这个 <code>lab</code> 中 <code>mmap</code> 的实现就非常简单了，我们首先观察一下该函数的模型<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure></li>
<li>它接受 <code>6</code> 个参数:<ul>
<li><code>addr</code> 指定的映射地址;</li>
<li><code>length</code> 指定的映射的内存长度;</li>
<li><code>prot</code> 指定的读写权限;</li>
<li><code>flags</code> 指定的该映射的模式，如果为 <code>MAP_SHARED</code> 表示映射的内存会回写到指定的<code>fd</code> 中, 还有其他的标志位；</li>
<li><code>fd</code> 指定的文件的描述符；</li>
<li><code>offset</code> 指定的文件的偏移量;</li>
</ul>
</li>
</ul>
<p>给定的 <code>lab</code> 只要求完成基本的功能即可，即不考虑文件的 <code>偏移量</code> 并且不指定映射的地址空间，实际我们实现时只需要在该进程的虚拟地址空间末尾增减 <code>length</code> 长度，然后将其新增加的尾部地址空间映射到指定 <code>fd</code> 上即可，实现非常简单了。里面有几个难点如下:</p>
<ul>
<li><p>首先我们直接将该进程的地址空间增减 <code>length</code> 长度，当然这里涉及到内存对齐的问题，这是由于进程每次只能向内核申请以物理页为最小单位的内存，所以这里需要处理涉及到内存对齐的问题，即映射的地址空间的起始位置要对齐 <code>PG_SIZE</code>。我们可以参考 <code>cow lab</code> 中的实现，直接将内存空间增大即可。</p>
</li>
<li><p>第二步我们需要在该进程中记录映射的区域，即所有的 <code>vma</code>，由于给定的 <code>lab</code> 中最大的 <code>vma</code> 只有 <code>16</code> 个，我们可以采用数组或者链表来实现，实现的 <code>linux</code> 实现就非常复杂了，实际处理应该是用的 <code>reb-black tree</code> 来记录所有的 <code>vma</code>，因为涉及到 <code>vma</code> 的查找，此时利用高效的二分搜索才能提高查找效率。</p>
</li>
<li><p>第三步，比较重要的是我们要完成真正的映射，前面提到过我们仅仅增加了进程的地址空间但并未分配实际的物理页，当存在某些程序读取到该未分配的地址空间时就会触发缺页中断，此时我们就需要在 <code>user trap</code> 中进行处理，此时我们就查找该进程的 <code>vma</code>，查找缺页的地址是否在 <code>vma</code> 记录中，</p>
<ul>
<li>如果在 <code>vma</code> 中，则我们从堆中申请一个新的物理页，并从 <code>vma</code> 中记录的 <code>fd</code> 中读取一个页长度的内容到新加入的物理页中。此时需要注意的是我们计算读取内从的 <code>offset</code>，稍微需要一点技巧。</li>
<li>如果该地址不在 <code>vma</code> 中，则将直接返回缺页中断。</li>
</ul>
</li>
<li><p>以上即完成了基本的 <code>map</code> 功能。</p>
</li>
<li><p><code>munmap</code> 的实现: 首先我们观察一下 <code>munmap</code> 的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">munmap(addr, length)</span><br></pre></td></tr></table></figure></li>
<li><p>给定的参数只有两个指定的地址与长度，我们在进行 <code>umap</code> 操作时，首先会计算物理页的长度，由于题目给定的限定条件为 <code>umanp</code> 操作只会从起始地址到结束地址依次进行 <code>umap</code> 而不会存在从中间进行 <code>umap</code> 的操作，因此就比较容易实现。</p>
<ul>
<li>首先我们从 <code>vma</code> 中查找给定的 <code>addr</code> 是否合法，如果合法则将其从中去除，并查看该 <code>vma</code> 的对应的 <code>flag</code>，如果 <code>flag</code> 为 <code>MAP_SHARED</code> 则将其写回到文件中，当然这里实际应该需要处理一下文件的 <code>offset</code> 的问题，存在一定的瑕疵。</li>
<li>上述操作完成后，则将该段地址对应的物理页内存全部释放掉。当然我比较异疑惑的一点，对应的物理内存页释放掉，但是进程的地址空间实际没有进行变化，按道理此时进程的地址空间也应该释放掉一部分，否则每次访问该对应的地址都会出现 <code>page fault</code> 的问题。</li>
</ul>
</li>
<li><p>对于 <code>fork</code> 子进程时，子进程创建时需要复制父进程的 <code>vma</code> 表项，当进程退出进行 <code>exit</code> 时需要释放 <code>vma</code>，并将其所有的内容可以写回需要写回到文件中。</p>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ol>
<li><p>增加 <code>sys_map</code> 与 <code>sys_umap</code> 的系统调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="title">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> </span>= &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_mmap]    sys_mmap,</span><br><span class="line">[SYS_munmap]   sys_munmap</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vma</code> 结构的定义如下，并在 <code>proc</code> 结构体中增加 <code>vma</code> 表项，每次 <code>vma</code> 都对应记录地址映射的内容。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* vam entry */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">vmaEntry</span> &#123;</span><br><span class="line">	uint64 addr;</span><br><span class="line">	uint32 length;</span><br><span class="line">	uint32 permissions;</span><br><span class="line">	uint32 flag;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> *pf;</span><br><span class="line">	uint32 offset;</span><br><span class="line">	uint32 valid;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmaEntry</span> *next;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">vmaEntry</span> *prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-process state</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">proc</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">spinlock</span> lock;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">procstate</span> state;        <span class="comment">// Process state</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *parent;         <span class="comment">// Parent process</span></span><br><span class="line">  <span class="type">void</span> *chan;                  <span class="comment">// If non-zero, sleeping on chan</span></span><br><span class="line">  <span class="type">int</span> killed;                  <span class="comment">// If non-zero, have been killed</span></span><br><span class="line">  <span class="type">int</span> xstate;                  <span class="comment">// Exit status to be returned to parent&#x27;s wait</span></span><br><span class="line">  <span class="type">int</span> pid;                     <span class="comment">// Process ID</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">  uint64 sz;                   <span class="comment">// Size of process memory (bytes)</span></span><br><span class="line">  <span class="type">pagetable_t</span> pagetable;       <span class="comment">// User page table</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">trapframe</span> *trapframe; <span class="comment">// data page for trampoline.S</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">context</span> context;      <span class="comment">// swtch() here to run process</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *ofile[NOFILE];  <span class="comment">// Open files</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">inode</span> *cwd;           <span class="comment">// Current directory</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">16</span>];               <span class="comment">// Process name (debugging)</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">vmaEntry</span> vma[<span class="number">16</span>];         <span class="comment">// Process vma entry</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>sys_map</code> 与 <code>sys_umap</code> 的实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;riscv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;defs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;proc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleeplock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sysmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a, b) ((a) &lt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_readfile</span><span class="params">(<span class="type">int</span> vma_offset, <span class="type">int</span> offset, uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">file</span> *pf = p-&gt;vma[vma_offset].pf;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	ret = <span class="built_in">readi</span>(pf-&gt;ip, <span class="number">0</span>, addr, offset, length);</span><br><span class="line">	<span class="built_in">iunlock</span>(pf-&gt;ip);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_writefile</span><span class="params">(<span class="keyword">struct</span> file *pf, <span class="type">int</span> offset, uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">begin_op</span>();</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	ret = <span class="built_in">writei</span>(pf-&gt;ip, <span class="number">1</span>, addr, offset, length);</span><br><span class="line">	<span class="built_in">ilock</span>(pf-&gt;ip);</span><br><span class="line">	<span class="built_in">end_op</span>();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_init</span><span class="params">(<span class="keyword">struct</span> vmaEntry *vma)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">	  vma[i].valid = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_copy</span><span class="params">(<span class="keyword">struct</span> vmaEntry *src, <span class="keyword">struct</span> vmaEntry *dst)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (src[i].valid) &#123;</span><br><span class="line">		   dst[i].addr = src[i].addr;</span><br><span class="line">		   dst[i].length = src[i].length;</span><br><span class="line">		   dst[i].permissions = src[i].permissions;</span><br><span class="line">		   dst[i].flag = src[i].flag;</span><br><span class="line">		   dst[i].pf = src[i].pf;</span><br><span class="line">		   dst[i].offset = src[i].offset;</span><br><span class="line">		   dst[i].valid = <span class="number">1</span>;</span><br><span class="line">		   dst[i].pf = <span class="built_in">filedup</span>(dst[i].pf);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		   dst[i].valid = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_query</span><span class="params">(uint64 va)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">   	   <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">		   <span class="type">int</span> offset = va - p-&gt;vma[i].addr;</span><br><span class="line">		   <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; p-&gt;vma[i].length) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">		   &#125;</span><br><span class="line">   	   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_add</span><span class="params">(uint64 addr, <span class="keyword">struct</span> file *f, <span class="type">int</span> len, <span class="type">int</span> prot, <span class="type">int</span> flag, <span class="type">int</span> offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* record the vma of the current process */</span></span><br><span class="line">  f-&gt;ref++;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_ENTRY_SIZE; i++) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (!p-&gt;vma[i].valid) &#123;</span><br><span class="line">		p-&gt;vma[i].valid = <span class="number">1</span>;</span><br><span class="line">		p-&gt;vma[i].addr = addr;</span><br><span class="line">		p-&gt;vma[i].length = len;</span><br><span class="line">		p-&gt;vma[i].permissions = prot;</span><br><span class="line">		p-&gt;vma[i].flag = flag;</span><br><span class="line">		p-&gt;vma[i].pf = f;</span><br><span class="line">		p-&gt;vma[i].offset = offset &amp; ~(PGSIZE - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_vma_remove</span><span class="params">(<span class="type">int</span> vma_offset)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="keyword">if</span> ((p-&gt;vma[vma_offset].permissions &amp; PROT_WRITE) &amp;&amp; p-&gt;vma[vma_offset].flag == MAP_SHARED) &#123;</span><br><span class="line">		<span class="built_in">filewrite</span>(p-&gt;vma[vma_offset].pf, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">uvmunmap</span>(p-&gt;pagetable, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length / PGSIZE, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* remove all mapped pages */</span></span><br><span class="line">	p-&gt;vma[vma_offset].pf-&gt;ref--;</span><br><span class="line">	p-&gt;vma[vma_offset].valid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">map_unmap</span><span class="params">(uint64 addr, <span class="type">int</span> length)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(addr);</span><br><span class="line">	<span class="keyword">if</span> (vma_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;vma[vma_offset].flag == MAP_SHARED) &#123;</span><br><span class="line">		<span class="built_in">filewrite</span>(p-&gt;vma[vma_offset].pf, p-&gt;vma[vma_offset].addr, p-&gt;vma[vma_offset].length);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">uvmunmap</span>(p-&gt;pagetable, p-&gt;vma[vma_offset].addr, length / PGSIZE, <span class="number">0</span>);</span><br><span class="line">	p-&gt;vma[vma_offset].length -= length;</span><br><span class="line">	p-&gt;vma[vma_offset].addr += length;</span><br><span class="line">	<span class="comment">/* remove all mapped pages */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;vma[vma_offset].length == <span class="number">0</span>) &#123;</span><br><span class="line">		p-&gt;vma[vma_offset].pf-&gt;ref--;</span><br><span class="line">		p-&gt;vma[vma_offset].valid = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* map files into process address spaces */</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;	</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">int</span> prot;</span><br><span class="line">  <span class="type">int</span> flag;</span><br><span class="line">  <span class="type">int</span> offset;</span><br><span class="line">  <span class="type">int</span> fd;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">file</span> *f;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* parse syscall args */</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || \</span><br><span class="line">  	 <span class="built_in">argint</span>(<span class="number">3</span>, &amp;flag) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">5</span>, &amp;offset) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* fd to file struct */</span></span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span> || fd &gt;= NOFILE || (f = <span class="built_in">myproc</span>()-&gt;ofile[fd]) == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we check the file readable and writeable */</span></span><br><span class="line">  <span class="keyword">if</span> (f-&gt;writable == <span class="number">0</span> &amp;&amp; flag == MAP_SHARED &amp;&amp; (prot &amp; PROT_WRITE)) &#123;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* we add the map address at the end of virtual address */</span></span><br><span class="line">  addr = <span class="built_in">myproc</span>()-&gt;sz;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p-&gt;sz + len &gt; MAXVA) &#123;</span><br><span class="line">	  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p-&gt;sz += len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">map_vma_add</span>(addr, f, len, prot, flag, offset);</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* unmap files into process address spaces */</span></span><br><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint64 addr;	</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* parse syscall args */</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">argaddr</span>(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || <span class="built_in">argint</span>(<span class="number">1</span>, &amp;len) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* we add the map address at the end of virtual address */</span>	</span><br><span class="line">	<span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(addr);</span><br><span class="line">	<span class="keyword">if</span> (vma_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">/* remove all the pages from process */</span></span><br><span class="line">	<span class="built_in">map_unmap</span>(addr, len);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> `usertrap` 的实现：需要检测缺页中断，并去按照不同的缺页中断去处理，主要检测缺页的地址是否属于 `vma` 表项。</span><br><span class="line">```C++</span><br><span class="line">uint64 pcode = <span class="built_in">r_scause</span>();</span><br><span class="line">uint64 va = <span class="built_in">PGROUNDDOWN</span>(<span class="built_in">r_stval</span>());</span><br><span class="line"><span class="comment">// uint64 epc = r_sepc();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line"><span class="keyword">if</span> (pcode == <span class="number">15</span> || pcode == <span class="number">13</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> vma_offset = <span class="built_in">map_vma_query</span>(va);</span><br><span class="line">    <span class="keyword">if</span> (vma_offset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// alloc a page</span></span><br><span class="line">        <span class="type">char</span> *mem = <span class="built_in">kalloc</span>();  </span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="type">int</span> offset = p-&gt;vma[vma_offset].offset + <span class="built_in">PGROUNDDOWN</span>(va - p-&gt;vma[vma_offset].addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get mmap page fault! va = %p\n&quot;</span>, va);</span><br><span class="line">        <span class="built_in">map_readfile</span>(vma_offset, offset, (uint64)mem, PGSIZE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mapper a page for va</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va), PGSIZE, (uint64)mem, (p-&gt;vma[vma_offset].permissions &lt;&lt; <span class="number">1</span>) | PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">kfree</span>(mem);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;get mmap page fault! va = %p\n&quot;</span>, va);</span><br><span class="line">            p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> fail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p-&gt;trapframe-&gt;epc += epc;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fork</code> 操作时同时复制 <code>vma</code> 表项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map_vma_init</span>(np-&gt;vma);</span><br><span class="line"><span class="built_in">map_vma_copy</span>(p-&gt;vma, np-&gt;vma);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">    np-&gt;vma[i].pf = <span class="built_in">filedup</span>(p-&gt;vma[i].pf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exit</code> 操作时，同时移除 <code>vma</code> 表项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove all map virtual address</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vma[i].valid) &#123;</span><br><span class="line">    <span class="built_in">map_vma_remove</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说这个 <code>lab</code> 还是非常有挑战性的，是个好的 <code>lab</code>，用户空间的 <code>page fault</code> 处理确实是个非常有效的利器，后期会继续深入学习以下 <code>GC</code> 的处理流程。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a target="_blank" rel="noopener" href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png" alt="1"></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#公开课学习" >
    <span class="tag-code">公开课学习</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/11/20/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/81/">
        <span class="nav-arrow">← </span>
        
          【CSAPP】 lab3
        
      </a>
    
    
      <a class="nav-right" href="/2022/11/20/%E5%8A%9B%E6%89%A3%E5%91%A8%E8%B5%9B%E9%A2%98%E8%A7%A3/54/">
        
          kickstart 2021 round  H
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo="mike-box/blogtalk"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#MIT-6-S081-lab10"><span class="toc-nav-text">MIT 6.S081 lab10</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#lab10-mmap"><span class="toc-nav-text">lab10 mmap</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-nav-text">题目</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%80%9D%E8%80%83"><span class="toc-nav-text">思考</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-nav-text">代码</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-nav-text">总结</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-text"></span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/11/20/公开课学习/83/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>







  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2023 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
  <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
</footer>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>



<!-- Baidu Tongji -->


<script src="/js/script.js"></script>



  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'forest'});
    }
  </script>


  </body>
</html>