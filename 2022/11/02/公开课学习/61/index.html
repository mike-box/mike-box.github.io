<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="good study, day day up">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      【MIT6.S081】 lab5 lazy alloaction | Mike Meng Blog
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    
<script src="/js/qrious.js"></script>

  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
  
    
<script src="/js/local-search.js"></script>


<meta name="generator" content="Hexo 5.4.2"></head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Mike Meng Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/series/" class="item-link">Series</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
      
        <li class="menu-item menu-item-search right-list">
    <a role="button" class="popup-trigger">
        <i class="fa fa-search fa-fw"></i>
    </a>
</li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/series/" class="menu-link">Series</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
    
      <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
            <span class="search-icon">
                <i class="fa fa-search"></i>
            </span>
            <div class="search-input-container">
                <input autocomplete="off" autocapitalize="off"
                    placeholder="Please enter your keyword(s) to search." spellcheck="false"
                    type="search" class="search-input">
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times-circle"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>
    
  </div>
</header>

    <div id="article-banner">
  <h2>【MIT6.S081】 lab5 lazy alloaction</h2>
  <p class="post-date">2022-11-02</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h1 id="lazy-alloaction"><a href="#lazy-alloaction" class="headerlink" title="lazy alloaction"></a>lazy alloaction</h1><p>感觉这个<code>lab</code>是最近感觉最容易的<code>lab</code>了，只花了一天就完成了<code>lab</code>，还是感谢网络资源，感谢各位后浪们的付出，将课件翻译成中文版，翻译的质量很好，通过阅读<code>lecture</code>即可很快的熟悉相关的<code>lazy allocation</code>的原理描述，利用<code>trap</code>来实现。我们再来仔细看一下<code>trap</code>的原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">中断现场-&gt;保存现场-&gt; 处理trap -&gt;恢复现场-&gt;恢复运行</span><br></pre></td></tr></table></figure>
<p>利用<code>trap</code>我们可以进行相关的指令跳转，来执行我们需要的操作，执行完成之后，我们再恢复指令重新执行。所以我们可以利用<code>trap</code>来进行<code>lazy allocation</code>.按需申请物理内存资源，我们在申请内存时，可以先对只对该虚拟地址<code>va</code>进行标记，如果实际的程序需要进行访问该<code>va</code>时，我们再申请实际的物理内存页进行映射，映射完成后我们再恢复指令运行。<br><a target="_blank" rel="noopener" href="https://github.com/mike-box/MIT6.S081/tree/main/lab-lazy-handin">git repo</a></p>
<h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk"></a>Eliminate allocation from sbrk</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process&#x27;s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process&#x27;s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory -- so you should delete the call to growproc() (but you still need to increase the process&#x27;s size!).</span><br></pre></td></tr></table></figure>
<p>这个非常容易实现，我们只需要在<code>sys_sbrk</code>函数内部对地址进行标记，标记该进程已经拥有该地址空间即可。<br>我们可以仔细分析一下内存<br><img src="https://i.loli.net/2021/08/24/OoGUsINFqVa62cy.png"><br>我们可以看到代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> * p = <span class="built_in">myproc</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">argint</span>(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  addr = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;sz + n &gt; MAXVA) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  	p-&gt;sz += n;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">growproc</span>(n) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the printf call that produced the &quot;usertrap(): ...&quot; message. Modify whatever other xv6 kernel code you need to in order to get echo hi to work.</span><br></pre></td></tr></table></figure>
<ul>
<li>实现在发生<code>trap</code>时我们时，我们首先判断发生<code>trap</code>时的地址是否合法，如果合法则我们认为该内存是<code>lazy allocation</code>，此时我们就<code>kalloc</code>一页实际的物理内存，然后进行映射，映射完成后，我们将<code>trap</code>恢复时执行的指令地址设置为$sepc$寄存器中的地址，CPU会从再次从发生<code>trap</code>的指令处开始执行。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">usertrap</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((<span class="built_in">r_sstatus</span>() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  <span class="built_in">w_stvec</span>((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">r_scause</span>() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sstatus &amp;c registers,</span></span><br><span class="line">    <span class="comment">// so don&#x27;t enable until done with those registers.</span></span><br><span class="line">    <span class="built_in">intr_on</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">syscall</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = <span class="built_in">devintr</span>()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64 pcode = <span class="built_in">r_scause</span>();</span><br><span class="line">	uint64 va = <span class="built_in">r_stval</span>();</span><br><span class="line">	uint64 epc = <span class="built_in">r_sepc</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// page fault, valid virtual address, 记录trap发生的原因</span></span><br><span class="line">  	<span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= p-&gt;sz || va &lt;= p-&gt;trapframe-&gt;sp || va &gt; MAXVA)&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// alloc a page</span></span><br><span class="line">		<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();		</span><br><span class="line">	    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">	        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper a page for va</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">kfree</span>(mem);</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore epc</span></span><br><span class="line">		p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">	    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;killed)</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">usertrapret</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>修改<code>uvmunmap</code>时，我们在页表中<code>walk</code>时一旦发现该<code>virtual address</code>无法找到对应的物理页时，则我们此时直接跳过，而不是直接<code>panic</code>。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Remove npages of mappings starting from va. va must be</span></span><br><span class="line"><span class="comment">// page-aligned. The mappings must exist.</span></span><br><span class="line"><span class="comment">// Optionally free the physical memory.</span></span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">uvmunmap</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="type">int</span> do_free)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((va % PGSIZE) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;uvmunmap: not aligned&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="comment">// 未找到该地址</span></span><br><span class="line">    <span class="keyword">if</span>((pte = <span class="built_in">walk</span>(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">	     <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">PTE_FLAGS</span>(*pte) == PTE_V)</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">      <span class="built_in">kfree</span>((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">We&#x27;ve supplied you with lazytests, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both lazytests and usertests pass.</span><br><span class="line">Handle negative sbrk() arguments.</span><br><span class="line">Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().</span><br><span class="line">Handle the parent-to-child memory copy in fork() correctly.</span><br><span class="line">Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.</span><br><span class="line">Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.</span><br><span class="line">Handle faults on the invalid page below the user stack.</span><br></pre></td></tr></table></figure></li>
<li>我们发现在进行<code>usertests</code>，<code>sbrkarg</code>这个测试结果一直过不了，页没有报<code>usertrap</code>的错误，仔细跟踪了一下代码，发现它是调用了<code>sys_write</code>操作，而<code>sys_write</code>最终调用了<code>copyin</code>的操作，仔细检查一下<code>copyin</code>的函数发现它是直接在页表中读取操作，<code>walkaddr</code>时报错，所以直接返回<code>-1</code>。所以我们需要修改<code>walkaddr</code>函数，我们发现当前的地址没有在页表中找到时，则取申请一页新的物理页，然后将其映射到新的物理地址中。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">walkaddr</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = <span class="built_in">walk</span>(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="keyword">struct</span> <span class="title class_">proc</span> *p = <span class="built_in">myproc</span>();</span><br><span class="line">	<span class="keyword">if</span>(va &gt;= p-&gt;sz) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// malloc a new page</span></span><br><span class="line">	<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();</span><br><span class="line">	<span class="keyword">if</span>(mem == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// map a page for the new address</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">kfree</span>(mem);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">return</span> (uint64)mem;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pa = <span class="built_in">PTE2PA</span>(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>我们最后还需要注意的提示：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Handle faults on the invalid page below the user stack.</span><br></pre></td></tr></table></figure>
我们首先看一下系统用户进程的栈空间分布？<br>我们知道在栈的空件是从高地址往低地址增长的，如果我们发现栈的空间大小一个<code>page</code>，栈的地址空间为<code>1~4096</code>,因为所有的进程都是用户初始化进程的子进程，在子进程复制时，同时会复制父进程的栈空间。我们在进行<code>sbrk</code>操作时，实际扩充的进程的<code>heap</code>.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">userinit</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">proc</span> *p;</span><br><span class="line"></span><br><span class="line">  p = <span class="built_in">allocproc</span>();</span><br><span class="line">  initproc = p;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allocate one user page and copy init&#x27;s instructions</span></span><br><span class="line">  <span class="comment">// and data into it.</span></span><br><span class="line">  <span class="built_in">uvminit</span>(p-&gt;pagetable, initcode, <span class="built_in">sizeof</span>(initcode));</span><br><span class="line">  p-&gt;sz = PGSIZE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// prepare for the very first &quot;return&quot; from kernel to user.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = <span class="number">0</span>;      <span class="comment">// user program counter</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = PGSIZE;  <span class="comment">// user stack pointer</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">safestrcpy</span>(p-&gt;name, <span class="string">&quot;initcode&quot;</span>, <span class="built_in">sizeof</span>(p-&gt;name));</span><br><span class="line">  p-&gt;cwd = <span class="built_in">namei</span>(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p-&gt;state = RUNNABLE;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">release</span>(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>Handle faults on the invalid page below the user stack.</code></li>
</ul>
<ol>
<li><code>user stack</code>：user stack主要作为用户程序在<code>userspace</code>执行时需要的栈空间，当我们在用户空间执行用户的程序时，这时<code>sp</code>寄存器指向的就是<code>user stack</code>。</li>
<li><code>kernel stack</code>：<code>kernel stack</code>主要用户进程在系统调用时，切换到内核时执行内核的系统函数时，则这时<code>kernel space</code>执行时需要的栈空间，当系统调用发生时，则会发生<code>trap</code>，此时系统会切换<code>pc</code>到内核的函数调用，则此时我们执行内核函数时所需要的栈即为<code>kernel stack</code>。我们可以看到<code>kstack</code>之间有一个<code>guard page</code>.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line"><span class="comment">// map kernel stacks beneath the trampoline,</span></span><br><span class="line"><span class="comment">// each surrounded by invalid guard pages.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)</span></span><br></pre></td></tr></table></figure></li>
<li><code>stack</code>相邻的地方都有一个<code>guard page</code>，为了防止<code>stack</code>越界，访问<code>guard page</code>时就会报错。我们可以看到在<code>exec</code>函数执行时，代码和数据加装在完成后，会紧接着申请两个物理页，一个作为<code>guard page</code>,一个作为<code>stack</code>。当然方式比较奇怪：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate two pages at the next page boundary.</span></span><br><span class="line"><span class="comment">// Use the second as the user stack.</span></span><br><span class="line">sz = <span class="built_in">PGROUNDUP</span>(sz);</span><br><span class="line">uint64 sz1;</span><br><span class="line"><span class="comment">// malloc 2 page</span></span><br><span class="line"><span class="keyword">if</span>((sz1 = <span class="built_in">uvmalloc</span>(pagetable, sz, sz + <span class="number">2</span>*PGSIZE)) == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">sz = sz1;</span><br><span class="line"><span class="comment">// 将第一个page标志位去掉</span></span><br><span class="line"><span class="built_in">uvmclear</span>(pagetable, sz<span class="number">-2</span>*PGSIZE);</span><br><span class="line">sp = sz;</span><br><span class="line">stackbase = sp - PGSIZE;</span><br></pre></td></tr></table></figure></li>
<li><code>Handle faults on the invalid page below the user stack.</code>我们只需要检测当前的<code>va</code>是否处在<code>guard page</code>中。我们知道<code>guard page</code>的地址范围为：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stackbase = <span class="built_in">PGROUNDDOWN</span>(p-&gt;trapframe-&gt;sp) \\</span><br><span class="line">stackbase - PGSIZE \le va \le stackbase</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// page fault, valid virtual address</span></span><br><span class="line">  	<span class="keyword">if</span>(pcode == <span class="number">15</span> || pcode == <span class="number">13</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= (stack<span class="number">-2</span>*PGSIZE) &amp;&amp; va &lt; (stack-PGSIZE))&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(va &gt;= p-&gt;sz || va &gt; MAXVA)&#123;</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">char</span> *mem = <span class="built_in">kalloc</span>();		</span><br><span class="line">	    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">	        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">	    &#125;</span><br><span class="line">		<span class="built_in">memset</span>(mem,<span class="number">0</span>,PGSIZE);</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">mappages</span>(p-&gt;pagetable,<span class="built_in">PGROUNDDOWN</span>(va),PGSIZE,(uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">kfree</span>(mem);</span><br><span class="line">			p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">		p-&gt;trapframe-&gt;epc = epc;  </span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), p-&gt;pid);</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=%p stval=%p\n&quot;</span>, <span class="built_in">r_sepc</span>(), <span class="built_in">r_stval</span>());</span><br><span class="line">	    p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>欢迎关注和打赏，感谢支持！</p>
<ul>
<li>关注我的博客: <a target="_blank" rel="noopener" href="http://mikemeng.org/">http://mikemeng.org/</a></li>
<li>关注我的知乎：<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/da-hua-niu">https://www.zhihu.com/people/da-hua-niu</a></li>
<li>关注我的微信公众号: 公务程序猿<br><img src="https://i.loli.net/2020/11/16/xtyDOgT6Gm1AKdS.png" alt="1"></li>
</ul>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#公开课学习" >
    <span class="tag-code">公开课学习</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2022/11/02/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/62/">
        <span class="nav-arrow">← </span>
        
          【MIT6.S081】 lab4 traps
        
      </a>
    
    
      <a class="nav-right" href="/2022/11/02/%E5%85%AC%E5%BC%80%E8%AF%BE%E5%AD%A6%E4%B9%A0/60/">
        
          【MIT6.S081】 lab6 cow pages
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Utterances START -->
      <div id="utterances"></div>
      <script src="https://utteranc.es/client.js"
        repo="mike-box/blogtalk"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async></script>    
      <!-- Utterances END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#lazy-alloaction"><span class="toc-nav-text">lazy alloaction</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Eliminate-allocation-from-sbrk"><span class="toc-nav-text">Eliminate allocation from sbrk</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Lazy-allocation"><span class="toc-nav-text">Lazy allocation</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Lazytests-and-Usertests"><span class="toc-nav-text">Lazytests and Usertests</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link"><span class="toc-nav-text"></span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://example.com/2022/11/02/公开课学习/61/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/css/images/error_icon.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/css/images/error_icon.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>






    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2022 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a target="_blank" rel="noopener" href="https://github.com/yanm1ng">yanm1ng</a>
    
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      hljs.configure({useBR: true});
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->


<script src="/js/script.js"></script>


  </body>
</html>