---
title: "leetcode biweekly contes 115"
banner: 力扣季度赛
category: 力扣周赛
tags:
 - 力扣周赛赛
 - 题解



---

## leetcode biweekly contes 115

双周赛的题目不太好，出的比较怪异的题目，特别是第一题。`T4` 竟然没有想到解法。

### 2899. 上一个遍历的整数

给你一个下标从 **0** 开始的字符串数组 `words` ，其中 `words[i]` 要么是一个字符串形式的正整数，要么是字符串 `"prev"` 。

我们从数组的开头开始遍历，对于 `words` 中的每个 `"prev"` 字符串，找到 `words` 中的 **上一个遍历的整数** ，定义如下：

- `k` 表示到当前位置为止的连续 `"prev"` 字符串数目（包含当前字符串），令下标从 **0** 开始的 **整数** 数组 `nums` 表示目前为止遍历过的所有整数，同时用 `nums_reverse` 表示 `nums` 反转得到的数组，那么当前 `"prev"` 对应的 **上一个遍历的整数** 是 `nums_reverse` 数组中下标为 `(k - 1)` 的整数。
- 如果 `k` 比目前为止遍历过的整数数目 **更多** ，那么上一个遍历的整数为 `-1` 。

请你返回一个整数数组，包含所有上一个遍历的整数。

 

**示例 1：**

```
输入：words = ["1","2","prev","prev","prev"]
输出：[2,1,-1]
解释：
对于下标为 2 处的 "prev" ，上一个遍历的整数是 2 ，因为连续 "prev" 数目为 1 ，同时在数组 reverse_nums 中，第一个元素是 2 。
对于下标为 3 处的 "prev" ，上一个遍历的整数是 1 ，因为连续 "prev" 数目为 2 ，同时在数组 reverse_nums 中，第二个元素是 1 。
对于下标为 4 处的 "prev" ，上一个遍历的整数是 -1 ，因为连续 "prev" 数目为 3 ，但总共只遍历过 2 个整数。
```

**示例 2：**

```
输入：words = ["1","prev","2","prev","prev"]
输出：[1,2,1]
解释：
对于下标为 1 处的 "prev" ，上一个遍历的整数是 1 。
对于下标为 3 处的 "prev" ，上一个遍历的整数是 2 。
对于下标为 4 处的 "prev" ，上一个遍历的整数是 1 ，因为连续 "prev" 数目为 2 ，同时在数组 reverse_nums 中，第二个元素是 1 。
```

 

**提示：**

- `1 <= words.length <= 100`
- `words[i] == "prev"` 或 `1 <= int(words[i]) <= 100`

#### 地址

https://leetcode.cn/contest/biweekly-contest-115/problems/last-visited-integers/

#### 题意

    模拟

#### 思路

1. 按照题意模拟即可，但是改题目确实出的不好。
2. 复杂度分析：

+ 时间复杂度：$O(n)$，其中 $n$ 表示给定的元素。
+ 空间复杂度：$O(1)$。

#### 代码

```python
class Solution:
    def lastVisitedIntegers(self, words: List[str]) -> List[int]:
        n = len(words)
        ans = []
        nums = []
        k = 0
        for i, word in enumerate(words):
            if word == "prev":
                k += 1
                ans.append(-1 if k > len(nums) else nums[-k])
            else:
                nums.append(int(word))
                k = 0
        return ans
```

----



### 2900. 最长相邻不相等子序列 I

给你一个整数 `n` 和一个下标从 **0** 开始的字符串数组 `words` ，和一个下标从 **0** 开始的 **二进制** 数组 `groups` ，两个数组长度都是 `n` 。

你需要从下标 `[0, 1, ..., n - 1]` 中选出一个 **最长子序列** ，将这个子序列记作长度为 `k` 的 `[i0, i1, ..., ik - 1]` ，对于所有满足 `0 < j + 1 < k` 的 `j` 都有 `groups[ij] != groups[ij + 1]` 。

请你返回一个字符串数组，它是下标子序列 **依次** 对应 `words` 数组中的字符串连接形成的字符串数组。如果有多个答案，返回任意一个。

**子序列** 指的是从原数组中删掉一些（也可能一个也不删掉）元素，剩余元素不改变相对位置得到的新的数组。

**注意：**`words` 中的字符串长度可能 **不相等** 。

 

**示例 1：**

```
输入：n = 3, words = ["e","a","b"], groups = [0,0,1]
输出：["e","b"]
解释：一个可行的子序列是 [0,2] ，因为 groups[0] != groups[2] 。
所以一个可行的答案是 [words[0],words[2]] = ["e","b"] 。
另一个可行的子序列是 [1,2] ，因为 groups[1] != groups[2] 。
得到答案为 [words[1],words[2]] = ["a","b"] 。
这也是一个可行的答案。
符合题意的最长子序列的长度为 2 。
```

**示例 2：**

```
输入：n = 4, words = ["a","b","c","d"], groups = [1,0,1,1]
输出：["a","b","c"]
解释：一个可行的子序列为 [0,1,2] 因为 groups[0] != groups[1] 且 groups[1] != groups[2] 。
所以一个可行的答案是 [words[0],words[1],words[2]] = ["a","b","c"] 。
另一个可行的子序列为 [0,1,3] 因为 groups[0] != groups[1] 且 groups[1] != groups[3] 。
得到答案为 [words[0],words[1],words[3]] = ["a","b","d"] 。
这也是一个可行的答案。
符合题意的最长子序列的长度为 3 。
```

 

**提示：**

- `1 <= n == words.length == groups.length <= 100`
- `1 <= words[i].length <= 10`
- `0 <= groups[i] < 2`
- `words` 中的字符串 **互不相同** 。
- `words[i]` 只包含小写英文字母。

### 地址

https://leetcode.cn/contest/weekly-contest-365/problems/maximum-value-of-an-ordered-triplet-ii/

#### 题意

    贪心 + 排序

#### 思路

1. 如要使得最大时间尽可能的短，则应使得 $4$ 个核心中处理的任务尽可能尽可能的短，对于每个处理器到达最小的空闲时间，则其应该分配耗时更长的任务，这样才能保障最大值尽可能的小，我们的目标是让下面的值尽可能的小：
   $$
   T = \min(processorTime[0] + task[a_0], processorTime[1] + task[a_1], \cdots )
   $$
   在上述操作下，如何使得上述 $T$ 的值最小，此时我们将最短等带时间的处理器与耗时最长的任务匹配，比如 $i$ 与 $j$ 个任务匹配，则此时最优匹配应该是接下来连续的三个任务都应该由 $i$ 来进行处理, 需要数学归纳法证明，证明在此不再描述。

2. 复杂度分析：

+ 时间复杂度：$O(n \log n)$，其中 $n$ 为数组的长度。
+ 空间复杂度：$O(\log n)$，其中 $n$ 为数组的长度。

#### 代码

```C++
class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        tasks.sort(key = lambda x : -x)
        processorTime.sort()
        return max([processorTime[i] + tasks[4 * i] for i in range(len(processorTime))])                
```

----

###   8028. 执行操作使两个字符串相等

给你两个下标从 **0** 开始的二进制字符串 `s1` 和 `s2` ，两个字符串的长度都是 `n` ，再给你一个正整数 `x` 。

你可以对字符串 `s1` 执行以下操作 **任意次** ：

- 选择两个下标 `i` 和 `j` ，将 `s1[i]` 和 `s1[j]` 都反转，操作的代价为 `x` 。
- 选择满足 `i < n - 1` 的下标 `i` ，反转 `s1[i]` 和 `s1[i + 1]` ，操作的代价为 `1` 。

请你返回使字符串 `s1` 和 `s2` 相等的 **最小** 操作代价之和，如果无法让二者相等，返回 `-1` 。

**注意** ，反转字符的意思是将 `0` 变成 `1` ，或者 `1` 变成 `0` 。

 

**示例 1：**

```
输入：s1 = "1100011000", s2 = "0101001010", x = 2
输出：4
解释：我们可以执行以下操作：
- 选择 i = 3 执行第二个操作。结果字符串是 s1 = "1101111000" 。
- 选择 i = 4 执行第二个操作。结果字符串是 s1 = "1101001000" 。
- 选择 i = 0 和 j = 8 ，执行第一个操作。结果字符串是 s1 = "0101001010" = s2 。
总代价是 1 + 1 + 2 = 4 。这是最小代价和。
```

**示例 2：**

```
输入：s1 = "10110", s2 = "00011", x = 4
输出：-1
解释：无法使两个字符串相等。
```

 

**提示：**

- `n == s1.length == s2.length`
- `1 <= n, x <= 500`
- `s1` 和 `s2` 只包含字符 `'0'` 和 `'1'` 。

#### 地址

https://leetcode.cn/contest/weekly-contest-366/problems/apply-operations-to-make-two-strings-equal/

#### 题意

>  动态规划

#### 思路

1. 题目还是非常有意思的，比如我们需要同时反转两个字符 $s[i], s[j]$ 时，此时可以有两种方法：

   +  同时反转 $s[i],s[j]$, 此时需要的代价为 $x$;
   +  假设 $i < j$, 则此时需要依次反转 $(s[i],s[i+1]),(s[i+1],s[i+2]), \cdots,(s[j-1],s[j])$, 一共需要反转 $j - i$ 次，此时需要的代价为 $j-i$;

   给定字符串 $s1$ 与 $s2$, 通过两两反转使得 $s1$ 与 $s2$ 相等，此时我们需要仔细分析该问题，首先看到题目给定的数量级为 $[1,500]$, 则可以肯定的是该题的时间复杂度为 $O(n^2)$ ，此时需要仔细思考哪些算法在这个时间复杂度范围内，由于给定的  $s[i]$ 可以与 $[0,n-1]$ 中的任意一个字符进行交换，我们需要仔细分析：

   + 首先需要统计字符中不同的字符位置 $diff$, 如果两个字符串中字符不同的位置数量为奇数个，则此时肯定无法实现反转使得两个字符串相等，因为根据题意可以知道一次操作会使得两个字符同时反转，所以如果字符串不同位置的数量为奇数个则一定无法通过反转使得两个字符串相等；
   + 其次我们需要思考一个问题，假设两个字符中不同的位置序列为 $[c_0,c_1,c_2,\cdots,c_m]$, 此时我们需要思考的是 $c_i$ 该与哪个字符交换，假设 $c_i$ 与 $c_j$ 进行了交换，则可以知道一定为如下三种情况：
     + $i = j + 1$,  此时两个最接近的位置进行了交换，此时使得 $[c_j,c_{j+1}]$ 两个相邻位置的字符相等，不再有其他的位置与其交换；
     + $i = j - 1$,  此时两个最接近的位置进行了交换，此时使得 $[c_{j-1},c_{j}]$ 两个相邻位置的字符相等，不再有其他的位置与其交换；
     + $i < j$,  此时两个位置进行了交换，此时使得 $(c_i,c_j)$ 两个相邻位置的字符相等, 处于位置 $c_{i+1},c_{i+2}, \cdots,c_{j-1}$ 的字符根据贪心原则，他们一定是在区间 $[i+1,j-1]$ 内部进行自交换，一定不会出现交换的情况，即 $s_k,k \in[i+1,j-1]$ 与 $s_p,p\in[0,i-1] \and [j+1,n-1]$ 进行交换，因为这样交换的代价一定不是最优的，可以用反证法来证明；
     + 根据前 $3$ 点分析可以知道，设 $dp[i][j]$ 表示区间 $[i,j]$ 之间的字符串通过反转与 $s2$ 相同的最小代价，此时我们可以知道如下：
       + 第 $j$ 个字符与第 $j - 1$ 个字符用第二种操作反转，则此时最小代价为 $dp[i][j] = \min (dp[i][j],dp[i][j-2] + diff[j] - diff[j-1])$;
       + 第 $i$ 个字符与第 $i + 1$ 个字符用第二种操作反转，则此时最小代价为 $dp[i][j] = \min (dp[i][j],dp[i+2][j] + diff[i+1] - diff[i])$;
       + 第 $i$ 个字符与第 $j$ 个字符用第一种操作反转，则此时最小代价为 $dp[i][j] = \min (dp[i][j],dp[i+1][j-1] + x)$;
     + 根据上述动态规划递推即可计算出最小结果 $dp[0][n-1]$；

2. 复杂度分析：

+ 时间复杂度：$O(n^2)$，其中$n$ 表示字符串的长度；
+ 空间复杂度：$O(n^2)$，其中$n$ 表示字符串的长度；

#### 代码

```python
class Solution {
public:
    static constexpr int INF = 0x3f3f3f3f;
    
    int minOperations(string s1, string s2, int x) {
        vector<int> diff;
        for (int i = 0; i < s1.size(); i++) {
            if (s1[i] != s2[i]) {
                diff.emplace_back(i);
            }
        }
        
        int n = diff.size();
        if (n & 1) return -1;
        if (n == 0) return 0;
        
        vector<vector<int>> dp(n, vector<int>(n, INF));
        for (int i = 0; i < n; i++) {
            for (int j = i - 1; j >= 0; j--) {
                if (i - j == 1) {
                    dp[j][i] = min(x, diff[i] - diff[j]);
                } else {
                    dp[j][i] = min(dp[j][i], dp[j + 2][i] + min(x, diff[j + 1] - diff[j]));
                    dp[j][i] = min(dp[j][i], dp[j][i - 2] + min(x, diff[i] - diff[i - 1]));
                    dp[j][i] = min(dp[j][i], dp[j + 1][i - 1] + min(x, diff[i] - diff[j]));
                }
            }
        }
        return dp[0][n - 1];        
    }
};
```

----

### 100087. 对数组执行操作使平方和最大

给你一个下标从 **0** 开始的整数数组 `nums` 和一个 **正** 整数 `k` 。

你可以对数组执行以下操作 **任意次** ：

- 选择两个互不相同的下标 `i` 和 `j` ，**同时** 将 `nums[i]` 更新为 `(nums[i] AND nums[j])` 且将 `nums[j]` 更新为 `(nums[i] OR nums[j])` ，`OR` 表示按位 **或** 运算，`AND` 表示按位 **与** 运算。

你需要从最终的数组里选择 `k` 个元素，并计算它们的 **平方** 之和。

请你返回你可以得到的 **最大** 平方和。

由于答案可能会很大，将答案对 `109 + 7` **取余** 后返回。

 

**示例 1：**

```
输入：nums = [2,6,5,8], k = 2
输出：261
解释：我们可以对数组执行以下操作：
- 选择 i = 0 和 j = 3 ，同时将 nums[0] 变为 (2 AND 8) = 0 且 nums[3] 变为 (2 OR 8) = 10 ，结果数组为 nums = [0,6,5,10] 。
- 选择 i = 2 和 j = 3 ，同时将 nums[2] 变为 (5 AND 10) = 0 且 nums[3] 变为 (5 OR 10) = 15 ，结果数组为 nums = [0,6,0,15] 。
从最终数组里选择元素 15 和 6 ，平方和为 152 + 62 = 261 。
261 是可以得到的最大结果。
```

**示例 2：**

```
输入：nums = [4,5,4,7], k = 3
输出：90
解释：不需要执行任何操作。
选择元素 7 ，5 和 4 ，平方和为 72 + 52 + 42 = 90 。
90 是可以得到的最大结果。
```

 

**提示：**

- `1 <= k <= nums.length <= 105`
- `1 <= nums[i] <= 109`

#### 地址

https://leetcode.cn/contest/weekly-contest-366/problems/apply-operations-on-array-to-maximize-sum-of-squares/

#### 题意

>  数学问题

#### 思路

1. 题目出的比较有意思，关键在于如何理解该位运算，有题目可以知道：
   $$
   x \and y + x \or y = x + y \\
   x, y = x \and y, x \or y
   $$
   我们可以看到通过**与**运算和**或**运算只是将 $x$ 中的 $1$ 转移到 $y$ 中，但是两者的和不会改变。我们还需要计算转移的大小，即此时假设从 $x$ 转移了 $d$ 到 $y$, 此时我们应该尽量进行转移，因为转移后的元素的平方和的值会更大。
   $$
   (x - d)^2 + (y + d)^2 \ge x^2 + y^2
   $$


   因此我们应该将尽可能多的 $1$ 转移到最大数上面，此时我们只需要每次尝试最多可以转移的 $1$ 个数即可构成最大的数。

2. 复杂度分析：

+ 时间复杂度：$O(C(n + k))$，其中 $n$ 表示数组的长度，$k$ 表示给定的元素；
+ 空间复杂度：$O(C)$，其中 $C = 32$ ；

#### 代码

```python
class Solution:
    def maxSum(self, nums: List[int], k: int) -> int:
        cnt = [0] * 32
        for v in nums:
            for j in range(32):
                if v & (1 << j):
                    cnt[j] += 1
        
        res = 0
        for i in range(k):
            cur = 0
            for j in range(31, -1, -1):
                if cnt[j] > 0:
                    cur |= (1 << j)
                    cnt[j] -= 1
            res += cur * cur
        return res % (10**9 + 7)
```


欢迎关注和打赏，感谢支持！

+ 关注我的博客: http://whistle-wind.com/
+ 关注我的知乎：https://www.zhihu.com/people/da-hua-niu
+ 关注我的微信公众号: 公务程序猿
  ![1](https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png)

