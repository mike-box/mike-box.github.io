---
title: "leetcode biweekly contes 364"
banner: 力扣季度赛
category: 力扣周赛
tags:
 - 力扣周赛赛
 - 题解

---

## leetcode weekly contes 364

最近周赛题目的质量越来越高了，非常不错的周赛题目，适合思维性的思考题目，不涉及到非常复杂的算法，基本上全是思维题目。

### 8048. 最大二进制奇数

给你一个 **二进制** 字符串 `s` ，其中至少包含一个 `'1'` 。

你必须按某种方式 **重新排列** 字符串中的位，使得到的二进制数字是可以由该组合生成的 **最大二进制奇数** 。

以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。

**注意** 返回的结果字符串 **可以** 含前导零。

 

**示例 1：**

```
输入：s = "010"
输出："001"
解释：因为字符串 s 中仅有一个 '1' ，其必须出现在最后一位上。所以答案是 "001" 。
```

**示例 2：**

```
输入：s = "0101"
输出："1001"
解释：其中一个 '1' 必须出现在最后一位上。而由剩下的数字可以生产的最大数字是 "100" 。所以答案是 "1001" 。
```

 

**提示：**

- `1 <= s.length <= 100`
- `s` 仅由 `'0'` 和 `'1'` 组成
- `s` 中至少包含一个 `'1'`

#### 地址

https://leetcode.cn/contest/weekly-contest-364/problems/maximum-odd-binary-number/

#### 题意

    模拟

#### 思路

1. 比较简单的题目，若使得通过字符交换构成最大的奇数，需要满足如下条件：
   + 最低位一定为 $1$；
   + 若使得构成的数字最大，则一定满足最低位以外，高位全部为 $1$,低位全部为 $0$;
   + 根据上述分析可以构造最大的奇数即可；
2. 复杂度分析：

+ 时间复杂度：$O(n)$，其中 $n$ 表示字符串的长度,。
+ 空间复杂度：$O(1)$。

#### 代码

```C++ [sol1-C++]
class Solution {
public:
    string maximumOddBinaryNumber(string s) {
        int cnt = count(s.begin(), s.end(), '1');
        return string(cnt - 1, '1') + string(s.size() - cnt, '0') + '1';
    }
};
```

----

### 100049. 美丽塔 I

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `maxHeights` 。

你的任务是在坐标轴上建 `n` 座塔。第 `i` 座塔的下标为 `i` ，高度为 `heights[i]` 。

如果以下条件满足，我们称这些塔是 **美丽** 的：

1. `1 <= heights[i] <= maxHeights[i]`
2. `heights` 是一个 **山状** 数组。

如果存在下标 `i` 满足以下条件，那么我们称数组 `heights` 是一个 **山状** 数组：

- 对于所有 `0 < j <= i` ，都有 `heights[j - 1] <= heights[j]`
- 对于所有 `i <= k < n - 1` ，都有 `heights[k + 1] <= heights[k]`

请你返回满足 **美丽塔** 要求的方案中，**高度和的最大值** 。

 

**示例 1：**

```
输入：maxHeights = [5,3,4,1,1]
输出：13
解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]  
- heights 是个山状数组，峰值在 i = 0 处。
13 是所有美丽塔方案中的最大高度和。
```

**示例 2：**

```
输入：maxHeights = [6,5,3,9,2,7]
输出：22
解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山状数组，峰值在 i = 3 处。
22 是所有美丽塔方案中的最大高度和。
```

**示例 3：**

```
输入：maxHeights = [3,2,5,5,2,3]
输出：18
解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山状数组，最大值在 i = 2 处。
注意，在这个方案中，i = 3 也是一个峰值。
18 是所有美丽塔方案中的最大高度和。
```

 

**提示：**

- `1 <= n == maxHeights <= 103`
- `1 <= maxHeights[i] <= 109`

### 地址

https://leetcode.cn/contest/weekly-contest-364/problems/beautiful-towers-i/

#### 题意

    枚举

#### 思路

1. 首先 $O(n^2)$ 的解法非常简单，我们直接枚举以第 $i$ 个数位最大值即可，此时枚举方案如下，假设第 $i$ 个数为**美丽塔**  的最大元素，按照贪心法则，则第 $i$ 个数应该尽可能的大，此时第 $i$ 个数的取值即为 $maxHeights[i]$，然后依次向两遍扩展，使得每个位置上的元素尽可能的大，解法比较简单，设上一个元素的值为 $pre$,则当前元素最大值只能取到 $\max(pre, maxHeights[i])$，我们依次对每个位置上可以取的最大元素求和即可。
2. 复杂度分析：

+ 时间复杂度：$O(n^2)$，其中 $n$ 为数组的长度。
+ 空间复杂度：$O(1)$。

#### 代码

```C++
class Solution {
public:
    long long maximumSumOfHeights(vector<int>& maxHeights) {
        int n = maxHeights.size();
        long long res = 0;
        for (int i = 0; i < n; i++) {
            long long curr = 0;
            int pre = maxHeights[i];
            curr += pre;
            for (int j = i - 1; j >= 0; j--) {
                pre = min(pre, maxHeights[j]);
                curr += pre;
            }
            pre = maxHeights[i];
            for (int j = i + 1; j < n; j++) {
                pre = min(pre, maxHeights[j]);
                curr += pre;
            }
            res = max(res, curr);
        }
        return res;
    }
};
```

----

###   100048. 美丽塔 II

给你一个长度为 `n` 下标从 **0** 开始的整数数组 `maxHeights` 。

你的任务是在坐标轴上建 `n` 座塔。第 `i` 座塔的下标为 `i` ，高度为 `heights[i]` 。

如果以下条件满足，我们称这些塔是 **美丽** 的：

1. `1 <= heights[i] <= maxHeights[i]`
2. `heights` 是一个 **山状** 数组。

如果存在下标 `i` 满足以下条件，那么我们称数组 `heights` 是一个 **山状** 数组：

- 对于所有 `0 < j <= i` ，都有 `heights[j - 1] <= heights[j]`
- 对于所有 `i <= k < n - 1` ，都有 `heights[k + 1] <= heights[k]`

请你返回满足 **美丽塔** 要求的方案中，**高度和的最大值** 。

 

**示例 1：**

```
输入：maxHeights = [5,3,4,1,1]
输出：13
解释：和最大的美丽塔方案为 heights = [5,3,3,1,1] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]  
- heights 是个山状数组，峰值在 i = 0 处。
13 是所有美丽塔方案中的最大高度和。
```

**示例 2：**

```
输入：maxHeights = [6,5,3,9,2,7]
输出：22
解释： 和最大的美丽塔方案为 heights = [3,3,3,9,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山状数组，峰值在 i = 3 处。
22 是所有美丽塔方案中的最大高度和。
```

**示例 3：**

```
输入：maxHeights = [3,2,5,5,2,3]
输出：18
解释：和最大的美丽塔方案为 heights = [2,2,5,5,2,2] ，这是一个美丽塔方案，因为：
- 1 <= heights[i] <= maxHeights[i]
- heights 是个山状数组，最大值在 i = 2 处。
注意，在这个方案中，i = 3 也是一个峰值。
18 是所有美丽塔方案中的最大高度和。
```

 

**提示：**

- `1 <= n == maxHeights <= 105`
- `1 <= maxHeights[i] <= 109`

#### 地址

https://leetcode.cn/contest/weekly-contest-364/problems/beautiful-towers-ii/

#### 题意

>  单调栈 + 动态规划

#### 思路

1. 第三题与第二题的题目一样，只是数量级有所变换，给定的数量级为 $10^5$，这说明只能用 $O(n)$ 的解法了，这就需要仔细分析了。假设我们设 $dp[i]$ 表示前 $i$ 个元素变为非递减且以 $maxHeights[i]$ 为结尾的前缀和最大值，则此时我们可以观察一下如下 $dp[i]$ 是否与 $dp[j]$ 存在递推关系，其中 $j < i$, 通过仔细观察可以发现如下：

   + 假设 $[j + 1, i-1]$ 之间的元素都满足 $maxHeights[{j+1} \cdots {i-1}] \ge maxHeights[i]，maxHeights[j] \le maxHeights[i]$ ，即 $[j+1,i]$ 之间的最小元素为 $maxHeights[i]$, 由于此时区间 $[0,i]$ 的最大值为 $maxHeights[i]$, 则此时 $[j+1,i]$ 之间的元素的最大值只能取到 $maxHeights[i]$, 则此时存在递推关系为:

     $$dp[i] = dp[j] + (i- j) * maxHeights[i]$$

   + 根据以上分析可以发现，我们只需要找到 $maxHeights[i]$ 左边第一个小于等于 $maxHeights[i]$ 的元素，即可使用上述的递推关系，此时我们自然而然想到用单调栈即可解决上述的问题，当然了山峰问题本身就是可以利用单调栈解决该问题，因为单调的情况下才能满足当前的值满足连续递增或者递减。

2. 复杂度分析：

+ 时间复杂度：$O(n)$，其中$n$ 表示数组的长度；
+ 空间复杂度：$O(n)$，其中$n$ 表示数组的长度；

#### 代码

```C++
class Solution {
public:
    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {
        long long res = 0;
        for (int i = 0; i < k; i++) {
            long long l = 0, r = 1e9;
            long long maxVal = 0;
            while (l <= r) {
                long long mid = (l + r) >> 1;
                long long tot = 0;
                for (int j = 0; j < composition[i].size(); j++) {
                    long long need = composition[i][j] * mid;
                    if (need > stock[j]) {
                        tot += (need - stock[j]) * cost[j];
                    }
                }
                if (tot > budget) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                    maxVal = mid;
                }
            }
            res = max(res, maxVal);
        }
        return res;
    }
};
```

----

### 2862. 完全子集的最大元素和

给你一个下标从 **1** 开始、由 `n` 个整数组成的数组。

如果一组数字中每对元素的乘积都是一个完全平方数，则称这组数字是一个 **完全集** 。

下标集 `{1, 2, ..., n}` 的子集可以表示为 `{i1, i2, ..., ik}`，我们定义对应该子集的 **元素和** 为 `nums[i1] + nums[i2] + ... + nums[ik]` 。

返回下标集 `{1, 2, ..., n}` 的 **完全子集** 所能取到的 **最大元素和** 。

完全平方数是指可以表示为一个整数和其自身相乘的数。

 

**示例 1：**

```
输入：nums = [8,7,3,5,7,2,4,9]
输出：16
解释：除了由单个下标组成的子集之外，还有两个下标集的完全子集：{1,4} 和 {2,8} 。
与下标 1 和 4 对应的元素和等于 nums[1] + nums[4] = 8 + 5 = 13 。
与下标 2 和 8 对应的元素和等于 nums[2] + nums[8] = 7 + 9 = 16 。
因此，下标集的完全子集可以取到的最大元素和为 16 。
```

**示例 2：**

```
输入：nums = [5,10,3,10,1,13,7,9,4]
输出：19
解释：除了由单个下标组成的子集之外，还有四个下标集的完全子集：{1,4}、{1,9}、{2,8}、{4,9} 和 {1,4,9} 。 
与下标 1 和 4 对应的元素和等于 nums[1] + nums[4] = 5 + 10 = 15 。 
与下标 1 和 9 对应的元素和等于 nums[1] + nums[9] = 5 + 4 = 9 。 
与下标 2 和 8 对应的元素和等于 nums[2] + nums[8] = 10 + 9 = 19 。
与下标 4 和 9 对应的元素和等于 nums[4] + nums[9] = 10 + 4 = 14 。 
与下标 1、4 和 9 对应的元素和等于 nums[1] + nums[4] + nums[9] = 5 + 10 + 4 = 19 。 
因此，下标集的完全子集可以取到的最大元素和为 19 。
```

 

**提示：**

- `1 <= n == nums.length <= 104`
- `1 <= nums[i] <= 109`

#### 地址

https://leetcode.cn/contest/weekly-contest-363/problems/maximum-element-sum-of-a-complete-subset-of-indices/

#### 题意

>  数论

#### 思路

1. 题目本身倒不是特别难，但是需要仔细检查细节即可，其实如果题目换个思路则问题就比较困难了，比如换成数组中所有元素的乘积为**完全集** ，则题目又是另外一种解法，需要仔细思考的题目，我们先要分析一下，什么样的数组构成 **完全集**，根据完全集的定义为:
   + 数组中任意两个元素的乘积是一个完全平方数，即任意两个元素等于某个数的平方 $x^2$；
   + 什么样的数才可以构成完全平方数，即该数的每个质因子出现的次数都是偶数次，即此时 $a = p_1^{2c_1} \times p_2^{2c_2} \times p_3^{2c_3}\times \cdots$;
   + 什么样的数相称一定可以构成完全平方数，即两个数 $x，y$ 二者中出现次数为奇数次的质因子 相同，假设 $x$ 中 $p_1,p_2,\cdots $ 出现的次数为奇数次，则 $y$ 中出现次数为奇数次的质因子也相同；
   + 由于**完全集** 中任意两个元素的乘积均为完全平方数，则此时该数组中每个元素出现次数为奇数次的质因子都相同，此时我们统计数组中每个元素的中质因子次数为奇数的个数，此时我们可以用乘积来表示这些出现次数为奇数次的质因子，$calc(x)$ 则表示 $x$ 中出现次数为奇数次的质因子的乘积，由于质数乘法的原因，因此不同组合的质数相乘的乘积一定是唯一的，则此时 $calc(x) = p_1 \times p_2 \times \cdots p_i$，由于数组中每个元素都不相同，因此我们只需要将 $calc(x)$ 值相同的元素放到同一个数组中，此时该数组的任意两个元素相乘一定满足二者的乘积为完全平方数；
   + 题目的关键则变为如何求出出现次数为奇数次的质因子，此时的求法其实很简单，对 $x$ 来说，假设 $p  \in [2,\sqrt{n}]$ 的质数，我们将 $x$ 除去所有 $p^2$ ，此时 $x$ 剩余的即为出现奇数次的质因子，按照上述方法依次除即可
2. 复杂度分析：

+ 时间复杂度：$O(n \sqrt{n})$，其中 $n$ 表示数组的长度。
+ 空间复杂度：$O(n)$，其中 $n$ 表示节点的数目。

#### 代码

```C++
class Solution {
public:
    constexpr static int primers[25] = {2,3,5,7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};
    int calc(int x) {
        int m = sqrt(x);
        for (int i = 0; i < 25 && primers[i] <= m; i++) {
            int d = primers[i] * primers[i];
            while (x % d == 0) {
                x /= d;
            }
        }
        return x;
    }
    
    long long maximumSum(vector<int>& nums) {
        long long res = 0;
        unordered_map<int, long long> dp;
        int n = nums.size();
        for (int i = 1; i <= n; i++) {
            dp[calc(i)] += nums[i - 1];
        }
        for (auto [k, v] : dp) {
            res = max(res, v);
        }
        return res;
    }
};
```


欢迎关注和打赏，感谢支持！

+ 关注我的博客: http://whistle-wind.com/
+ 关注我的知乎：https://www.zhihu.com/people/da-hua-niu
+ 关注我的微信公众号: 公务程序猿
  ![1](https://raw.githubusercontent.com/mike-box/pic/main/202210080853104.png)

